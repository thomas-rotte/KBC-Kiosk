(self["webpackChunkcapsule_ui"] = self["webpackChunkcapsule_ui"] || []).push([
  [998],
  {
    1001: function (t, e, n) {
      "use strict";
      function r(t, e, n, r, i, a, o, s) {
        var c,
          l = "function" === typeof t ? t.options : t;
        if (
          (e && ((l.render = e), (l.staticRenderFns = n), (l._compiled = !0)),
          r && (l.functional = !0),
          a && (l._scopeId = "data-v-" + a),
          o
            ? ((c = function (t) {
                (t =
                  t ||
                  (this.$vnode && this.$vnode.ssrContext) ||
                  (this.parent &&
                    this.parent.$vnode &&
                    this.parent.$vnode.ssrContext)),
                  t ||
                    "undefined" === typeof __VUE_SSR_CONTEXT__ ||
                    (t = __VUE_SSR_CONTEXT__),
                  i && i.call(this, t),
                  t &&
                    t._registeredComponents &&
                    t._registeredComponents.add(o);
              }),
              (l._ssrRegister = c))
            : i &&
              (c = s
                ? function () {
                    i.call(
                      this,
                      (l.functional ? this.parent : this).$root.$options
                        .shadowRoot
                    );
                  }
                : i),
          c)
        )
          if (l.functional) {
            l._injectStyles = c;
            var u = l.render;
            l.render = function (t, e) {
              return c.call(e), u(t, e);
            };
          } else {
            var h = l.beforeCreate;
            l.beforeCreate = h ? [].concat(h, c) : [c];
          }
        return { exports: t, options: l };
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    9662: function (t, e, n) {
      var r = n(614),
        i = n(6330),
        a = TypeError;
      t.exports = function (t) {
        if (r(t)) return t;
        throw a(i(t) + " is not a function");
      };
    },
    9670: function (t, e, n) {
      var r = n(111),
        i = String,
        a = TypeError;
      t.exports = function (t) {
        if (r(t)) return t;
        throw a(i(t) + " is not an object");
      };
    },
    1318: function (t, e, n) {
      var r = n(5656),
        i = n(1400),
        a = n(6244),
        o = function (t) {
          return function (e, n, o) {
            var s,
              c = r(e),
              l = a(c),
              u = i(o, l);
            if (t && n != n) {
              while (l > u) if (((s = c[u++]), s != s)) return !0;
            } else
              for (; l > u; u++)
                if ((t || u in c) && c[u] === n) return t || u || 0;
            return !t && -1;
          };
        };
      t.exports = { includes: o(!0), indexOf: o(!1) };
    },
    206: function (t, e, n) {
      var r = n(1702);
      t.exports = r([].slice);
    },
    4326: function (t, e, n) {
      var r = n(1702),
        i = r({}.toString),
        a = r("".slice);
      t.exports = function (t) {
        return a(i(t), 8, -1);
      };
    },
    9920: function (t, e, n) {
      var r = n(2597),
        i = n(3887),
        a = n(1236),
        o = n(3070);
      t.exports = function (t, e, n) {
        for (var s = i(e), c = o.f, l = a.f, u = 0; u < s.length; u++) {
          var h = s[u];
          r(t, h) || (n && r(n, h)) || c(t, h, l(e, h));
        }
      };
    },
    8880: function (t, e, n) {
      var r = n(9781),
        i = n(3070),
        a = n(9114);
      t.exports = r
        ? function (t, e, n) {
            return i.f(t, e, a(1, n));
          }
        : function (t, e, n) {
            return (t[e] = n), t;
          };
    },
    9114: function (t) {
      t.exports = function (t, e) {
        return {
          enumerable: !(1 & t),
          configurable: !(2 & t),
          writable: !(4 & t),
          value: e,
        };
      };
    },
    7045: function (t, e, n) {
      var r = n(6339),
        i = n(3070);
      t.exports = function (t, e, n) {
        return (
          n.get && r(n.get, e, { getter: !0 }),
          n.set && r(n.set, e, { setter: !0 }),
          i.f(t, e, n)
        );
      };
    },
    8052: function (t, e, n) {
      var r = n(614),
        i = n(3070),
        a = n(6339),
        o = n(3072);
      t.exports = function (t, e, n, s) {
        s || (s = {});
        var c = s.enumerable,
          l = void 0 !== s.name ? s.name : e;
        if ((r(n) && a(n, l, s), s.global)) c ? (t[e] = n) : o(e, n);
        else {
          try {
            s.unsafe ? t[e] && (c = !0) : delete t[e];
          } catch (u) {}
          c
            ? (t[e] = n)
            : i.f(t, e, {
                value: n,
                enumerable: !1,
                configurable: !s.nonConfigurable,
                writable: !s.nonWritable,
              });
        }
        return t;
      };
    },
    3072: function (t, e, n) {
      var r = n(7854),
        i = Object.defineProperty;
      t.exports = function (t, e) {
        try {
          i(r, t, { value: e, configurable: !0, writable: !0 });
        } catch (n) {
          r[t] = e;
        }
        return e;
      };
    },
    9781: function (t, e, n) {
      var r = n(7293);
      t.exports = !r(function () {
        return (
          7 !=
          Object.defineProperty({}, 1, {
            get: function () {
              return 7;
            },
          })[1]
        );
      });
    },
    317: function (t, e, n) {
      var r = n(7854),
        i = n(111),
        a = r.document,
        o = i(a) && i(a.createElement);
      t.exports = function (t) {
        return o ? a.createElement(t) : {};
      };
    },
    6833: function (t, e, n) {
      var r = n(8113);
      t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(r);
    },
    5268: function (t, e, n) {
      var r = n(4326),
        i = n(7854);
      t.exports = "process" == r(i.process);
    },
    8113: function (t, e, n) {
      var r = n(5005);
      t.exports = r("navigator", "userAgent") || "";
    },
    7392: function (t, e, n) {
      var r,
        i,
        a = n(7854),
        o = n(8113),
        s = a.process,
        c = a.Deno,
        l = (s && s.versions) || (c && c.version),
        u = l && l.v8;
      u &&
        ((r = u.split(".")), (i = r[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1]))),
        !i &&
          o &&
          ((r = o.match(/Edge\/(\d+)/)),
          (!r || r[1] >= 74) &&
            ((r = o.match(/Chrome\/(\d+)/)), r && (i = +r[1]))),
        (t.exports = i);
    },
    748: function (t) {
      t.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf",
      ];
    },
    2109: function (t, e, n) {
      var r = n(7854),
        i = n(1236).f,
        a = n(8880),
        o = n(8052),
        s = n(3072),
        c = n(9920),
        l = n(4705);
      t.exports = function (t, e) {
        var n,
          u,
          h,
          d,
          f,
          p,
          m = t.target,
          g = t.global,
          v = t.stat;
        if (((u = g ? r : v ? r[m] || s(m, {}) : (r[m] || {}).prototype), u))
          for (h in e) {
            if (
              ((f = e[h]),
              t.dontCallGetSet
                ? ((p = i(u, h)), (d = p && p.value))
                : (d = u[h]),
              (n = l(g ? h : m + (v ? "." : "#") + h, t.forced)),
              !n && void 0 !== d)
            ) {
              if (typeof f == typeof d) continue;
              c(f, d);
            }
            (t.sham || (d && d.sham)) && a(f, "sham", !0), o(u, h, f, t);
          }
      };
    },
    7293: function (t) {
      t.exports = function (t) {
        try {
          return !!t();
        } catch (e) {
          return !0;
        }
      };
    },
    2104: function (t, e, n) {
      var r = n(4374),
        i = Function.prototype,
        a = i.apply,
        o = i.call;
      t.exports =
        ("object" == typeof Reflect && Reflect.apply) ||
        (r
          ? o.bind(a)
          : function () {
              return o.apply(a, arguments);
            });
    },
    9974: function (t, e, n) {
      var r = n(1702),
        i = n(9662),
        a = n(4374),
        o = r(r.bind);
      t.exports = function (t, e) {
        return (
          i(t),
          void 0 === e
            ? t
            : a
            ? o(t, e)
            : function () {
                return t.apply(e, arguments);
              }
        );
      };
    },
    4374: function (t, e, n) {
      var r = n(7293);
      t.exports = !r(function () {
        var t = function () {}.bind();
        return "function" != typeof t || t.hasOwnProperty("prototype");
      });
    },
    6916: function (t, e, n) {
      var r = n(4374),
        i = Function.prototype.call;
      t.exports = r
        ? i.bind(i)
        : function () {
            return i.apply(i, arguments);
          };
    },
    6530: function (t, e, n) {
      var r = n(9781),
        i = n(2597),
        a = Function.prototype,
        o = r && Object.getOwnPropertyDescriptor,
        s = i(a, "name"),
        c = s && "something" === function () {}.name,
        l = s && (!r || (r && o(a, "name").configurable));
      t.exports = { EXISTS: s, PROPER: c, CONFIGURABLE: l };
    },
    1702: function (t, e, n) {
      var r = n(4374),
        i = Function.prototype,
        a = i.bind,
        o = i.call,
        s = r && a.bind(o, o);
      t.exports = r
        ? function (t) {
            return t && s(t);
          }
        : function (t) {
            return (
              t &&
              function () {
                return o.apply(t, arguments);
              }
            );
          };
    },
    5005: function (t, e, n) {
      var r = n(7854),
        i = n(614),
        a = function (t) {
          return i(t) ? t : void 0;
        };
      t.exports = function (t, e) {
        return arguments.length < 2 ? a(r[t]) : r[t] && r[t][e];
      };
    },
    8173: function (t, e, n) {
      var r = n(9662);
      t.exports = function (t, e) {
        var n = t[e];
        return null == n ? void 0 : r(n);
      };
    },
    7854: function (t, e, n) {
      var r = function (t) {
        return t && t.Math == Math && t;
      };
      t.exports =
        r("object" == typeof globalThis && globalThis) ||
        r("object" == typeof window && window) ||
        r("object" == typeof self && self) ||
        r("object" == typeof n.g && n.g) ||
        (function () {
          return this;
        })() ||
        Function("return this")();
    },
    2597: function (t, e, n) {
      var r = n(1702),
        i = n(7908),
        a = r({}.hasOwnProperty);
      t.exports =
        Object.hasOwn ||
        function (t, e) {
          return a(i(t), e);
        };
    },
    3501: function (t) {
      t.exports = {};
    },
    490: function (t, e, n) {
      var r = n(5005);
      t.exports = r("document", "documentElement");
    },
    4664: function (t, e, n) {
      var r = n(9781),
        i = n(7293),
        a = n(317);
      t.exports =
        !r &&
        !i(function () {
          return (
            7 !=
            Object.defineProperty(a("div"), "a", {
              get: function () {
                return 7;
              },
            }).a
          );
        });
    },
    8361: function (t, e, n) {
      var r = n(1702),
        i = n(7293),
        a = n(4326),
        o = Object,
        s = r("".split);
      t.exports = i(function () {
        return !o("z").propertyIsEnumerable(0);
      })
        ? function (t) {
            return "String" == a(t) ? s(t, "") : o(t);
          }
        : o;
    },
    2788: function (t, e, n) {
      var r = n(1702),
        i = n(614),
        a = n(5465),
        o = r(Function.toString);
      i(a.inspectSource) ||
        (a.inspectSource = function (t) {
          return o(t);
        }),
        (t.exports = a.inspectSource);
    },
    9909: function (t, e, n) {
      var r,
        i,
        a,
        o = n(8536),
        s = n(7854),
        c = n(1702),
        l = n(111),
        u = n(8880),
        h = n(2597),
        d = n(5465),
        f = n(6200),
        p = n(3501),
        m = "Object already initialized",
        g = s.TypeError,
        v = s.WeakMap,
        y = function (t) {
          return a(t) ? i(t) : r(t, {});
        },
        b = function (t) {
          return function (e) {
            var n;
            if (!l(e) || (n = i(e)).type !== t)
              throw g("Incompatible receiver, " + t + " required");
            return n;
          };
        };
      if (o || d.state) {
        var x = d.state || (d.state = new v()),
          _ = c(x.get),
          w = c(x.has),
          S = c(x.set);
        (r = function (t, e) {
          if (w(x, t)) throw new g(m);
          return (e.facade = t), S(x, t, e), e;
        }),
          (i = function (t) {
            return _(x, t) || {};
          }),
          (a = function (t) {
            return w(x, t);
          });
      } else {
        var M = f("state");
        (p[M] = !0),
          (r = function (t, e) {
            if (h(t, M)) throw new g(m);
            return (e.facade = t), u(t, M, e), e;
          }),
          (i = function (t) {
            return h(t, M) ? t[M] : {};
          }),
          (a = function (t) {
            return h(t, M);
          });
      }
      t.exports = { set: r, get: i, has: a, enforce: y, getterFor: b };
    },
    614: function (t) {
      t.exports = function (t) {
        return "function" == typeof t;
      };
    },
    4705: function (t, e, n) {
      var r = n(7293),
        i = n(614),
        a = /#|\.prototype\./,
        o = function (t, e) {
          var n = c[s(t)];
          return n == u || (n != l && (i(e) ? r(e) : !!e));
        },
        s = (o.normalize = function (t) {
          return String(t).replace(a, ".").toLowerCase();
        }),
        c = (o.data = {}),
        l = (o.NATIVE = "N"),
        u = (o.POLYFILL = "P");
      t.exports = o;
    },
    111: function (t, e, n) {
      var r = n(614);
      t.exports = function (t) {
        return "object" == typeof t ? null !== t : r(t);
      };
    },
    1913: function (t) {
      t.exports = !1;
    },
    2190: function (t, e, n) {
      var r = n(5005),
        i = n(614),
        a = n(7976),
        o = n(3307),
        s = Object;
      t.exports = o
        ? function (t) {
            return "symbol" == typeof t;
          }
        : function (t) {
            var e = r("Symbol");
            return i(e) && a(e.prototype, s(t));
          };
    },
    6244: function (t, e, n) {
      var r = n(7466);
      t.exports = function (t) {
        return r(t.length);
      };
    },
    6339: function (t, e, n) {
      var r = n(7293),
        i = n(614),
        a = n(2597),
        o = n(9781),
        s = n(6530).CONFIGURABLE,
        c = n(2788),
        l = n(9909),
        u = l.enforce,
        h = l.get,
        d = Object.defineProperty,
        f =
          o &&
          !r(function () {
            return 8 !== d(function () {}, "length", { value: 8 }).length;
          }),
        p = String(String).split("String"),
        m = (t.exports = function (t, e, n) {
          "Symbol(" === String(e).slice(0, 7) &&
            (e = "[" + String(e).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
            n && n.getter && (e = "get " + e),
            n && n.setter && (e = "set " + e),
            (!a(t, "name") || (s && t.name !== e)) &&
              (o ? d(t, "name", { value: e, configurable: !0 }) : (t.name = e)),
            f &&
              n &&
              a(n, "arity") &&
              t.length !== n.arity &&
              d(t, "length", { value: n.arity });
          try {
            n && a(n, "constructor") && n.constructor
              ? o && d(t, "prototype", { writable: !1 })
              : t.prototype && (t.prototype = void 0);
          } catch (i) {}
          var r = u(t);
          return (
            a(r, "source") ||
              (r.source = p.join("string" == typeof e ? e : "")),
            t
          );
        });
      Function.prototype.toString = m(function () {
        return (i(this) && h(this).source) || c(this);
      }, "toString");
    },
    4758: function (t) {
      var e = Math.ceil,
        n = Math.floor;
      t.exports =
        Math.trunc ||
        function (t) {
          var r = +t;
          return (r > 0 ? n : e)(r);
        };
    },
    133: function (t, e, n) {
      var r = n(7392),
        i = n(7293);
      t.exports =
        !!Object.getOwnPropertySymbols &&
        !i(function () {
          var t = Symbol();
          return (
            !String(t) ||
            !(Object(t) instanceof Symbol) ||
            (!Symbol.sham && r && r < 41)
          );
        });
    },
    8536: function (t, e, n) {
      var r = n(7854),
        i = n(614),
        a = n(2788),
        o = r.WeakMap;
      t.exports = i(o) && /native code/.test(a(o));
    },
    3070: function (t, e, n) {
      var r = n(9781),
        i = n(4664),
        a = n(3353),
        o = n(9670),
        s = n(4948),
        c = TypeError,
        l = Object.defineProperty,
        u = Object.getOwnPropertyDescriptor,
        h = "enumerable",
        d = "configurable",
        f = "writable";
      e.f = r
        ? a
          ? function (t, e, n) {
              if (
                (o(t),
                (e = s(e)),
                o(n),
                "function" === typeof t &&
                  "prototype" === e &&
                  "value" in n &&
                  f in n &&
                  !n[f])
              ) {
                var r = u(t, e);
                r &&
                  r[f] &&
                  ((t[e] = n.value),
                  (n = {
                    configurable: d in n ? n[d] : r[d],
                    enumerable: h in n ? n[h] : r[h],
                    writable: !1,
                  }));
              }
              return l(t, e, n);
            }
          : l
        : function (t, e, n) {
            if ((o(t), (e = s(e)), o(n), i))
              try {
                return l(t, e, n);
              } catch (r) {}
            if ("get" in n || "set" in n) throw c("Accessors not supported");
            return "value" in n && (t[e] = n.value), t;
          };
    },
    1236: function (t, e, n) {
      var r = n(9781),
        i = n(6916),
        a = n(5296),
        o = n(9114),
        s = n(5656),
        c = n(4948),
        l = n(2597),
        u = n(4664),
        h = Object.getOwnPropertyDescriptor;
      e.f = r
        ? h
        : function (t, e) {
            if (((t = s(t)), (e = c(e)), u))
              try {
                return h(t, e);
              } catch (n) {}
            if (l(t, e)) return o(!i(a.f, t, e), t[e]);
          };
    },
    8006: function (t, e, n) {
      var r = n(6324),
        i = n(748),
        a = i.concat("length", "prototype");
      e.f =
        Object.getOwnPropertyNames ||
        function (t) {
          return r(t, a);
        };
    },
    5181: function (t, e) {
      e.f = Object.getOwnPropertySymbols;
    },
    7976: function (t, e, n) {
      var r = n(1702);
      t.exports = r({}.isPrototypeOf);
    },
    6324: function (t, e, n) {
      var r = n(1702),
        i = n(2597),
        a = n(5656),
        o = n(1318).indexOf,
        s = n(3501),
        c = r([].push);
      t.exports = function (t, e) {
        var n,
          r = a(t),
          l = 0,
          u = [];
        for (n in r) !i(s, n) && i(r, n) && c(u, n);
        while (e.length > l) i(r, (n = e[l++])) && (~o(u, n) || c(u, n));
        return u;
      };
    },
    5296: function (t, e) {
      "use strict";
      var n = {}.propertyIsEnumerable,
        r = Object.getOwnPropertyDescriptor,
        i = r && !n.call({ 1: 2 }, 1);
      e.f = i
        ? function (t) {
            var e = r(this, t);
            return !!e && e.enumerable;
          }
        : n;
    },
    2140: function (t, e, n) {
      var r = n(6916),
        i = n(614),
        a = n(111),
        o = TypeError;
      t.exports = function (t, e) {
        var n, s;
        if ("string" === e && i((n = t.toString)) && !a((s = r(n, t))))
          return s;
        if (i((n = t.valueOf)) && !a((s = r(n, t)))) return s;
        if ("string" !== e && i((n = t.toString)) && !a((s = r(n, t))))
          return s;
        throw o("Can't convert object to primitive value");
      };
    },
    3887: function (t, e, n) {
      var r = n(5005),
        i = n(1702),
        a = n(8006),
        o = n(5181),
        s = n(9670),
        c = i([].concat);
      t.exports =
        r("Reflect", "ownKeys") ||
        function (t) {
          var e = a.f(s(t)),
            n = o.f;
          return n ? c(e, n(t)) : e;
        };
    },
    7066: function (t, e, n) {
      "use strict";
      var r = n(9670);
      t.exports = function () {
        var t = r(this),
          e = "";
        return (
          t.hasIndices && (e += "d"),
          t.global && (e += "g"),
          t.ignoreCase && (e += "i"),
          t.multiline && (e += "m"),
          t.dotAll && (e += "s"),
          t.unicode && (e += "u"),
          t.unicodeSets && (e += "v"),
          t.sticky && (e += "y"),
          e
        );
      };
    },
    4488: function (t) {
      var e = TypeError;
      t.exports = function (t) {
        if (void 0 == t) throw e("Can't call method on " + t);
        return t;
      };
    },
    6200: function (t, e, n) {
      var r = n(2309),
        i = n(9711),
        a = r("keys");
      t.exports = function (t) {
        return a[t] || (a[t] = i(t));
      };
    },
    5465: function (t, e, n) {
      var r = n(7854),
        i = n(3072),
        a = "__core-js_shared__",
        o = r[a] || i(a, {});
      t.exports = o;
    },
    2309: function (t, e, n) {
      var r = n(1913),
        i = n(5465);
      (t.exports = function (t, e) {
        return i[t] || (i[t] = void 0 !== e ? e : {});
      })("versions", []).push({
        version: "3.24.1",
        mode: r ? "pure" : "global",
        copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",
        source: "https://github.com/zloirock/core-js",
      });
    },
    261: function (t, e, n) {
      var r,
        i,
        a,
        o,
        s = n(7854),
        c = n(2104),
        l = n(9974),
        u = n(614),
        h = n(2597),
        d = n(7293),
        f = n(490),
        p = n(206),
        m = n(317),
        g = n(8053),
        v = n(6833),
        y = n(5268),
        b = s.setImmediate,
        x = s.clearImmediate,
        _ = s.process,
        w = s.Dispatch,
        S = s.Function,
        M = s.MessageChannel,
        T = s.String,
        E = 0,
        A = {},
        C = "onreadystatechange";
      try {
        r = s.location;
      } catch (O) {}
      var L = function (t) {
          if (h(A, t)) {
            var e = A[t];
            delete A[t], e();
          }
        },
        R = function (t) {
          return function () {
            L(t);
          };
        },
        P = function (t) {
          L(t.data);
        },
        I = function (t) {
          s.postMessage(T(t), r.protocol + "//" + r.host);
        };
      (b && x) ||
        ((b = function (t) {
          g(arguments.length, 1);
          var e = u(t) ? t : S(t),
            n = p(arguments, 1);
          return (
            (A[++E] = function () {
              c(e, void 0, n);
            }),
            i(E),
            E
          );
        }),
        (x = function (t) {
          delete A[t];
        }),
        y
          ? (i = function (t) {
              _.nextTick(R(t));
            })
          : w && w.now
          ? (i = function (t) {
              w.now(R(t));
            })
          : M && !v
          ? ((a = new M()),
            (o = a.port2),
            (a.port1.onmessage = P),
            (i = l(o.postMessage, o)))
          : s.addEventListener &&
            u(s.postMessage) &&
            !s.importScripts &&
            r &&
            "file:" !== r.protocol &&
            !d(I)
          ? ((i = I), s.addEventListener("message", P, !1))
          : (i =
              C in m("script")
                ? function (t) {
                    f.appendChild(m("script"))[C] = function () {
                      f.removeChild(this), L(t);
                    };
                  }
                : function (t) {
                    setTimeout(R(t), 0);
                  })),
        (t.exports = { set: b, clear: x });
    },
    1400: function (t, e, n) {
      var r = n(9303),
        i = Math.max,
        a = Math.min;
      t.exports = function (t, e) {
        var n = r(t);
        return n < 0 ? i(n + e, 0) : a(n, e);
      };
    },
    5656: function (t, e, n) {
      var r = n(8361),
        i = n(4488);
      t.exports = function (t) {
        return r(i(t));
      };
    },
    9303: function (t, e, n) {
      var r = n(4758);
      t.exports = function (t) {
        var e = +t;
        return e !== e || 0 === e ? 0 : r(e);
      };
    },
    7466: function (t, e, n) {
      var r = n(9303),
        i = Math.min;
      t.exports = function (t) {
        return t > 0 ? i(r(t), 9007199254740991) : 0;
      };
    },
    7908: function (t, e, n) {
      var r = n(4488),
        i = Object;
      t.exports = function (t) {
        return i(r(t));
      };
    },
    7593: function (t, e, n) {
      var r = n(6916),
        i = n(111),
        a = n(2190),
        o = n(8173),
        s = n(2140),
        c = n(5112),
        l = TypeError,
        u = c("toPrimitive");
      t.exports = function (t, e) {
        if (!i(t) || a(t)) return t;
        var n,
          c = o(t, u);
        if (c) {
          if (
            (void 0 === e && (e = "default"), (n = r(c, t, e)), !i(n) || a(n))
          )
            return n;
          throw l("Can't convert object to primitive value");
        }
        return void 0 === e && (e = "number"), s(t, e);
      };
    },
    4948: function (t, e, n) {
      var r = n(7593),
        i = n(2190);
      t.exports = function (t) {
        var e = r(t, "string");
        return i(e) ? e : e + "";
      };
    },
    6330: function (t) {
      var e = String;
      t.exports = function (t) {
        try {
          return e(t);
        } catch (n) {
          return "Object";
        }
      };
    },
    9711: function (t, e, n) {
      var r = n(1702),
        i = 0,
        a = Math.random(),
        o = r((1).toString);
      t.exports = function (t) {
        return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++i + a, 36);
      };
    },
    3307: function (t, e, n) {
      var r = n(133);
      t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    },
    3353: function (t, e, n) {
      var r = n(9781),
        i = n(7293);
      t.exports =
        r &&
        i(function () {
          return (
            42 !=
            Object.defineProperty(function () {}, "prototype", {
              value: 42,
              writable: !1,
            }).prototype
          );
        });
    },
    8053: function (t) {
      var e = TypeError;
      t.exports = function (t, n) {
        if (t < n) throw e("Not enough arguments");
        return t;
      };
    },
    5112: function (t, e, n) {
      var r = n(7854),
        i = n(2309),
        a = n(2597),
        o = n(9711),
        s = n(133),
        c = n(3307),
        l = i("wks"),
        u = r.Symbol,
        h = u && u["for"],
        d = c ? u : (u && u.withoutSetter) || o;
      t.exports = function (t) {
        if (!a(l, t) || (!s && "string" != typeof l[t])) {
          var e = "Symbol." + t;
          s && a(u, t) ? (l[t] = u[t]) : (l[t] = c && h ? h(e) : d(e));
        }
        return l[t];
      };
    },
    2087: function (t, e, n) {
      var r = n(7854),
        i = n(9781),
        a = n(7045),
        o = n(7066),
        s = n(7293),
        c = r.RegExp,
        l = c.prototype,
        u =
          i &&
          s(function () {
            var t = !0;
            try {
              c(".", "d");
            } catch (u) {
              t = !1;
            }
            var e = {},
              n = "",
              r = t ? "dgimsy" : "gimsy",
              i = function (t, r) {
                Object.defineProperty(e, t, {
                  get: function () {
                    return (n += r), !0;
                  },
                });
              },
              a = {
                dotAll: "s",
                global: "g",
                ignoreCase: "i",
                multiline: "m",
                sticky: "y",
              };
            for (var o in (t && (a.hasIndices = "d"), a)) i(o, a[o]);
            var s = Object.getOwnPropertyDescriptor(l, "flags").get.call(e);
            return s !== r || n !== r;
          });
      u && a(l, "flags", { configurable: !0, get: o });
    },
    1091: function (t, e, n) {
      var r = n(2109),
        i = n(7854),
        a = n(261).clear;
      r(
        {
          global: !0,
          bind: !0,
          enumerable: !0,
          forced: i.clearImmediate !== a,
        },
        { clearImmediate: a }
      );
    },
    4633: function (t, e, n) {
      n(1091), n(2986);
    },
    2986: function (t, e, n) {
      var r = n(2109),
        i = n(7854),
        a = n(261).set;
      r(
        { global: !0, bind: !0, enumerable: !0, forced: i.setImmediate !== a },
        { setImmediate: a }
      );
    },
    9425: function (t, e, n) {
      "use strict";
      function r(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function i(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? r(Object(n), !0).forEach(function (e) {
                a(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : r(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function a(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      n.d(e, {
        Z: function () {
          return p;
        },
      });
      var o = {},
        s = "https://www.googletagmanager.com/gtag/js",
        c = {
          debug_mode: !1,
          send_page_view: !1,
          anonymize_ip: !1,
          allow_google_signals: !0,
          allow_ad_personalization_signals: !0,
          cookie_flags: "",
        },
        l = {
          gtagName: "gtag",
          dataLayerName: "ga4DataLayer",
          measurementIds: [],
          gtagConfig: c,
        };
      function u() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = 0,
          n = h(t.measurementIds),
          r = i(i({}, l), t);
        return {
          name: "google-analytics",
          config: r,
          initialize: function (t) {
            var e = t.config,
              r = t.instance,
              a = e.dataLayerName,
              l = e.customScriptSrc,
              u = e.gtagName,
              h = e.gtagConfig,
              d = e.debug;
            if (!f(l || s)) {
              var p = a ? "&l=".concat(a) : "",
                m = document.createElement("script");
              (m.async = !0),
                (m.src = l || "".concat(s, "?id=").concat(n[0]).concat(p)),
                document.body.appendChild(m);
            }
            window[a] ||
              ((window[a] = window[a] || []),
              (window[u] = function () {
                window[a].push(arguments);
              }),
              window[u]("js", new Date()));
            var g = i(i(i({}, c), h || {}), d ? { debug_mode: !0 } : {}),
              v = r.user() || {},
              y = v.traits || {};
            Object.keys(y).length && window[u]("set", "user_properties", y);
            for (var b = 0; b < n.length; b++)
              o[n[b]] || (window[u]("config", n[b], g), (o[n[b]] = !0));
          },
          identify: function (t) {
            var e = t.payload,
              r = t.config,
              i = r.gtagName;
            window[i] &&
              n.length &&
              (e.userId && window[i]("set", { user_id: e.userId }),
              Object.keys(e.traits).length &&
                window[i]("set", "user_properties", e.traits));
          },
          page: function (t) {
            var r = t.payload,
              a = t.config,
              o = t.instance,
              s = a.gtagName,
              c = a.gtagConfig;
            if (window[s] && n.length) {
              var l = r.properties,
                u = l.send_to,
                h = o.getState("context.campaign"),
                f = {
                  page_title: l.title,
                  page_location: l.url,
                  page_path: l.path || document.location.pathname,
                  page_hash: l.hash,
                  page_search: l.page_search,
                  page_referrer: l.referrer,
                },
                p = d(h),
                m = i(i(i({}, u ? { send_to: u } : {}), f), p);
              (c && c.send_page_view && 0 === e) ||
                window[s]("event", "page_view", m),
                e++;
            }
          },
          track: function (t) {
            var e = t.payload,
              r = t.config,
              a = t.instance,
              o = e.properties,
              s = e.event,
              c = a.getState("context.campaign"),
              l = r.gtagName;
            if (window[l] && n.length) {
              var u = d(c),
                h = i(i({}, o), u);
              window[l]("event", s, h);
            }
          },
          loaded: function () {
            var t = r.dataLayerName,
              e = r.customScriptSrc,
              n = t && window[t] && Array.prototype.push === window[t].push;
            return f(e || s) && n;
          },
          methods: {
            addTag: function (t) {
              var e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
              window[r.gtagName] &&
                (window[r.gtagName]("config", t, e),
                n && !n.includes(t) && (n = n.concat(t)));
            },
            disable: function (t) {
              for (var e = t ? h(t) : n, r = 0; r < n.length; r++) {
                var i = n[r];
                e.includes(i) && (window["ga-disable-".concat(i)] = !0);
              }
            },
            enable: function (t) {
              for (var e = t ? h(t) : n, r = 0; r < n.length; r++) {
                var i = n[r];
                e.includes(i) && (window["ga-disable-".concat(i)] = !1);
              }
            },
          },
        };
      }
      function h(t) {
        if (!t) throw new Error("No GA Measurement ID defined");
        if (Array.isArray(t)) return t;
        if ("string" === typeof t) return [t];
        throw new Error("GA Measurement ID must be string or array of strings");
      }
      function d() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = {},
          n = t.id,
          r = t.name,
          i = t.source,
          a = t.medium,
          o = t.content,
          s = t.keyword;
        return (
          n && (e.campaignId = n),
          r && (e.campaignName = r),
          i && (e.campaignSource = i),
          a && (e.campaignMedium = a),
          o && (e.campaignContent = o),
          s && (e.campaignKeyword = s),
          e
        );
      }
      function f(t) {
        var e = document.querySelectorAll("script[src]"),
          n = new RegExp("^".concat(t));
        return Boolean(
          Object.values(e).filter(function (t) {
            return n.test(t.src);
          }).length
        );
      }
      var p = u;
    },
    7749: function (t, e, n) {
      "use strict";
      n.d(e, {
        GN: function () {
          return R;
        },
      });
      var r = n(3494);
      function i(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function a(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? i(Object(n), !0).forEach(function (e) {
                s(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : i(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function o(t) {
        return (
          (o =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          o(t)
        );
      }
      function s(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function c(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = {},
          a = Object.keys(t);
        for (r = 0; r < a.length; r++)
          (n = a[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
        return i;
      }
      function l(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = c(t, e);
        if (Object.getOwnPropertySymbols) {
          var a = Object.getOwnPropertySymbols(t);
          for (r = 0; r < a.length; r++)
            (n = a[r]),
              e.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, n) &&
                  (i[n] = t[n]));
        }
        return i;
      }
      function u(t) {
        return h(t) || d(t) || f(t) || m();
      }
      function h(t) {
        if (Array.isArray(t)) return p(t);
      }
      function d(t) {
        if (
          ("undefined" !== typeof Symbol && null != t[Symbol.iterator]) ||
          null != t["@@iterator"]
        )
          return Array.from(t);
      }
      function f(t, e) {
        if (t) {
          if ("string" === typeof t) return p(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === n && t.constructor && (n = t.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(t)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? p(t, e)
              : void 0
          );
        }
      }
      function p(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function m() {
        throw new TypeError(
          "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var g =
          "undefined" !== typeof globalThis
            ? globalThis
            : "undefined" !== typeof window
            ? window
            : "undefined" !== typeof n.g
            ? n.g
            : "undefined" !== typeof self
            ? self
            : {},
        v = { exports: {} };
      (function (t) {
        (function (e) {
          var n = function (t, e, r) {
              if (!l(e) || h(e) || d(e) || f(e) || c(e)) return e;
              var i,
                a = 0,
                o = 0;
              if (u(e))
                for (i = [], o = e.length; a < o; a++) i.push(n(t, e[a], r));
              else
                for (var s in ((i = {}), e))
                  Object.prototype.hasOwnProperty.call(e, s) &&
                    (i[t(s, r)] = n(t, e[s], r));
              return i;
            },
            r = function (t, e) {
              e = e || {};
              var n = e.separator || "_",
                r = e.split || /(?=[A-Z])/;
              return t.split(r).join(n);
            },
            i = function (t) {
              return p(t)
                ? t
                : ((t = t.replace(/[\-_\s]+(.)?/g, function (t, e) {
                    return e ? e.toUpperCase() : "";
                  })),
                  t.substr(0, 1).toLowerCase() + t.substr(1));
            },
            a = function (t) {
              var e = i(t);
              return e.substr(0, 1).toUpperCase() + e.substr(1);
            },
            o = function (t, e) {
              return r(t, e).toLowerCase();
            },
            s = Object.prototype.toString,
            c = function (t) {
              return "function" === typeof t;
            },
            l = function (t) {
              return t === Object(t);
            },
            u = function (t) {
              return "[object Array]" == s.call(t);
            },
            h = function (t) {
              return "[object Date]" == s.call(t);
            },
            d = function (t) {
              return "[object RegExp]" == s.call(t);
            },
            f = function (t) {
              return "[object Boolean]" == s.call(t);
            },
            p = function (t) {
              return (t -= 0), t === t;
            },
            m = function (t, e) {
              var n = e && "process" in e ? e.process : e;
              return "function" !== typeof n
                ? t
                : function (e, r) {
                    return n(e, t, r);
                  };
            },
            g = {
              camelize: i,
              decamelize: o,
              pascalize: a,
              depascalize: o,
              camelizeKeys: function (t, e) {
                return n(m(i, e), t);
              },
              decamelizeKeys: function (t, e) {
                return n(m(o, e), t, e);
              },
              pascalizeKeys: function (t, e) {
                return n(m(a, e), t);
              },
              depascalizeKeys: function () {
                return this.decamelizeKeys.apply(this, arguments);
              },
            };
          t.exports ? (t.exports = g) : (e.humps = g);
        })(g);
      })(v);
      var y = v.exports,
        b = ["class", "style", "attrs"];
      function x(t) {
        return t
          .split(";")
          .map(function (t) {
            return t.trim();
          })
          .filter(function (t) {
            return t;
          })
          .reduce(function (t, e) {
            var n = e.indexOf(":"),
              r = y.camelize(e.slice(0, n)),
              i = e.slice(n + 1).trim();
            return (t[r] = i), t;
          }, {});
      }
      function _(t) {
        return t.split(/\s+/).reduce(function (t, e) {
          return (t[e] = !0), t;
        }, {});
      }
      function w() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return e.reduce(function (t, e) {
          return Array.isArray(e) ? (t = t.concat(e)) : t.push(e), t;
        }, []);
      }
      function S(t, e) {
        var n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
          i = (e.children || []).map(S.bind(null, t)),
          o = Object.keys(e.attributes || {}).reduce(
            function (t, n) {
              var r = e.attributes[n];
              switch (n) {
                case "class":
                  t["class"] = _(r);
                  break;
                case "style":
                  t["style"] = x(r);
                  break;
                default:
                  t.attrs[n] = r;
              }
              return t;
            },
            { class: {}, style: {}, attrs: {} }
          ),
          s = r.class,
          c = void 0 === s ? {} : s,
          u = r.style,
          h = void 0 === u ? {} : u,
          d = r.attrs,
          f = void 0 === d ? {} : d,
          p = l(r, b);
        return "string" === typeof e
          ? e
          : t(
              e.tag,
              a(
                a(
                  {
                    class: w(o.class, c),
                    style: a(a({}, o.style), h),
                    attrs: a(a({}, o.attrs), f),
                  },
                  p
                ),
                {},
                { props: n }
              ),
              i
            );
      }
      var M = !1;
      try {
        M = !0;
      } catch (P) {}
      function T() {
        var t;
        !M &&
          console &&
          "function" === typeof console.error &&
          (t = console).error.apply(t, arguments);
      }
      function E(t, e) {
        return (Array.isArray(e) && e.length > 0) || (!Array.isArray(e) && e)
          ? s({}, t, e)
          : {};
      }
      function A(t) {
        var e,
          n =
            ((e = {
              "fa-spin": t.spin,
              "fa-spin-pulse": t.spinPulse,
              "fa-spin-reverse": t.spinReverse,
              "fa-pulse": t.pulse,
              "fa-beat": t.beat,
              "fa-fade": t.fade,
              "fa-flash": t.flash,
              "fa-fw": t.fixedWidth,
              "fa-border": t.border,
              "fa-li": t.listItem,
              "fa-inverse": t.inverse,
              "fa-flip": !0 === t.flip,
              "fa-flip-horizontal":
                "horizontal" === t.flip || "both" === t.flip,
              "fa-flip-vertical": "vertical" === t.flip || "both" === t.flip,
            }),
            s(e, "fa-".concat(t.size), null !== t.size),
            s(e, "fa-rotate-".concat(t.rotation), null !== t.rotation),
            s(e, "fa-pull-".concat(t.pull), null !== t.pull),
            s(e, "fa-swap-opacity", t.swapOpacity),
            s(e, "fa-bounce", t.bounce),
            s(e, "fa-shake", t.shake),
            s(e, "fa-beat-fade", t.beatFade),
            e);
        return Object.keys(n)
          .map(function (t) {
            return n[t] ? t : null;
          })
          .filter(function (t) {
            return t;
          });
      }
      function C(t, e) {
        var n = 0 === (t || "").length ? [] : [t];
        return n.concat(e).join(" ");
      }
      function L(t) {
        return t && "object" === o(t) && t.prefix && t.iconName && t.icon
          ? t
          : r.Qc.icon
          ? r.Qc.icon(t)
          : null === t
          ? null
          : "object" === o(t) && t.prefix && t.iconName
          ? t
          : Array.isArray(t) && 2 === t.length
          ? { prefix: t[0], iconName: t[1] }
          : "string" === typeof t
          ? { prefix: "fas", iconName: t }
          : void 0;
      }
      var R = {
        name: "FontAwesomeIcon",
        functional: !0,
        props: {
          beat: { type: Boolean, default: !1 },
          border: { type: Boolean, default: !1 },
          fade: { type: Boolean, default: !1 },
          fixedWidth: { type: Boolean, default: !1 },
          flash: { type: Boolean, default: !1 },
          flip: {
            type: [Boolean, String],
            default: !1,
            validator: function (t) {
              return [!0, !1, "horizontal", "vertical", "both"].indexOf(t) > -1;
            },
          },
          icon: { type: [Object, Array, String], required: !0 },
          mask: { type: [Object, Array, String], default: null },
          listItem: { type: Boolean, default: !1 },
          pull: {
            type: String,
            default: null,
            validator: function (t) {
              return ["right", "left"].indexOf(t) > -1;
            },
          },
          pulse: { type: Boolean, default: !1 },
          rotation: {
            type: [String, Number],
            default: null,
            validator: function (t) {
              return [90, 180, 270].indexOf(parseInt(t, 10)) > -1;
            },
          },
          swapOpacity: { type: Boolean, default: !1 },
          size: {
            type: String,
            default: null,
            validator: function (t) {
              return (
                [
                  "2xs",
                  "xs",
                  "sm",
                  "lg",
                  "xl",
                  "2xl",
                  "1x",
                  "2x",
                  "3x",
                  "4x",
                  "5x",
                  "6x",
                  "7x",
                  "8x",
                  "9x",
                  "10x",
                ].indexOf(t) > -1
              );
            },
          },
          spin: { type: Boolean, default: !1 },
          spinPulse: { type: Boolean, default: !1 },
          spinReverse: { type: Boolean, default: !1 },
          transform: { type: [String, Object], default: null },
          symbol: { type: [Boolean, String], default: !1 },
          title: { type: String, default: null },
          inverse: { type: Boolean, default: !1 },
          bounce: { type: Boolean, default: !1 },
          shake: { type: Boolean, default: !1 },
          beatFade: { type: Boolean, default: !1 },
        },
        render: function (t, e) {
          var n = e.props,
            i = n.icon,
            o = n.mask,
            s = n.symbol,
            c = n.title,
            l = L(i),
            u = E("classes", A(n)),
            h = E(
              "transform",
              "string" === typeof n.transform
                ? r.Qc.transform(n.transform)
                : n.transform
            ),
            d = E("mask", L(o)),
            f = (0, r.qv)(
              l,
              a(a(a(a({}, u), h), d), {}, { symbol: s, title: c })
            );
          if (!f) return T("Could not find one or more icon(s)", l, d);
          var p = f.abstract,
            m = S.bind(null, t);
          return m(p[0], {}, e.data);
        },
      };
      Boolean, Boolean;
    },
    1912: function (t, e, n) {
      "use strict";
      n.d(e, {
        ZP: function () {
          return We;
        },
      });
      var r = n(2883),
        i = n.n(r),
        a = "undefined",
        o = "object",
        s = "any",
        c = "*",
        l = "__",
        u = "undefined" != typeof process ? process : {},
        h = (u.env && u.env.NODE_ENV, "undefined" != typeof window);
      h && window.location.hostname,
        null != u.versions && u.versions.node,
        "undefined" != typeof Deno && Deno.core,
        "object" == typeof self && self.constructor && self.constructor.name,
        (h && "nodejs" === window.name) ||
          ("undefined" != typeof navigator &&
            (navigator.userAgent.includes("Node.js") ||
              navigator.userAgent.includes("jsdom")));
      function d(t, e) {
        return e.charAt(0)[t]() + e.slice(1);
      }
      var f = d.bind(null, "toUpperCase"),
        p = d.bind(null, "toLowerCase");
      function m(t) {
        return w(t)
          ? f("null")
          : "object" == typeof t
          ? A(t)
          : Object.prototype.toString.call(t).slice(8, -1);
      }
      function g(t, e) {
        void 0 === e && (e = !0);
        var n = m(t);
        return e ? p(n) : n;
      }
      function v(t, e) {
        return typeof e === t;
      }
      var y = v.bind(null, "function"),
        b = v.bind(null, "string"),
        x = v.bind(null, "undefined");
      var _ = v.bind(null, "boolean");
      v.bind(null, "symbol");
      function w(t) {
        return null === t;
      }
      function S(t) {
        return "number" === g(t) && !isNaN(t);
      }
      function M(t) {
        return "array" === g(t);
      }
      function T(t) {
        if (!E(t)) return !1;
        for (var e = t; null !== Object.getPrototypeOf(e); )
          e = Object.getPrototypeOf(e);
        return Object.getPrototypeOf(t) === e;
      }
      function E(t) {
        return t && ("object" == typeof t || null !== t);
      }
      function A(t) {
        return y(t.constructor) ? t.constructor.name : null;
      }
      function C(t) {
        return (
          t instanceof Error ||
          (b(t.message) && t.constructor && S(t.constructor.stackTraceLimit))
        );
      }
      function L(t, e) {
        if ("object" != typeof e || w(e)) return !1;
        if (e instanceof t) return !0;
        var n = g(new t(""));
        if (C(e))
          for (; e; ) {
            if (g(e) === n) return !0;
            e = Object.getPrototypeOf(e);
          }
        return !1;
      }
      L.bind(null, TypeError), L.bind(null, SyntaxError);
      function R(t, e) {
        var n = t instanceof Element || t instanceof HTMLDocument;
        return n && e ? P(t, e) : n;
      }
      function P(t, e) {
        return void 0 === e && (e = ""), t && t.nodeName === e.toUpperCase();
      }
      function I(t) {
        var e = [].slice.call(arguments, 1);
        return function () {
          return t.apply(void 0, [].slice.call(arguments).concat(e));
        };
      }
      I(R, "form"), I(R, "button"), I(R, "input"), I(R, "select");
      function O(t) {
        try {
          return decodeURIComponent(t.replace(/\+/g, " "));
        } catch (t) {
          return null;
        }
      }
      function k() {
        if (h) {
          var t = navigator,
            e = t.languages;
          return t.userLanguage || (e && e.length ? e[0] : t.language);
        }
      }
      function N() {
        try {
          return Intl.DateTimeFormat().resolvedOptions().timeZone;
        } catch (t) {}
      }
      function D(t) {
        return (function (t) {
          for (
            var e, n = Object.create(null), r = /([^&=]+)=?([^&]*)/g;
            (e = r.exec(t));

          ) {
            var i = O(e[1]),
              a = O(e[2]);
            "[]" === i.substring(i.length - 2)
              ? (n[(i = i.substring(0, i.length - 2))] || (n[i] = [])).push(a)
              : (n[i] = "" === a || a);
          }
          for (var o in n) {
            var s = o.split("[");
            s.length > 1 &&
              (z(
                n,
                s.map(function (t) {
                  return t.replace(/[?[\]\\ ]/g, "");
                }),
                n[o]
              ),
              delete n[o]);
          }
          return n;
        })(
          (function (t) {
            if (t) {
              var e = t.match(/\?(.*)/);
              return e && e[1] ? e[1].split("#")[0] : "";
            }
            return h && window.location.search.substring(1);
          })(t)
        );
      }
      function z(t, e, n) {
        for (var r = e.length - 1, i = 0; i < r; ++i) {
          var a = e[i];
          if ("__proto__" === a || "constructor" === a) break;
          a in t || (t[a] = {}), (t = t[a]);
        }
        t[e[r]] = n;
      }
      function F() {
        for (
          var t = "", e = 0, n = (4294967295 * Math.random()) | 0;
          e++ < 36;

        ) {
          var r = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"[e - 1],
            i = 15 & n;
          (t +=
            "-" == r || "4" == r
              ? r
              : ("x" == r ? i : (3 & i) | 8).toString(16)),
            (n = e % 8 == 0 ? (4294967295 * Math.random()) | 0 : n >> 4);
        }
        return t;
      }
      var U = "global",
        B = l + "global" + l,
        j =
          (typeof self === o && self.self === self && self) ||
          (typeof n.g === o && n.g.global === n.g && n.g) ||
          void 0;
      function H(t) {
        return j[B][t];
      }
      function V(t, e) {
        return (j[B][t] = e);
      }
      function G(t) {
        delete j[B][t];
      }
      function W(t, e, n) {
        var r;
        try {
          if (X(t)) {
            var i = window[t];
            r = i[e].bind(i);
          }
        } catch (t) {}
        return r || n;
      }
      j[B] || (j[B] = {});
      var q = {};
      function X(t) {
        if (typeof q[t] !== a) return q[t];
        try {
          var e = window[t];
          e.setItem(a, a), e.removeItem(a);
        } catch (e) {
          return (q[t] = !1);
        }
        return (q[t] = !0);
      }
      function $() {
        return (
          ($ =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var r in n)
                  Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
              }
              return t;
            }),
          $.apply(this, arguments)
        );
      }
      var Y = "function",
        J = "undefined",
        K = "@@redux/" + Math.random().toString(36),
        Z = (function () {
          return (typeof Symbol === Y && Symbol.observable) || "@@observable";
        })(),
        Q = " != " + Y;
      function tt(t, e, n) {
        var r;
        if (
          (typeof e === Y && typeof n === J && ((n = e), (e = void 0)),
          typeof n !== J)
        ) {
          if (typeof n !== Y) throw new Error("enhancer" + Q);
          return n(tt)(t, e);
        }
        if (typeof t !== Y) throw new Error("reducer" + Q);
        var i = t,
          a = e,
          o = [],
          s = o,
          c = !1;
        function l() {
          s === o && (s = o.slice());
        }
        function u() {
          return a;
        }
        function h(t) {
          if (typeof t !== Y) throw new Error("Listener" + Q);
          var e = !0;
          return (
            l(),
            s.push(t),
            function () {
              if (e) {
                (e = !1), l();
                var n = s.indexOf(t);
                s.splice(n, 1);
              }
            }
          );
        }
        function d(t) {
          if (!T(t)) throw new Error("Act != obj");
          if (typeof t.type === J) throw new Error("ActType " + J);
          if (c) throw new Error("Dispatch in reducer");
          try {
            (c = !0), (a = i(a, t));
          } finally {
            c = !1;
          }
          for (var e = (o = s), n = 0; n < e.length; n++) (0, e[n])();
          return t;
        }
        return (
          d({ type: "@@redux/INIT" }),
          ((r = {
            dispatch: d,
            subscribe: h,
            getState: u,
            replaceReducer: function (t) {
              if (typeof t !== Y) throw new Error("next reducer" + Q);
              (i = t), d({ type: "@@redux/INIT" });
            },
          })[Z] = function () {
            var t,
              e = h;
            return (
              ((t = {
                subscribe: function (t) {
                  if ("object" != typeof t)
                    throw new TypeError("Observer != obj");
                  function n() {
                    t.next && t.next(u());
                  }
                  return n(), { unsubscribe: e(n) };
                },
              })[Z] = function () {
                return this;
              }),
              t
            );
          }),
          r
        );
      }
      function et(t, e) {
        var n = e && e.type;
        return (
          "action " +
          ((n && n.toString()) || "?") +
          "reducer " +
          t +
          " returns " +
          J
        );
      }
      function nt() {
        var t = [].slice.call(arguments);
        return 0 === t.length
          ? function (t) {
              return t;
            }
          : 1 === t.length
          ? t[0]
          : t.reduce(function (t, e) {
              return function () {
                return t(e.apply(void 0, [].slice.call(arguments)));
              };
            });
      }
      function rt() {
        var t = arguments;
        return function (e) {
          return function (n, r, i) {
            var a,
              o = e(n, r, i),
              s = o.dispatch,
              c = {
                getState: o.getState,
                dispatch: function (t) {
                  return s(t);
                },
              };
            return (
              (a = [].slice.call(t).map(function (t) {
                return t(c);
              })),
              $({}, o, { dispatch: (s = nt.apply(void 0, a)(o.dispatch)) })
            );
          };
        };
      }
      var it = l + "anon_id",
        at = l + "user_id",
        ot = l + "user_traits",
        st = "userId",
        ct = "anonymousId",
        lt = [
          "bootstrap",
          "params",
          "campaign",
          "initializeStart",
          "initialize",
          "initializeEnd",
          "ready",
          "resetStart",
          "reset",
          "resetEnd",
          "pageStart",
          "page",
          "pageEnd",
          "pageAborted",
          "trackStart",
          "track",
          "trackEnd",
          "trackAborted",
          "identifyStart",
          "identify",
          "identifyEnd",
          "identifyAborted",
          "userIdChanged",
          "registerPlugins",
          "enablePlugin",
          "disablePlugin",
          "online",
          "offline",
          "setItemStart",
          "setItem",
          "setItemEnd",
          "setItemAborted",
          "removeItemStart",
          "removeItem",
          "removeItemEnd",
          "removeItemAborted",
        ],
        ut = ["name", "EVENTS", "config", "loaded"],
        ht = lt.reduce(
          function (t, e) {
            return (t[e] = e), t;
          },
          {
            registerPluginType: function (t) {
              return "registerPlugin:" + t;
            },
            pluginReadyType: function (t) {
              return "ready:" + t;
            },
          }
        ),
        dt = /^utm_/,
        ft = /^an_prop_/,
        pt = /^an_trait_/;
      function mt(t) {
        var e = t.storage.setItem;
        return function (n) {
          return function (r) {
            return function (i) {
              if (i.type === ht.bootstrap) {
                var a = i.params,
                  o = i.user,
                  s = i.persistedUser,
                  c = i.initialUser,
                  l = s.userId === o.userId;
                s.anonymousId !== o.anonymousId && e(it, o.anonymousId),
                  l || e(at, o.userId),
                  c.traits &&
                    e(ot, $({}, l && s.traits ? s.traits : {}, c.traits));
                var u = Object.keys(i.params);
                if (u.length) {
                  var h = a.an_uid,
                    d = a.an_event,
                    f = u.reduce(
                      function (t, e) {
                        if (e.match(dt) || e.match(/^(d|g)clid/)) {
                          var n = e.replace(dt, "");
                          t.campaign["campaign" === n ? "name" : n] = a[e];
                        }
                        return (
                          e.match(ft) && (t.props[e.replace(ft, "")] = a[e]),
                          e.match(pt) && (t.traits[e.replace(pt, "")] = a[e]),
                          t
                        );
                      },
                      { campaign: {}, props: {}, traits: {} }
                    );
                  n.dispatch(
                    $({ type: ht.params, raw: a }, f, h ? { userId: h } : {})
                  ),
                    h &&
                      setTimeout(function () {
                        return t.identify(h, f.traits);
                      }, 0),
                    d &&
                      setTimeout(function () {
                        return t.track(d, f.props);
                      }, 0),
                    Object.keys(f.campaign).length &&
                      n.dispatch({ type: ht.campaign, campaign: f.campaign });
                }
              }
              return r(i);
            };
          };
        };
      }
      function gt(t) {
        return function (e, n) {
          if (
            (void 0 === e && (e = {}),
            void 0 === n && (n = {}),
            n.type === ht.setItemEnd)
          ) {
            if (n.key === it) return $({}, e, { anonymousId: n.value });
            if (n.key === at) return $({}, e, { userId: n.value });
          }
          switch (n.type) {
            case ht.identify:
              return Object.assign({}, e, {
                userId: n.userId,
                traits: $({}, e.traits, n.traits),
              });
            case ht.reset:
              return (
                [at, it, ot].forEach(function (e) {
                  t.removeItem(e);
                }),
                Object.assign({}, e, {
                  userId: null,
                  anonymousId: null,
                  traits: {},
                })
              );
            default:
              return e;
          }
        };
      }
      function vt(t) {
        return {
          userId: t.getItem(at),
          anonymousId: t.getItem(it),
          traits: t.getItem(ot),
        };
      }
      var yt = function (t) {
        return l + "TEMP" + l + t;
      };
      function bt(t) {
        var e = t.storage,
          n = e.setItem,
          r = e.removeItem,
          i = e.getItem;
        return function (t) {
          return function (e) {
            return function (a) {
              var o = a.userId,
                s = a.traits,
                c = a.options;
              if (
                (a.type === ht.reset &&
                  ([at, ot, it].forEach(function (t) {
                    r(t);
                  }),
                  [st, ct, "traits"].forEach(function (t) {
                    G(yt(t));
                  })),
                a.type === ht.identify)
              ) {
                i(it) || n(it, F());
                var l = i(at),
                  u = i(ot) || {};
                l &&
                  l !== o &&
                  t.dispatch({
                    type: ht.userIdChanged,
                    old: { userId: l, traits: u },
                    new: { userId: o, traits: s },
                    options: c,
                  }),
                  o && n(at, o),
                  s && n(ot, $({}, u, s));
              }
              return e(a);
            };
          };
        };
      }
      var xt = {};
      function _t(t, e) {
        xt[t] && y(xt[t]) && (xt[t](e), delete xt[t]);
      }
      function wt(t, e, n) {
        return new Promise(function (r, i) {
          return e()
            ? r(t)
            : n < 1
            ? i($({}, t, { queue: !0 }))
            : new Promise(function (t) {
                return setTimeout(t, 10);
              }).then(function (a) {
                return wt(t, e, n - 10).then(r, i);
              });
        });
      }
      function St(t, e, n) {
        var r = e(),
          i = t.getState(),
          a = i.plugins,
          o = i.queue,
          s = i.user;
        if (!i.context.offline && o && o.actions && o.actions.length) {
          var c = o.actions.reduce(
            function (t, e, n) {
              return (
                a[e.plugin].loaded
                  ? (t.process.push(e), t.processIndex.push(n))
                  : (t.requeue.push(e), t.requeueIndex.push(n)),
                t
              );
            },
            { processIndex: [], process: [], requeue: [], requeueIndex: [] }
          );
          if (c.processIndex && c.processIndex.length) {
            c.processIndex.forEach(function (e) {
              var i = o.actions[e],
                c = i.plugin,
                l = i.payload.type,
                u = r[c][l];
              if (u && y(u)) {
                var h = (function (t, e) {
                  return (
                    void 0 === t && (t = {}),
                    void 0 === e && (e = {}),
                    [st, ct].reduce(function (n, r) {
                      return (
                        t.hasOwnProperty(r) &&
                          e[r] &&
                          e[r] !== t[r] &&
                          (n[r] = e[r]),
                        n
                      );
                    }, t)
                  );
                })(i.payload, s);
                u({ payload: h, config: a[c].config, instance: n });
                var d = l + ":" + c;
                t.dispatch(
                  $({}, h, { type: d, _: { called: d, from: "queueDrain" } })
                );
              }
            });
            var l = o.actions.filter(function (t, e) {
              return !~c.processIndex.indexOf(e);
            });
            o.actions = l;
          }
        }
      }
      var Mt = function (t) {
          var e = t.data,
            n = t.action,
            r = t.instance,
            i = t.state,
            a = t.allPlugins,
            o = t.allMatches,
            s = t.store,
            c = t.EVENTS;
          try {
            var l = i.plugins,
              u = i.context,
              h = n.type,
              d = h.match(Tt),
              f = e.exact.map(function (t) {
                return t.pluginName;
              });
            d &&
              (f = o.during.map(function (t) {
                return t.pluginName;
              }));
            var p = (function (t, e) {
                return function (n, r, i) {
                  var a = r.config,
                    o = r.name,
                    s = o + "." + n.type;
                  i && (s = i.event);
                  var c = n.type.match(Tt)
                    ? (function (t, e, n, r, i) {
                        return function (a, o) {
                          var s = r ? r.name : t,
                            c = o && kt(o) ? o : n;
                          if (
                            r &&
                            (!(c = o && kt(o) ? o : [t]).includes(t) ||
                              1 !== c.length)
                          )
                            throw new Error(
                              "Method " +
                                e +
                                " can only abort " +
                                t +
                                " plugin. " +
                                JSON.stringify(c) +
                                " input valid"
                            );
                          return $({}, i, {
                            abort: { reason: a, plugins: c, caller: e, _: s },
                          });
                        };
                      })(o, s, e, i, n)
                    : (function (t, e) {
                        return function () {
                          throw new Error(
                            t.type +
                              " action not cancellable. Remove abort in " +
                              e
                          );
                        };
                      })(n, s);
                  return {
                    payload: zt(n),
                    instance: t,
                    config: a || {},
                    abort: c,
                  };
                };
              })(r, f),
              m = e.exact.reduce(function (t, e) {
                var n = e.pluginName,
                  r = e.methodName,
                  i = !1;
                return (
                  r.match(/^initialize/) ||
                    r.match(/^reset/) ||
                    (i = !l[n].loaded),
                  u.offline && r.match(/^(page|track|identify)/) && (i = !0),
                  (t["" + n] = i),
                  t
                );
              }, {});
            return Promise.resolve(
              e.exact.reduce(function (t, i, o) {
                var s = i.pluginName;
                return Promise.resolve(t).then(function (t) {
                  function i() {
                    return Promise.resolve(t);
                  }
                  var o = (function () {
                    if (e.namespaced && e.namespaced[s])
                      return Promise.resolve(
                        e.namespaced[s].reduce(function (t, e, n) {
                          return Promise.resolve(t).then(function (t) {
                            return e.method && y(e.method)
                              ? ((function (t, e) {
                                  var n = Dt(t);
                                  if (n && n.name === e) {
                                    var r = Dt(n.method);
                                    throw new Error(
                                      [
                                        e + " plugin is calling method " + t,
                                        "Plugins cant call self",
                                        "Use " +
                                          n.method +
                                          " " +
                                          (r ? "or " + r.method : "") +
                                          " in " +
                                          e +
                                          " plugin insteadof " +
                                          t,
                                      ].join("\n")
                                    );
                                  }
                                })(e.methodName, e.pluginName),
                                Promise.resolve(
                                  e.method({
                                    payload: t,
                                    instance: r,
                                    abort:
                                      ((n = t),
                                      (i = s),
                                      (o = e.pluginName),
                                      function (t, e) {
                                        return $({}, n, {
                                          abort: {
                                            reason: t,
                                            plugins: e || [i],
                                            caller: h,
                                            from: o || i,
                                          },
                                        });
                                      }),
                                    config: Lt(e.pluginName, l, a),
                                    plugins: l,
                                  })
                                ).then(function (e) {
                                  var n = T(e) ? e : {};
                                  return Promise.resolve($({}, t, n));
                                }))
                              : t;
                            var n, i, o;
                          });
                        }, Promise.resolve(n))
                      ).then(function (e) {
                        t[s] = e;
                      });
                    t[s] = n;
                  })();
                  return o && o.then ? o.then(i) : i();
                });
              }, Promise.resolve({}))
            ).then(function (t) {
              return Promise.resolve(
                e.exact.reduce(function (n, i, o) {
                  try {
                    var c = e.exact.length === o + 1,
                      u = i.pluginName,
                      f = a[u];
                    return Promise.resolve(n).then(function (e) {
                      var n = t[u] ? t[u] : {};
                      if ((d && (n = e), It(n, u)))
                        return (
                          Ct({
                            data: n,
                            method: h,
                            instance: r,
                            pluginName: u,
                            store: s,
                          }),
                          Promise.resolve(e)
                        );
                      if (It(e, u))
                        return (
                          c &&
                            Ct({ data: e, method: h, instance: r, store: s }),
                          Promise.resolve(e)
                        );
                      if (m.hasOwnProperty(u) && !0 === m[u])
                        return (
                          s.dispatch({
                            type: "queue",
                            plugin: u,
                            payload: n,
                            _: { called: "queue", from: "queueMechanism" },
                          }),
                          Promise.resolve(e)
                        );
                      var i = p(t[u], a[u]);
                      return Promise.resolve(
                        f[h]({
                          abort: i.abort,
                          payload: n,
                          instance: r,
                          config: Lt(u, l, a),
                          plugins: l,
                        })
                      ).then(function (i) {
                        var a = T(i) ? i : {},
                          o = $({}, e, a),
                          c = t[u];
                        if (It(c, u))
                          Ct({
                            data: c,
                            method: h,
                            instance: r,
                            pluginName: u,
                            store: s,
                          });
                        else {
                          var l = h + ":" + u;
                          (l.match(/:/g) || []).length < 2 &&
                            !h.match(Et) &&
                            !h.match(At) &&
                            r.dispatch(
                              $({}, d ? o : n, {
                                type: l,
                                _: { called: l, from: "submethod" },
                              })
                            );
                        }
                        return Promise.resolve(o);
                      });
                    });
                  } catch (t) {
                    return Promise.reject(t);
                  }
                }, Promise.resolve(n))
              ).then(function (t) {
                if (
                  !(
                    h.match(Tt) ||
                    h.match(/^registerPlugin/) ||
                    h.match(At) ||
                    h.match(Et) ||
                    h.match(/^params/) ||
                    h.match(/^userIdChanged/)
                  )
                ) {
                  if ((c.plugins.includes(h), t._ && t._.originalAction === h))
                    return t;
                  var n = $({}, t, {
                    _: {
                      originalAction: t.type,
                      called: t.type,
                      from: "engineEnd",
                    },
                  });
                  Ot(t, e.exact.length) &&
                    !h.match(/End$/) &&
                    (n = $({}, n, { type: t.type + "Aborted" })),
                    s.dispatch(n);
                }
                return t;
              });
            });
          } catch (t) {
            return Promise.reject(t);
          }
        },
        Tt = /Start$/,
        Et = /^bootstrap/,
        At = /^ready/;
      function Ct(t) {
        var e = t.pluginName,
          n = t.method + "Aborted" + (e ? ":" + e : "");
        t.store.dispatch(
          $({}, t.data, { type: n, _: { called: n, from: "abort" } })
        );
      }
      function Lt(t, e, n) {
        var r = e[t] || n[t];
        return r && r.config ? r.config : {};
      }
      function Rt(t, e) {
        return e.reduce(function (e, n) {
          return n[t]
            ? e.concat({ methodName: t, pluginName: n.name, method: n[t] })
            : e;
        }, []);
      }
      function Pt(t, e) {
        var n = t.replace(Tt, ""),
          r = e ? ":" + e : "";
        return ["" + t + r, "" + n + r, n + "End" + r];
      }
      function It(t, e) {
        var n = t.abort;
        return !!n && (!0 === n || Nt(n, e) || (n && Nt(n.plugins, e)));
      }
      function Ot(t, e) {
        var n = t.abort;
        if (!n) return !1;
        if (!0 === n || b(n)) return !0;
        var r = n.plugins;
        return (kt(n) && n.length === e) || (kt(r) && r.length === e);
      }
      function kt(t) {
        return Array.isArray(t);
      }
      function Nt(t, e) {
        return !(!t || !kt(t)) && t.includes(e);
      }
      function Dt(t) {
        var e = t.match(/(.*):(.*)/);
        return !!e && { method: e[1], name: e[2] };
      }
      function zt(t) {
        return Object.keys(t).reduce(function (e, n) {
          return (
            "type" === n || (e[n] = T(t[n]) ? Object.assign({}, t[n]) : t[n]), e
          );
        }, {});
      }
      function Ft(t, e, n) {
        var r = {};
        return function (i) {
          return function (a) {
            return function (o) {
              try {
                var s,
                  c = function (t) {
                    return s ? t : a(h);
                  },
                  l = o.type,
                  u = o.plugins,
                  h = o;
                if (o.abort) return Promise.resolve(a(o));
                if (
                  (l === ht.enablePlugin &&
                    i.dispatch({
                      type: ht.initializeStart,
                      plugins: u,
                      disabled: [],
                      fromEnable: !0,
                      meta: o.meta,
                    }),
                  l === ht.disablePlugin &&
                    setTimeout(function () {
                      return _t(o.meta.rid, { payload: o });
                    }, 0),
                  l === ht.initializeEnd)
                ) {
                  var d = e(),
                    f = Object.keys(d),
                    p = f
                      .filter(function (t) {
                        return u.includes(t);
                      })
                      .map(function (t) {
                        return d[t];
                      }),
                    m = [],
                    g = [],
                    v = o.disabled,
                    b = p.map(function (t) {
                      var e = t.name;
                      return wt(t, t.loaded, 1e4)
                        .then(function (n) {
                          return (
                            r[e] ||
                              (i.dispatch({
                                type: ht.pluginReadyType(e),
                                name: e,
                                events: Object.keys(t).filter(function (t) {
                                  return !ut.includes(t);
                                }),
                              }),
                              (r[e] = !0)),
                            (m = m.concat(e)),
                            t
                          );
                        })
                        .catch(function (t) {
                          if (t instanceof Error) throw new Error(t);
                          return (g = g.concat(t.name)), t;
                        });
                    });
                  Promise.all(b).then(function (t) {
                    var e = { plugins: m, failed: g, disabled: v };
                    setTimeout(function () {
                      f.length === b.length + v.length &&
                        i.dispatch($({}, { type: ht.ready }, e));
                    }, 0);
                  });
                }
                var x = (function () {
                  if (l !== ht.bootstrap)
                    return (
                      /^ready:([^:]*)$/.test(l) &&
                        setTimeout(function () {
                          return St(i, e, t);
                        }, 0),
                      Promise.resolve(
                        (function (t, e, n, r, i) {
                          try {
                            var a = y(e) ? e() : e,
                              o = t.type,
                              s = o.replace(Tt, "");
                            if (t._ && t._.called) return Promise.resolve(t);
                            var c = n.getState(),
                              l =
                                ((d = a),
                                void 0 === (f = c.plugins) && (f = {}),
                                void 0 === (p = t.options) && (p = {}),
                                Object.keys(d)
                                  .filter(function (t) {
                                    var e = p.plugins || {};
                                    return _(e[t])
                                      ? e[t]
                                      : !1 !== e.all &&
                                          (!f[t] || !1 !== f[t].enabled);
                                  })
                                  .map(function (t) {
                                    return d[t];
                                  }));
                            o === ht.initializeStart &&
                              t.fromEnable &&
                              (l = Object.keys(c.plugins)
                                .filter(function (e) {
                                  var n = c.plugins[e];
                                  return (
                                    t.plugins.includes(e) && !n.initialized
                                  );
                                })
                                .map(function (t) {
                                  return a[t];
                                }));
                            var u = l.map(function (t) {
                                return t.name;
                              }),
                              h = (function (t, e, n) {
                                var r = Pt(t).map(function (t) {
                                  return Rt(t, e);
                                });
                                return e.reduce(
                                  function (n, r) {
                                    var i = r.name,
                                      a = Pt(t, i).map(function (t) {
                                        return Rt(t, e);
                                      }),
                                      o = a[0],
                                      s = a[1],
                                      c = a[2];
                                    return (
                                      o.length && (n.beforeNS[i] = o),
                                      s.length && (n.duringNS[i] = s),
                                      c.length && (n.afterNS[i] = c),
                                      n
                                    );
                                  },
                                  {
                                    before: r[0],
                                    beforeNS: {},
                                    during: r[1],
                                    duringNS: {},
                                    after: r[2],
                                    afterNS: {},
                                  }
                                );
                              })(o, l);
                            return Promise.resolve(
                              Mt({
                                action: t,
                                data: {
                                  exact: h.before,
                                  namespaced: h.beforeNS,
                                },
                                state: c,
                                allPlugins: a,
                                allMatches: h,
                                instance: n,
                                store: r,
                                EVENTS: i,
                              })
                            ).then(function (t) {
                              function e() {
                                var e = (function () {
                                  if (o.match(Tt))
                                    return Promise.resolve(
                                      Mt({
                                        action: $({}, l, { type: s + "End" }),
                                        data: {
                                          exact: h.after,
                                          namespaced: h.afterNS,
                                        },
                                        state: c,
                                        allPlugins: a,
                                        allMatches: h,
                                        instance: n,
                                        store: r,
                                        EVENTS: i,
                                      })
                                    ).then(function (t) {
                                      t.meta &&
                                        t.meta.hasCallback &&
                                        _t(t.meta.rid, { payload: t });
                                    });
                                })();
                                return e && e.then
                                  ? e.then(function () {
                                      return t;
                                    })
                                  : t;
                              }
                              if (Ot(t, u.length)) return t;
                              var l,
                                d = (function () {
                                  if (o !== s)
                                    return Promise.resolve(
                                      Mt({
                                        action: $({}, t, { type: s }),
                                        data: {
                                          exact: h.during,
                                          namespaced: h.duringNS,
                                        },
                                        state: c,
                                        allPlugins: a,
                                        allMatches: h,
                                        instance: n,
                                        store: r,
                                        EVENTS: i,
                                      })
                                    ).then(function (t) {
                                      l = t;
                                    });
                                  l = t;
                                })();
                              return d && d.then ? d.then(e) : e();
                            });
                          } catch (t) {
                            return Promise.reject(t);
                          }
                          var d, f, p;
                        })(o, e, t, i, n)
                      ).then(function (t) {
                        var e = a(t);
                        return (s = 1), e;
                      })
                    );
                })();
                return Promise.resolve(x && x.then ? x.then(c) : c(x));
              } catch (t) {
                return Promise.reject(t);
              }
            };
          };
        };
      }
      function Ut(t) {
        return function (e) {
          return function (e) {
            return function (n) {
              var r = n.type,
                i = n.key,
                a = n.value,
                o = n.options;
              if (r === ht.setItem || r === ht.removeItem) {
                if (n.abort) return e(n);
                r === ht.setItem ? t.setItem(i, a, o) : t.removeItem(i, o);
              }
              return e(n);
            };
          };
        };
      }
      var Bt = function () {
        var t = this;
        (this.before = []),
          (this.after = []),
          (this.addMiddleware = function (e, n) {
            t[n] = t[n].concat(e);
          }),
          (this.removeMiddleware = function (e, n) {
            var r = t[n].findIndex(function (t) {
              return t === e;
            });
            -1 !== r && (t[n] = [].concat(t[n].slice(0, r), t[n].slice(r + 1)));
          }),
          (this.dynamicMiddlewares = function (e) {
            return function (n) {
              return function (r) {
                return function (i) {
                  var a = {
                      getState: n.getState,
                      dispatch: function (t) {
                        return n.dispatch(t);
                      },
                    },
                    o = t[e].map(function (t) {
                      return t(a);
                    });
                  return nt.apply(void 0, o)(r)(i);
                };
              };
            };
          });
      };
      function jt(t) {
        return function (e, n) {
          void 0 === e && (e = {});
          var r = {};
          if ("initialize:aborted" === n.type) return e;
          if (/^registerPlugin:([^:]*)$/.test(n.type)) {
            var i = Ht(n.type, "registerPlugin"),
              a = t()[i];
            if (!a || !i) return e;
            var o = n.enabled;
            return (
              (r[i] = {
                enabled: o,
                initialized: !!o && Boolean(!a.initialize),
                loaded: !!o && Boolean(a.loaded()),
                config: a.config || {},
              }),
              $({}, e, r)
            );
          }
          if (/^initialize:([^:]*)$/.test(n.type)) {
            var s = Ht(n.type, ht.initialize),
              c = t()[s];
            return c && s
              ? ((r[s] = $({}, e[s], {
                  initialized: !0,
                  loaded: Boolean(c.loaded()),
                })),
                $({}, e, r))
              : e;
          }
          if (/^ready:([^:]*)$/.test(n.type))
            return (r[n.name] = $({}, e[n.name], { loaded: !0 })), $({}, e, r);
          switch (n.type) {
            case ht.disablePlugin:
              return $({}, e, Vt(n.plugins, !1, e));
            case ht.enablePlugin:
              return $({}, e, Vt(n.plugins, !0, e));
            default:
              return e;
          }
        };
      }
      function Ht(t, e) {
        return t.substring(e.length + 1, t.length);
      }
      function Vt(t, e, n) {
        return t.reduce(function (t, r) {
          return (t[r] = $({}, n[r], { enabled: e })), t;
        }, n);
      }
      function Gt(t) {
        try {
          return JSON.parse(JSON.stringify(t));
        } catch (t) {}
        return t;
      }
      var Wt = { last: {}, history: [] };
      function qt(t, e) {
        void 0 === t && (t = Wt);
        var n = e.options,
          r = e.meta;
        if (e.type === ht.track) {
          var i = Gt(
            $(
              { event: e.event, properties: e.properties },
              Object.keys(n).length && { options: n },
              { meta: r }
            )
          );
          return $({}, t, { last: i, history: t.history.concat(i) });
        }
        return t;
      }
      var Xt = { actions: [] };
      function $t(t, e) {
        void 0 === t && (t = Xt);
        var n = e.payload;
        switch (e.type) {
          case "queue":
            var r;
            return (
              (r =
                n && n.type && n.type === ht.identify
                  ? [e].concat(t.actions)
                  : t.actions.concat(e)),
              $({}, t, { actions: r })
            );
          case "dequeue":
            return [];
          default:
            return t;
        }
      }
      var Yt = /#.*$/;
      function Jt(t) {
        var e = /(http[s]?:\/\/)?([^\/\s]+\/)(.*)/g.exec(t);
        return "/" + (e && e[3] ? e[3].split("?")[0].replace(Yt, "") : "");
      }
      var Kt,
        Zt,
        Qt,
        te,
        ee = function (t) {
          if ((void 0 === t && (t = {}), !h)) return t;
          var e = document,
            n = e.title,
            r = e.referrer,
            i = window,
            a = i.location,
            o = i.innerWidth,
            s = i.innerHeight,
            c = a.hash,
            l = a.search,
            u = (function (t) {
              var e = (function () {
                if (h)
                  for (
                    var t, e = document.getElementsByTagName("link"), n = 0;
                    (t = e[n]);
                    n++
                  )
                    if ("canonical" === t.getAttribute("rel"))
                      return t.getAttribute("href");
              })();
              return e
                ? e.match(/\?/)
                  ? e
                  : e + t
                : window.location.href.replace(Yt, "");
            })(l),
            d = {
              title: n,
              url: u,
              path: Jt(u),
              hash: c,
              search: l,
              width: o,
              height: s,
            };
          return r && "" !== r && (d.referrer = r), $({}, d, t);
        },
        ne = { last: {}, history: [] };
      function re(t, e) {
        void 0 === t && (t = ne);
        var n = e.options;
        if (e.type === ht.page) {
          var r = Gt(
            $(
              { properties: e.properties, meta: e.meta },
              Object.keys(n).length && { options: n }
            )
          );
          return $({}, t, { last: r, history: t.history.concat(r) });
        }
        return t;
      }
      (Kt = (function () {
        if (!h) return !1;
        var t = navigator.appVersion;
        return ~t.indexOf("Win")
          ? "Windows"
          : ~t.indexOf("Mac")
          ? "MacOS"
          : ~t.indexOf("X11")
          ? "UNIX"
          : ~t.indexOf("Linux")
          ? "Linux"
          : "Unknown OS";
      })()),
        (Zt = h ? document.referrer : null),
        (Qt = k()),
        (te = N());
      var ie = {
        initialized: !1,
        sessionId: F(),
        app: null,
        version: null,
        debug: !1,
        offline: !!h && !navigator.onLine,
        os: { name: Kt },
        userAgent: h ? navigator.userAgent : "node",
        library: { name: "analytics", version: "0.11.0" },
        timezone: te,
        locale: Qt,
        campaign: {},
        referrer: Zt,
      };
      function ae(t, e) {
        void 0 === t && (t = ie);
        var n = t.initialized,
          r = e.campaign;
        switch (e.type) {
          case ht.campaign:
            return $({}, t, { campaign: r });
          case ht.offline:
            return $({}, t, { offline: !0 });
          case ht.online:
            return $({}, t, { offline: !1 });
          default:
            return n ? t : $({}, ie, t, { initialized: !0 });
        }
      }
      var oe = ["plugins", "reducers", "storage"];
      function se(t, e, n) {
        if (h) {
          var r = window[(n ? "add" : "remove") + "EventListener"];
          t.split(" ").forEach(function (t) {
            r(t, e);
          });
        }
      }
      function ce(t) {
        var e = se.bind(null, "online offline", function (e) {
          return Promise.resolve(!navigator.onLine).then(t);
        });
        return (
          e(!0),
          function (t) {
            return e(!1);
          }
        );
      }
      function le() {
        return (
          V("analytics", []),
          function (t) {
            return function (e, n, r) {
              var i = t(e, n, r),
                a = i.dispatch;
              return Object.assign(i, {
                dispatch: function (t) {
                  return j[B].analytics.push(t.action || t), a(t);
                },
              });
            };
          }
        );
      }
      function ue(t) {
        return function () {
          return nt(nt.apply(null, arguments), le());
        };
      }
      function he(t) {
        return t ? (M(t) ? t : [t]) : [];
      }
      function de(t, e, n) {
        void 0 === t && (t = {});
        var r,
          i,
          a = F();
        return (
          e &&
            (xt[a] =
              ((r = e),
              (i = (function (t) {
                for (
                  var e, n = t || Array.prototype.slice.call(arguments), r = 0;
                  r < n.length;
                  r++
                )
                  if (y(n[r])) {
                    e = n[r];
                    break;
                  }
                return e;
              })(n)),
              function (t) {
                i && i(t), r(t);
              })),
          $(
            {},
            t,
            { rid: a, ts: new Date().getTime() },
            e ? { hasCallback: !0 } : {}
          )
        );
      }
      function fe(t) {
        void 0 === t && (t = {});
        var e = t.reducers || {},
          n = t.initialUser || {},
          r = (t.plugins || []).reduce(
            function (t, e) {
              if (y(e)) return (t.middlewares = t.middlewares.concat(e)), t;
              if ((e.NAMESPACE && (e.name = e.NAMESPACE), !e.name))
                throw new Error("https://lytics.dev/errors/1");
              var n = e.EVENTS
                ? Object.keys(e.EVENTS).map(function (t) {
                    return e.EVENTS[t];
                  })
                : [];
              (t.pluginEnabled[e.name] = !(
                !1 === e.enabled ||
                (e.config && !1 === e.config.enabled)
              )),
                delete e.enabled,
                e.methods &&
                  ((t.methods[e.name] = Object.keys(e.methods).reduce(function (
                    t,
                    n
                  ) {
                    var r;
                    return (
                      (t[n] =
                        ((r = e.methods[n]),
                        function () {
                          for (
                            var t = Array.prototype.slice.call(arguments),
                              e = new Array(r.length),
                              n = 0;
                            n < t.length;
                            n++
                          )
                            e[n] = t[n];
                          return (e[e.length] = M), r.apply({ instance: M }, e);
                        })),
                      t
                    );
                  },
                  {})),
                  delete e.methods);
              var r = Object.keys(e).concat(n),
                i = new Set(t.events.concat(r));
              if (
                ((t.events = Array.from(i)),
                (t.pluginsArray = t.pluginsArray.concat(e)),
                t.plugins[e.name])
              )
                throw new Error(e.name + "AlreadyLoaded");
              return (
                (t.plugins[e.name] = e),
                t.plugins[e.name].loaded ||
                  (t.plugins[e.name].loaded = function () {
                    return !0;
                  }),
                t
              );
            },
            {
              plugins: {},
              pluginEnabled: {},
              methods: {},
              pluginsArray: [],
              middlewares: [],
              events: [],
            }
          ),
          a = t.storage ? t.storage : { getItem: H, setItem: V, removeItem: G },
          o = (function (t) {
            return function (e, n, r) {
              return (
                n.getState("user")[e] ||
                (r && T(r) && r[e] ? r[e] : vt(t)[e] || H(yt(e)) || null)
              );
            };
          })(a),
          s = r.plugins,
          c = r.events
            .filter(function (t) {
              return !ut.includes(t);
            })
            .sort(),
          l = new Set(
            c.concat(lt).filter(function (t) {
              return !ut.includes(t);
            })
          ),
          u = Array.from(l).sort(),
          d = function () {
            return s;
          },
          f = new Bt(),
          p = f.addMiddleware,
          m = f.removeMiddleware,
          g = f.dynamicMiddlewares,
          v = function () {
            throw new Error("Abort disabled inListener");
          },
          x = D(),
          _ = vt(a),
          w = $(
            {},
            _,
            n,
            x.an_uid ? { userId: x.an_uid } : {},
            x.an_aid ? { anonymousId: x.an_aid } : {}
          );
        w.anonymousId || (w.anonymousId = F());
        var S = $(
            {
              enable: function (t, e) {
                return new Promise(function (n) {
                  N.dispatch(
                    {
                      type: ht.enablePlugin,
                      plugins: he(t),
                      _: { originalAction: ht.enablePlugin },
                    },
                    n,
                    [e]
                  );
                });
              },
              disable: function (t, e) {
                return new Promise(function (n) {
                  N.dispatch(
                    {
                      type: ht.disablePlugin,
                      plugins: he(t),
                      _: { originalAction: ht.disablePlugin },
                    },
                    n,
                    [e]
                  );
                });
              },
            },
            r.methods
          ),
          M = {
            identify: function (t, e, n, r) {
              try {
                var i = b(t) ? t : null,
                  a = T(t) ? t : e,
                  s = n || {},
                  c = M.user();
                V(yt(st), i);
                var l = i || a.userId || o(st, M, a);
                return Promise.resolve(
                  new Promise(function (t) {
                    N.dispatch(
                      $(
                        {
                          type: ht.identifyStart,
                          userId: l,
                          traits: a || {},
                          options: s,
                          anonymousId: c.anonymousId,
                        },
                        c.id && c.id !== i && { previousId: c.id }
                      ),
                      t,
                      [e, n, r]
                    );
                  })
                );
              } catch (t) {
                return Promise.reject(t);
              }
            },
            track: function (t, e, n, r) {
              try {
                var i = T(t) ? t.event : t;
                if (!i || !b(i)) throw new Error("EventMissing");
                var a = T(t) ? t : e || {},
                  s = T(n) ? n : {};
                return Promise.resolve(
                  new Promise(function (t) {
                    N.dispatch(
                      {
                        type: ht.trackStart,
                        event: i,
                        properties: a,
                        options: s,
                        userId: o(st, M, e),
                        anonymousId: o(ct, M, e),
                      },
                      t,
                      [e, n, r]
                    );
                  })
                );
              } catch (t) {
                return Promise.reject(t);
              }
            },
            page: function (t, e, n) {
              try {
                var r = T(t) ? t : {},
                  i = T(e) ? e : {};
                return Promise.resolve(
                  new Promise(function (a) {
                    N.dispatch(
                      {
                        type: ht.pageStart,
                        properties: ee(r),
                        options: i,
                        userId: o(st, M, r),
                        anonymousId: o(ct, M, r),
                      },
                      a,
                      [t, e, n]
                    );
                  })
                );
              } catch (t) {
                return Promise.reject(t);
              }
            },
            user: function (t) {
              if (t === st || "id" === t) return o(st, M);
              if (t === ct || "anonId" === t) return o(ct, M);
              var e = M.getState("user");
              return t ? i()(e, t) : e;
            },
            reset: function (t) {
              return new Promise(function (e) {
                N.dispatch({ type: ht.resetStart }, e, t);
              });
            },
            ready: function (t) {
              return M.on(ht.ready, t);
            },
            on: function (t, e) {
              if (!t || !y(e)) return !1;
              if (t === ht.bootstrap) throw new Error(".on disabled for " + t);
              var n = /Start$|Start:/;
              if ("*" === t) {
                var r = function (t) {
                    return function (t) {
                      return function (r) {
                        return (
                          r.type.match(n) &&
                            e({ payload: r, instance: M, plugins: s }),
                          t(r)
                        );
                      };
                    };
                  },
                  i = function (t) {
                    return function (t) {
                      return function (r) {
                        return (
                          r.type.match(n) ||
                            e({ payload: r, instance: M, plugins: s }),
                          t(r)
                        );
                      };
                    };
                  };
                return (
                  p(r, pe),
                  p(i, me),
                  function () {
                    m(r, pe), m(i, me);
                  }
                );
              }
              var a = t.match(n) ? pe : me,
                o = function (n) {
                  return function (n) {
                    return function (r) {
                      return (
                        r.type === t &&
                          e({ payload: r, instance: M, plugins: s, abort: v }),
                        n(r)
                      );
                    };
                  };
                };
              return (
                p(o, a),
                function () {
                  return m(o, a);
                }
              );
            },
            once: function (t, e) {
              if (!t || !y(e)) return !1;
              if (t === ht.bootstrap)
                throw new Error(".once disabled for " + t);
              var n = M.on(t, function (t) {
                e({ payload: t.payload, instance: M, plugins: s, abort: v }),
                  n();
              });
              return n;
            },
            getState: function (t) {
              var e = N.getState();
              return t ? i()(e, t) : Object.assign({}, e);
            },
            dispatch: function (t) {
              var e = b(t) ? { type: t } : t;
              if (lt.includes(e.type))
                throw new Error("reserved action " + e.type);
              var n = $({}, e, { _: $({ originalAction: e.type }, t._ || {}) });
              N.dispatch(n);
            },
            enablePlugin: S.enable,
            disablePlugin: S.disable,
            plugins: S,
            storage: {
              getItem: a.getItem,
              setItem: function (t, e, n) {
                N.dispatch({
                  type: ht.setItemStart,
                  key: t,
                  value: e,
                  options: n,
                });
              },
              removeItem: function (t, e) {
                N.dispatch({ type: ht.removeItemStart, key: t, options: e });
              },
            },
            setAnonymousId: function (t, e) {
              M.storage.setItem(it, t, e);
            },
            events: { core: lt, plugins: c },
          },
          E = r.middlewares.concat([
            function (t) {
              return function (t) {
                return function (e) {
                  return e.meta || (e.meta = de()), t(e);
                };
              };
            },
            g(pe),
            Ft(M, d, { all: u, plugins: c }),
            Ut(a),
            mt(M),
            bt(M),
            g(me),
          ]),
          A = {
            context: ae,
            user: gt(a),
            page: re,
            track: qt,
            plugins: jt(d),
            queue: $t,
          },
          C = nt,
          L = nt;
        if (h && t.debug) {
          var R = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
          R && (C = R({ trace: !0, traceLimit: 25 })),
            (L = function () {
              return 0 === arguments.length
                ? le()
                : T(typeof arguments[0])
                ? ue()
                : ue().apply(null, arguments);
            });
        }
        var P,
          I = (function (t) {
            return Object.keys(t).reduce(function (e, n) {
              return oe.includes(n) || (e[n] = t[n]), e;
            }, {});
          })(t),
          O = r.pluginsArray.reduce(function (t, e) {
            var n = e.name,
              i = e.config,
              a = e.loaded,
              o = r.pluginEnabled[n];
            return (
              (t[n] = {
                enabled: o,
                initialized: !!o && Boolean(!e.initialize),
                loaded: Boolean(a()),
                config: i || {},
              }),
              t
            );
          }, {}),
          k = { context: I, user: w, plugins: O },
          N = tt(
            (function (t) {
              for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++) {
                var i = e[r];
                typeof t[i] === Y && (n[i] = t[i]);
              }
              var a,
                o = Object.keys(n);
              try {
                !(function (t) {
                  Object.keys(t).forEach(function (e) {
                    var n = t[e];
                    if (
                      typeof n(void 0, { type: "@@redux/INIT" }) === J ||
                      typeof n(void 0, { type: K }) === J
                    )
                      throw new Error("reducer " + e + " " + J);
                  });
                })(n);
              } catch (t) {
                a = t;
              }
              return function (t, e) {
                if ((void 0 === t && (t = {}), a)) throw a;
                for (var r = !1, i = {}, s = 0; s < o.length; s++) {
                  var c = o[s],
                    l = t[c],
                    u = (0, n[c])(l, e);
                  if (typeof u === J) {
                    var h = et(c, e);
                    throw new Error(h);
                  }
                  (i[c] = u), (r = r || u !== l);
                }
                return r ? i : t;
              };
            })($({}, A, e)),
            k,
            L(C(rt.apply(void 0, E)))
          );
        N.dispatch =
          ((P = N.dispatch),
          function (t, e, n) {
            var r = $({}, t, { meta: de(t.meta, e, he(n)) });
            return P.apply(null, [r]);
          });
        var z = Object.keys(s);
        N.dispatch({
          type: ht.bootstrap,
          plugins: z,
          config: I,
          params: x,
          user: w,
          initialUser: n,
          persistedUser: _,
        });
        var U = z.filter(function (t) {
            return r.pluginEnabled[t];
          }),
          B = z.filter(function (t) {
            return !r.pluginEnabled[t];
          });
        return (
          N.dispatch({
            type: ht.registerPlugins,
            plugins: z,
            enabled: r.pluginEnabled,
          }),
          r.pluginsArray.map(function (t, e) {
            var n = t.bootstrap,
              i = t.config,
              a = t.name;
            n && y(n) && n({ instance: M, config: i, payload: t }),
              N.dispatch({
                type: ht.registerPluginType(a),
                name: a,
                enabled: r.pluginEnabled[a],
                plugin: t,
              }),
              r.pluginsArray.length === e + 1 &&
                N.dispatch({
                  type: ht.initializeStart,
                  plugins: U,
                  disabled: B,
                });
          }),
          ce(function (t) {
            N.dispatch({ type: t ? ht.offline : ht.online });
          }),
          (function (t, e, n) {
            setInterval(function () {
              return St(t, e, n);
            }, 3e3);
          })(N, d, M),
          M
        );
      }
      var pe = "before",
        me = "after",
        ge = "cookie",
        ve = _e(),
        ye = we,
        be = we;
      function xe(t) {
        return ve ? we(t, "", -1) : G(t);
      }
      function _e() {
        if (void 0 !== ve) return ve;
        var t = "cookiecookie";
        try {
          we(t, t), (ve = -1 !== document.cookie.indexOf(t)), xe(t);
        } catch (t) {
          ve = !1;
        }
        return ve;
      }
      function we(t, e, n, r, i, a) {
        if ("undefined" != typeof window) {
          var o = arguments.length > 1;
          return (
            !1 === ve && (o ? V(t, e) : H(t)),
            o
              ? (document.cookie =
                  t +
                  "=" +
                  encodeURIComponent(e) +
                  (n
                    ? "; expires=" +
                      new Date(+new Date() + 1e3 * n).toUTCString() +
                      (r ? "; path=" + r : "") +
                      (i ? "; domain=" + i : "") +
                      (a ? "; secure" : "")
                    : ""))
              : decodeURIComponent(
                  (
                    ("; " + document.cookie).split("; " + t + "=")[1] || ""
                  ).split(";")[0]
                )
          );
        }
      }
      var Se = "localStorage",
        Me = X.bind(null, "localStorage"),
        Te =
          (W("localStorage", "getItem", H),
          W("localStorage", "setItem", V),
          W("localStorage", "removeItem", G),
          "sessionStorage"),
        Ee = X.bind(null, "sessionStorage");
      W("sessionStorage", "getItem", H),
        W("sessionStorage", "setItem", V),
        W("sessionStorage", "removeItem", G);
      function Ae(t) {
        var e = t;
        try {
          if ("true" === (e = JSON.parse(t))) return !0;
          if ("false" === e) return !1;
          if (T(e)) return e;
          parseFloat(e) === e && (e = parseFloat(e));
        } catch (t) {}
        if (null !== e && "" !== e) return e;
      }
      var Ce = Me(),
        Le = Ee(),
        Re = _e();
      function Pe(t, e) {
        if (t) {
          var n = ke(e),
            r = !Fe(n),
            i = Ne(n) ? Ae(localStorage.getItem(t)) : void 0;
          if (r && !x(i)) return i;
          var a = De(n) ? Ae(ye(t)) : void 0;
          if (r && a) return a;
          var o = ze(n) ? Ae(sessionStorage.getItem(t)) : void 0;
          if (r && o) return o;
          var s = H(t);
          return r
            ? s
            : { localStorage: i, sessionStorage: o, cookie: a, global: s };
        }
      }
      function Ie(t, e, n) {
        if (t && !x(e)) {
          var r = {},
            i = ke(n),
            a = JSON.stringify(e),
            o = !Fe(i);
          return Ne(i) &&
            ((r[Se] = Be(Se, e, Ae(localStorage.getItem(t)))),
            localStorage.setItem(t, a),
            o)
            ? r[Se]
            : De(i) && ((r[ge] = Be(ge, e, Ae(ye(t)))), be(t, a), o)
            ? r[ge]
            : ze(i) &&
              ((r[Te] = Be(Te, e, Ae(sessionStorage.getItem(t)))),
              sessionStorage.setItem(t, a),
              o)
            ? r[Te]
            : ((r[U] = Be(U, e, H(t))), V(t, e), o ? r[U] : r);
        }
      }
      function Oe(t, e) {
        if (t) {
          var n = ke(e),
            r = Pe(t, c),
            i = {};
          return (
            !x(r.localStorage) &&
              Ne(n) &&
              (localStorage.removeItem(t), (i[Se] = r.localStorage)),
            !x(r.cookie) && De(n) && (xe(t), (i[ge] = r.cookie)),
            !x(r.sessionStorage) &&
              ze(n) &&
              (sessionStorage.removeItem(t), (i[Te] = r.sessionStorage)),
            !x(r.global) && Ue(n, U) && (G(t), (i[U] = r.global)),
            i
          );
        }
      }
      function ke(t) {
        return t ? (b(t) ? t : t.storage) : s;
      }
      function Ne(t) {
        return Ce && Ue(t, Se);
      }
      function De(t) {
        return Re && Ue(t, ge);
      }
      function ze(t) {
        return Le && Ue(t, Te);
      }
      function Fe(t) {
        return t === c || "all" === t;
      }
      function Ue(t, e) {
        return t === s || t === e || Fe(t);
      }
      function Be(t, e, n) {
        return { location: t, current: e, previous: n };
      }
      var je = { setItem: Ie, getItem: Pe, removeItem: Oe };
      function He(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function Ve(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Ge(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? Ve(Object(n), !0).forEach(function (e) {
                He(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : Ve(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function We() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = { storage: je };
        return fe(Ge(Ge({}, e), t));
      }
    },
    2883: function (t) {
      !(function (e, n) {
        t.exports = function (t, e, n, r, i) {
          for (e = e.split ? e.split(".") : e, r = 0; r < e.length; r++)
            t = t ? t[e[r]] : i;
          return t === i ? n : t;
        };
      })();
    },
    315: function (t, e, n) {
      n(2087),
        (function (e, n) {
          t.exports = n();
        })("undefined" !== typeof self && self, function () {
          return (function () {
            var t = {
                9662: function (t, e, n) {
                  var r = n(614),
                    i = n(6330),
                    a = TypeError;
                  t.exports = function (t) {
                    if (r(t)) return t;
                    throw a(i(t) + " is not a function");
                  };
                },
                6077: function (t, e, n) {
                  var r = n(614),
                    i = String,
                    a = TypeError;
                  t.exports = function (t) {
                    if ("object" == typeof t || r(t)) return t;
                    throw a("Can't set " + i(t) + " as a prototype");
                  };
                },
                1223: function (t, e, n) {
                  var r = n(5112),
                    i = n(30),
                    a = n(3070).f,
                    o = r("unscopables"),
                    s = Array.prototype;
                  void 0 == s[o] &&
                    a(s, o, { configurable: !0, value: i(null) }),
                    (t.exports = function (t) {
                      s[o][t] = !0;
                    });
                },
                9670: function (t, e, n) {
                  var r = n(111),
                    i = String,
                    a = TypeError;
                  t.exports = function (t) {
                    if (r(t)) return t;
                    throw a(i(t) + " is not an object");
                  };
                },
                4019: function (t) {
                  t.exports =
                    "undefined" != typeof ArrayBuffer &&
                    "undefined" != typeof DataView;
                },
                260: function (t, e, n) {
                  "use strict";
                  var r,
                    i,
                    a,
                    o = n(4019),
                    s = n(9781),
                    c = n(7854),
                    l = n(614),
                    u = n(111),
                    h = n(2597),
                    d = n(648),
                    f = n(6330),
                    p = n(8880),
                    m = n(8052),
                    g = n(3070).f,
                    v = n(7976),
                    y = n(9518),
                    b = n(7674),
                    x = n(5112),
                    _ = n(9711),
                    w = n(9909),
                    S = w.enforce,
                    M = w.get,
                    T = c.Int8Array,
                    E = T && T.prototype,
                    A = c.Uint8ClampedArray,
                    C = A && A.prototype,
                    L = T && y(T),
                    R = E && y(E),
                    P = Object.prototype,
                    I = c.TypeError,
                    O = x("toStringTag"),
                    k = _("TYPED_ARRAY_TAG"),
                    N = "TypedArrayConstructor",
                    D = o && !!b && "Opera" !== d(c.opera),
                    z = !1,
                    F = {
                      Int8Array: 1,
                      Uint8Array: 1,
                      Uint8ClampedArray: 1,
                      Int16Array: 2,
                      Uint16Array: 2,
                      Int32Array: 4,
                      Uint32Array: 4,
                      Float32Array: 4,
                      Float64Array: 8,
                    },
                    U = { BigInt64Array: 8, BigUint64Array: 8 },
                    B = function (t) {
                      if (!u(t)) return !1;
                      var e = d(t);
                      return "DataView" === e || h(F, e) || h(U, e);
                    },
                    j = function (t) {
                      var e = y(t);
                      if (u(e)) {
                        var n = M(e);
                        return n && h(n, N) ? n[N] : j(e);
                      }
                    },
                    H = function (t) {
                      if (!u(t)) return !1;
                      var e = d(t);
                      return h(F, e) || h(U, e);
                    },
                    V = function (t) {
                      if (H(t)) return t;
                      throw I("Target is not a typed array");
                    },
                    G = function (t) {
                      if (l(t) && (!b || v(L, t))) return t;
                      throw I(f(t) + " is not a typed array constructor");
                    },
                    W = function (t, e, n, r) {
                      if (s) {
                        if (n)
                          for (var i in F) {
                            var a = c[i];
                            if (a && h(a.prototype, t))
                              try {
                                delete a.prototype[t];
                              } catch (o) {
                                try {
                                  a.prototype[t] = e;
                                } catch (l) {}
                              }
                          }
                        (R[t] && !n) || m(R, t, n ? e : (D && E[t]) || e, r);
                      }
                    },
                    q = function (t, e, n) {
                      var r, i;
                      if (s) {
                        if (b) {
                          if (n)
                            for (r in F)
                              if (((i = c[r]), i && h(i, t)))
                                try {
                                  delete i[t];
                                } catch (a) {}
                          if (L[t] && !n) return;
                          try {
                            return m(L, t, n ? e : (D && L[t]) || e);
                          } catch (a) {}
                        }
                        for (r in F)
                          (i = c[r]), !i || (i[t] && !n) || m(i, t, e);
                      }
                    };
                  for (r in F)
                    (i = c[r]),
                      (a = i && i.prototype),
                      a ? (S(a)[N] = i) : (D = !1);
                  for (r in U)
                    (i = c[r]), (a = i && i.prototype), a && (S(a)[N] = i);
                  if (
                    (!D || !l(L) || L === Function.prototype) &&
                    ((L = function () {
                      throw I("Incorrect invocation");
                    }),
                    D)
                  )
                    for (r in F) c[r] && b(c[r], L);
                  if ((!D || !R || R === P) && ((R = L.prototype), D))
                    for (r in F) c[r] && b(c[r].prototype, R);
                  if ((D && y(C) !== R && b(C, R), s && !h(R, O)))
                    for (r in ((z = !0),
                    g(R, O, {
                      get: function () {
                        return u(this) ? this[k] : void 0;
                      },
                    }),
                    F))
                      c[r] && p(c[r], k, r);
                  t.exports = {
                    NATIVE_ARRAY_BUFFER_VIEWS: D,
                    TYPED_ARRAY_TAG: z && k,
                    aTypedArray: V,
                    aTypedArrayConstructor: G,
                    exportTypedArrayMethod: W,
                    exportTypedArrayStaticMethod: q,
                    getTypedArrayConstructor: j,
                    isView: B,
                    isTypedArray: H,
                    TypedArray: L,
                    TypedArrayPrototype: R,
                  };
                },
                1318: function (t, e, n) {
                  var r = n(5656),
                    i = n(1400),
                    a = n(6244),
                    o = function (t) {
                      return function (e, n, o) {
                        var s,
                          c = r(e),
                          l = a(c),
                          u = i(o, l);
                        if (t && n != n) {
                          while (l > u) if (((s = c[u++]), s != s)) return !0;
                        } else
                          for (; l > u; u++)
                            if ((t || u in c) && c[u] === n) return t || u || 0;
                        return !t && -1;
                      };
                    };
                  t.exports = { includes: o(!0), indexOf: o(!1) };
                },
                9671: function (t, e, n) {
                  var r = n(9974),
                    i = n(8361),
                    a = n(7908),
                    o = n(6244),
                    s = function (t) {
                      var e = 1 == t;
                      return function (n, s, c) {
                        var l,
                          u,
                          h = a(n),
                          d = i(h),
                          f = r(s, c),
                          p = o(d);
                        while (p-- > 0)
                          if (((l = d[p]), (u = f(l, p, h)), u))
                            switch (t) {
                              case 0:
                                return l;
                              case 1:
                                return p;
                            }
                        return e ? -1 : void 0;
                      };
                    };
                  t.exports = { findLast: s(0), findLastIndex: s(1) };
                },
                4326: function (t, e, n) {
                  var r = n(1702),
                    i = r({}.toString),
                    a = r("".slice);
                  t.exports = function (t) {
                    return a(i(t), 8, -1);
                  };
                },
                648: function (t, e, n) {
                  var r = n(1694),
                    i = n(614),
                    a = n(4326),
                    o = n(5112),
                    s = o("toStringTag"),
                    c = Object,
                    l =
                      "Arguments" ==
                      a(
                        (function () {
                          return arguments;
                        })()
                      ),
                    u = function (t, e) {
                      try {
                        return t[e];
                      } catch (n) {}
                    };
                  t.exports = r
                    ? a
                    : function (t) {
                        var e, n, r;
                        return void 0 === t
                          ? "Undefined"
                          : null === t
                          ? "Null"
                          : "string" == typeof (n = u((e = c(t)), s))
                          ? n
                          : l
                          ? a(e)
                          : "Object" == (r = a(e)) && i(e.callee)
                          ? "Arguments"
                          : r;
                      };
                },
                7741: function (t, e, n) {
                  var r = n(1702),
                    i = Error,
                    a = r("".replace),
                    o = (function (t) {
                      return String(i(t).stack);
                    })("zxcasd"),
                    s = /\n\s*at [^:]*:[^\n]*/,
                    c = s.test(o);
                  t.exports = function (t, e) {
                    if (c && "string" == typeof t && !i.prepareStackTrace)
                      while (e--) t = a(t, s, "");
                    return t;
                  };
                },
                2128: function (t, e, n) {
                  var r = n(2597),
                    i = n(3887),
                    a = n(1236),
                    o = n(3070);
                  t.exports = function (t, e, n) {
                    for (
                      var s = i(e), c = o.f, l = a.f, u = 0;
                      u < s.length;
                      u++
                    ) {
                      var h = s[u];
                      r(t, h) || (n && r(n, h)) || c(t, h, l(e, h));
                    }
                  };
                },
                9920: function (t, e, n) {
                  var r = n(7293);
                  t.exports = !r(function () {
                    function t() {}
                    return (
                      (t.prototype.constructor = null),
                      Object.getPrototypeOf(new t()) !== t.prototype
                    );
                  });
                },
                8880: function (t, e, n) {
                  var r = n(9781),
                    i = n(3070),
                    a = n(9114);
                  t.exports = r
                    ? function (t, e, n) {
                        return i.f(t, e, a(1, n));
                      }
                    : function (t, e, n) {
                        return (t[e] = n), t;
                      };
                },
                9114: function (t) {
                  t.exports = function (t, e) {
                    return {
                      enumerable: !(1 & t),
                      configurable: !(2 & t),
                      writable: !(4 & t),
                      value: e,
                    };
                  };
                },
                7045: function (t, e, n) {
                  var r = n(6339),
                    i = n(3070);
                  t.exports = function (t, e, n) {
                    return (
                      n.get && r(n.get, e, { getter: !0 }),
                      n.set && r(n.set, e, { setter: !0 }),
                      i.f(t, e, n)
                    );
                  };
                },
                8052: function (t, e, n) {
                  var r = n(614),
                    i = n(3070),
                    a = n(6339),
                    o = n(3072);
                  t.exports = function (t, e, n, s) {
                    s || (s = {});
                    var c = s.enumerable,
                      l = void 0 !== s.name ? s.name : e;
                    if ((r(n) && a(n, l, s), s.global))
                      c ? (t[e] = n) : o(e, n);
                    else {
                      try {
                        s.unsafe ? t[e] && (c = !0) : delete t[e];
                      } catch (u) {}
                      c
                        ? (t[e] = n)
                        : i.f(t, e, {
                            value: n,
                            enumerable: !1,
                            configurable: !s.nonConfigurable,
                            writable: !s.nonWritable,
                          });
                    }
                    return t;
                  };
                },
                3072: function (t, e, n) {
                  var r = n(7854),
                    i = Object.defineProperty;
                  t.exports = function (t, e) {
                    try {
                      i(r, t, { value: e, configurable: !0, writable: !0 });
                    } catch (n) {
                      r[t] = e;
                    }
                    return e;
                  };
                },
                9781: function (t, e, n) {
                  var r = n(7293);
                  t.exports = !r(function () {
                    return (
                      7 !=
                      Object.defineProperty({}, 1, {
                        get: function () {
                          return 7;
                        },
                      })[1]
                    );
                  });
                },
                317: function (t, e, n) {
                  var r = n(7854),
                    i = n(111),
                    a = r.document,
                    o = i(a) && i(a.createElement);
                  t.exports = function (t) {
                    return o ? a.createElement(t) : {};
                  };
                },
                8113: function (t, e, n) {
                  var r = n(5005);
                  t.exports = r("navigator", "userAgent") || "";
                },
                7392: function (t, e, n) {
                  var r,
                    i,
                    a = n(7854),
                    o = n(8113),
                    s = a.process,
                    c = a.Deno,
                    l = (s && s.versions) || (c && c.version),
                    u = l && l.v8;
                  u &&
                    ((r = u.split(".")),
                    (i = r[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1]))),
                    !i &&
                      o &&
                      ((r = o.match(/Edge\/(\d+)/)),
                      (!r || r[1] >= 74) &&
                        ((r = o.match(/Chrome\/(\d+)/)), r && (i = +r[1]))),
                    (t.exports = i);
                },
                748: function (t) {
                  t.exports = [
                    "constructor",
                    "hasOwnProperty",
                    "isPrototypeOf",
                    "propertyIsEnumerable",
                    "toLocaleString",
                    "toString",
                    "valueOf",
                  ];
                },
                2914: function (t, e, n) {
                  var r = n(7293),
                    i = n(9114);
                  t.exports = !r(function () {
                    var t = Error("a");
                    return (
                      !("stack" in t) ||
                      (Object.defineProperty(t, "stack", i(1, 7)),
                      7 !== t.stack)
                    );
                  });
                },
                2109: function (t, e, n) {
                  var r = n(7854),
                    i = n(1236).f,
                    a = n(8880),
                    o = n(8052),
                    s = n(3072),
                    c = n(2128),
                    l = n(4705);
                  t.exports = function (t, e) {
                    var n,
                      u,
                      h,
                      d,
                      f,
                      p,
                      m = t.target,
                      g = t.global,
                      v = t.stat;
                    if (
                      ((u = g
                        ? r
                        : v
                        ? r[m] || s(m, {})
                        : (r[m] || {}).prototype),
                      u)
                    )
                      for (h in e) {
                        if (
                          ((f = e[h]),
                          t.dontCallGetSet
                            ? ((p = i(u, h)), (d = p && p.value))
                            : (d = u[h]),
                          (n = l(g ? h : m + (v ? "." : "#") + h, t.forced)),
                          !n && void 0 !== d)
                        ) {
                          if (typeof f == typeof d) continue;
                          c(f, d);
                        }
                        (t.sham || (d && d.sham)) && a(f, "sham", !0),
                          o(u, h, f, t);
                      }
                  };
                },
                7293: function (t) {
                  t.exports = function (t) {
                    try {
                      return !!t();
                    } catch (e) {
                      return !0;
                    }
                  };
                },
                2104: function (t, e, n) {
                  var r = n(4374),
                    i = Function.prototype,
                    a = i.apply,
                    o = i.call;
                  t.exports =
                    ("object" == typeof Reflect && Reflect.apply) ||
                    (r
                      ? o.bind(a)
                      : function () {
                          return o.apply(a, arguments);
                        });
                },
                9974: function (t, e, n) {
                  var r = n(1702),
                    i = n(9662),
                    a = n(4374),
                    o = r(r.bind);
                  t.exports = function (t, e) {
                    return (
                      i(t),
                      void 0 === e
                        ? t
                        : a
                        ? o(t, e)
                        : function () {
                            return t.apply(e, arguments);
                          }
                    );
                  };
                },
                4374: function (t, e, n) {
                  var r = n(7293);
                  t.exports = !r(function () {
                    var t = function () {}.bind();
                    return (
                      "function" != typeof t || t.hasOwnProperty("prototype")
                    );
                  });
                },
                6916: function (t, e, n) {
                  var r = n(4374),
                    i = Function.prototype.call;
                  t.exports = r
                    ? i.bind(i)
                    : function () {
                        return i.apply(i, arguments);
                      };
                },
                6530: function (t, e, n) {
                  var r = n(9781),
                    i = n(2597),
                    a = Function.prototype,
                    o = r && Object.getOwnPropertyDescriptor,
                    s = i(a, "name"),
                    c = s && "something" === function () {}.name,
                    l = s && (!r || (r && o(a, "name").configurable));
                  t.exports = { EXISTS: s, PROPER: c, CONFIGURABLE: l };
                },
                1702: function (t, e, n) {
                  var r = n(4374),
                    i = Function.prototype,
                    a = i.bind,
                    o = i.call,
                    s = r && a.bind(o, o);
                  t.exports = r
                    ? function (t) {
                        return t && s(t);
                      }
                    : function (t) {
                        return (
                          t &&
                          function () {
                            return o.apply(t, arguments);
                          }
                        );
                      };
                },
                5005: function (t, e, n) {
                  var r = n(7854),
                    i = n(614),
                    a = function (t) {
                      return i(t) ? t : void 0;
                    };
                  t.exports = function (t, e) {
                    return arguments.length < 2 ? a(r[t]) : r[t] && r[t][e];
                  };
                },
                8173: function (t, e, n) {
                  var r = n(9662);
                  t.exports = function (t, e) {
                    var n = t[e];
                    return null == n ? void 0 : r(n);
                  };
                },
                7854: function (t, e, n) {
                  var r = function (t) {
                    return t && t.Math == Math && t;
                  };
                  t.exports =
                    r("object" == typeof globalThis && globalThis) ||
                    r("object" == typeof window && window) ||
                    r("object" == typeof self && self) ||
                    r("object" == typeof n.g && n.g) ||
                    (function () {
                      return this;
                    })() ||
                    Function("return this")();
                },
                2597: function (t, e, n) {
                  var r = n(1702),
                    i = n(7908),
                    a = r({}.hasOwnProperty);
                  t.exports =
                    Object.hasOwn ||
                    function (t, e) {
                      return a(i(t), e);
                    };
                },
                3501: function (t) {
                  t.exports = {};
                },
                490: function (t, e, n) {
                  var r = n(5005);
                  t.exports = r("document", "documentElement");
                },
                4664: function (t, e, n) {
                  var r = n(9781),
                    i = n(7293),
                    a = n(317);
                  t.exports =
                    !r &&
                    !i(function () {
                      return (
                        7 !=
                        Object.defineProperty(a("div"), "a", {
                          get: function () {
                            return 7;
                          },
                        }).a
                      );
                    });
                },
                8361: function (t, e, n) {
                  var r = n(1702),
                    i = n(7293),
                    a = n(4326),
                    o = Object,
                    s = r("".split);
                  t.exports = i(function () {
                    return !o("z").propertyIsEnumerable(0);
                  })
                    ? function (t) {
                        return "String" == a(t) ? s(t, "") : o(t);
                      }
                    : o;
                },
                9587: function (t, e, n) {
                  var r = n(614),
                    i = n(111),
                    a = n(7674);
                  t.exports = function (t, e, n) {
                    var o, s;
                    return (
                      a &&
                        r((o = e.constructor)) &&
                        o !== n &&
                        i((s = o.prototype)) &&
                        s !== n.prototype &&
                        a(t, s),
                      t
                    );
                  };
                },
                2788: function (t, e, n) {
                  var r = n(1702),
                    i = n(614),
                    a = n(5465),
                    o = r(Function.toString);
                  i(a.inspectSource) ||
                    (a.inspectSource = function (t) {
                      return o(t);
                    }),
                    (t.exports = a.inspectSource);
                },
                8340: function (t, e, n) {
                  var r = n(111),
                    i = n(8880);
                  t.exports = function (t, e) {
                    r(e) && "cause" in e && i(t, "cause", e.cause);
                  };
                },
                9909: function (t, e, n) {
                  var r,
                    i,
                    a,
                    o = n(8536),
                    s = n(7854),
                    c = n(1702),
                    l = n(111),
                    u = n(8880),
                    h = n(2597),
                    d = n(5465),
                    f = n(6200),
                    p = n(3501),
                    m = "Object already initialized",
                    g = s.TypeError,
                    v = s.WeakMap,
                    y = function (t) {
                      return a(t) ? i(t) : r(t, {});
                    },
                    b = function (t) {
                      return function (e) {
                        var n;
                        if (!l(e) || (n = i(e)).type !== t)
                          throw g("Incompatible receiver, " + t + " required");
                        return n;
                      };
                    };
                  if (o || d.state) {
                    var x = d.state || (d.state = new v()),
                      _ = c(x.get),
                      w = c(x.has),
                      S = c(x.set);
                    (r = function (t, e) {
                      if (w(x, t)) throw new g(m);
                      return (e.facade = t), S(x, t, e), e;
                    }),
                      (i = function (t) {
                        return _(x, t) || {};
                      }),
                      (a = function (t) {
                        return w(x, t);
                      });
                  } else {
                    var M = f("state");
                    (p[M] = !0),
                      (r = function (t, e) {
                        if (h(t, M)) throw new g(m);
                        return (e.facade = t), u(t, M, e), e;
                      }),
                      (i = function (t) {
                        return h(t, M) ? t[M] : {};
                      }),
                      (a = function (t) {
                        return h(t, M);
                      });
                  }
                  t.exports = {
                    set: r,
                    get: i,
                    has: a,
                    enforce: y,
                    getterFor: b,
                  };
                },
                614: function (t) {
                  t.exports = function (t) {
                    return "function" == typeof t;
                  };
                },
                4705: function (t, e, n) {
                  var r = n(7293),
                    i = n(614),
                    a = /#|\.prototype\./,
                    o = function (t, e) {
                      var n = c[s(t)];
                      return n == u || (n != l && (i(e) ? r(e) : !!e));
                    },
                    s = (o.normalize = function (t) {
                      return String(t).replace(a, ".").toLowerCase();
                    }),
                    c = (o.data = {}),
                    l = (o.NATIVE = "N"),
                    u = (o.POLYFILL = "P");
                  t.exports = o;
                },
                111: function (t, e, n) {
                  var r = n(614);
                  t.exports = function (t) {
                    return "object" == typeof t ? null !== t : r(t);
                  };
                },
                1913: function (t) {
                  t.exports = !1;
                },
                2190: function (t, e, n) {
                  var r = n(5005),
                    i = n(614),
                    a = n(7976),
                    o = n(3307),
                    s = Object;
                  t.exports = o
                    ? function (t) {
                        return "symbol" == typeof t;
                      }
                    : function (t) {
                        var e = r("Symbol");
                        return i(e) && a(e.prototype, s(t));
                      };
                },
                6244: function (t, e, n) {
                  var r = n(7466);
                  t.exports = function (t) {
                    return r(t.length);
                  };
                },
                6339: function (t, e, n) {
                  var r = n(7293),
                    i = n(614),
                    a = n(2597),
                    o = n(9781),
                    s = n(6530).CONFIGURABLE,
                    c = n(2788),
                    l = n(9909),
                    u = l.enforce,
                    h = l.get,
                    d = Object.defineProperty,
                    f =
                      o &&
                      !r(function () {
                        return (
                          8 !== d(function () {}, "length", { value: 8 }).length
                        );
                      }),
                    p = String(String).split("String"),
                    m = (t.exports = function (t, e, n) {
                      "Symbol(" === String(e).slice(0, 7) &&
                        (e =
                          "[" +
                          String(e).replace(/^Symbol\(([^)]*)\)/, "$1") +
                          "]"),
                        n && n.getter && (e = "get " + e),
                        n && n.setter && (e = "set " + e),
                        (!a(t, "name") || (s && t.name !== e)) &&
                          (o
                            ? d(t, "name", { value: e, configurable: !0 })
                            : (t.name = e)),
                        f &&
                          n &&
                          a(n, "arity") &&
                          t.length !== n.arity &&
                          d(t, "length", { value: n.arity });
                      try {
                        n && a(n, "constructor") && n.constructor
                          ? o && d(t, "prototype", { writable: !1 })
                          : t.prototype && (t.prototype = void 0);
                      } catch (i) {}
                      var r = u(t);
                      return (
                        a(r, "source") ||
                          (r.source = p.join("string" == typeof e ? e : "")),
                        t
                      );
                    });
                  Function.prototype.toString = m(function () {
                    return (i(this) && h(this).source) || c(this);
                  }, "toString");
                },
                4758: function (t) {
                  var e = Math.ceil,
                    n = Math.floor;
                  t.exports =
                    Math.trunc ||
                    function (t) {
                      var r = +t;
                      return (r > 0 ? n : e)(r);
                    };
                },
                133: function (t, e, n) {
                  var r = n(7392),
                    i = n(7293);
                  t.exports =
                    !!Object.getOwnPropertySymbols &&
                    !i(function () {
                      var t = Symbol();
                      return (
                        !String(t) ||
                        !(Object(t) instanceof Symbol) ||
                        (!Symbol.sham && r && r < 41)
                      );
                    });
                },
                8536: function (t, e, n) {
                  var r = n(7854),
                    i = n(614),
                    a = n(2788),
                    o = r.WeakMap;
                  t.exports = i(o) && /native code/.test(a(o));
                },
                6277: function (t, e, n) {
                  var r = n(1340);
                  t.exports = function (t, e) {
                    return void 0 === t
                      ? arguments.length < 2
                        ? ""
                        : e
                      : r(t);
                  };
                },
                30: function (t, e, n) {
                  var r,
                    i = n(9670),
                    a = n(6048),
                    o = n(748),
                    s = n(3501),
                    c = n(490),
                    l = n(317),
                    u = n(6200),
                    h = ">",
                    d = "<",
                    f = "prototype",
                    p = "script",
                    m = u("IE_PROTO"),
                    g = function () {},
                    v = function (t) {
                      return d + p + h + t + d + "/" + p + h;
                    },
                    y = function (t) {
                      t.write(v("")), t.close();
                      var e = t.parentWindow.Object;
                      return (t = null), e;
                    },
                    b = function () {
                      var t,
                        e = l("iframe"),
                        n = "java" + p + ":";
                      return (
                        (e.style.display = "none"),
                        c.appendChild(e),
                        (e.src = String(n)),
                        (t = e.contentWindow.document),
                        t.open(),
                        t.write(v("document.F=Object")),
                        t.close(),
                        t.F
                      );
                    },
                    x = function () {
                      try {
                        r = new ActiveXObject("htmlfile");
                      } catch (e) {}
                      x =
                        "undefined" != typeof document
                          ? document.domain && r
                            ? y(r)
                            : b()
                          : y(r);
                      var t = o.length;
                      while (t--) delete x[f][o[t]];
                      return x();
                    };
                  (s[m] = !0),
                    (t.exports =
                      Object.create ||
                      function (t, e) {
                        var n;
                        return (
                          null !== t
                            ? ((g[f] = i(t)),
                              (n = new g()),
                              (g[f] = null),
                              (n[m] = t))
                            : (n = x()),
                          void 0 === e ? n : a.f(n, e)
                        );
                      });
                },
                6048: function (t, e, n) {
                  var r = n(9781),
                    i = n(3353),
                    a = n(3070),
                    o = n(9670),
                    s = n(5656),
                    c = n(1956);
                  e.f =
                    r && !i
                      ? Object.defineProperties
                      : function (t, e) {
                          o(t);
                          var n,
                            r = s(e),
                            i = c(e),
                            l = i.length,
                            u = 0;
                          while (l > u) a.f(t, (n = i[u++]), r[n]);
                          return t;
                        };
                },
                3070: function (t, e, n) {
                  var r = n(9781),
                    i = n(4664),
                    a = n(3353),
                    o = n(9670),
                    s = n(4948),
                    c = TypeError,
                    l = Object.defineProperty,
                    u = Object.getOwnPropertyDescriptor,
                    h = "enumerable",
                    d = "configurable",
                    f = "writable";
                  e.f = r
                    ? a
                      ? function (t, e, n) {
                          if (
                            (o(t),
                            (e = s(e)),
                            o(n),
                            "function" === typeof t &&
                              "prototype" === e &&
                              "value" in n &&
                              f in n &&
                              !n[f])
                          ) {
                            var r = u(t, e);
                            r &&
                              r[f] &&
                              ((t[e] = n.value),
                              (n = {
                                configurable: d in n ? n[d] : r[d],
                                enumerable: h in n ? n[h] : r[h],
                                writable: !1,
                              }));
                          }
                          return l(t, e, n);
                        }
                      : l
                    : function (t, e, n) {
                        if ((o(t), (e = s(e)), o(n), i))
                          try {
                            return l(t, e, n);
                          } catch (r) {}
                        if ("get" in n || "set" in n)
                          throw c("Accessors not supported");
                        return "value" in n && (t[e] = n.value), t;
                      };
                },
                1236: function (t, e, n) {
                  var r = n(9781),
                    i = n(6916),
                    a = n(5296),
                    o = n(9114),
                    s = n(5656),
                    c = n(4948),
                    l = n(2597),
                    u = n(4664),
                    h = Object.getOwnPropertyDescriptor;
                  e.f = r
                    ? h
                    : function (t, e) {
                        if (((t = s(t)), (e = c(e)), u))
                          try {
                            return h(t, e);
                          } catch (n) {}
                        if (l(t, e)) return o(!i(a.f, t, e), t[e]);
                      };
                },
                8006: function (t, e, n) {
                  var r = n(6324),
                    i = n(748),
                    a = i.concat("length", "prototype");
                  e.f =
                    Object.getOwnPropertyNames ||
                    function (t) {
                      return r(t, a);
                    };
                },
                5181: function (t, e) {
                  e.f = Object.getOwnPropertySymbols;
                },
                9518: function (t, e, n) {
                  var r = n(2597),
                    i = n(614),
                    a = n(7908),
                    o = n(6200),
                    s = n(9920),
                    c = o("IE_PROTO"),
                    l = Object,
                    u = l.prototype;
                  t.exports = s
                    ? l.getPrototypeOf
                    : function (t) {
                        var e = a(t);
                        if (r(e, c)) return e[c];
                        var n = e.constructor;
                        return i(n) && e instanceof n
                          ? n.prototype
                          : e instanceof l
                          ? u
                          : null;
                      };
                },
                7976: function (t, e, n) {
                  var r = n(1702);
                  t.exports = r({}.isPrototypeOf);
                },
                6324: function (t, e, n) {
                  var r = n(1702),
                    i = n(2597),
                    a = n(5656),
                    o = n(1318).indexOf,
                    s = n(3501),
                    c = r([].push);
                  t.exports = function (t, e) {
                    var n,
                      r = a(t),
                      l = 0,
                      u = [];
                    for (n in r) !i(s, n) && i(r, n) && c(u, n);
                    while (e.length > l)
                      i(r, (n = e[l++])) && (~o(u, n) || c(u, n));
                    return u;
                  };
                },
                1956: function (t, e, n) {
                  var r = n(6324),
                    i = n(748);
                  t.exports =
                    Object.keys ||
                    function (t) {
                      return r(t, i);
                    };
                },
                5296: function (t, e) {
                  "use strict";
                  var n = {}.propertyIsEnumerable,
                    r = Object.getOwnPropertyDescriptor,
                    i = r && !n.call({ 1: 2 }, 1);
                  e.f = i
                    ? function (t) {
                        var e = r(this, t);
                        return !!e && e.enumerable;
                      }
                    : n;
                },
                7674: function (t, e, n) {
                  var r = n(1702),
                    i = n(9670),
                    a = n(6077);
                  t.exports =
                    Object.setPrototypeOf ||
                    ("__proto__" in {}
                      ? (function () {
                          var t,
                            e = !1,
                            n = {};
                          try {
                            (t = r(
                              Object.getOwnPropertyDescriptor(
                                Object.prototype,
                                "__proto__"
                              ).set
                            )),
                              t(n, []),
                              (e = n instanceof Array);
                          } catch (o) {}
                          return function (n, r) {
                            return (
                              i(n), a(r), e ? t(n, r) : (n.__proto__ = r), n
                            );
                          };
                        })()
                      : void 0);
                },
                2140: function (t, e, n) {
                  var r = n(6916),
                    i = n(614),
                    a = n(111),
                    o = TypeError;
                  t.exports = function (t, e) {
                    var n, s;
                    if (
                      "string" === e &&
                      i((n = t.toString)) &&
                      !a((s = r(n, t)))
                    )
                      return s;
                    if (i((n = t.valueOf)) && !a((s = r(n, t)))) return s;
                    if (
                      "string" !== e &&
                      i((n = t.toString)) &&
                      !a((s = r(n, t)))
                    )
                      return s;
                    throw o("Can't convert object to primitive value");
                  };
                },
                3887: function (t, e, n) {
                  var r = n(5005),
                    i = n(1702),
                    a = n(8006),
                    o = n(5181),
                    s = n(9670),
                    c = i([].concat);
                  t.exports =
                    r("Reflect", "ownKeys") ||
                    function (t) {
                      var e = a.f(s(t)),
                        n = o.f;
                      return n ? c(e, n(t)) : e;
                    };
                },
                2626: function (t, e, n) {
                  var r = n(3070).f;
                  t.exports = function (t, e, n) {
                    n in t ||
                      r(t, n, {
                        configurable: !0,
                        get: function () {
                          return e[n];
                        },
                        set: function (t) {
                          e[n] = t;
                        },
                      });
                  };
                },
                7066: function (t, e, n) {
                  "use strict";
                  var r = n(9670);
                  t.exports = function () {
                    var t = r(this),
                      e = "";
                    return (
                      t.hasIndices && (e += "d"),
                      t.global && (e += "g"),
                      t.ignoreCase && (e += "i"),
                      t.multiline && (e += "m"),
                      t.dotAll && (e += "s"),
                      t.unicode && (e += "u"),
                      t.unicodeSets && (e += "v"),
                      t.sticky && (e += "y"),
                      e
                    );
                  };
                },
                4488: function (t) {
                  var e = TypeError;
                  t.exports = function (t) {
                    if (void 0 == t) throw e("Can't call method on " + t);
                    return t;
                  };
                },
                6200: function (t, e, n) {
                  var r = n(2309),
                    i = n(9711),
                    a = r("keys");
                  t.exports = function (t) {
                    return a[t] || (a[t] = i(t));
                  };
                },
                5465: function (t, e, n) {
                  var r = n(7854),
                    i = n(3072),
                    a = "__core-js_shared__",
                    o = r[a] || i(a, {});
                  t.exports = o;
                },
                2309: function (t, e, n) {
                  var r = n(1913),
                    i = n(5465);
                  (t.exports = function (t, e) {
                    return i[t] || (i[t] = void 0 !== e ? e : {});
                  })("versions", []).push({
                    version: "3.23.3",
                    mode: r ? "pure" : "global",
                    copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)",
                    license:
                      "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
                    source: "https://github.com/zloirock/core-js",
                  });
                },
                1400: function (t, e, n) {
                  var r = n(9303),
                    i = Math.max,
                    a = Math.min;
                  t.exports = function (t, e) {
                    var n = r(t);
                    return n < 0 ? i(n + e, 0) : a(n, e);
                  };
                },
                5656: function (t, e, n) {
                  var r = n(8361),
                    i = n(4488);
                  t.exports = function (t) {
                    return r(i(t));
                  };
                },
                9303: function (t, e, n) {
                  var r = n(4758);
                  t.exports = function (t) {
                    var e = +t;
                    return e !== e || 0 === e ? 0 : r(e);
                  };
                },
                7466: function (t, e, n) {
                  var r = n(9303),
                    i = Math.min;
                  t.exports = function (t) {
                    return t > 0 ? i(r(t), 9007199254740991) : 0;
                  };
                },
                7908: function (t, e, n) {
                  var r = n(4488),
                    i = Object;
                  t.exports = function (t) {
                    return i(r(t));
                  };
                },
                4590: function (t, e, n) {
                  var r = n(3002),
                    i = RangeError;
                  t.exports = function (t, e) {
                    var n = r(t);
                    if (n % e) throw i("Wrong offset");
                    return n;
                  };
                },
                3002: function (t, e, n) {
                  var r = n(9303),
                    i = RangeError;
                  t.exports = function (t) {
                    var e = r(t);
                    if (e < 0) throw i("The argument can't be less than 0");
                    return e;
                  };
                },
                7593: function (t, e, n) {
                  var r = n(6916),
                    i = n(111),
                    a = n(2190),
                    o = n(8173),
                    s = n(2140),
                    c = n(5112),
                    l = TypeError,
                    u = c("toPrimitive");
                  t.exports = function (t, e) {
                    if (!i(t) || a(t)) return t;
                    var n,
                      c = o(t, u);
                    if (c) {
                      if (
                        (void 0 === e && (e = "default"),
                        (n = r(c, t, e)),
                        !i(n) || a(n))
                      )
                        return n;
                      throw l("Can't convert object to primitive value");
                    }
                    return void 0 === e && (e = "number"), s(t, e);
                  };
                },
                4948: function (t, e, n) {
                  var r = n(7593),
                    i = n(2190);
                  t.exports = function (t) {
                    var e = r(t, "string");
                    return i(e) ? e : e + "";
                  };
                },
                1694: function (t, e, n) {
                  var r = n(5112),
                    i = r("toStringTag"),
                    a = {};
                  (a[i] = "z"), (t.exports = "[object z]" === String(a));
                },
                1340: function (t, e, n) {
                  var r = n(648),
                    i = String;
                  t.exports = function (t) {
                    if ("Symbol" === r(t))
                      throw TypeError(
                        "Cannot convert a Symbol value to a string"
                      );
                    return i(t);
                  };
                },
                6330: function (t) {
                  var e = String;
                  t.exports = function (t) {
                    try {
                      return e(t);
                    } catch (n) {
                      return "Object";
                    }
                  };
                },
                9711: function (t, e, n) {
                  var r = n(1702),
                    i = 0,
                    a = Math.random(),
                    o = r((1).toString);
                  t.exports = function (t) {
                    return (
                      "Symbol(" +
                      (void 0 === t ? "" : t) +
                      ")_" +
                      o(++i + a, 36)
                    );
                  };
                },
                3307: function (t, e, n) {
                  var r = n(133);
                  t.exports =
                    r && !Symbol.sham && "symbol" == typeof Symbol.iterator;
                },
                3353: function (t, e, n) {
                  var r = n(9781),
                    i = n(7293);
                  t.exports =
                    r &&
                    i(function () {
                      return (
                        42 !=
                        Object.defineProperty(function () {}, "prototype", {
                          value: 42,
                          writable: !1,
                        }).prototype
                      );
                    });
                },
                5112: function (t, e, n) {
                  var r = n(7854),
                    i = n(2309),
                    a = n(2597),
                    o = n(9711),
                    s = n(133),
                    c = n(3307),
                    l = i("wks"),
                    u = r.Symbol,
                    h = u && u["for"],
                    d = c ? u : (u && u.withoutSetter) || o;
                  t.exports = function (t) {
                    if (!a(l, t) || (!s && "string" != typeof l[t])) {
                      var e = "Symbol." + t;
                      s && a(u, t)
                        ? (l[t] = u[t])
                        : (l[t] = c && h ? h(e) : d(e));
                    }
                    return l[t];
                  };
                },
                9191: function (t, e, n) {
                  "use strict";
                  var r = n(5005),
                    i = n(2597),
                    a = n(8880),
                    o = n(7976),
                    s = n(7674),
                    c = n(2128),
                    l = n(2626),
                    u = n(9587),
                    h = n(6277),
                    d = n(8340),
                    f = n(7741),
                    p = n(2914),
                    m = n(9781),
                    g = n(1913);
                  t.exports = function (t, e, n, v) {
                    var y = "stackTraceLimit",
                      b = v ? 2 : 1,
                      x = t.split("."),
                      _ = x[x.length - 1],
                      w = r.apply(null, x);
                    if (w) {
                      var S = w.prototype;
                      if ((!g && i(S, "cause") && delete S.cause, !n)) return w;
                      var M = r("Error"),
                        T = e(function (t, e) {
                          var n = h(v ? e : t, void 0),
                            r = v ? new w(t) : new w();
                          return (
                            void 0 !== n && a(r, "message", n),
                            p && a(r, "stack", f(r.stack, 2)),
                            this && o(S, this) && u(r, this, T),
                            arguments.length > b && d(r, arguments[b]),
                            r
                          );
                        });
                      if (
                        ((T.prototype = S),
                        "Error" !== _
                          ? s
                            ? s(T, M)
                            : c(T, M, { name: !0 })
                          : m &&
                            y in w &&
                            (l(T, w, y), l(T, w, "prepareStackTrace")),
                        c(T, w),
                        !g)
                      )
                        try {
                          S.name !== _ && a(S, "name", _), (S.constructor = T);
                        } catch (E) {}
                      return T;
                    }
                  };
                },
                2262: function (t, e, n) {
                  "use strict";
                  var r = n(2109),
                    i = n(7908),
                    a = n(6244),
                    o = n(9303),
                    s = n(1223);
                  r(
                    { target: "Array", proto: !0 },
                    {
                      at: function (t) {
                        var e = i(this),
                          n = a(e),
                          r = o(t),
                          s = r >= 0 ? r : n + r;
                        return s < 0 || s >= n ? void 0 : e[s];
                      },
                    }
                  ),
                    s("at");
                },
                1703: function (t, e, n) {
                  var r = n(2109),
                    i = n(7854),
                    a = n(2104),
                    o = n(9191),
                    s = "WebAssembly",
                    c = i[s],
                    l = 7 !== Error("e", { cause: 7 }).cause,
                    u = function (t, e) {
                      var n = {};
                      (n[t] = o(t, e, l)),
                        r(
                          { global: !0, constructor: !0, arity: 1, forced: l },
                          n
                        );
                    },
                    h = function (t, e) {
                      if (c && c[t]) {
                        var n = {};
                        (n[t] = o(s + "." + t, e, l)),
                          r(
                            {
                              target: s,
                              stat: !0,
                              constructor: !0,
                              arity: 1,
                              forced: l,
                            },
                            n
                          );
                      }
                    };
                  u("Error", function (t) {
                    return function (e) {
                      return a(t, this, arguments);
                    };
                  }),
                    u("EvalError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    u("RangeError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    u("ReferenceError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    u("SyntaxError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    u("TypeError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    u("URIError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    h("CompileError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    h("LinkError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    }),
                    h("RuntimeError", function (t) {
                      return function (e) {
                        return a(t, this, arguments);
                      };
                    });
                },
                2087: function (t, e, n) {
                  var r = n(7854),
                    i = n(9781),
                    a = n(7045),
                    o = n(7066),
                    s = n(7293),
                    c = r.RegExp,
                    l = c.prototype,
                    u =
                      i &&
                      s(function () {
                        var t = !0;
                        try {
                          c(".", "d");
                        } catch (u) {
                          t = !1;
                        }
                        var e = {},
                          n = "",
                          r = t ? "dgimsy" : "gimsy",
                          i = function (t, r) {
                            Object.defineProperty(e, t, {
                              get: function () {
                                return (n += r), !0;
                              },
                            });
                          },
                          a = {
                            dotAll: "s",
                            global: "g",
                            ignoreCase: "i",
                            multiline: "m",
                            sticky: "y",
                          };
                        for (var o in (t && (a.hasIndices = "d"), a))
                          i(o, a[o]);
                        var s = Object.getOwnPropertyDescriptor(
                          l,
                          "flags"
                        ).get.call(e);
                        return s !== r || n !== r;
                      });
                  u && a(l, "flags", { configurable: !0, get: o });
                },
                4506: function (t, e, n) {
                  "use strict";
                  var r = n(2109),
                    i = n(1702),
                    a = n(4488),
                    o = n(9303),
                    s = n(1340),
                    c = n(7293),
                    l = i("".charAt),
                    u = c(function () {
                      return "\ud842" !== "𠮷".at(-2);
                    });
                  r(
                    { target: "String", proto: !0, forced: u },
                    {
                      at: function (t) {
                        var e = s(a(this)),
                          n = e.length,
                          r = o(t),
                          i = r >= 0 ? r : n + r;
                        return i < 0 || i >= n ? void 0 : l(e, i);
                      },
                    }
                  );
                },
                8675: function (t, e, n) {
                  "use strict";
                  var r = n(260),
                    i = n(6244),
                    a = n(9303),
                    o = r.aTypedArray,
                    s = r.exportTypedArrayMethod;
                  s("at", function (t) {
                    var e = o(this),
                      n = i(e),
                      r = a(t),
                      s = r >= 0 ? r : n + r;
                    return s < 0 || s >= n ? void 0 : e[s];
                  });
                },
                2958: function (t, e, n) {
                  "use strict";
                  var r = n(260),
                    i = n(9671).findLastIndex,
                    a = r.aTypedArray,
                    o = r.exportTypedArrayMethod;
                  o("findLastIndex", function (t) {
                    return i(
                      a(this),
                      t,
                      arguments.length > 1 ? arguments[1] : void 0
                    );
                  });
                },
                3408: function (t, e, n) {
                  "use strict";
                  var r = n(260),
                    i = n(9671).findLast,
                    a = r.aTypedArray,
                    o = r.exportTypedArrayMethod;
                  o("findLast", function (t) {
                    return i(
                      a(this),
                      t,
                      arguments.length > 1 ? arguments[1] : void 0
                    );
                  });
                },
                3462: function (t, e, n) {
                  "use strict";
                  var r = n(7854),
                    i = n(6916),
                    a = n(260),
                    o = n(6244),
                    s = n(4590),
                    c = n(7908),
                    l = n(7293),
                    u = r.RangeError,
                    h = r.Int8Array,
                    d = h && h.prototype,
                    f = d && d.set,
                    p = a.aTypedArray,
                    m = a.exportTypedArrayMethod,
                    g = !l(function () {
                      var t = new Uint8ClampedArray(2);
                      return i(f, t, { length: 1, 0: 3 }, 1), 3 !== t[1];
                    }),
                    v =
                      g &&
                      a.NATIVE_ARRAY_BUFFER_VIEWS &&
                      l(function () {
                        var t = new h(2);
                        return (
                          t.set(1), t.set("2", 1), 0 !== t[0] || 2 !== t[1]
                        );
                      });
                  m(
                    "set",
                    function (t) {
                      p(this);
                      var e = s(
                          arguments.length > 1 ? arguments[1] : void 0,
                          1
                        ),
                        n = c(t);
                      if (g) return i(f, this, n, e);
                      var r = this.length,
                        a = o(n),
                        l = 0;
                      if (a + e > r) throw u("Wrong length");
                      while (l < a) this[e + l] = n[l++];
                    },
                    !g || v
                  );
                },
                1118: function (t, e, n) {
                  n(2958);
                },
                7380: function (t, e, n) {
                  n(3408);
                },
              },
              e = {};
            function n(r) {
              var i = e[r];
              if (void 0 !== i) return i.exports;
              var a = (e[r] = { exports: {} });
              return t[r](a, a.exports, n), a.exports;
            }
            !(function () {
              n.d = function (t, e) {
                for (var r in e)
                  n.o(e, r) &&
                    !n.o(t, r) &&
                    Object.defineProperty(t, r, { enumerable: !0, get: e[r] });
              };
            })(),
              (function () {
                n.g = (function () {
                  if ("object" === typeof globalThis) return globalThis;
                  try {
                    return this || new Function("return this")();
                  } catch (t) {
                    if ("object" === typeof window) return window;
                  }
                })();
              })(),
              (function () {
                n.o = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e);
                };
              })(),
              (function () {
                n.r = function (t) {
                  "undefined" !== typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                      value: "Module",
                    }),
                    Object.defineProperty(t, "__esModule", { value: !0 });
                };
              })(),
              (function () {
                n.p = "";
              })();
            var r = {};
            return (
              (function () {
                "use strict";
                n.r(r),
                  n.d(r, {
                    default: function () {
                      return hx;
                    },
                    vue3dLoader: function () {
                      return sx;
                    },
                  });
                var t = {};
                if (
                  (n.r(t),
                  n.d(t, {
                    AsyncCompress: function () {
                      return Qg;
                    },
                    AsyncDecompress: function () {
                      return mv;
                    },
                    AsyncDeflate: function () {
                      return Wg;
                    },
                    AsyncGunzip: function () {
                      return rv;
                    },
                    AsyncGzip: function () {
                      return Qg;
                    },
                    AsyncInflate: function () {
                      return Yg;
                    },
                    AsyncUnzipInflate: function () {
                      return Hv;
                    },
                    AsyncUnzlib: function () {
                      return hv;
                    },
                    AsyncZipDeflate: function () {
                      return Dv;
                    },
                    AsyncZlib: function () {
                      return sv;
                    },
                    Compress: function () {
                      return Zg;
                    },
                    DecodeUTF8: function () {
                      return Sv;
                    },
                    Decompress: function () {
                      return pv;
                    },
                    Deflate: function () {
                      return Gg;
                    },
                    EncodeUTF8: function () {
                      return Mv;
                    },
                    Gunzip: function () {
                      return nv;
                    },
                    Gzip: function () {
                      return Zg;
                    },
                    Inflate: function () {
                      return $g;
                    },
                    Unzip: function () {
                      return Vv;
                    },
                    UnzipInflate: function () {
                      return jv;
                    },
                    UnzipPassThrough: function () {
                      return Bv;
                    },
                    Unzlib: function () {
                      return uv;
                    },
                    Zip: function () {
                      return zv;
                    },
                    ZipDeflate: function () {
                      return Nv;
                    },
                    ZipPassThrough: function () {
                      return kv;
                    },
                    Zlib: function () {
                      return ov;
                    },
                    compress: function () {
                      return tv;
                    },
                    compressSync: function () {
                      return ev;
                    },
                    decompress: function () {
                      return gv;
                    },
                    decompressSync: function () {
                      return vv;
                    },
                    deflate: function () {
                      return qg;
                    },
                    deflateSync: function () {
                      return Xg;
                    },
                    gunzip: function () {
                      return iv;
                    },
                    gunzipSync: function () {
                      return av;
                    },
                    gzip: function () {
                      return tv;
                    },
                    gzipSync: function () {
                      return ev;
                    },
                    inflate: function () {
                      return Jg;
                    },
                    inflateSync: function () {
                      return Kg;
                    },
                    strFromU8: function () {
                      return Ev;
                    },
                    strToU8: function () {
                      return Tv;
                    },
                    unzip: function () {
                      return Gv;
                    },
                    unzipSync: function () {
                      return Wv;
                    },
                    unzlib: function () {
                      return dv;
                    },
                    unzlibSync: function () {
                      return fv;
                    },
                    zip: function () {
                      return Fv;
                    },
                    zipSync: function () {
                      return Uv;
                    },
                    zlib: function () {
                      return cv;
                    },
                    zlibSync: function () {
                      return lv;
                    },
                  }),
                  "undefined" !== typeof window)
                ) {
                  var e = window.document.currentScript,
                    i = e && e.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
                  i && (n.p = i[1]);
                }
                var a = function () {
                    var t = this,
                      e = t.$createElement,
                      n = t._self._c || e;
                    return n(
                      "div",
                      { ref: "container", staticClass: "viewer-container" },
                      [
                        n("canvas", {
                          ref: "canvas",
                          staticClass: "viewer-canvas",
                        }),
                      ]
                    );
                  },
                  o = [];
                n(8675), n(3462), n(7380), n(1118), n(1703), n(2262), n(4506);
                /**
                 * @license
                 * Copyright 2010-2022 Three.js Authors
                 * SPDX-License-Identifier: MIT
                 */
                const s = "142",
                  c = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                  },
                  l = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
                  u = 0,
                  h = 1,
                  d = 2,
                  f = 1,
                  p = 2,
                  m = 3,
                  g = 0,
                  v = 1,
                  y = 2,
                  b = 1,
                  x = 0,
                  _ = 1,
                  w = 2,
                  S = 3,
                  M = 4,
                  T = 5,
                  E = 100,
                  A = 101,
                  C = 102,
                  L = 103,
                  R = 104,
                  P = 200,
                  I = 201,
                  O = 202,
                  k = 203,
                  N = 204,
                  D = 205,
                  z = 206,
                  F = 207,
                  U = 208,
                  B = 209,
                  j = 210,
                  H = 0,
                  V = 1,
                  G = 2,
                  W = 3,
                  q = 4,
                  X = 5,
                  $ = 6,
                  Y = 7,
                  J = 0,
                  K = 1,
                  Z = 2,
                  Q = 0,
                  tt = 1,
                  et = 2,
                  nt = 3,
                  rt = 4,
                  it = 5,
                  at = 300,
                  ot = 301,
                  st = 302,
                  ct = 303,
                  lt = 304,
                  ut = 306,
                  ht = 1e3,
                  dt = 1001,
                  ft = 1002,
                  pt = 1003,
                  mt = 1004,
                  gt = 1005,
                  vt = 1006,
                  yt = 1007,
                  bt = 1008,
                  xt = 1009,
                  _t = 1010,
                  wt = 1011,
                  St = 1012,
                  Mt = 1013,
                  Tt = 1014,
                  Et = 1015,
                  At = 1016,
                  Ct = 1017,
                  Lt = 1018,
                  Rt = 1020,
                  Pt = 1021,
                  It = 1022,
                  Ot = 1023,
                  kt = 1024,
                  Nt = 1025,
                  Dt = 1026,
                  zt = 1027,
                  Ft = 1028,
                  Ut = 1029,
                  Bt = 1030,
                  jt = 1031,
                  Ht = 1033,
                  Vt = 33776,
                  Gt = 33777,
                  Wt = 33778,
                  qt = 33779,
                  Xt = 35840,
                  $t = 35841,
                  Yt = 35842,
                  Jt = 35843,
                  Kt = 36196,
                  Zt = 37492,
                  Qt = 37496,
                  te = 37808,
                  ee = 37809,
                  ne = 37810,
                  re = 37811,
                  ie = 37812,
                  ae = 37813,
                  oe = 37814,
                  se = 37815,
                  ce = 37816,
                  le = 37817,
                  ue = 37818,
                  he = 37819,
                  de = 37820,
                  fe = 37821,
                  pe = 36492,
                  me = 2200,
                  ge = 2201,
                  ve = 2202,
                  ye = 2300,
                  be = 2301,
                  xe = 2302,
                  _e = 2400,
                  we = 2401,
                  Se = 2402,
                  Me = 2500,
                  Te = 2501,
                  Ee = 1,
                  Ae = 2,
                  Ce = 3e3,
                  Le = 3001,
                  Re = 3200,
                  Pe = 3201,
                  Ie = 0,
                  Oe = 1,
                  ke = "srgb",
                  Ne = "srgb-linear",
                  De = 7680,
                  ze = 519,
                  Fe = 35044,
                  Ue = "300 es",
                  Be = 1035;
                class je {
                  addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[t] && (n[t] = []),
                      -1 === n[t].indexOf(e) && n[t].push(e);
                  }
                  hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e);
                  }
                  removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners,
                      r = n[t];
                    if (void 0 !== r) {
                      const t = r.indexOf(e);
                      -1 !== t && r.splice(t, 1);
                    }
                  }
                  dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners,
                      n = e[t.type];
                    if (void 0 !== n) {
                      t.target = this;
                      const e = n.slice(0);
                      for (let n = 0, r = e.length; n < r; n++)
                        e[n].call(this, t);
                      t.target = null;
                    }
                  }
                }
                const He = [
                  "00",
                  "01",
                  "02",
                  "03",
                  "04",
                  "05",
                  "06",
                  "07",
                  "08",
                  "09",
                  "0a",
                  "0b",
                  "0c",
                  "0d",
                  "0e",
                  "0f",
                  "10",
                  "11",
                  "12",
                  "13",
                  "14",
                  "15",
                  "16",
                  "17",
                  "18",
                  "19",
                  "1a",
                  "1b",
                  "1c",
                  "1d",
                  "1e",
                  "1f",
                  "20",
                  "21",
                  "22",
                  "23",
                  "24",
                  "25",
                  "26",
                  "27",
                  "28",
                  "29",
                  "2a",
                  "2b",
                  "2c",
                  "2d",
                  "2e",
                  "2f",
                  "30",
                  "31",
                  "32",
                  "33",
                  "34",
                  "35",
                  "36",
                  "37",
                  "38",
                  "39",
                  "3a",
                  "3b",
                  "3c",
                  "3d",
                  "3e",
                  "3f",
                  "40",
                  "41",
                  "42",
                  "43",
                  "44",
                  "45",
                  "46",
                  "47",
                  "48",
                  "49",
                  "4a",
                  "4b",
                  "4c",
                  "4d",
                  "4e",
                  "4f",
                  "50",
                  "51",
                  "52",
                  "53",
                  "54",
                  "55",
                  "56",
                  "57",
                  "58",
                  "59",
                  "5a",
                  "5b",
                  "5c",
                  "5d",
                  "5e",
                  "5f",
                  "60",
                  "61",
                  "62",
                  "63",
                  "64",
                  "65",
                  "66",
                  "67",
                  "68",
                  "69",
                  "6a",
                  "6b",
                  "6c",
                  "6d",
                  "6e",
                  "6f",
                  "70",
                  "71",
                  "72",
                  "73",
                  "74",
                  "75",
                  "76",
                  "77",
                  "78",
                  "79",
                  "7a",
                  "7b",
                  "7c",
                  "7d",
                  "7e",
                  "7f",
                  "80",
                  "81",
                  "82",
                  "83",
                  "84",
                  "85",
                  "86",
                  "87",
                  "88",
                  "89",
                  "8a",
                  "8b",
                  "8c",
                  "8d",
                  "8e",
                  "8f",
                  "90",
                  "91",
                  "92",
                  "93",
                  "94",
                  "95",
                  "96",
                  "97",
                  "98",
                  "99",
                  "9a",
                  "9b",
                  "9c",
                  "9d",
                  "9e",
                  "9f",
                  "a0",
                  "a1",
                  "a2",
                  "a3",
                  "a4",
                  "a5",
                  "a6",
                  "a7",
                  "a8",
                  "a9",
                  "aa",
                  "ab",
                  "ac",
                  "ad",
                  "ae",
                  "af",
                  "b0",
                  "b1",
                  "b2",
                  "b3",
                  "b4",
                  "b5",
                  "b6",
                  "b7",
                  "b8",
                  "b9",
                  "ba",
                  "bb",
                  "bc",
                  "bd",
                  "be",
                  "bf",
                  "c0",
                  "c1",
                  "c2",
                  "c3",
                  "c4",
                  "c5",
                  "c6",
                  "c7",
                  "c8",
                  "c9",
                  "ca",
                  "cb",
                  "cc",
                  "cd",
                  "ce",
                  "cf",
                  "d0",
                  "d1",
                  "d2",
                  "d3",
                  "d4",
                  "d5",
                  "d6",
                  "d7",
                  "d8",
                  "d9",
                  "da",
                  "db",
                  "dc",
                  "dd",
                  "de",
                  "df",
                  "e0",
                  "e1",
                  "e2",
                  "e3",
                  "e4",
                  "e5",
                  "e6",
                  "e7",
                  "e8",
                  "e9",
                  "ea",
                  "eb",
                  "ec",
                  "ed",
                  "ee",
                  "ef",
                  "f0",
                  "f1",
                  "f2",
                  "f3",
                  "f4",
                  "f5",
                  "f6",
                  "f7",
                  "f8",
                  "f9",
                  "fa",
                  "fb",
                  "fc",
                  "fd",
                  "fe",
                  "ff",
                ];
                let Ve = 1234567;
                const Ge = Math.PI / 180,
                  We = 180 / Math.PI;
                function qe() {
                  const t = (4294967295 * Math.random()) | 0,
                    e = (4294967295 * Math.random()) | 0,
                    n = (4294967295 * Math.random()) | 0,
                    r = (4294967295 * Math.random()) | 0,
                    i =
                      He[255 & t] +
                      He[(t >> 8) & 255] +
                      He[(t >> 16) & 255] +
                      He[(t >> 24) & 255] +
                      "-" +
                      He[255 & e] +
                      He[(e >> 8) & 255] +
                      "-" +
                      He[((e >> 16) & 15) | 64] +
                      He[(e >> 24) & 255] +
                      "-" +
                      He[(63 & n) | 128] +
                      He[(n >> 8) & 255] +
                      "-" +
                      He[(n >> 16) & 255] +
                      He[(n >> 24) & 255] +
                      He[255 & r] +
                      He[(r >> 8) & 255] +
                      He[(r >> 16) & 255] +
                      He[(r >> 24) & 255];
                  return i.toLowerCase();
                }
                function Xe(t, e, n) {
                  return Math.max(e, Math.min(n, t));
                }
                function $e(t, e) {
                  return ((t % e) + e) % e;
                }
                function Ye(t, e, n, r, i) {
                  return r + ((t - e) * (i - r)) / (n - e);
                }
                function Je(t, e, n) {
                  return t !== e ? (n - t) / (e - t) : 0;
                }
                function Ke(t, e, n) {
                  return (1 - n) * t + n * e;
                }
                function Ze(t, e, n, r) {
                  return Ke(t, e, 1 - Math.exp(-n * r));
                }
                function Qe(t, e = 1) {
                  return e - Math.abs($e(t, 2 * e) - e);
                }
                function tn(t, e, n) {
                  return t <= e
                    ? 0
                    : t >= n
                    ? 1
                    : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
                }
                function en(t, e, n) {
                  return t <= e
                    ? 0
                    : t >= n
                    ? 1
                    : ((t = (t - e) / (n - e)),
                      t * t * t * (t * (6 * t - 15) + 10));
                }
                function nn(t, e) {
                  return t + Math.floor(Math.random() * (e - t + 1));
                }
                function rn(t, e) {
                  return t + Math.random() * (e - t);
                }
                function an(t) {
                  return t * (0.5 - Math.random());
                }
                function on(t) {
                  void 0 !== t && (Ve = t);
                  let e = (Ve += 1831565813);
                  return (
                    (e = Math.imul(e ^ (e >>> 15), 1 | e)),
                    (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
                    ((e ^ (e >>> 14)) >>> 0) / 4294967296
                  );
                }
                function sn(t) {
                  return t * Ge;
                }
                function cn(t) {
                  return t * We;
                }
                function ln(t) {
                  return 0 === (t & (t - 1)) && 0 !== t;
                }
                function un(t) {
                  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
                }
                function hn(t) {
                  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
                }
                function dn(t, e, n, r, i) {
                  const a = Math.cos,
                    o = Math.sin,
                    s = a(n / 2),
                    c = o(n / 2),
                    l = a((e + r) / 2),
                    u = o((e + r) / 2),
                    h = a((e - r) / 2),
                    d = o((e - r) / 2),
                    f = a((r - e) / 2),
                    p = o((r - e) / 2);
                  switch (i) {
                    case "XYX":
                      t.set(s * u, c * h, c * d, s * l);
                      break;
                    case "YZY":
                      t.set(c * d, s * u, c * h, s * l);
                      break;
                    case "ZXZ":
                      t.set(c * h, c * d, s * u, s * l);
                      break;
                    case "XZX":
                      t.set(s * u, c * p, c * f, s * l);
                      break;
                    case "YXY":
                      t.set(c * f, s * u, c * p, s * l);
                      break;
                    case "ZYZ":
                      t.set(c * p, c * f, s * u, s * l);
                      break;
                    default:
                      console.warn(
                        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                          i
                      );
                  }
                }
                function fn(t, e) {
                  switch (e.constructor) {
                    case Float32Array:
                      return t;
                    case Uint16Array:
                      return t / 65535;
                    case Uint8Array:
                      return t / 255;
                    case Int16Array:
                      return Math.max(t / 32767, -1);
                    case Int8Array:
                      return Math.max(t / 127, -1);
                    default:
                      throw new Error("Invalid component type.");
                  }
                }
                function pn(t, e) {
                  switch (e.constructor) {
                    case Float32Array:
                      return t;
                    case Uint16Array:
                      return Math.round(65535 * t);
                    case Uint8Array:
                      return Math.round(255 * t);
                    case Int16Array:
                      return Math.round(32767 * t);
                    case Int8Array:
                      return Math.round(127 * t);
                    default:
                      throw new Error("Invalid component type.");
                  }
                }
                var mn = Object.freeze({
                  __proto__: null,
                  DEG2RAD: Ge,
                  RAD2DEG: We,
                  generateUUID: qe,
                  clamp: Xe,
                  euclideanModulo: $e,
                  mapLinear: Ye,
                  inverseLerp: Je,
                  lerp: Ke,
                  damp: Ze,
                  pingpong: Qe,
                  smoothstep: tn,
                  smootherstep: en,
                  randInt: nn,
                  randFloat: rn,
                  randFloatSpread: an,
                  seededRandom: on,
                  degToRad: sn,
                  radToDeg: cn,
                  isPowerOfTwo: ln,
                  ceilPowerOfTwo: un,
                  floorPowerOfTwo: hn,
                  setQuaternionFromProperEuler: dn,
                  normalize: pn,
                  denormalize: fn,
                });
                class gn {
                  constructor(t = 0, e = 0) {
                    (gn.prototype.isVector2 = !0), (this.x = t), (this.y = e);
                  }
                  get width() {
                    return this.x;
                  }
                  set width(t) {
                    this.x = t;
                  }
                  get height() {
                    return this.y;
                  }
                  set height(t) {
                    this.y = t;
                  }
                  set(t, e) {
                    return (this.x = t), (this.y = e), this;
                  }
                  setScalar(t) {
                    return (this.x = t), (this.y = t), this;
                  }
                  setX(t) {
                    return (this.x = t), this;
                  }
                  setY(t) {
                    return (this.y = t), this;
                  }
                  setComponent(t, e) {
                    switch (t) {
                      case 0:
                        this.x = e;
                        break;
                      case 1:
                        this.y = e;
                        break;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                    return this;
                  }
                  getComponent(t) {
                    switch (t) {
                      case 0:
                        return this.x;
                      case 1:
                        return this.y;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                  }
                  clone() {
                    return new this.constructor(this.x, this.y);
                  }
                  copy(t) {
                    return (this.x = t.x), (this.y = t.y), this;
                  }
                  add(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                        ),
                        this.addVectors(t, e))
                      : ((this.x += t.x), (this.y += t.y), this);
                  }
                  addScalar(t) {
                    return (this.x += t), (this.y += t), this;
                  }
                  addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                  }
                  addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), this;
                  }
                  sub(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                        ),
                        this.subVectors(t, e))
                      : ((this.x -= t.x), (this.y -= t.y), this);
                  }
                  subScalar(t) {
                    return (this.x -= t), (this.y -= t), this;
                  }
                  subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                  }
                  multiply(t) {
                    return (this.x *= t.x), (this.y *= t.y), this;
                  }
                  multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), this;
                  }
                  divide(t) {
                    return (this.x /= t.x), (this.y /= t.y), this;
                  }
                  divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                  }
                  applyMatrix3(t) {
                    const e = this.x,
                      n = this.y,
                      r = t.elements;
                    return (
                      (this.x = r[0] * e + r[3] * n + r[6]),
                      (this.y = r[1] * e + r[4] * n + r[7]),
                      this
                    );
                  }
                  min(t) {
                    return (
                      (this.x = Math.min(this.x, t.x)),
                      (this.y = Math.min(this.y, t.y)),
                      this
                    );
                  }
                  max(t) {
                    return (
                      (this.x = Math.max(this.x, t.x)),
                      (this.y = Math.max(this.y, t.y)),
                      this
                    );
                  }
                  clamp(t, e) {
                    return (
                      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                      this
                    );
                  }
                  clampScalar(t, e) {
                    return (
                      (this.x = Math.max(t, Math.min(e, this.x))),
                      (this.y = Math.max(t, Math.min(e, this.y))),
                      this
                    );
                  }
                  clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(
                      Math.max(t, Math.min(e, n))
                    );
                  }
                  floor() {
                    return (
                      (this.x = Math.floor(this.x)),
                      (this.y = Math.floor(this.y)),
                      this
                    );
                  }
                  ceil() {
                    return (
                      (this.x = Math.ceil(this.x)),
                      (this.y = Math.ceil(this.y)),
                      this
                    );
                  }
                  round() {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      this
                    );
                  }
                  roundToZero() {
                    return (
                      (this.x =
                        this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                      (this.y =
                        this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                      this
                    );
                  }
                  negate() {
                    return (this.x = -this.x), (this.y = -this.y), this;
                  }
                  dot(t) {
                    return this.x * t.x + this.y * t.y;
                  }
                  cross(t) {
                    return this.x * t.y - this.y * t.x;
                  }
                  lengthSq() {
                    return this.x * this.x + this.y * this.y;
                  }
                  length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                  }
                  manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y);
                  }
                  normalize() {
                    return this.divideScalar(this.length() || 1);
                  }
                  angle() {
                    const t = Math.atan2(-this.y, -this.x) + Math.PI;
                    return t;
                  }
                  distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                  }
                  distanceToSquared(t) {
                    const e = this.x - t.x,
                      n = this.y - t.y;
                    return e * e + n * n;
                  }
                  manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                  }
                  setLength(t) {
                    return this.normalize().multiplyScalar(t);
                  }
                  lerp(t, e) {
                    return (
                      (this.x += (t.x - this.x) * e),
                      (this.y += (t.y - this.y) * e),
                      this
                    );
                  }
                  lerpVectors(t, e, n) {
                    return (
                      (this.x = t.x + (e.x - t.x) * n),
                      (this.y = t.y + (e.y - t.y) * n),
                      this
                    );
                  }
                  equals(t) {
                    return t.x === this.x && t.y === this.y;
                  }
                  fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), this;
                  }
                  toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), t;
                  }
                  fromBufferAttribute(t, e, n) {
                    return (
                      void 0 !== n &&
                        console.warn(
                          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                        ),
                      (this.x = t.getX(e)),
                      (this.y = t.getY(e)),
                      this
                    );
                  }
                  rotateAround(t, e) {
                    const n = Math.cos(e),
                      r = Math.sin(e),
                      i = this.x - t.x,
                      a = this.y - t.y;
                    return (
                      (this.x = i * n - a * r + t.x),
                      (this.y = i * r + a * n + t.y),
                      this
                    );
                  }
                  random() {
                    return (
                      (this.x = Math.random()), (this.y = Math.random()), this
                    );
                  }
                  *[Symbol.iterator]() {
                    yield this.x, yield this.y;
                  }
                }
                class vn {
                  constructor() {
                    (vn.prototype.isMatrix3 = !0),
                      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                      arguments.length > 0 &&
                        console.error(
                          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                        );
                  }
                  set(t, e, n, r, i, a, o, s, c) {
                    const l = this.elements;
                    return (
                      (l[0] = t),
                      (l[1] = r),
                      (l[2] = o),
                      (l[3] = e),
                      (l[4] = i),
                      (l[5] = s),
                      (l[6] = n),
                      (l[7] = a),
                      (l[8] = c),
                      this
                    );
                  }
                  identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                  }
                  copy(t) {
                    const e = this.elements,
                      n = t.elements;
                    return (
                      (e[0] = n[0]),
                      (e[1] = n[1]),
                      (e[2] = n[2]),
                      (e[3] = n[3]),
                      (e[4] = n[4]),
                      (e[5] = n[5]),
                      (e[6] = n[6]),
                      (e[7] = n[7]),
                      (e[8] = n[8]),
                      this
                    );
                  }
                  extractBasis(t, e, n) {
                    return (
                      t.setFromMatrix3Column(this, 0),
                      e.setFromMatrix3Column(this, 1),
                      n.setFromMatrix3Column(this, 2),
                      this
                    );
                  }
                  setFromMatrix4(t) {
                    const e = t.elements;
                    return (
                      this.set(
                        e[0],
                        e[4],
                        e[8],
                        e[1],
                        e[5],
                        e[9],
                        e[2],
                        e[6],
                        e[10]
                      ),
                      this
                    );
                  }
                  multiply(t) {
                    return this.multiplyMatrices(this, t);
                  }
                  premultiply(t) {
                    return this.multiplyMatrices(t, this);
                  }
                  multiplyMatrices(t, e) {
                    const n = t.elements,
                      r = e.elements,
                      i = this.elements,
                      a = n[0],
                      o = n[3],
                      s = n[6],
                      c = n[1],
                      l = n[4],
                      u = n[7],
                      h = n[2],
                      d = n[5],
                      f = n[8],
                      p = r[0],
                      m = r[3],
                      g = r[6],
                      v = r[1],
                      y = r[4],
                      b = r[7],
                      x = r[2],
                      _ = r[5],
                      w = r[8];
                    return (
                      (i[0] = a * p + o * v + s * x),
                      (i[3] = a * m + o * y + s * _),
                      (i[6] = a * g + o * b + s * w),
                      (i[1] = c * p + l * v + u * x),
                      (i[4] = c * m + l * y + u * _),
                      (i[7] = c * g + l * b + u * w),
                      (i[2] = h * p + d * v + f * x),
                      (i[5] = h * m + d * y + f * _),
                      (i[8] = h * g + d * b + f * w),
                      this
                    );
                  }
                  multiplyScalar(t) {
                    const e = this.elements;
                    return (
                      (e[0] *= t),
                      (e[3] *= t),
                      (e[6] *= t),
                      (e[1] *= t),
                      (e[4] *= t),
                      (e[7] *= t),
                      (e[2] *= t),
                      (e[5] *= t),
                      (e[8] *= t),
                      this
                    );
                  }
                  determinant() {
                    const t = this.elements,
                      e = t[0],
                      n = t[1],
                      r = t[2],
                      i = t[3],
                      a = t[4],
                      o = t[5],
                      s = t[6],
                      c = t[7],
                      l = t[8];
                    return (
                      e * a * l -
                      e * o * c -
                      n * i * l +
                      n * o * s +
                      r * i * c -
                      r * a * s
                    );
                  }
                  invert() {
                    const t = this.elements,
                      e = t[0],
                      n = t[1],
                      r = t[2],
                      i = t[3],
                      a = t[4],
                      o = t[5],
                      s = t[6],
                      c = t[7],
                      l = t[8],
                      u = l * a - o * c,
                      h = o * s - l * i,
                      d = c * i - a * s,
                      f = e * u + n * h + r * d;
                    if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const p = 1 / f;
                    return (
                      (t[0] = u * p),
                      (t[1] = (r * c - l * n) * p),
                      (t[2] = (o * n - r * a) * p),
                      (t[3] = h * p),
                      (t[4] = (l * e - r * s) * p),
                      (t[5] = (r * i - o * e) * p),
                      (t[6] = d * p),
                      (t[7] = (n * s - c * e) * p),
                      (t[8] = (a * e - n * i) * p),
                      this
                    );
                  }
                  transpose() {
                    let t;
                    const e = this.elements;
                    return (
                      (t = e[1]),
                      (e[1] = e[3]),
                      (e[3] = t),
                      (t = e[2]),
                      (e[2] = e[6]),
                      (e[6] = t),
                      (t = e[5]),
                      (e[5] = e[7]),
                      (e[7] = t),
                      this
                    );
                  }
                  getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose();
                  }
                  transposeIntoArray(t) {
                    const e = this.elements;
                    return (
                      (t[0] = e[0]),
                      (t[1] = e[3]),
                      (t[2] = e[6]),
                      (t[3] = e[1]),
                      (t[4] = e[4]),
                      (t[5] = e[7]),
                      (t[6] = e[2]),
                      (t[7] = e[5]),
                      (t[8] = e[8]),
                      this
                    );
                  }
                  setUvTransform(t, e, n, r, i, a, o) {
                    const s = Math.cos(i),
                      c = Math.sin(i);
                    return (
                      this.set(
                        n * s,
                        n * c,
                        -n * (s * a + c * o) + a + t,
                        -r * c,
                        r * s,
                        -r * (-c * a + s * o) + o + e,
                        0,
                        0,
                        1
                      ),
                      this
                    );
                  }
                  scale(t, e) {
                    const n = this.elements;
                    return (
                      (n[0] *= t),
                      (n[3] *= t),
                      (n[6] *= t),
                      (n[1] *= e),
                      (n[4] *= e),
                      (n[7] *= e),
                      this
                    );
                  }
                  rotate(t) {
                    const e = Math.cos(t),
                      n = Math.sin(t),
                      r = this.elements,
                      i = r[0],
                      a = r[3],
                      o = r[6],
                      s = r[1],
                      c = r[4],
                      l = r[7];
                    return (
                      (r[0] = e * i + n * s),
                      (r[3] = e * a + n * c),
                      (r[6] = e * o + n * l),
                      (r[1] = -n * i + e * s),
                      (r[4] = -n * a + e * c),
                      (r[7] = -n * o + e * l),
                      this
                    );
                  }
                  translate(t, e) {
                    const n = this.elements;
                    return (
                      (n[0] += t * n[2]),
                      (n[3] += t * n[5]),
                      (n[6] += t * n[8]),
                      (n[1] += e * n[2]),
                      (n[4] += e * n[5]),
                      (n[7] += e * n[8]),
                      this
                    );
                  }
                  equals(t) {
                    const e = this.elements,
                      n = t.elements;
                    for (let r = 0; r < 9; r++) if (e[r] !== n[r]) return !1;
                    return !0;
                  }
                  fromArray(t, e = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this;
                  }
                  toArray(t = [], e = 0) {
                    const n = this.elements;
                    return (
                      (t[e] = n[0]),
                      (t[e + 1] = n[1]),
                      (t[e + 2] = n[2]),
                      (t[e + 3] = n[3]),
                      (t[e + 4] = n[4]),
                      (t[e + 5] = n[5]),
                      (t[e + 6] = n[6]),
                      (t[e + 7] = n[7]),
                      (t[e + 8] = n[8]),
                      t
                    );
                  }
                  clone() {
                    return new this.constructor().fromArray(this.elements);
                  }
                }
                function yn(t) {
                  for (let e = t.length - 1; e >= 0; --e)
                    if (t[e] > 65535) return !0;
                  return !1;
                }
                const bn = {
                  Int8Array: Int8Array,
                  Uint8Array: Uint8Array,
                  Uint8ClampedArray: Uint8ClampedArray,
                  Int16Array: Int16Array,
                  Uint16Array: Uint16Array,
                  Int32Array: Int32Array,
                  Uint32Array: Uint32Array,
                  Float32Array: Float32Array,
                  Float64Array: Float64Array,
                };
                function xn(t, e) {
                  return new bn[t](e);
                }
                function _n(t) {
                  return document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    t
                  );
                }
                function wn(t) {
                  return t < 0.04045
                    ? 0.0773993808 * t
                    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
                }
                function Sn(t) {
                  return t < 0.0031308
                    ? 12.92 * t
                    : 1.055 * Math.pow(t, 0.41666) - 0.055;
                }
                const Mn = { [ke]: { [Ne]: wn }, [Ne]: { [ke]: Sn } },
                  Tn = {
                    legacyMode: !0,
                    get workingColorSpace() {
                      return Ne;
                    },
                    set workingColorSpace(t) {
                      console.warn(
                        "THREE.ColorManagement: .workingColorSpace is readonly."
                      );
                    },
                    convert: function (t, e, n) {
                      if (this.legacyMode || e === n || !e || !n) return t;
                      if (Mn[e] && void 0 !== Mn[e][n]) {
                        const r = Mn[e][n];
                        return (
                          (t.r = r(t.r)), (t.g = r(t.g)), (t.b = r(t.b)), t
                        );
                      }
                      throw new Error("Unsupported color space conversion.");
                    },
                    fromWorkingColorSpace: function (t, e) {
                      return this.convert(t, this.workingColorSpace, e);
                    },
                    toWorkingColorSpace: function (t, e) {
                      return this.convert(t, e, this.workingColorSpace);
                    },
                  },
                  En = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074,
                  },
                  An = { r: 0, g: 0, b: 0 },
                  Cn = { h: 0, s: 0, l: 0 },
                  Ln = { h: 0, s: 0, l: 0 };
                function Rn(t, e, n) {
                  return (
                    n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6
                      ? t + 6 * (e - t) * n
                      : n < 0.5
                      ? e
                      : n < 2 / 3
                      ? t + 6 * (e - t) * (2 / 3 - n)
                      : t
                  );
                }
                function Pn(t, e) {
                  return (e.r = t.r), (e.g = t.g), (e.b = t.b), e;
                }
                class In {
                  constructor(t, e, n) {
                    return (
                      (this.isColor = !0),
                      (this.r = 1),
                      (this.g = 1),
                      (this.b = 1),
                      void 0 === e && void 0 === n
                        ? this.set(t)
                        : this.setRGB(t, e, n)
                    );
                  }
                  set(t) {
                    return (
                      t && t.isColor
                        ? this.copy(t)
                        : "number" === typeof t
                        ? this.setHex(t)
                        : "string" === typeof t && this.setStyle(t),
                      this
                    );
                  }
                  setScalar(t) {
                    return (this.r = t), (this.g = t), (this.b = t), this;
                  }
                  setHex(t, e = ke) {
                    return (
                      (t = Math.floor(t)),
                      (this.r = ((t >> 16) & 255) / 255),
                      (this.g = ((t >> 8) & 255) / 255),
                      (this.b = (255 & t) / 255),
                      Tn.toWorkingColorSpace(this, e),
                      this
                    );
                  }
                  setRGB(t, e, n, r = Ne) {
                    return (
                      (this.r = t),
                      (this.g = e),
                      (this.b = n),
                      Tn.toWorkingColorSpace(this, r),
                      this
                    );
                  }
                  setHSL(t, e, n, r = Ne) {
                    if (
                      ((t = $e(t, 1)),
                      (e = Xe(e, 0, 1)),
                      (n = Xe(n, 0, 1)),
                      0 === e)
                    )
                      this.r = this.g = this.b = n;
                    else {
                      const r = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                        i = 2 * n - r;
                      (this.r = Rn(i, r, t + 1 / 3)),
                        (this.g = Rn(i, r, t)),
                        (this.b = Rn(i, r, t - 1 / 3));
                    }
                    return Tn.toWorkingColorSpace(this, r), this;
                  }
                  setStyle(t, e = ke) {
                    function n(e) {
                      void 0 !== e &&
                        parseFloat(e) < 1 &&
                        console.warn(
                          "THREE.Color: Alpha component of " +
                            t +
                            " will be ignored."
                        );
                    }
                    let r;
                    if ((r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
                      let t;
                      const i = r[1],
                        a = r[2];
                      switch (i) {
                        case "rgb":
                        case "rgba":
                          if (
                            (t =
                              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                a
                              ))
                          )
                            return (
                              (this.r =
                                Math.min(255, parseInt(t[1], 10)) / 255),
                              (this.g =
                                Math.min(255, parseInt(t[2], 10)) / 255),
                              (this.b =
                                Math.min(255, parseInt(t[3], 10)) / 255),
                              Tn.toWorkingColorSpace(this, e),
                              n(t[4]),
                              this
                            );
                          if (
                            (t =
                              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                a
                              ))
                          )
                            return (
                              (this.r =
                                Math.min(100, parseInt(t[1], 10)) / 100),
                              (this.g =
                                Math.min(100, parseInt(t[2], 10)) / 100),
                              (this.b =
                                Math.min(100, parseInt(t[3], 10)) / 100),
                              Tn.toWorkingColorSpace(this, e),
                              n(t[4]),
                              this
                            );
                          break;
                        case "hsl":
                        case "hsla":
                          if (
                            (t =
                              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                a
                              ))
                          ) {
                            const r = parseFloat(t[1]) / 360,
                              i = parseInt(t[2], 10) / 100,
                              a = parseInt(t[3], 10) / 100;
                            return n(t[4]), this.setHSL(r, i, a, e);
                          }
                          break;
                      }
                    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(t))) {
                      const t = r[1],
                        n = t.length;
                      if (3 === n)
                        return (
                          (this.r =
                            parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                          (this.g =
                            parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                          (this.b =
                            parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                          Tn.toWorkingColorSpace(this, e),
                          this
                        );
                      if (6 === n)
                        return (
                          (this.r =
                            parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                          (this.g =
                            parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                          (this.b =
                            parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                          Tn.toWorkingColorSpace(this, e),
                          this
                        );
                    }
                    return t && t.length > 0 ? this.setColorName(t, e) : this;
                  }
                  setColorName(t, e = ke) {
                    const n = En[t.toLowerCase()];
                    return (
                      void 0 !== n
                        ? this.setHex(n, e)
                        : console.warn("THREE.Color: Unknown color " + t),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor(this.r, this.g, this.b);
                  }
                  copy(t) {
                    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
                  }
                  copySRGBToLinear(t) {
                    return (
                      (this.r = wn(t.r)),
                      (this.g = wn(t.g)),
                      (this.b = wn(t.b)),
                      this
                    );
                  }
                  copyLinearToSRGB(t) {
                    return (
                      (this.r = Sn(t.r)),
                      (this.g = Sn(t.g)),
                      (this.b = Sn(t.b)),
                      this
                    );
                  }
                  convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this;
                  }
                  convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this;
                  }
                  getHex(t = ke) {
                    return (
                      Tn.fromWorkingColorSpace(Pn(this, An), t),
                      (Xe(255 * An.r, 0, 255) << 16) ^
                        (Xe(255 * An.g, 0, 255) << 8) ^
                        (Xe(255 * An.b, 0, 255) << 0)
                    );
                  }
                  getHexString(t = ke) {
                    return ("000000" + this.getHex(t).toString(16)).slice(-6);
                  }
                  getHSL(t, e = Ne) {
                    Tn.fromWorkingColorSpace(Pn(this, An), e);
                    const n = An.r,
                      r = An.g,
                      i = An.b,
                      a = Math.max(n, r, i),
                      o = Math.min(n, r, i);
                    let s, c;
                    const l = (o + a) / 2;
                    if (o === a) (s = 0), (c = 0);
                    else {
                      const t = a - o;
                      switch (
                        ((c = l <= 0.5 ? t / (a + o) : t / (2 - a - o)), a)
                      ) {
                        case n:
                          s = (r - i) / t + (r < i ? 6 : 0);
                          break;
                        case r:
                          s = (i - n) / t + 2;
                          break;
                        case i:
                          s = (n - r) / t + 4;
                          break;
                      }
                      s /= 6;
                    }
                    return (t.h = s), (t.s = c), (t.l = l), t;
                  }
                  getRGB(t, e = Ne) {
                    return (
                      Tn.fromWorkingColorSpace(Pn(this, An), e),
                      (t.r = An.r),
                      (t.g = An.g),
                      (t.b = An.b),
                      t
                    );
                  }
                  getStyle(t = ke) {
                    return (
                      Tn.fromWorkingColorSpace(Pn(this, An), t),
                      t !== ke
                        ? `color(${t} ${An.r} ${An.g} ${An.b})`
                        : `rgb(${(255 * An.r) | 0},${(255 * An.g) | 0},${
                            (255 * An.b) | 0
                          })`
                    );
                  }
                  offsetHSL(t, e, n) {
                    return (
                      this.getHSL(Cn),
                      (Cn.h += t),
                      (Cn.s += e),
                      (Cn.l += n),
                      this.setHSL(Cn.h, Cn.s, Cn.l),
                      this
                    );
                  }
                  add(t) {
                    return (
                      (this.r += t.r), (this.g += t.g), (this.b += t.b), this
                    );
                  }
                  addColors(t, e) {
                    return (
                      (this.r = t.r + e.r),
                      (this.g = t.g + e.g),
                      (this.b = t.b + e.b),
                      this
                    );
                  }
                  addScalar(t) {
                    return (this.r += t), (this.g += t), (this.b += t), this;
                  }
                  sub(t) {
                    return (
                      (this.r = Math.max(0, this.r - t.r)),
                      (this.g = Math.max(0, this.g - t.g)),
                      (this.b = Math.max(0, this.b - t.b)),
                      this
                    );
                  }
                  multiply(t) {
                    return (
                      (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
                    );
                  }
                  multiplyScalar(t) {
                    return (this.r *= t), (this.g *= t), (this.b *= t), this;
                  }
                  lerp(t, e) {
                    return (
                      (this.r += (t.r - this.r) * e),
                      (this.g += (t.g - this.g) * e),
                      (this.b += (t.b - this.b) * e),
                      this
                    );
                  }
                  lerpColors(t, e, n) {
                    return (
                      (this.r = t.r + (e.r - t.r) * n),
                      (this.g = t.g + (e.g - t.g) * n),
                      (this.b = t.b + (e.b - t.b) * n),
                      this
                    );
                  }
                  lerpHSL(t, e) {
                    this.getHSL(Cn), t.getHSL(Ln);
                    const n = Ke(Cn.h, Ln.h, e),
                      r = Ke(Cn.s, Ln.s, e),
                      i = Ke(Cn.l, Ln.l, e);
                    return this.setHSL(n, r, i), this;
                  }
                  equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b;
                  }
                  fromArray(t, e = 0) {
                    return (
                      (this.r = t[e]),
                      (this.g = t[e + 1]),
                      (this.b = t[e + 2]),
                      this
                    );
                  }
                  toArray(t = [], e = 0) {
                    return (
                      (t[e] = this.r),
                      (t[e + 1] = this.g),
                      (t[e + 2] = this.b),
                      t
                    );
                  }
                  fromBufferAttribute(t, e) {
                    return (
                      (this.r = t.getX(e)),
                      (this.g = t.getY(e)),
                      (this.b = t.getZ(e)),
                      !0 === t.normalized &&
                        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
                      this
                    );
                  }
                  toJSON() {
                    return this.getHex();
                  }
                  *[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b;
                  }
                }
                let On;
                In.NAMES = En;
                class kn {
                  static getDataURL(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                      void 0 === On && (On = _n("canvas")),
                        (On.width = t.width),
                        (On.height = t.height);
                      const n = On.getContext("2d");
                      t instanceof ImageData
                        ? n.putImageData(t, 0, 0)
                        : n.drawImage(t, 0, 0, t.width, t.height),
                        (e = On);
                    }
                    return e.width > 2048 || e.height > 2048
                      ? (console.warn(
                          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                          t
                        ),
                        e.toDataURL("image/jpeg", 0.6))
                      : e.toDataURL("image/png");
                  }
                  static sRGBToLinear(t) {
                    if (
                      ("undefined" !== typeof HTMLImageElement &&
                        t instanceof HTMLImageElement) ||
                      ("undefined" !== typeof HTMLCanvasElement &&
                        t instanceof HTMLCanvasElement) ||
                      ("undefined" !== typeof ImageBitmap &&
                        t instanceof ImageBitmap)
                    ) {
                      const e = _n("canvas");
                      (e.width = t.width), (e.height = t.height);
                      const n = e.getContext("2d");
                      n.drawImage(t, 0, 0, t.width, t.height);
                      const r = n.getImageData(0, 0, t.width, t.height),
                        i = r.data;
                      for (let t = 0; t < i.length; t++)
                        i[t] = 255 * wn(i[t] / 255);
                      return n.putImageData(r, 0, 0), e;
                    }
                    if (t.data) {
                      const e = t.data.slice(0);
                      for (let t = 0; t < e.length; t++)
                        e instanceof Uint8Array ||
                        e instanceof Uint8ClampedArray
                          ? (e[t] = Math.floor(255 * wn(e[t] / 255)))
                          : (e[t] = wn(e[t]));
                      return { data: e, width: t.width, height: t.height };
                    }
                    return (
                      console.warn(
                        "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
                      ),
                      t
                    );
                  }
                }
                class Nn {
                  constructor(t = null) {
                    (this.isSource = !0),
                      (this.uuid = qe()),
                      (this.data = t),
                      (this.version = 0);
                  }
                  set needsUpdate(t) {
                    !0 === t && this.version++;
                  }
                  toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.images[this.uuid])
                      return t.images[this.uuid];
                    const n = { uuid: this.uuid, url: "" },
                      r = this.data;
                    if (null !== r) {
                      let t;
                      if (Array.isArray(r)) {
                        t = [];
                        for (let e = 0, n = r.length; e < n; e++)
                          r[e].isDataTexture
                            ? t.push(Dn(r[e].image))
                            : t.push(Dn(r[e]));
                      } else t = Dn(r);
                      n.url = t;
                    }
                    return e || (t.images[this.uuid] = n), n;
                  }
                }
                function Dn(t) {
                  return ("undefined" !== typeof HTMLImageElement &&
                    t instanceof HTMLImageElement) ||
                    ("undefined" !== typeof HTMLCanvasElement &&
                      t instanceof HTMLCanvasElement) ||
                    ("undefined" !== typeof ImageBitmap &&
                      t instanceof ImageBitmap)
                    ? kn.getDataURL(t)
                    : t.data
                    ? {
                        data: Array.from(t.data),
                        width: t.width,
                        height: t.height,
                        type: t.data.constructor.name,
                      }
                    : (console.warn(
                        "THREE.Texture: Unable to serialize Texture."
                      ),
                      {});
                }
                let zn = 0;
                class Fn extends je {
                  constructor(
                    t = Fn.DEFAULT_IMAGE,
                    e = Fn.DEFAULT_MAPPING,
                    n = dt,
                    r = dt,
                    i = vt,
                    a = bt,
                    o = Ot,
                    s = xt,
                    c = 1,
                    l = Ce
                  ) {
                    super(),
                      (this.isTexture = !0),
                      Object.defineProperty(this, "id", { value: zn++ }),
                      (this.uuid = qe()),
                      (this.name = ""),
                      (this.source = new Nn(t)),
                      (this.mipmaps = []),
                      (this.mapping = e),
                      (this.wrapS = n),
                      (this.wrapT = r),
                      (this.magFilter = i),
                      (this.minFilter = a),
                      (this.anisotropy = c),
                      (this.format = o),
                      (this.internalFormat = null),
                      (this.type = s),
                      (this.offset = new gn(0, 0)),
                      (this.repeat = new gn(1, 1)),
                      (this.center = new gn(0, 0)),
                      (this.rotation = 0),
                      (this.matrixAutoUpdate = !0),
                      (this.matrix = new vn()),
                      (this.generateMipmaps = !0),
                      (this.premultiplyAlpha = !1),
                      (this.flipY = !0),
                      (this.unpackAlignment = 4),
                      (this.encoding = l),
                      (this.userData = {}),
                      (this.version = 0),
                      (this.onUpdate = null),
                      (this.isRenderTargetTexture = !1),
                      (this.needsPMREMUpdate = !1);
                  }
                  get image() {
                    return this.source.data;
                  }
                  set image(t) {
                    this.source.data = t;
                  }
                  updateMatrix() {
                    this.matrix.setUvTransform(
                      this.offset.x,
                      this.offset.y,
                      this.repeat.x,
                      this.repeat.y,
                      this.rotation,
                      this.center.x,
                      this.center.y
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    return (
                      (this.name = t.name),
                      (this.source = t.source),
                      (this.mipmaps = t.mipmaps.slice(0)),
                      (this.mapping = t.mapping),
                      (this.wrapS = t.wrapS),
                      (this.wrapT = t.wrapT),
                      (this.magFilter = t.magFilter),
                      (this.minFilter = t.minFilter),
                      (this.anisotropy = t.anisotropy),
                      (this.format = t.format),
                      (this.internalFormat = t.internalFormat),
                      (this.type = t.type),
                      this.offset.copy(t.offset),
                      this.repeat.copy(t.repeat),
                      this.center.copy(t.center),
                      (this.rotation = t.rotation),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      this.matrix.copy(t.matrix),
                      (this.generateMipmaps = t.generateMipmaps),
                      (this.premultiplyAlpha = t.premultiplyAlpha),
                      (this.flipY = t.flipY),
                      (this.unpackAlignment = t.unpackAlignment),
                      (this.encoding = t.encoding),
                      (this.userData = JSON.parse(JSON.stringify(t.userData))),
                      (this.needsUpdate = !0),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.textures[this.uuid])
                      return t.textures[this.uuid];
                    const n = {
                      metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON",
                      },
                      uuid: this.uuid,
                      name: this.name,
                      image: this.source.toJSON(t).uuid,
                      mapping: this.mapping,
                      repeat: [this.repeat.x, this.repeat.y],
                      offset: [this.offset.x, this.offset.y],
                      center: [this.center.x, this.center.y],
                      rotation: this.rotation,
                      wrap: [this.wrapS, this.wrapT],
                      format: this.format,
                      type: this.type,
                      encoding: this.encoding,
                      minFilter: this.minFilter,
                      magFilter: this.magFilter,
                      anisotropy: this.anisotropy,
                      flipY: this.flipY,
                      premultiplyAlpha: this.premultiplyAlpha,
                      unpackAlignment: this.unpackAlignment,
                    };
                    return (
                      "{}" !== JSON.stringify(this.userData) &&
                        (n.userData = this.userData),
                      e || (t.textures[this.uuid] = n),
                      n
                    );
                  }
                  dispose() {
                    this.dispatchEvent({ type: "dispose" });
                  }
                  transformUv(t) {
                    if (this.mapping !== at) return t;
                    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                      switch (this.wrapS) {
                        case ht:
                          t.x = t.x - Math.floor(t.x);
                          break;
                        case dt:
                          t.x = t.x < 0 ? 0 : 1;
                          break;
                        case ft:
                          1 === Math.abs(Math.floor(t.x) % 2)
                            ? (t.x = Math.ceil(t.x) - t.x)
                            : (t.x = t.x - Math.floor(t.x));
                          break;
                      }
                    if (t.y < 0 || t.y > 1)
                      switch (this.wrapT) {
                        case ht:
                          t.y = t.y - Math.floor(t.y);
                          break;
                        case dt:
                          t.y = t.y < 0 ? 0 : 1;
                          break;
                        case ft:
                          1 === Math.abs(Math.floor(t.y) % 2)
                            ? (t.y = Math.ceil(t.y) - t.y)
                            : (t.y = t.y - Math.floor(t.y));
                          break;
                      }
                    return this.flipY && (t.y = 1 - t.y), t;
                  }
                  set needsUpdate(t) {
                    !0 === t &&
                      (this.version++, (this.source.needsUpdate = !0));
                  }
                }
                (Fn.DEFAULT_IMAGE = null), (Fn.DEFAULT_MAPPING = at);
                class Un {
                  constructor(t = 0, e = 0, n = 0, r = 1) {
                    (Un.prototype.isVector4 = !0),
                      (this.x = t),
                      (this.y = e),
                      (this.z = n),
                      (this.w = r);
                  }
                  get width() {
                    return this.z;
                  }
                  set width(t) {
                    this.z = t;
                  }
                  get height() {
                    return this.w;
                  }
                  set height(t) {
                    this.w = t;
                  }
                  set(t, e, n, r) {
                    return (
                      (this.x = t),
                      (this.y = e),
                      (this.z = n),
                      (this.w = r),
                      this
                    );
                  }
                  setScalar(t) {
                    return (
                      (this.x = t),
                      (this.y = t),
                      (this.z = t),
                      (this.w = t),
                      this
                    );
                  }
                  setX(t) {
                    return (this.x = t), this;
                  }
                  setY(t) {
                    return (this.y = t), this;
                  }
                  setZ(t) {
                    return (this.z = t), this;
                  }
                  setW(t) {
                    return (this.w = t), this;
                  }
                  setComponent(t, e) {
                    switch (t) {
                      case 0:
                        this.x = e;
                        break;
                      case 1:
                        this.y = e;
                        break;
                      case 2:
                        this.z = e;
                        break;
                      case 3:
                        this.w = e;
                        break;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                    return this;
                  }
                  getComponent(t) {
                    switch (t) {
                      case 0:
                        return this.x;
                      case 1:
                        return this.y;
                      case 2:
                        return this.z;
                      case 3:
                        return this.w;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                  }
                  clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w);
                  }
                  copy(t) {
                    return (
                      (this.x = t.x),
                      (this.y = t.y),
                      (this.z = t.z),
                      (this.w = void 0 !== t.w ? t.w : 1),
                      this
                    );
                  }
                  add(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                        ),
                        this.addVectors(t, e))
                      : ((this.x += t.x),
                        (this.y += t.y),
                        (this.z += t.z),
                        (this.w += t.w),
                        this);
                  }
                  addScalar(t) {
                    return (
                      (this.x += t),
                      (this.y += t),
                      (this.z += t),
                      (this.w += t),
                      this
                    );
                  }
                  addVectors(t, e) {
                    return (
                      (this.x = t.x + e.x),
                      (this.y = t.y + e.y),
                      (this.z = t.z + e.z),
                      (this.w = t.w + e.w),
                      this
                    );
                  }
                  addScaledVector(t, e) {
                    return (
                      (this.x += t.x * e),
                      (this.y += t.y * e),
                      (this.z += t.z * e),
                      (this.w += t.w * e),
                      this
                    );
                  }
                  sub(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                        ),
                        this.subVectors(t, e))
                      : ((this.x -= t.x),
                        (this.y -= t.y),
                        (this.z -= t.z),
                        (this.w -= t.w),
                        this);
                  }
                  subScalar(t) {
                    return (
                      (this.x -= t),
                      (this.y -= t),
                      (this.z -= t),
                      (this.w -= t),
                      this
                    );
                  }
                  subVectors(t, e) {
                    return (
                      (this.x = t.x - e.x),
                      (this.y = t.y - e.y),
                      (this.z = t.z - e.z),
                      (this.w = t.w - e.w),
                      this
                    );
                  }
                  multiply(t) {
                    return (
                      (this.x *= t.x),
                      (this.y *= t.y),
                      (this.z *= t.z),
                      (this.w *= t.w),
                      this
                    );
                  }
                  multiplyScalar(t) {
                    return (
                      (this.x *= t),
                      (this.y *= t),
                      (this.z *= t),
                      (this.w *= t),
                      this
                    );
                  }
                  applyMatrix4(t) {
                    const e = this.x,
                      n = this.y,
                      r = this.z,
                      i = this.w,
                      a = t.elements;
                    return (
                      (this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i),
                      (this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i),
                      (this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i),
                      (this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i),
                      this
                    );
                  }
                  divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                  }
                  setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return (
                      e < 1e-4
                        ? ((this.x = 1), (this.y = 0), (this.z = 0))
                        : ((this.x = t.x / e),
                          (this.y = t.y / e),
                          (this.z = t.z / e)),
                      this
                    );
                  }
                  setAxisAngleFromRotationMatrix(t) {
                    let e, n, r, i;
                    const a = 0.01,
                      o = 0.1,
                      s = t.elements,
                      c = s[0],
                      l = s[4],
                      u = s[8],
                      h = s[1],
                      d = s[5],
                      f = s[9],
                      p = s[2],
                      m = s[6],
                      g = s[10];
                    if (
                      Math.abs(l - h) < a &&
                      Math.abs(u - p) < a &&
                      Math.abs(f - m) < a
                    ) {
                      if (
                        Math.abs(l + h) < o &&
                        Math.abs(u + p) < o &&
                        Math.abs(f + m) < o &&
                        Math.abs(c + d + g - 3) < o
                      )
                        return this.set(1, 0, 0, 0), this;
                      e = Math.PI;
                      const t = (c + 1) / 2,
                        s = (d + 1) / 2,
                        v = (g + 1) / 2,
                        y = (l + h) / 4,
                        b = (u + p) / 4,
                        x = (f + m) / 4;
                      return (
                        t > s && t > v
                          ? t < a
                            ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                            : ((n = Math.sqrt(t)), (r = y / n), (i = b / n))
                          : s > v
                          ? s < a
                            ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                            : ((r = Math.sqrt(s)), (n = y / r), (i = x / r))
                          : v < a
                          ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                          : ((i = Math.sqrt(v)), (n = b / i), (r = x / i)),
                        this.set(n, r, i, e),
                        this
                      );
                    }
                    let v = Math.sqrt(
                      (m - f) * (m - f) + (u - p) * (u - p) + (h - l) * (h - l)
                    );
                    return (
                      Math.abs(v) < 0.001 && (v = 1),
                      (this.x = (m - f) / v),
                      (this.y = (u - p) / v),
                      (this.z = (h - l) / v),
                      (this.w = Math.acos((c + d + g - 1) / 2)),
                      this
                    );
                  }
                  min(t) {
                    return (
                      (this.x = Math.min(this.x, t.x)),
                      (this.y = Math.min(this.y, t.y)),
                      (this.z = Math.min(this.z, t.z)),
                      (this.w = Math.min(this.w, t.w)),
                      this
                    );
                  }
                  max(t) {
                    return (
                      (this.x = Math.max(this.x, t.x)),
                      (this.y = Math.max(this.y, t.y)),
                      (this.z = Math.max(this.z, t.z)),
                      (this.w = Math.max(this.w, t.w)),
                      this
                    );
                  }
                  clamp(t, e) {
                    return (
                      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                      this
                    );
                  }
                  clampScalar(t, e) {
                    return (
                      (this.x = Math.max(t, Math.min(e, this.x))),
                      (this.y = Math.max(t, Math.min(e, this.y))),
                      (this.z = Math.max(t, Math.min(e, this.z))),
                      (this.w = Math.max(t, Math.min(e, this.w))),
                      this
                    );
                  }
                  clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(
                      Math.max(t, Math.min(e, n))
                    );
                  }
                  floor() {
                    return (
                      (this.x = Math.floor(this.x)),
                      (this.y = Math.floor(this.y)),
                      (this.z = Math.floor(this.z)),
                      (this.w = Math.floor(this.w)),
                      this
                    );
                  }
                  ceil() {
                    return (
                      (this.x = Math.ceil(this.x)),
                      (this.y = Math.ceil(this.y)),
                      (this.z = Math.ceil(this.z)),
                      (this.w = Math.ceil(this.w)),
                      this
                    );
                  }
                  round() {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      (this.z = Math.round(this.z)),
                      (this.w = Math.round(this.w)),
                      this
                    );
                  }
                  roundToZero() {
                    return (
                      (this.x =
                        this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                      (this.y =
                        this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                      (this.z =
                        this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                      (this.w =
                        this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                      this
                    );
                  }
                  negate() {
                    return (
                      (this.x = -this.x),
                      (this.y = -this.y),
                      (this.z = -this.z),
                      (this.w = -this.w),
                      this
                    );
                  }
                  dot(t) {
                    return (
                      this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    );
                  }
                  lengthSq() {
                    return (
                      this.x * this.x +
                      this.y * this.y +
                      this.z * this.z +
                      this.w * this.w
                    );
                  }
                  length() {
                    return Math.sqrt(
                      this.x * this.x +
                        this.y * this.y +
                        this.z * this.z +
                        this.w * this.w
                    );
                  }
                  manhattanLength() {
                    return (
                      Math.abs(this.x) +
                      Math.abs(this.y) +
                      Math.abs(this.z) +
                      Math.abs(this.w)
                    );
                  }
                  normalize() {
                    return this.divideScalar(this.length() || 1);
                  }
                  setLength(t) {
                    return this.normalize().multiplyScalar(t);
                  }
                  lerp(t, e) {
                    return (
                      (this.x += (t.x - this.x) * e),
                      (this.y += (t.y - this.y) * e),
                      (this.z += (t.z - this.z) * e),
                      (this.w += (t.w - this.w) * e),
                      this
                    );
                  }
                  lerpVectors(t, e, n) {
                    return (
                      (this.x = t.x + (e.x - t.x) * n),
                      (this.y = t.y + (e.y - t.y) * n),
                      (this.z = t.z + (e.z - t.z) * n),
                      (this.w = t.w + (e.w - t.w) * n),
                      this
                    );
                  }
                  equals(t) {
                    return (
                      t.x === this.x &&
                      t.y === this.y &&
                      t.z === this.z &&
                      t.w === this.w
                    );
                  }
                  fromArray(t, e = 0) {
                    return (
                      (this.x = t[e]),
                      (this.y = t[e + 1]),
                      (this.z = t[e + 2]),
                      (this.w = t[e + 3]),
                      this
                    );
                  }
                  toArray(t = [], e = 0) {
                    return (
                      (t[e] = this.x),
                      (t[e + 1] = this.y),
                      (t[e + 2] = this.z),
                      (t[e + 3] = this.w),
                      t
                    );
                  }
                  fromBufferAttribute(t, e, n) {
                    return (
                      void 0 !== n &&
                        console.warn(
                          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                        ),
                      (this.x = t.getX(e)),
                      (this.y = t.getY(e)),
                      (this.z = t.getZ(e)),
                      (this.w = t.getW(e)),
                      this
                    );
                  }
                  random() {
                    return (
                      (this.x = Math.random()),
                      (this.y = Math.random()),
                      (this.z = Math.random()),
                      (this.w = Math.random()),
                      this
                    );
                  }
                  *[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w;
                  }
                }
                class Bn extends je {
                  constructor(t, e, n = {}) {
                    super(),
                      (this.isWebGLRenderTarget = !0),
                      (this.width = t),
                      (this.height = e),
                      (this.depth = 1),
                      (this.scissor = new Un(0, 0, t, e)),
                      (this.scissorTest = !1),
                      (this.viewport = new Un(0, 0, t, e));
                    const r = { width: t, height: e, depth: 1 };
                    (this.texture = new Fn(
                      r,
                      n.mapping,
                      n.wrapS,
                      n.wrapT,
                      n.magFilter,
                      n.minFilter,
                      n.format,
                      n.type,
                      n.anisotropy,
                      n.encoding
                    )),
                      (this.texture.isRenderTargetTexture = !0),
                      (this.texture.flipY = !1),
                      (this.texture.generateMipmaps =
                        void 0 !== n.generateMipmaps && n.generateMipmaps),
                      (this.texture.internalFormat =
                        void 0 !== n.internalFormat ? n.internalFormat : null),
                      (this.texture.minFilter =
                        void 0 !== n.minFilter ? n.minFilter : vt),
                      (this.depthBuffer =
                        void 0 === n.depthBuffer || n.depthBuffer),
                      (this.stencilBuffer =
                        void 0 !== n.stencilBuffer && n.stencilBuffer),
                      (this.depthTexture =
                        void 0 !== n.depthTexture ? n.depthTexture : null),
                      (this.samples = void 0 !== n.samples ? n.samples : 0);
                  }
                  setSize(t, e, n = 1) {
                    (this.width === t &&
                      this.height === e &&
                      this.depth === n) ||
                      ((this.width = t),
                      (this.height = e),
                      (this.depth = n),
                      (this.texture.image.width = t),
                      (this.texture.image.height = e),
                      (this.texture.image.depth = n),
                      this.dispose()),
                      this.viewport.set(0, 0, t, e),
                      this.scissor.set(0, 0, t, e);
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    (this.width = t.width),
                      (this.height = t.height),
                      (this.depth = t.depth),
                      this.viewport.copy(t.viewport),
                      (this.texture = t.texture.clone()),
                      (this.texture.isRenderTargetTexture = !0);
                    const e = Object.assign({}, t.texture.image);
                    return (
                      (this.texture.source = new Nn(e)),
                      (this.depthBuffer = t.depthBuffer),
                      (this.stencilBuffer = t.stencilBuffer),
                      null !== t.depthTexture &&
                        (this.depthTexture = t.depthTexture.clone()),
                      (this.samples = t.samples),
                      this
                    );
                  }
                  dispose() {
                    this.dispatchEvent({ type: "dispose" });
                  }
                }
                class jn extends Fn {
                  constructor(t = null, e = 1, n = 1, r = 1) {
                    super(null),
                      (this.isDataArrayTexture = !0),
                      (this.image = { data: t, width: e, height: n, depth: r }),
                      (this.magFilter = pt),
                      (this.minFilter = pt),
                      (this.wrapR = dt),
                      (this.generateMipmaps = !1),
                      (this.flipY = !1),
                      (this.unpackAlignment = 1);
                  }
                }
                class Hn extends Fn {
                  constructor(t = null, e = 1, n = 1, r = 1) {
                    super(null),
                      (this.isData3DTexture = !0),
                      (this.image = { data: t, width: e, height: n, depth: r }),
                      (this.magFilter = pt),
                      (this.minFilter = pt),
                      (this.wrapR = dt),
                      (this.generateMipmaps = !1),
                      (this.flipY = !1),
                      (this.unpackAlignment = 1);
                  }
                }
                class Vn {
                  constructor(t = 0, e = 0, n = 0, r = 1) {
                    (this.isQuaternion = !0),
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._w = r);
                  }
                  static slerp(t, e, n, r) {
                    return (
                      console.warn(
                        "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
                      ),
                      n.slerpQuaternions(t, e, r)
                    );
                  }
                  static slerpFlat(t, e, n, r, i, a, o) {
                    let s = n[r + 0],
                      c = n[r + 1],
                      l = n[r + 2],
                      u = n[r + 3];
                    const h = i[a + 0],
                      d = i[a + 1],
                      f = i[a + 2],
                      p = i[a + 3];
                    if (0 === o)
                      return (
                        (t[e + 0] = s),
                        (t[e + 1] = c),
                        (t[e + 2] = l),
                        void (t[e + 3] = u)
                      );
                    if (1 === o)
                      return (
                        (t[e + 0] = h),
                        (t[e + 1] = d),
                        (t[e + 2] = f),
                        void (t[e + 3] = p)
                      );
                    if (u !== p || s !== h || c !== d || l !== f) {
                      let t = 1 - o;
                      const e = s * h + c * d + l * f + u * p,
                        n = e >= 0 ? 1 : -1,
                        r = 1 - e * e;
                      if (r > Number.EPSILON) {
                        const i = Math.sqrt(r),
                          a = Math.atan2(i, e * n);
                        (t = Math.sin(t * a) / i), (o = Math.sin(o * a) / i);
                      }
                      const i = o * n;
                      if (
                        ((s = s * t + h * i),
                        (c = c * t + d * i),
                        (l = l * t + f * i),
                        (u = u * t + p * i),
                        t === 1 - o)
                      ) {
                        const t = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                        (s *= t), (c *= t), (l *= t), (u *= t);
                      }
                    }
                    (t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = u);
                  }
                  static multiplyQuaternionsFlat(t, e, n, r, i, a) {
                    const o = n[r],
                      s = n[r + 1],
                      c = n[r + 2],
                      l = n[r + 3],
                      u = i[a],
                      h = i[a + 1],
                      d = i[a + 2],
                      f = i[a + 3];
                    return (
                      (t[e] = o * f + l * u + s * d - c * h),
                      (t[e + 1] = s * f + l * h + c * u - o * d),
                      (t[e + 2] = c * f + l * d + o * h - s * u),
                      (t[e + 3] = l * f - o * u - s * h - c * d),
                      t
                    );
                  }
                  get x() {
                    return this._x;
                  }
                  set x(t) {
                    (this._x = t), this._onChangeCallback();
                  }
                  get y() {
                    return this._y;
                  }
                  set y(t) {
                    (this._y = t), this._onChangeCallback();
                  }
                  get z() {
                    return this._z;
                  }
                  set z(t) {
                    (this._z = t), this._onChangeCallback();
                  }
                  get w() {
                    return this._w;
                  }
                  set w(t) {
                    (this._w = t), this._onChangeCallback();
                  }
                  set(t, e, n, r) {
                    return (
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._w = r),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor(
                      this._x,
                      this._y,
                      this._z,
                      this._w
                    );
                  }
                  copy(t) {
                    return (
                      (this._x = t.x),
                      (this._y = t.y),
                      (this._z = t.z),
                      (this._w = t.w),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  setFromEuler(t, e) {
                    if (!t || !t.isEuler)
                      throw new Error(
                        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
                      );
                    const n = t._x,
                      r = t._y,
                      i = t._z,
                      a = t._order,
                      o = Math.cos,
                      s = Math.sin,
                      c = o(n / 2),
                      l = o(r / 2),
                      u = o(i / 2),
                      h = s(n / 2),
                      d = s(r / 2),
                      f = s(i / 2);
                    switch (a) {
                      case "XYZ":
                        (this._x = h * l * u + c * d * f),
                          (this._y = c * d * u - h * l * f),
                          (this._z = c * l * f + h * d * u),
                          (this._w = c * l * u - h * d * f);
                        break;
                      case "YXZ":
                        (this._x = h * l * u + c * d * f),
                          (this._y = c * d * u - h * l * f),
                          (this._z = c * l * f - h * d * u),
                          (this._w = c * l * u + h * d * f);
                        break;
                      case "ZXY":
                        (this._x = h * l * u - c * d * f),
                          (this._y = c * d * u + h * l * f),
                          (this._z = c * l * f + h * d * u),
                          (this._w = c * l * u - h * d * f);
                        break;
                      case "ZYX":
                        (this._x = h * l * u - c * d * f),
                          (this._y = c * d * u + h * l * f),
                          (this._z = c * l * f - h * d * u),
                          (this._w = c * l * u + h * d * f);
                        break;
                      case "YZX":
                        (this._x = h * l * u + c * d * f),
                          (this._y = c * d * u + h * l * f),
                          (this._z = c * l * f - h * d * u),
                          (this._w = c * l * u - h * d * f);
                        break;
                      case "XZY":
                        (this._x = h * l * u - c * d * f),
                          (this._y = c * d * u - h * l * f),
                          (this._z = c * l * f + h * d * u),
                          (this._w = c * l * u + h * d * f);
                        break;
                      default:
                        console.warn(
                          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                            a
                        );
                    }
                    return !1 !== e && this._onChangeCallback(), this;
                  }
                  setFromAxisAngle(t, e) {
                    const n = e / 2,
                      r = Math.sin(n);
                    return (
                      (this._x = t.x * r),
                      (this._y = t.y * r),
                      (this._z = t.z * r),
                      (this._w = Math.cos(n)),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  setFromRotationMatrix(t) {
                    const e = t.elements,
                      n = e[0],
                      r = e[4],
                      i = e[8],
                      a = e[1],
                      o = e[5],
                      s = e[9],
                      c = e[2],
                      l = e[6],
                      u = e[10],
                      h = n + o + u;
                    if (h > 0) {
                      const t = 0.5 / Math.sqrt(h + 1);
                      (this._w = 0.25 / t),
                        (this._x = (l - s) * t),
                        (this._y = (i - c) * t),
                        (this._z = (a - r) * t);
                    } else if (n > o && n > u) {
                      const t = 2 * Math.sqrt(1 + n - o - u);
                      (this._w = (l - s) / t),
                        (this._x = 0.25 * t),
                        (this._y = (r + a) / t),
                        (this._z = (i + c) / t);
                    } else if (o > u) {
                      const t = 2 * Math.sqrt(1 + o - n - u);
                      (this._w = (i - c) / t),
                        (this._x = (r + a) / t),
                        (this._y = 0.25 * t),
                        (this._z = (s + l) / t);
                    } else {
                      const t = 2 * Math.sqrt(1 + u - n - o);
                      (this._w = (a - r) / t),
                        (this._x = (i + c) / t),
                        (this._y = (s + l) / t),
                        (this._z = 0.25 * t);
                    }
                    return this._onChangeCallback(), this;
                  }
                  setFromUnitVectors(t, e) {
                    let n = t.dot(e) + 1;
                    return (
                      n < Number.EPSILON
                        ? ((n = 0),
                          Math.abs(t.x) > Math.abs(t.z)
                            ? ((this._x = -t.y),
                              (this._y = t.x),
                              (this._z = 0),
                              (this._w = n))
                            : ((this._x = 0),
                              (this._y = -t.z),
                              (this._z = t.y),
                              (this._w = n)))
                        : ((this._x = t.y * e.z - t.z * e.y),
                          (this._y = t.z * e.x - t.x * e.z),
                          (this._z = t.x * e.y - t.y * e.x),
                          (this._w = n)),
                      this.normalize()
                    );
                  }
                  angleTo(t) {
                    return 2 * Math.acos(Math.abs(Xe(this.dot(t), -1, 1)));
                  }
                  rotateTowards(t, e) {
                    const n = this.angleTo(t);
                    if (0 === n) return this;
                    const r = Math.min(1, e / n);
                    return this.slerp(t, r), this;
                  }
                  identity() {
                    return this.set(0, 0, 0, 1);
                  }
                  invert() {
                    return this.conjugate();
                  }
                  conjugate() {
                    return (
                      (this._x *= -1),
                      (this._y *= -1),
                      (this._z *= -1),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  dot(t) {
                    return (
                      this._x * t._x +
                      this._y * t._y +
                      this._z * t._z +
                      this._w * t._w
                    );
                  }
                  lengthSq() {
                    return (
                      this._x * this._x +
                      this._y * this._y +
                      this._z * this._z +
                      this._w * this._w
                    );
                  }
                  length() {
                    return Math.sqrt(
                      this._x * this._x +
                        this._y * this._y +
                        this._z * this._z +
                        this._w * this._w
                    );
                  }
                  normalize() {
                    let t = this.length();
                    return (
                      0 === t
                        ? ((this._x = 0),
                          (this._y = 0),
                          (this._z = 0),
                          (this._w = 1))
                        : ((t = 1 / t),
                          (this._x = this._x * t),
                          (this._y = this._y * t),
                          (this._z = this._z * t),
                          (this._w = this._w * t)),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  multiply(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                        ),
                        this.multiplyQuaternions(t, e))
                      : this.multiplyQuaternions(this, t);
                  }
                  premultiply(t) {
                    return this.multiplyQuaternions(t, this);
                  }
                  multiplyQuaternions(t, e) {
                    const n = t._x,
                      r = t._y,
                      i = t._z,
                      a = t._w,
                      o = e._x,
                      s = e._y,
                      c = e._z,
                      l = e._w;
                    return (
                      (this._x = n * l + a * o + r * c - i * s),
                      (this._y = r * l + a * s + i * o - n * c),
                      (this._z = i * l + a * c + n * s - r * o),
                      (this._w = a * l - n * o - r * s - i * c),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const n = this._x,
                      r = this._y,
                      i = this._z,
                      a = this._w;
                    let o = a * t._w + n * t._x + r * t._y + i * t._z;
                    if (
                      (o < 0
                        ? ((this._w = -t._w),
                          (this._x = -t._x),
                          (this._y = -t._y),
                          (this._z = -t._z),
                          (o = -o))
                        : this.copy(t),
                      o >= 1)
                    )
                      return (
                        (this._w = a),
                        (this._x = n),
                        (this._y = r),
                        (this._z = i),
                        this
                      );
                    const s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                      const t = 1 - e;
                      return (
                        (this._w = t * a + e * this._w),
                        (this._x = t * n + e * this._x),
                        (this._y = t * r + e * this._y),
                        (this._z = t * i + e * this._z),
                        this.normalize(),
                        this._onChangeCallback(),
                        this
                      );
                    }
                    const c = Math.sqrt(s),
                      l = Math.atan2(c, o),
                      u = Math.sin((1 - e) * l) / c,
                      h = Math.sin(e * l) / c;
                    return (
                      (this._w = a * u + this._w * h),
                      (this._x = n * u + this._x * h),
                      (this._y = r * u + this._y * h),
                      (this._z = i * u + this._z * h),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  slerpQuaternions(t, e, n) {
                    return this.copy(t).slerp(e, n);
                  }
                  random() {
                    const t = Math.random(),
                      e = Math.sqrt(1 - t),
                      n = Math.sqrt(t),
                      r = 2 * Math.PI * Math.random(),
                      i = 2 * Math.PI * Math.random();
                    return this.set(
                      e * Math.cos(r),
                      n * Math.sin(i),
                      n * Math.cos(i),
                      e * Math.sin(r)
                    );
                  }
                  equals(t) {
                    return (
                      t._x === this._x &&
                      t._y === this._y &&
                      t._z === this._z &&
                      t._w === this._w
                    );
                  }
                  fromArray(t, e = 0) {
                    return (
                      (this._x = t[e]),
                      (this._y = t[e + 1]),
                      (this._z = t[e + 2]),
                      (this._w = t[e + 3]),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  toArray(t = [], e = 0) {
                    return (
                      (t[e] = this._x),
                      (t[e + 1] = this._y),
                      (t[e + 2] = this._z),
                      (t[e + 3] = this._w),
                      t
                    );
                  }
                  fromBufferAttribute(t, e) {
                    return (
                      (this._x = t.getX(e)),
                      (this._y = t.getY(e)),
                      (this._z = t.getZ(e)),
                      (this._w = t.getW(e)),
                      this
                    );
                  }
                  _onChange(t) {
                    return (this._onChangeCallback = t), this;
                  }
                  _onChangeCallback() {}
                  *[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w;
                  }
                }
                class Gn {
                  constructor(t = 0, e = 0, n = 0) {
                    (Gn.prototype.isVector3 = !0),
                      (this.x = t),
                      (this.y = e),
                      (this.z = n);
                  }
                  set(t, e, n) {
                    return (
                      void 0 === n && (n = this.z),
                      (this.x = t),
                      (this.y = e),
                      (this.z = n),
                      this
                    );
                  }
                  setScalar(t) {
                    return (this.x = t), (this.y = t), (this.z = t), this;
                  }
                  setX(t) {
                    return (this.x = t), this;
                  }
                  setY(t) {
                    return (this.y = t), this;
                  }
                  setZ(t) {
                    return (this.z = t), this;
                  }
                  setComponent(t, e) {
                    switch (t) {
                      case 0:
                        this.x = e;
                        break;
                      case 1:
                        this.y = e;
                        break;
                      case 2:
                        this.z = e;
                        break;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                    return this;
                  }
                  getComponent(t) {
                    switch (t) {
                      case 0:
                        return this.x;
                      case 1:
                        return this.y;
                      case 2:
                        return this.z;
                      default:
                        throw new Error("index is out of range: " + t);
                    }
                  }
                  clone() {
                    return new this.constructor(this.x, this.y, this.z);
                  }
                  copy(t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
                  }
                  add(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                        ),
                        this.addVectors(t, e))
                      : ((this.x += t.x),
                        (this.y += t.y),
                        (this.z += t.z),
                        this);
                  }
                  addScalar(t) {
                    return (this.x += t), (this.y += t), (this.z += t), this;
                  }
                  addVectors(t, e) {
                    return (
                      (this.x = t.x + e.x),
                      (this.y = t.y + e.y),
                      (this.z = t.z + e.z),
                      this
                    );
                  }
                  addScaledVector(t, e) {
                    return (
                      (this.x += t.x * e),
                      (this.y += t.y * e),
                      (this.z += t.z * e),
                      this
                    );
                  }
                  sub(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                        ),
                        this.subVectors(t, e))
                      : ((this.x -= t.x),
                        (this.y -= t.y),
                        (this.z -= t.z),
                        this);
                  }
                  subScalar(t) {
                    return (this.x -= t), (this.y -= t), (this.z -= t), this;
                  }
                  subVectors(t, e) {
                    return (
                      (this.x = t.x - e.x),
                      (this.y = t.y - e.y),
                      (this.z = t.z - e.z),
                      this
                    );
                  }
                  multiply(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                        ),
                        this.multiplyVectors(t, e))
                      : ((this.x *= t.x),
                        (this.y *= t.y),
                        (this.z *= t.z),
                        this);
                  }
                  multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), (this.z *= t), this;
                  }
                  multiplyVectors(t, e) {
                    return (
                      (this.x = t.x * e.x),
                      (this.y = t.y * e.y),
                      (this.z = t.z * e.z),
                      this
                    );
                  }
                  applyEuler(t) {
                    return (
                      (t && t.isEuler) ||
                        console.error(
                          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                        ),
                      this.applyQuaternion(qn.setFromEuler(t))
                    );
                  }
                  applyAxisAngle(t, e) {
                    return this.applyQuaternion(qn.setFromAxisAngle(t, e));
                  }
                  applyMatrix3(t) {
                    const e = this.x,
                      n = this.y,
                      r = this.z,
                      i = t.elements;
                    return (
                      (this.x = i[0] * e + i[3] * n + i[6] * r),
                      (this.y = i[1] * e + i[4] * n + i[7] * r),
                      (this.z = i[2] * e + i[5] * n + i[8] * r),
                      this
                    );
                  }
                  applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize();
                  }
                  applyMatrix4(t) {
                    const e = this.x,
                      n = this.y,
                      r = this.z,
                      i = t.elements,
                      a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                    return (
                      (this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a),
                      (this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a),
                      (this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a),
                      this
                    );
                  }
                  applyQuaternion(t) {
                    const e = this.x,
                      n = this.y,
                      r = this.z,
                      i = t.x,
                      a = t.y,
                      o = t.z,
                      s = t.w,
                      c = s * e + a * r - o * n,
                      l = s * n + o * e - i * r,
                      u = s * r + i * n - a * e,
                      h = -i * e - a * n - o * r;
                    return (
                      (this.x = c * s + h * -i + l * -o - u * -a),
                      (this.y = l * s + h * -a + u * -i - c * -o),
                      (this.z = u * s + h * -o + c * -a - l * -i),
                      this
                    );
                  }
                  project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
                      t.projectionMatrix
                    );
                  }
                  unproject(t) {
                    return this.applyMatrix4(
                      t.projectionMatrixInverse
                    ).applyMatrix4(t.matrixWorld);
                  }
                  transformDirection(t) {
                    const e = this.x,
                      n = this.y,
                      r = this.z,
                      i = t.elements;
                    return (
                      (this.x = i[0] * e + i[4] * n + i[8] * r),
                      (this.y = i[1] * e + i[5] * n + i[9] * r),
                      (this.z = i[2] * e + i[6] * n + i[10] * r),
                      this.normalize()
                    );
                  }
                  divide(t) {
                    return (
                      (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
                    );
                  }
                  divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                  }
                  min(t) {
                    return (
                      (this.x = Math.min(this.x, t.x)),
                      (this.y = Math.min(this.y, t.y)),
                      (this.z = Math.min(this.z, t.z)),
                      this
                    );
                  }
                  max(t) {
                    return (
                      (this.x = Math.max(this.x, t.x)),
                      (this.y = Math.max(this.y, t.y)),
                      (this.z = Math.max(this.z, t.z)),
                      this
                    );
                  }
                  clamp(t, e) {
                    return (
                      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                      this
                    );
                  }
                  clampScalar(t, e) {
                    return (
                      (this.x = Math.max(t, Math.min(e, this.x))),
                      (this.y = Math.max(t, Math.min(e, this.y))),
                      (this.z = Math.max(t, Math.min(e, this.z))),
                      this
                    );
                  }
                  clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(
                      Math.max(t, Math.min(e, n))
                    );
                  }
                  floor() {
                    return (
                      (this.x = Math.floor(this.x)),
                      (this.y = Math.floor(this.y)),
                      (this.z = Math.floor(this.z)),
                      this
                    );
                  }
                  ceil() {
                    return (
                      (this.x = Math.ceil(this.x)),
                      (this.y = Math.ceil(this.y)),
                      (this.z = Math.ceil(this.z)),
                      this
                    );
                  }
                  round() {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      (this.z = Math.round(this.z)),
                      this
                    );
                  }
                  roundToZero() {
                    return (
                      (this.x =
                        this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                      (this.y =
                        this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                      (this.z =
                        this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                      this
                    );
                  }
                  negate() {
                    return (
                      (this.x = -this.x),
                      (this.y = -this.y),
                      (this.z = -this.z),
                      this
                    );
                  }
                  dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z;
                  }
                  lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z;
                  }
                  length() {
                    return Math.sqrt(
                      this.x * this.x + this.y * this.y + this.z * this.z
                    );
                  }
                  manhattanLength() {
                    return (
                      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    );
                  }
                  normalize() {
                    return this.divideScalar(this.length() || 1);
                  }
                  setLength(t) {
                    return this.normalize().multiplyScalar(t);
                  }
                  lerp(t, e) {
                    return (
                      (this.x += (t.x - this.x) * e),
                      (this.y += (t.y - this.y) * e),
                      (this.z += (t.z - this.z) * e),
                      this
                    );
                  }
                  lerpVectors(t, e, n) {
                    return (
                      (this.x = t.x + (e.x - t.x) * n),
                      (this.y = t.y + (e.y - t.y) * n),
                      (this.z = t.z + (e.z - t.z) * n),
                      this
                    );
                  }
                  cross(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                        ),
                        this.crossVectors(t, e))
                      : this.crossVectors(this, t);
                  }
                  crossVectors(t, e) {
                    const n = t.x,
                      r = t.y,
                      i = t.z,
                      a = e.x,
                      o = e.y,
                      s = e.z;
                    return (
                      (this.x = r * s - i * o),
                      (this.y = i * a - n * s),
                      (this.z = n * o - r * a),
                      this
                    );
                  }
                  projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const n = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(n);
                  }
                  projectOnPlane(t) {
                    return Wn.copy(this).projectOnVector(t), this.sub(Wn);
                  }
                  reflect(t) {
                    return this.sub(Wn.copy(t).multiplyScalar(2 * this.dot(t)));
                  }
                  angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const n = this.dot(t) / e;
                    return Math.acos(Xe(n, -1, 1));
                  }
                  distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                  }
                  distanceToSquared(t) {
                    const e = this.x - t.x,
                      n = this.y - t.y,
                      r = this.z - t.z;
                    return e * e + n * n + r * r;
                  }
                  manhattanDistanceTo(t) {
                    return (
                      Math.abs(this.x - t.x) +
                      Math.abs(this.y - t.y) +
                      Math.abs(this.z - t.z)
                    );
                  }
                  setFromSpherical(t) {
                    return this.setFromSphericalCoords(
                      t.radius,
                      t.phi,
                      t.theta
                    );
                  }
                  setFromSphericalCoords(t, e, n) {
                    const r = Math.sin(e) * t;
                    return (
                      (this.x = r * Math.sin(n)),
                      (this.y = Math.cos(e) * t),
                      (this.z = r * Math.cos(n)),
                      this
                    );
                  }
                  setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(
                      t.radius,
                      t.theta,
                      t.y
                    );
                  }
                  setFromCylindricalCoords(t, e, n) {
                    return (
                      (this.x = t * Math.sin(e)),
                      (this.y = n),
                      (this.z = t * Math.cos(e)),
                      this
                    );
                  }
                  setFromMatrixPosition(t) {
                    const e = t.elements;
                    return (
                      (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
                    );
                  }
                  setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                      n = this.setFromMatrixColumn(t, 1).length(),
                      r = this.setFromMatrixColumn(t, 2).length();
                    return (this.x = e), (this.y = n), (this.z = r), this;
                  }
                  setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e);
                  }
                  setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e);
                  }
                  setFromEuler(t) {
                    return (
                      (this.x = t._x), (this.y = t._y), (this.z = t._z), this
                    );
                  }
                  equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z;
                  }
                  fromArray(t, e = 0) {
                    return (
                      (this.x = t[e]),
                      (this.y = t[e + 1]),
                      (this.z = t[e + 2]),
                      this
                    );
                  }
                  toArray(t = [], e = 0) {
                    return (
                      (t[e] = this.x),
                      (t[e + 1] = this.y),
                      (t[e + 2] = this.z),
                      t
                    );
                  }
                  fromBufferAttribute(t, e, n) {
                    return (
                      void 0 !== n &&
                        console.warn(
                          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                        ),
                      (this.x = t.getX(e)),
                      (this.y = t.getY(e)),
                      (this.z = t.getZ(e)),
                      this
                    );
                  }
                  random() {
                    return (
                      (this.x = Math.random()),
                      (this.y = Math.random()),
                      (this.z = Math.random()),
                      this
                    );
                  }
                  randomDirection() {
                    const t = 2 * (Math.random() - 0.5),
                      e = Math.random() * Math.PI * 2,
                      n = Math.sqrt(1 - t ** 2);
                    return (
                      (this.x = n * Math.cos(e)),
                      (this.y = n * Math.sin(e)),
                      (this.z = t),
                      this
                    );
                  }
                  *[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z;
                  }
                }
                const Wn = new Gn(),
                  qn = new Vn();
                class Xn {
                  constructor(
                    t = new Gn(1 / 0, 1 / 0, 1 / 0),
                    e = new Gn(-1 / 0, -1 / 0, -1 / 0)
                  ) {
                    (this.isBox3 = !0), (this.min = t), (this.max = e);
                  }
                  set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this;
                  }
                  setFromArray(t) {
                    let e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0;
                    for (let s = 0, c = t.length; s < c; s += 3) {
                      const c = t[s],
                        l = t[s + 1],
                        u = t[s + 2];
                      c < e && (e = c),
                        l < n && (n = l),
                        u < r && (r = u),
                        c > i && (i = c),
                        l > a && (a = l),
                        u > o && (o = u);
                    }
                    return this.min.set(e, n, r), this.max.set(i, a, o), this;
                  }
                  setFromBufferAttribute(t) {
                    let e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0;
                    for (let s = 0, c = t.count; s < c; s++) {
                      const c = t.getX(s),
                        l = t.getY(s),
                        u = t.getZ(s);
                      c < e && (e = c),
                        l < n && (n = l),
                        u < r && (r = u),
                        c > i && (i = c),
                        l > a && (a = l),
                        u > o && (o = u);
                    }
                    return this.min.set(e, n, r), this.max.set(i, a, o), this;
                  }
                  setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++)
                      this.expandByPoint(t[e]);
                    return this;
                  }
                  setFromCenterAndSize(t, e) {
                    const n = Yn.copy(e).multiplyScalar(0.5);
                    return (
                      this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    );
                  }
                  setFromObject(t, e = !1) {
                    return this.makeEmpty(), this.expandByObject(t, e);
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this;
                  }
                  makeEmpty() {
                    return (
                      (this.min.x = this.min.y = this.min.z = 1 / 0),
                      (this.max.x = this.max.y = this.max.z = -1 / 0),
                      this
                    );
                  }
                  isEmpty() {
                    return (
                      this.max.x < this.min.x ||
                      this.max.y < this.min.y ||
                      this.max.z < this.min.z
                    );
                  }
                  getCenter(t) {
                    return this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.addVectors(this.min, this.max).multiplyScalar(0.5);
                  }
                  getSize(t) {
                    return this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.subVectors(this.max, this.min);
                  }
                  expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this;
                  }
                  expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this;
                  }
                  expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this;
                  }
                  expandByObject(t, e = !1) {
                    t.updateWorldMatrix(!1, !1);
                    const n = t.geometry;
                    if (void 0 !== n)
                      if (
                        e &&
                        void 0 != n.attributes &&
                        void 0 !== n.attributes.position
                      ) {
                        const e = n.attributes.position;
                        for (let n = 0, r = e.count; n < r; n++)
                          Yn.fromBufferAttribute(e, n).applyMatrix4(
                            t.matrixWorld
                          ),
                            this.expandByPoint(Yn);
                      } else
                        null === n.boundingBox && n.computeBoundingBox(),
                          Jn.copy(n.boundingBox),
                          Jn.applyMatrix4(t.matrixWorld),
                          this.union(Jn);
                    const r = t.children;
                    for (let i = 0, a = r.length; i < a; i++)
                      this.expandByObject(r[i], e);
                    return this;
                  }
                  containsPoint(t) {
                    return !(
                      t.x < this.min.x ||
                      t.x > this.max.x ||
                      t.y < this.min.y ||
                      t.y > this.max.y ||
                      t.z < this.min.z ||
                      t.z > this.max.z
                    );
                  }
                  containsBox(t) {
                    return (
                      this.min.x <= t.min.x &&
                      t.max.x <= this.max.x &&
                      this.min.y <= t.min.y &&
                      t.max.y <= this.max.y &&
                      this.min.z <= t.min.z &&
                      t.max.z <= this.max.z
                    );
                  }
                  getParameter(t, e) {
                    return e.set(
                      (t.x - this.min.x) / (this.max.x - this.min.x),
                      (t.y - this.min.y) / (this.max.y - this.min.y),
                      (t.z - this.min.z) / (this.max.z - this.min.z)
                    );
                  }
                  intersectsBox(t) {
                    return !(
                      t.max.x < this.min.x ||
                      t.min.x > this.max.x ||
                      t.max.y < this.min.y ||
                      t.min.y > this.max.y ||
                      t.max.z < this.min.z ||
                      t.min.z > this.max.z
                    );
                  }
                  intersectsSphere(t) {
                    return (
                      this.clampPoint(t.center, Yn),
                      Yn.distanceToSquared(t.center) <= t.radius * t.radius
                    );
                  }
                  intersectsPlane(t) {
                    let e, n;
                    return (
                      t.normal.x > 0
                        ? ((e = t.normal.x * this.min.x),
                          (n = t.normal.x * this.max.x))
                        : ((e = t.normal.x * this.max.x),
                          (n = t.normal.x * this.min.x)),
                      t.normal.y > 0
                        ? ((e += t.normal.y * this.min.y),
                          (n += t.normal.y * this.max.y))
                        : ((e += t.normal.y * this.max.y),
                          (n += t.normal.y * this.min.y)),
                      t.normal.z > 0
                        ? ((e += t.normal.z * this.min.z),
                          (n += t.normal.z * this.max.z))
                        : ((e += t.normal.z * this.max.z),
                          (n += t.normal.z * this.min.z)),
                      e <= -t.constant && n >= -t.constant
                    );
                  }
                  intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(rr),
                      ir.subVectors(this.max, rr),
                      Kn.subVectors(t.a, rr),
                      Zn.subVectors(t.b, rr),
                      Qn.subVectors(t.c, rr),
                      tr.subVectors(Zn, Kn),
                      er.subVectors(Qn, Zn),
                      nr.subVectors(Kn, Qn);
                    let e = [
                      0,
                      -tr.z,
                      tr.y,
                      0,
                      -er.z,
                      er.y,
                      0,
                      -nr.z,
                      nr.y,
                      tr.z,
                      0,
                      -tr.x,
                      er.z,
                      0,
                      -er.x,
                      nr.z,
                      0,
                      -nr.x,
                      -tr.y,
                      tr.x,
                      0,
                      -er.y,
                      er.x,
                      0,
                      -nr.y,
                      nr.x,
                      0,
                    ];
                    return (
                      !!sr(e, Kn, Zn, Qn, ir) &&
                      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                      !!sr(e, Kn, Zn, Qn, ir) &&
                        (ar.crossVectors(tr, er),
                        (e = [ar.x, ar.y, ar.z]),
                        sr(e, Kn, Zn, Qn, ir)))
                    );
                  }
                  clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max);
                  }
                  distanceToPoint(t) {
                    const e = Yn.copy(t).clamp(this.min, this.max);
                    return e.sub(t).length();
                  }
                  getBoundingSphere(t) {
                    return (
                      this.getCenter(t.center),
                      (t.radius = 0.5 * this.getSize(Yn).length()),
                      t
                    );
                  }
                  intersect(t) {
                    return (
                      this.min.max(t.min),
                      this.max.min(t.max),
                      this.isEmpty() && this.makeEmpty(),
                      this
                    );
                  }
                  union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this;
                  }
                  applyMatrix4(t) {
                    return (
                      this.isEmpty() ||
                        ($n[0]
                          .set(this.min.x, this.min.y, this.min.z)
                          .applyMatrix4(t),
                        $n[1]
                          .set(this.min.x, this.min.y, this.max.z)
                          .applyMatrix4(t),
                        $n[2]
                          .set(this.min.x, this.max.y, this.min.z)
                          .applyMatrix4(t),
                        $n[3]
                          .set(this.min.x, this.max.y, this.max.z)
                          .applyMatrix4(t),
                        $n[4]
                          .set(this.max.x, this.min.y, this.min.z)
                          .applyMatrix4(t),
                        $n[5]
                          .set(this.max.x, this.min.y, this.max.z)
                          .applyMatrix4(t),
                        $n[6]
                          .set(this.max.x, this.max.y, this.min.z)
                          .applyMatrix4(t),
                        $n[7]
                          .set(this.max.x, this.max.y, this.max.z)
                          .applyMatrix4(t),
                        this.setFromPoints($n)),
                      this
                    );
                  }
                  translate(t) {
                    return this.min.add(t), this.max.add(t), this;
                  }
                  equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max);
                  }
                }
                const $n = [
                    new Gn(),
                    new Gn(),
                    new Gn(),
                    new Gn(),
                    new Gn(),
                    new Gn(),
                    new Gn(),
                    new Gn(),
                  ],
                  Yn = new Gn(),
                  Jn = new Xn(),
                  Kn = new Gn(),
                  Zn = new Gn(),
                  Qn = new Gn(),
                  tr = new Gn(),
                  er = new Gn(),
                  nr = new Gn(),
                  rr = new Gn(),
                  ir = new Gn(),
                  ar = new Gn(),
                  or = new Gn();
                function sr(t, e, n, r, i) {
                  for (let a = 0, o = t.length - 3; a <= o; a += 3) {
                    or.fromArray(t, a);
                    const o =
                        i.x * Math.abs(or.x) +
                        i.y * Math.abs(or.y) +
                        i.z * Math.abs(or.z),
                      s = e.dot(or),
                      c = n.dot(or),
                      l = r.dot(or);
                    if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > o)
                      return !1;
                  }
                  return !0;
                }
                const cr = new Xn(),
                  lr = new Gn(),
                  ur = new Gn(),
                  hr = new Gn();
                class dr {
                  constructor(t = new Gn(), e = -1) {
                    (this.center = t), (this.radius = e);
                  }
                  set(t, e) {
                    return this.center.copy(t), (this.radius = e), this;
                  }
                  setFromPoints(t, e) {
                    const n = this.center;
                    void 0 !== e ? n.copy(e) : cr.setFromPoints(t).getCenter(n);
                    let r = 0;
                    for (let i = 0, a = t.length; i < a; i++)
                      r = Math.max(r, n.distanceToSquared(t[i]));
                    return (this.radius = Math.sqrt(r)), this;
                  }
                  copy(t) {
                    return (
                      this.center.copy(t.center), (this.radius = t.radius), this
                    );
                  }
                  isEmpty() {
                    return this.radius < 0;
                  }
                  makeEmpty() {
                    return this.center.set(0, 0, 0), (this.radius = -1), this;
                  }
                  containsPoint(t) {
                    return (
                      t.distanceToSquared(this.center) <=
                      this.radius * this.radius
                    );
                  }
                  distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius;
                  }
                  intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e;
                  }
                  intersectsBox(t) {
                    return t.intersectsSphere(this);
                  }
                  intersectsPlane(t) {
                    return (
                      Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    );
                  }
                  clampPoint(t, e) {
                    const n = this.center.distanceToSquared(t);
                    return (
                      e.copy(t),
                      n > this.radius * this.radius &&
                        (e.sub(this.center).normalize(),
                        e.multiplyScalar(this.radius).add(this.center)),
                      e
                    );
                  }
                  getBoundingBox(t) {
                    return this.isEmpty()
                      ? (t.makeEmpty(), t)
                      : (t.set(this.center, this.center),
                        t.expandByScalar(this.radius),
                        t);
                  }
                  applyMatrix4(t) {
                    return (
                      this.center.applyMatrix4(t),
                      (this.radius = this.radius * t.getMaxScaleOnAxis()),
                      this
                    );
                  }
                  translate(t) {
                    return this.center.add(t), this;
                  }
                  expandByPoint(t) {
                    hr.subVectors(t, this.center);
                    const e = hr.lengthSq();
                    if (e > this.radius * this.radius) {
                      const t = Math.sqrt(e),
                        n = 0.5 * (t - this.radius);
                      this.center.add(hr.multiplyScalar(n / t)),
                        (this.radius += n);
                    }
                    return this;
                  }
                  union(t) {
                    return (
                      !0 === this.center.equals(t.center)
                        ? ur.set(0, 0, 1).multiplyScalar(t.radius)
                        : ur
                            .subVectors(t.center, this.center)
                            .normalize()
                            .multiplyScalar(t.radius),
                      this.expandByPoint(lr.copy(t.center).add(ur)),
                      this.expandByPoint(lr.copy(t.center).sub(ur)),
                      this
                    );
                  }
                  equals(t) {
                    return (
                      t.center.equals(this.center) && t.radius === this.radius
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                const fr = new Gn(),
                  pr = new Gn(),
                  mr = new Gn(),
                  gr = new Gn(),
                  vr = new Gn(),
                  yr = new Gn(),
                  br = new Gn();
                class xr {
                  constructor(t = new Gn(), e = new Gn(0, 0, -1)) {
                    (this.origin = t), (this.direction = e);
                  }
                  set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this;
                  }
                  copy(t) {
                    return (
                      this.origin.copy(t.origin),
                      this.direction.copy(t.direction),
                      this
                    );
                  }
                  at(t, e) {
                    return e
                      .copy(this.direction)
                      .multiplyScalar(t)
                      .add(this.origin);
                  }
                  lookAt(t) {
                    return (
                      this.direction.copy(t).sub(this.origin).normalize(), this
                    );
                  }
                  recast(t) {
                    return this.origin.copy(this.at(t, fr)), this;
                  }
                  closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const n = e.dot(this.direction);
                    return n < 0
                      ? e.copy(this.origin)
                      : e
                          .copy(this.direction)
                          .multiplyScalar(n)
                          .add(this.origin);
                  }
                  distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t));
                  }
                  distanceSqToPoint(t) {
                    const e = fr.subVectors(t, this.origin).dot(this.direction);
                    return e < 0
                      ? this.origin.distanceToSquared(t)
                      : (fr
                          .copy(this.direction)
                          .multiplyScalar(e)
                          .add(this.origin),
                        fr.distanceToSquared(t));
                  }
                  distanceSqToSegment(t, e, n, r) {
                    pr.copy(t).add(e).multiplyScalar(0.5),
                      mr.copy(e).sub(t).normalize(),
                      gr.copy(this.origin).sub(pr);
                    const i = 0.5 * t.distanceTo(e),
                      a = -this.direction.dot(mr),
                      o = gr.dot(this.direction),
                      s = -gr.dot(mr),
                      c = gr.lengthSq(),
                      l = Math.abs(1 - a * a);
                    let u, h, d, f;
                    if (l > 0)
                      if (
                        ((u = a * s - o), (h = a * o - s), (f = i * l), u >= 0)
                      )
                        if (h >= -f)
                          if (h <= f) {
                            const t = 1 / l;
                            (u *= t),
                              (h *= t),
                              (d =
                                u * (u + a * h + 2 * o) +
                                h * (a * u + h + 2 * s) +
                                c);
                          } else
                            (h = i),
                              (u = Math.max(0, -(a * h + o))),
                              (d = -u * u + h * (h + 2 * s) + c);
                        else
                          (h = -i),
                            (u = Math.max(0, -(a * h + o))),
                            (d = -u * u + h * (h + 2 * s) + c);
                      else
                        h <= -f
                          ? ((u = Math.max(0, -(-a * i + o))),
                            (h = u > 0 ? -i : Math.min(Math.max(-i, -s), i)),
                            (d = -u * u + h * (h + 2 * s) + c))
                          : h <= f
                          ? ((u = 0),
                            (h = Math.min(Math.max(-i, -s), i)),
                            (d = h * (h + 2 * s) + c))
                          : ((u = Math.max(0, -(a * i + o))),
                            (h = u > 0 ? i : Math.min(Math.max(-i, -s), i)),
                            (d = -u * u + h * (h + 2 * s) + c));
                    else
                      (h = a > 0 ? -i : i),
                        (u = Math.max(0, -(a * h + o))),
                        (d = -u * u + h * (h + 2 * s) + c);
                    return (
                      n &&
                        n
                          .copy(this.direction)
                          .multiplyScalar(u)
                          .add(this.origin),
                      r && r.copy(mr).multiplyScalar(h).add(pr),
                      d
                    );
                  }
                  intersectSphere(t, e) {
                    fr.subVectors(t.center, this.origin);
                    const n = fr.dot(this.direction),
                      r = fr.dot(fr) - n * n,
                      i = t.radius * t.radius;
                    if (r > i) return null;
                    const a = Math.sqrt(i - r),
                      o = n - a,
                      s = n + a;
                    return o < 0 && s < 0
                      ? null
                      : o < 0
                      ? this.at(s, e)
                      : this.at(o, e);
                  }
                  intersectsSphere(t) {
                    return (
                      this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    );
                  }
                  distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e)
                      return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null;
                  }
                  intersectPlane(t, e) {
                    const n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e);
                  }
                  intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    const n = t.normal.dot(this.direction);
                    return n * e < 0;
                  }
                  intersectBox(t, e) {
                    let n, r, i, a, o, s;
                    const c = 1 / this.direction.x,
                      l = 1 / this.direction.y,
                      u = 1 / this.direction.z,
                      h = this.origin;
                    return (
                      c >= 0
                        ? ((n = (t.min.x - h.x) * c), (r = (t.max.x - h.x) * c))
                        : ((n = (t.max.x - h.x) * c),
                          (r = (t.min.x - h.x) * c)),
                      l >= 0
                        ? ((i = (t.min.y - h.y) * l), (a = (t.max.y - h.y) * l))
                        : ((i = (t.max.y - h.y) * l),
                          (a = (t.min.y - h.y) * l)),
                      n > a || i > r
                        ? null
                        : ((i > n || n !== n) && (n = i),
                          (a < r || r !== r) && (r = a),
                          u >= 0
                            ? ((o = (t.min.z - h.z) * u),
                              (s = (t.max.z - h.z) * u))
                            : ((o = (t.max.z - h.z) * u),
                              (s = (t.min.z - h.z) * u)),
                          n > s || o > r
                            ? null
                            : ((o > n || n !== n) && (n = o),
                              (s < r || r !== r) && (r = s),
                              r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                    );
                  }
                  intersectsBox(t) {
                    return null !== this.intersectBox(t, fr);
                  }
                  intersectTriangle(t, e, n, r, i) {
                    vr.subVectors(e, t),
                      yr.subVectors(n, t),
                      br.crossVectors(vr, yr);
                    let a,
                      o = this.direction.dot(br);
                    if (o > 0) {
                      if (r) return null;
                      a = 1;
                    } else {
                      if (!(o < 0)) return null;
                      (a = -1), (o = -o);
                    }
                    gr.subVectors(this.origin, t);
                    const s = a * this.direction.dot(yr.crossVectors(gr, yr));
                    if (s < 0) return null;
                    const c = a * this.direction.dot(vr.cross(gr));
                    if (c < 0) return null;
                    if (s + c > o) return null;
                    const l = -a * gr.dot(br);
                    return l < 0 ? null : this.at(l / o, i);
                  }
                  applyMatrix4(t) {
                    return (
                      this.origin.applyMatrix4(t),
                      this.direction.transformDirection(t),
                      this
                    );
                  }
                  equals(t) {
                    return (
                      t.origin.equals(this.origin) &&
                      t.direction.equals(this.direction)
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                class _r {
                  constructor() {
                    (_r.prototype.isMatrix4 = !0),
                      (this.elements = [
                        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                      ]),
                      arguments.length > 0 &&
                        console.error(
                          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                        );
                  }
                  set(t, e, n, r, i, a, o, s, c, l, u, h, d, f, p, m) {
                    const g = this.elements;
                    return (
                      (g[0] = t),
                      (g[4] = e),
                      (g[8] = n),
                      (g[12] = r),
                      (g[1] = i),
                      (g[5] = a),
                      (g[9] = o),
                      (g[13] = s),
                      (g[2] = c),
                      (g[6] = l),
                      (g[10] = u),
                      (g[14] = h),
                      (g[3] = d),
                      (g[7] = f),
                      (g[11] = p),
                      (g[15] = m),
                      this
                    );
                  }
                  identity() {
                    return (
                      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  clone() {
                    return new _r().fromArray(this.elements);
                  }
                  copy(t) {
                    const e = this.elements,
                      n = t.elements;
                    return (
                      (e[0] = n[0]),
                      (e[1] = n[1]),
                      (e[2] = n[2]),
                      (e[3] = n[3]),
                      (e[4] = n[4]),
                      (e[5] = n[5]),
                      (e[6] = n[6]),
                      (e[7] = n[7]),
                      (e[8] = n[8]),
                      (e[9] = n[9]),
                      (e[10] = n[10]),
                      (e[11] = n[11]),
                      (e[12] = n[12]),
                      (e[13] = n[13]),
                      (e[14] = n[14]),
                      (e[15] = n[15]),
                      this
                    );
                  }
                  copyPosition(t) {
                    const e = this.elements,
                      n = t.elements;
                    return (
                      (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
                    );
                  }
                  setFromMatrix3(t) {
                    const e = t.elements;
                    return (
                      this.set(
                        e[0],
                        e[3],
                        e[6],
                        0,
                        e[1],
                        e[4],
                        e[7],
                        0,
                        e[2],
                        e[5],
                        e[8],
                        0,
                        0,
                        0,
                        0,
                        1
                      ),
                      this
                    );
                  }
                  extractBasis(t, e, n) {
                    return (
                      t.setFromMatrixColumn(this, 0),
                      e.setFromMatrixColumn(this, 1),
                      n.setFromMatrixColumn(this, 2),
                      this
                    );
                  }
                  makeBasis(t, e, n) {
                    return (
                      this.set(
                        t.x,
                        e.x,
                        n.x,
                        0,
                        t.y,
                        e.y,
                        n.y,
                        0,
                        t.z,
                        e.z,
                        n.z,
                        0,
                        0,
                        0,
                        0,
                        1
                      ),
                      this
                    );
                  }
                  extractRotation(t) {
                    const e = this.elements,
                      n = t.elements,
                      r = 1 / wr.setFromMatrixColumn(t, 0).length(),
                      i = 1 / wr.setFromMatrixColumn(t, 1).length(),
                      a = 1 / wr.setFromMatrixColumn(t, 2).length();
                    return (
                      (e[0] = n[0] * r),
                      (e[1] = n[1] * r),
                      (e[2] = n[2] * r),
                      (e[3] = 0),
                      (e[4] = n[4] * i),
                      (e[5] = n[5] * i),
                      (e[6] = n[6] * i),
                      (e[7] = 0),
                      (e[8] = n[8] * a),
                      (e[9] = n[9] * a),
                      (e[10] = n[10] * a),
                      (e[11] = 0),
                      (e[12] = 0),
                      (e[13] = 0),
                      (e[14] = 0),
                      (e[15] = 1),
                      this
                    );
                  }
                  makeRotationFromEuler(t) {
                    (t && t.isEuler) ||
                      console.error(
                        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
                      );
                    const e = this.elements,
                      n = t.x,
                      r = t.y,
                      i = t.z,
                      a = Math.cos(n),
                      o = Math.sin(n),
                      s = Math.cos(r),
                      c = Math.sin(r),
                      l = Math.cos(i),
                      u = Math.sin(i);
                    if ("XYZ" === t.order) {
                      const t = a * l,
                        n = a * u,
                        r = o * l,
                        i = o * u;
                      (e[0] = s * l),
                        (e[4] = -s * u),
                        (e[8] = c),
                        (e[1] = n + r * c),
                        (e[5] = t - i * c),
                        (e[9] = -o * s),
                        (e[2] = i - t * c),
                        (e[6] = r + n * c),
                        (e[10] = a * s);
                    } else if ("YXZ" === t.order) {
                      const t = s * l,
                        n = s * u,
                        r = c * l,
                        i = c * u;
                      (e[0] = t + i * o),
                        (e[4] = r * o - n),
                        (e[8] = a * c),
                        (e[1] = a * u),
                        (e[5] = a * l),
                        (e[9] = -o),
                        (e[2] = n * o - r),
                        (e[6] = i + t * o),
                        (e[10] = a * s);
                    } else if ("ZXY" === t.order) {
                      const t = s * l,
                        n = s * u,
                        r = c * l,
                        i = c * u;
                      (e[0] = t - i * o),
                        (e[4] = -a * u),
                        (e[8] = r + n * o),
                        (e[1] = n + r * o),
                        (e[5] = a * l),
                        (e[9] = i - t * o),
                        (e[2] = -a * c),
                        (e[6] = o),
                        (e[10] = a * s);
                    } else if ("ZYX" === t.order) {
                      const t = a * l,
                        n = a * u,
                        r = o * l,
                        i = o * u;
                      (e[0] = s * l),
                        (e[4] = r * c - n),
                        (e[8] = t * c + i),
                        (e[1] = s * u),
                        (e[5] = i * c + t),
                        (e[9] = n * c - r),
                        (e[2] = -c),
                        (e[6] = o * s),
                        (e[10] = a * s);
                    } else if ("YZX" === t.order) {
                      const t = a * s,
                        n = a * c,
                        r = o * s,
                        i = o * c;
                      (e[0] = s * l),
                        (e[4] = i - t * u),
                        (e[8] = r * u + n),
                        (e[1] = u),
                        (e[5] = a * l),
                        (e[9] = -o * l),
                        (e[2] = -c * l),
                        (e[6] = n * u + r),
                        (e[10] = t - i * u);
                    } else if ("XZY" === t.order) {
                      const t = a * s,
                        n = a * c,
                        r = o * s,
                        i = o * c;
                      (e[0] = s * l),
                        (e[4] = -u),
                        (e[8] = c * l),
                        (e[1] = t * u + i),
                        (e[5] = a * l),
                        (e[9] = n * u - r),
                        (e[2] = r * u - n),
                        (e[6] = o * l),
                        (e[10] = i * u + t);
                    }
                    return (
                      (e[3] = 0),
                      (e[7] = 0),
                      (e[11] = 0),
                      (e[12] = 0),
                      (e[13] = 0),
                      (e[14] = 0),
                      (e[15] = 1),
                      this
                    );
                  }
                  makeRotationFromQuaternion(t) {
                    return this.compose(Mr, t, Tr);
                  }
                  lookAt(t, e, n) {
                    const r = this.elements;
                    return (
                      Cr.subVectors(t, e),
                      0 === Cr.lengthSq() && (Cr.z = 1),
                      Cr.normalize(),
                      Er.crossVectors(n, Cr),
                      0 === Er.lengthSq() &&
                        (1 === Math.abs(n.z) ? (Cr.x += 1e-4) : (Cr.z += 1e-4),
                        Cr.normalize(),
                        Er.crossVectors(n, Cr)),
                      Er.normalize(),
                      Ar.crossVectors(Cr, Er),
                      (r[0] = Er.x),
                      (r[4] = Ar.x),
                      (r[8] = Cr.x),
                      (r[1] = Er.y),
                      (r[5] = Ar.y),
                      (r[9] = Cr.y),
                      (r[2] = Er.z),
                      (r[6] = Ar.z),
                      (r[10] = Cr.z),
                      this
                    );
                  }
                  multiply(t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                        ),
                        this.multiplyMatrices(t, e))
                      : this.multiplyMatrices(this, t);
                  }
                  premultiply(t) {
                    return this.multiplyMatrices(t, this);
                  }
                  multiplyMatrices(t, e) {
                    const n = t.elements,
                      r = e.elements,
                      i = this.elements,
                      a = n[0],
                      o = n[4],
                      s = n[8],
                      c = n[12],
                      l = n[1],
                      u = n[5],
                      h = n[9],
                      d = n[13],
                      f = n[2],
                      p = n[6],
                      m = n[10],
                      g = n[14],
                      v = n[3],
                      y = n[7],
                      b = n[11],
                      x = n[15],
                      _ = r[0],
                      w = r[4],
                      S = r[8],
                      M = r[12],
                      T = r[1],
                      E = r[5],
                      A = r[9],
                      C = r[13],
                      L = r[2],
                      R = r[6],
                      P = r[10],
                      I = r[14],
                      O = r[3],
                      k = r[7],
                      N = r[11],
                      D = r[15];
                    return (
                      (i[0] = a * _ + o * T + s * L + c * O),
                      (i[4] = a * w + o * E + s * R + c * k),
                      (i[8] = a * S + o * A + s * P + c * N),
                      (i[12] = a * M + o * C + s * I + c * D),
                      (i[1] = l * _ + u * T + h * L + d * O),
                      (i[5] = l * w + u * E + h * R + d * k),
                      (i[9] = l * S + u * A + h * P + d * N),
                      (i[13] = l * M + u * C + h * I + d * D),
                      (i[2] = f * _ + p * T + m * L + g * O),
                      (i[6] = f * w + p * E + m * R + g * k),
                      (i[10] = f * S + p * A + m * P + g * N),
                      (i[14] = f * M + p * C + m * I + g * D),
                      (i[3] = v * _ + y * T + b * L + x * O),
                      (i[7] = v * w + y * E + b * R + x * k),
                      (i[11] = v * S + y * A + b * P + x * N),
                      (i[15] = v * M + y * C + b * I + x * D),
                      this
                    );
                  }
                  multiplyScalar(t) {
                    const e = this.elements;
                    return (
                      (e[0] *= t),
                      (e[4] *= t),
                      (e[8] *= t),
                      (e[12] *= t),
                      (e[1] *= t),
                      (e[5] *= t),
                      (e[9] *= t),
                      (e[13] *= t),
                      (e[2] *= t),
                      (e[6] *= t),
                      (e[10] *= t),
                      (e[14] *= t),
                      (e[3] *= t),
                      (e[7] *= t),
                      (e[11] *= t),
                      (e[15] *= t),
                      this
                    );
                  }
                  determinant() {
                    const t = this.elements,
                      e = t[0],
                      n = t[4],
                      r = t[8],
                      i = t[12],
                      a = t[1],
                      o = t[5],
                      s = t[9],
                      c = t[13],
                      l = t[2],
                      u = t[6],
                      h = t[10],
                      d = t[14],
                      f = t[3],
                      p = t[7],
                      m = t[11],
                      g = t[15];
                    return (
                      f *
                        (+i * s * u -
                          r * c * u -
                          i * o * h +
                          n * c * h +
                          r * o * d -
                          n * s * d) +
                      p *
                        (+e * s * d -
                          e * c * h +
                          i * a * h -
                          r * a * d +
                          r * c * l -
                          i * s * l) +
                      m *
                        (+e * c * u -
                          e * o * d -
                          i * a * u +
                          n * a * d +
                          i * o * l -
                          n * c * l) +
                      g *
                        (-r * o * l -
                          e * s * u +
                          e * o * h +
                          r * a * u -
                          n * a * h +
                          n * s * l)
                    );
                  }
                  transpose() {
                    const t = this.elements;
                    let e;
                    return (
                      (e = t[1]),
                      (t[1] = t[4]),
                      (t[4] = e),
                      (e = t[2]),
                      (t[2] = t[8]),
                      (t[8] = e),
                      (e = t[6]),
                      (t[6] = t[9]),
                      (t[9] = e),
                      (e = t[3]),
                      (t[3] = t[12]),
                      (t[12] = e),
                      (e = t[7]),
                      (t[7] = t[13]),
                      (t[13] = e),
                      (e = t[11]),
                      (t[11] = t[14]),
                      (t[14] = e),
                      this
                    );
                  }
                  setPosition(t, e, n) {
                    const r = this.elements;
                    return (
                      t.isVector3
                        ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
                        : ((r[12] = t), (r[13] = e), (r[14] = n)),
                      this
                    );
                  }
                  invert() {
                    const t = this.elements,
                      e = t[0],
                      n = t[1],
                      r = t[2],
                      i = t[3],
                      a = t[4],
                      o = t[5],
                      s = t[6],
                      c = t[7],
                      l = t[8],
                      u = t[9],
                      h = t[10],
                      d = t[11],
                      f = t[12],
                      p = t[13],
                      m = t[14],
                      g = t[15],
                      v =
                        u * m * c -
                        p * h * c +
                        p * s * d -
                        o * m * d -
                        u * s * g +
                        o * h * g,
                      y =
                        f * h * c -
                        l * m * c -
                        f * s * d +
                        a * m * d +
                        l * s * g -
                        a * h * g,
                      b =
                        l * p * c -
                        f * u * c +
                        f * o * d -
                        a * p * d -
                        l * o * g +
                        a * u * g,
                      x =
                        f * u * s -
                        l * p * s -
                        f * o * h +
                        a * p * h +
                        l * o * m -
                        a * u * m,
                      _ = e * v + n * y + r * b + i * x;
                    if (0 === _)
                      return this.set(
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                      );
                    const w = 1 / _;
                    return (
                      (t[0] = v * w),
                      (t[1] =
                        (p * h * i -
                          u * m * i -
                          p * r * d +
                          n * m * d +
                          u * r * g -
                          n * h * g) *
                        w),
                      (t[2] =
                        (o * m * i -
                          p * s * i +
                          p * r * c -
                          n * m * c -
                          o * r * g +
                          n * s * g) *
                        w),
                      (t[3] =
                        (u * s * i -
                          o * h * i -
                          u * r * c +
                          n * h * c +
                          o * r * d -
                          n * s * d) *
                        w),
                      (t[4] = y * w),
                      (t[5] =
                        (l * m * i -
                          f * h * i +
                          f * r * d -
                          e * m * d -
                          l * r * g +
                          e * h * g) *
                        w),
                      (t[6] =
                        (f * s * i -
                          a * m * i -
                          f * r * c +
                          e * m * c +
                          a * r * g -
                          e * s * g) *
                        w),
                      (t[7] =
                        (a * h * i -
                          l * s * i +
                          l * r * c -
                          e * h * c -
                          a * r * d +
                          e * s * d) *
                        w),
                      (t[8] = b * w),
                      (t[9] =
                        (f * u * i -
                          l * p * i -
                          f * n * d +
                          e * p * d +
                          l * n * g -
                          e * u * g) *
                        w),
                      (t[10] =
                        (a * p * i -
                          f * o * i +
                          f * n * c -
                          e * p * c -
                          a * n * g +
                          e * o * g) *
                        w),
                      (t[11] =
                        (l * o * i -
                          a * u * i -
                          l * n * c +
                          e * u * c +
                          a * n * d -
                          e * o * d) *
                        w),
                      (t[12] = x * w),
                      (t[13] =
                        (l * p * r -
                          f * u * r +
                          f * n * h -
                          e * p * h -
                          l * n * m +
                          e * u * m) *
                        w),
                      (t[14] =
                        (f * o * r -
                          a * p * r -
                          f * n * s +
                          e * p * s +
                          a * n * m -
                          e * o * m) *
                        w),
                      (t[15] =
                        (a * u * r -
                          l * o * r +
                          l * n * s -
                          e * u * s -
                          a * n * h +
                          e * o * h) *
                        w),
                      this
                    );
                  }
                  scale(t) {
                    const e = this.elements,
                      n = t.x,
                      r = t.y,
                      i = t.z;
                    return (
                      (e[0] *= n),
                      (e[4] *= r),
                      (e[8] *= i),
                      (e[1] *= n),
                      (e[5] *= r),
                      (e[9] *= i),
                      (e[2] *= n),
                      (e[6] *= r),
                      (e[10] *= i),
                      (e[3] *= n),
                      (e[7] *= r),
                      (e[11] *= i),
                      this
                    );
                  }
                  getMaxScaleOnAxis() {
                    const t = this.elements,
                      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                      r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, r));
                  }
                  makeTranslation(t, e, n) {
                    return (
                      this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                      this
                    );
                  }
                  makeRotationX(t) {
                    const e = Math.cos(t),
                      n = Math.sin(t);
                    return (
                      this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  makeRotationY(t) {
                    const e = Math.cos(t),
                      n = Math.sin(t);
                    return (
                      this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  makeRotationZ(t) {
                    const e = Math.cos(t),
                      n = Math.sin(t);
                    return (
                      this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  makeRotationAxis(t, e) {
                    const n = Math.cos(e),
                      r = Math.sin(e),
                      i = 1 - n,
                      a = t.x,
                      o = t.y,
                      s = t.z,
                      c = i * a,
                      l = i * o;
                    return (
                      this.set(
                        c * a + n,
                        c * o - r * s,
                        c * s + r * o,
                        0,
                        c * o + r * s,
                        l * o + n,
                        l * s - r * a,
                        0,
                        c * s - r * o,
                        l * s + r * a,
                        i * s * s + n,
                        0,
                        0,
                        0,
                        0,
                        1
                      ),
                      this
                    );
                  }
                  makeScale(t, e, n) {
                    return (
                      this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  makeShear(t, e, n, r, i, a) {
                    return (
                      this.set(1, n, i, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1),
                      this
                    );
                  }
                  compose(t, e, n) {
                    const r = this.elements,
                      i = e._x,
                      a = e._y,
                      o = e._z,
                      s = e._w,
                      c = i + i,
                      l = a + a,
                      u = o + o,
                      h = i * c,
                      d = i * l,
                      f = i * u,
                      p = a * l,
                      m = a * u,
                      g = o * u,
                      v = s * c,
                      y = s * l,
                      b = s * u,
                      x = n.x,
                      _ = n.y,
                      w = n.z;
                    return (
                      (r[0] = (1 - (p + g)) * x),
                      (r[1] = (d + b) * x),
                      (r[2] = (f - y) * x),
                      (r[3] = 0),
                      (r[4] = (d - b) * _),
                      (r[5] = (1 - (h + g)) * _),
                      (r[6] = (m + v) * _),
                      (r[7] = 0),
                      (r[8] = (f + y) * w),
                      (r[9] = (m - v) * w),
                      (r[10] = (1 - (h + p)) * w),
                      (r[11] = 0),
                      (r[12] = t.x),
                      (r[13] = t.y),
                      (r[14] = t.z),
                      (r[15] = 1),
                      this
                    );
                  }
                  decompose(t, e, n) {
                    const r = this.elements;
                    let i = wr.set(r[0], r[1], r[2]).length();
                    const a = wr.set(r[4], r[5], r[6]).length(),
                      o = wr.set(r[8], r[9], r[10]).length(),
                      s = this.determinant();
                    s < 0 && (i = -i),
                      (t.x = r[12]),
                      (t.y = r[13]),
                      (t.z = r[14]),
                      Sr.copy(this);
                    const c = 1 / i,
                      l = 1 / a,
                      u = 1 / o;
                    return (
                      (Sr.elements[0] *= c),
                      (Sr.elements[1] *= c),
                      (Sr.elements[2] *= c),
                      (Sr.elements[4] *= l),
                      (Sr.elements[5] *= l),
                      (Sr.elements[6] *= l),
                      (Sr.elements[8] *= u),
                      (Sr.elements[9] *= u),
                      (Sr.elements[10] *= u),
                      e.setFromRotationMatrix(Sr),
                      (n.x = i),
                      (n.y = a),
                      (n.z = o),
                      this
                    );
                  }
                  makePerspective(t, e, n, r, i, a) {
                    void 0 === a &&
                      console.warn(
                        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
                      );
                    const o = this.elements,
                      s = (2 * i) / (e - t),
                      c = (2 * i) / (n - r),
                      l = (e + t) / (e - t),
                      u = (n + r) / (n - r),
                      h = -(a + i) / (a - i),
                      d = (-2 * a * i) / (a - i);
                    return (
                      (o[0] = s),
                      (o[4] = 0),
                      (o[8] = l),
                      (o[12] = 0),
                      (o[1] = 0),
                      (o[5] = c),
                      (o[9] = u),
                      (o[13] = 0),
                      (o[2] = 0),
                      (o[6] = 0),
                      (o[10] = h),
                      (o[14] = d),
                      (o[3] = 0),
                      (o[7] = 0),
                      (o[11] = -1),
                      (o[15] = 0),
                      this
                    );
                  }
                  makeOrthographic(t, e, n, r, i, a) {
                    const o = this.elements,
                      s = 1 / (e - t),
                      c = 1 / (n - r),
                      l = 1 / (a - i),
                      u = (e + t) * s,
                      h = (n + r) * c,
                      d = (a + i) * l;
                    return (
                      (o[0] = 2 * s),
                      (o[4] = 0),
                      (o[8] = 0),
                      (o[12] = -u),
                      (o[1] = 0),
                      (o[5] = 2 * c),
                      (o[9] = 0),
                      (o[13] = -h),
                      (o[2] = 0),
                      (o[6] = 0),
                      (o[10] = -2 * l),
                      (o[14] = -d),
                      (o[3] = 0),
                      (o[7] = 0),
                      (o[11] = 0),
                      (o[15] = 1),
                      this
                    );
                  }
                  equals(t) {
                    const e = this.elements,
                      n = t.elements;
                    for (let r = 0; r < 16; r++) if (e[r] !== n[r]) return !1;
                    return !0;
                  }
                  fromArray(t, e = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this;
                  }
                  toArray(t = [], e = 0) {
                    const n = this.elements;
                    return (
                      (t[e] = n[0]),
                      (t[e + 1] = n[1]),
                      (t[e + 2] = n[2]),
                      (t[e + 3] = n[3]),
                      (t[e + 4] = n[4]),
                      (t[e + 5] = n[5]),
                      (t[e + 6] = n[6]),
                      (t[e + 7] = n[7]),
                      (t[e + 8] = n[8]),
                      (t[e + 9] = n[9]),
                      (t[e + 10] = n[10]),
                      (t[e + 11] = n[11]),
                      (t[e + 12] = n[12]),
                      (t[e + 13] = n[13]),
                      (t[e + 14] = n[14]),
                      (t[e + 15] = n[15]),
                      t
                    );
                  }
                }
                const wr = new Gn(),
                  Sr = new _r(),
                  Mr = new Gn(0, 0, 0),
                  Tr = new Gn(1, 1, 1),
                  Er = new Gn(),
                  Ar = new Gn(),
                  Cr = new Gn(),
                  Lr = new _r(),
                  Rr = new Vn();
                class Pr {
                  constructor(t = 0, e = 0, n = 0, r = Pr.DefaultOrder) {
                    (this.isEuler = !0),
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._order = r);
                  }
                  get x() {
                    return this._x;
                  }
                  set x(t) {
                    (this._x = t), this._onChangeCallback();
                  }
                  get y() {
                    return this._y;
                  }
                  set y(t) {
                    (this._y = t), this._onChangeCallback();
                  }
                  get z() {
                    return this._z;
                  }
                  set z(t) {
                    (this._z = t), this._onChangeCallback();
                  }
                  get order() {
                    return this._order;
                  }
                  set order(t) {
                    (this._order = t), this._onChangeCallback();
                  }
                  set(t, e, n, r = this._order) {
                    return (
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._order = r),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor(
                      this._x,
                      this._y,
                      this._z,
                      this._order
                    );
                  }
                  copy(t) {
                    return (
                      (this._x = t._x),
                      (this._y = t._y),
                      (this._z = t._z),
                      (this._order = t._order),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  setFromRotationMatrix(t, e = this._order, n = !0) {
                    const r = t.elements,
                      i = r[0],
                      a = r[4],
                      o = r[8],
                      s = r[1],
                      c = r[5],
                      l = r[9],
                      u = r[2],
                      h = r[6],
                      d = r[10];
                    switch (e) {
                      case "XYZ":
                        (this._y = Math.asin(Xe(o, -1, 1))),
                          Math.abs(o) < 0.9999999
                            ? ((this._x = Math.atan2(-l, d)),
                              (this._z = Math.atan2(-a, i)))
                            : ((this._x = Math.atan2(h, c)), (this._z = 0));
                        break;
                      case "YXZ":
                        (this._x = Math.asin(-Xe(l, -1, 1))),
                          Math.abs(l) < 0.9999999
                            ? ((this._y = Math.atan2(o, d)),
                              (this._z = Math.atan2(s, c)))
                            : ((this._y = Math.atan2(-u, i)), (this._z = 0));
                        break;
                      case "ZXY":
                        (this._x = Math.asin(Xe(h, -1, 1))),
                          Math.abs(h) < 0.9999999
                            ? ((this._y = Math.atan2(-u, d)),
                              (this._z = Math.atan2(-a, c)))
                            : ((this._y = 0), (this._z = Math.atan2(s, i)));
                        break;
                      case "ZYX":
                        (this._y = Math.asin(-Xe(u, -1, 1))),
                          Math.abs(u) < 0.9999999
                            ? ((this._x = Math.atan2(h, d)),
                              (this._z = Math.atan2(s, i)))
                            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
                        break;
                      case "YZX":
                        (this._z = Math.asin(Xe(s, -1, 1))),
                          Math.abs(s) < 0.9999999
                            ? ((this._x = Math.atan2(-l, c)),
                              (this._y = Math.atan2(-u, i)))
                            : ((this._x = 0), (this._y = Math.atan2(o, d)));
                        break;
                      case "XZY":
                        (this._z = Math.asin(-Xe(a, -1, 1))),
                          Math.abs(a) < 0.9999999
                            ? ((this._x = Math.atan2(h, c)),
                              (this._y = Math.atan2(o, i)))
                            : ((this._x = Math.atan2(-l, d)), (this._y = 0));
                        break;
                      default:
                        console.warn(
                          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                            e
                        );
                    }
                    return (
                      (this._order = e),
                      !0 === n && this._onChangeCallback(),
                      this
                    );
                  }
                  setFromQuaternion(t, e, n) {
                    return (
                      Lr.makeRotationFromQuaternion(t),
                      this.setFromRotationMatrix(Lr, e, n)
                    );
                  }
                  setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e);
                  }
                  reorder(t) {
                    return Rr.setFromEuler(this), this.setFromQuaternion(Rr, t);
                  }
                  equals(t) {
                    return (
                      t._x === this._x &&
                      t._y === this._y &&
                      t._z === this._z &&
                      t._order === this._order
                    );
                  }
                  fromArray(t) {
                    return (
                      (this._x = t[0]),
                      (this._y = t[1]),
                      (this._z = t[2]),
                      void 0 !== t[3] && (this._order = t[3]),
                      this._onChangeCallback(),
                      this
                    );
                  }
                  toArray(t = [], e = 0) {
                    return (
                      (t[e] = this._x),
                      (t[e + 1] = this._y),
                      (t[e + 2] = this._z),
                      (t[e + 3] = this._order),
                      t
                    );
                  }
                  _onChange(t) {
                    return (this._onChangeCallback = t), this;
                  }
                  _onChangeCallback() {}
                  *[Symbol.iterator]() {
                    yield this._x,
                      yield this._y,
                      yield this._z,
                      yield this._order;
                  }
                  toVector3() {
                    console.error(
                      "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
                    );
                  }
                }
                (Pr.DefaultOrder = "XYZ"),
                  (Pr.RotationOrders = [
                    "XYZ",
                    "YZX",
                    "ZXY",
                    "XZY",
                    "YXZ",
                    "ZYX",
                  ]);
                class Ir {
                  constructor() {
                    this.mask = 1;
                  }
                  set(t) {
                    this.mask = ((1 << t) | 0) >>> 0;
                  }
                  enable(t) {
                    this.mask |= (1 << t) | 0;
                  }
                  enableAll() {
                    this.mask = -1;
                  }
                  toggle(t) {
                    this.mask ^= (1 << t) | 0;
                  }
                  disable(t) {
                    this.mask &= ~((1 << t) | 0);
                  }
                  disableAll() {
                    this.mask = 0;
                  }
                  test(t) {
                    return 0 !== (this.mask & t.mask);
                  }
                  isEnabled(t) {
                    return 0 !== (this.mask & ((1 << t) | 0));
                  }
                }
                let Or = 0;
                const kr = new Gn(),
                  Nr = new Vn(),
                  Dr = new _r(),
                  zr = new Gn(),
                  Fr = new Gn(),
                  Ur = new Gn(),
                  Br = new Vn(),
                  jr = new Gn(1, 0, 0),
                  Hr = new Gn(0, 1, 0),
                  Vr = new Gn(0, 0, 1),
                  Gr = { type: "added" },
                  Wr = { type: "removed" };
                class qr extends je {
                  constructor() {
                    super(),
                      (this.isObject3D = !0),
                      Object.defineProperty(this, "id", { value: Or++ }),
                      (this.uuid = qe()),
                      (this.name = ""),
                      (this.type = "Object3D"),
                      (this.parent = null),
                      (this.children = []),
                      (this.up = qr.DefaultUp.clone());
                    const t = new Gn(),
                      e = new Pr(),
                      n = new Vn(),
                      r = new Gn(1, 1, 1);
                    function i() {
                      n.setFromEuler(e, !1);
                    }
                    function a() {
                      e.setFromQuaternion(n, void 0, !1);
                    }
                    e._onChange(i),
                      n._onChange(a),
                      Object.defineProperties(this, {
                        position: {
                          configurable: !0,
                          enumerable: !0,
                          value: t,
                        },
                        rotation: {
                          configurable: !0,
                          enumerable: !0,
                          value: e,
                        },
                        quaternion: {
                          configurable: !0,
                          enumerable: !0,
                          value: n,
                        },
                        scale: { configurable: !0, enumerable: !0, value: r },
                        modelViewMatrix: { value: new _r() },
                        normalMatrix: { value: new vn() },
                      }),
                      (this.matrix = new _r()),
                      (this.matrixWorld = new _r()),
                      (this.matrixAutoUpdate = qr.DefaultMatrixAutoUpdate),
                      (this.matrixWorldNeedsUpdate = !1),
                      (this.layers = new Ir()),
                      (this.visible = !0),
                      (this.castShadow = !1),
                      (this.receiveShadow = !1),
                      (this.frustumCulled = !0),
                      (this.renderOrder = 0),
                      (this.animations = []),
                      (this.userData = {});
                  }
                  onBeforeRender() {}
                  onAfterRender() {}
                  applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                      this.matrix.premultiply(t),
                      this.matrix.decompose(
                        this.position,
                        this.quaternion,
                        this.scale
                      );
                  }
                  applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this;
                  }
                  setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e);
                  }
                  setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0);
                  }
                  setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t);
                  }
                  setRotationFromQuaternion(t) {
                    this.quaternion.copy(t);
                  }
                  rotateOnAxis(t, e) {
                    return (
                      Nr.setFromAxisAngle(t, e),
                      this.quaternion.multiply(Nr),
                      this
                    );
                  }
                  rotateOnWorldAxis(t, e) {
                    return (
                      Nr.setFromAxisAngle(t, e),
                      this.quaternion.premultiply(Nr),
                      this
                    );
                  }
                  rotateX(t) {
                    return this.rotateOnAxis(jr, t);
                  }
                  rotateY(t) {
                    return this.rotateOnAxis(Hr, t);
                  }
                  rotateZ(t) {
                    return this.rotateOnAxis(Vr, t);
                  }
                  translateOnAxis(t, e) {
                    return (
                      kr.copy(t).applyQuaternion(this.quaternion),
                      this.position.add(kr.multiplyScalar(e)),
                      this
                    );
                  }
                  translateX(t) {
                    return this.translateOnAxis(jr, t);
                  }
                  translateY(t) {
                    return this.translateOnAxis(Hr, t);
                  }
                  translateZ(t) {
                    return this.translateOnAxis(Vr, t);
                  }
                  localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld);
                  }
                  worldToLocal(t) {
                    return t.applyMatrix4(Dr.copy(this.matrixWorld).invert());
                  }
                  lookAt(t, e, n) {
                    t.isVector3 ? zr.copy(t) : zr.set(t, e, n);
                    const r = this.parent;
                    this.updateWorldMatrix(!0, !1),
                      Fr.setFromMatrixPosition(this.matrixWorld),
                      this.isCamera || this.isLight
                        ? Dr.lookAt(Fr, zr, this.up)
                        : Dr.lookAt(zr, Fr, this.up),
                      this.quaternion.setFromRotationMatrix(Dr),
                      r &&
                        (Dr.extractRotation(r.matrixWorld),
                        Nr.setFromRotationMatrix(Dr),
                        this.quaternion.premultiply(Nr.invert()));
                  }
                  add(t) {
                    if (arguments.length > 1) {
                      for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                      return this;
                    }
                    return t === this
                      ? (console.error(
                          "THREE.Object3D.add: object can't be added as a child of itself.",
                          t
                        ),
                        this)
                      : (t && t.isObject3D
                          ? (null !== t.parent && t.parent.remove(t),
                            (t.parent = this),
                            this.children.push(t),
                            t.dispatchEvent(Gr))
                          : console.error(
                              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                              t
                            ),
                        this);
                  }
                  remove(t) {
                    if (arguments.length > 1) {
                      for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                      return this;
                    }
                    const e = this.children.indexOf(t);
                    return (
                      -1 !== e &&
                        ((t.parent = null),
                        this.children.splice(e, 1),
                        t.dispatchEvent(Wr)),
                      this
                    );
                  }
                  removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this;
                  }
                  clear() {
                    for (let t = 0; t < this.children.length; t++) {
                      const e = this.children[t];
                      (e.parent = null), e.dispatchEvent(Wr);
                    }
                    return (this.children.length = 0), this;
                  }
                  attach(t) {
                    return (
                      this.updateWorldMatrix(!0, !1),
                      Dr.copy(this.matrixWorld).invert(),
                      null !== t.parent &&
                        (t.parent.updateWorldMatrix(!0, !1),
                        Dr.multiply(t.parent.matrixWorld)),
                      t.applyMatrix4(Dr),
                      this.add(t),
                      t.updateWorldMatrix(!1, !0),
                      this
                    );
                  }
                  getObjectById(t) {
                    return this.getObjectByProperty("id", t);
                  }
                  getObjectByName(t) {
                    return this.getObjectByProperty("name", t);
                  }
                  getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                      const r = this.children[n],
                        i = r.getObjectByProperty(t, e);
                      if (void 0 !== i) return i;
                    }
                  }
                  getWorldPosition(t) {
                    return (
                      this.updateWorldMatrix(!0, !1),
                      t.setFromMatrixPosition(this.matrixWorld)
                    );
                  }
                  getWorldQuaternion(t) {
                    return (
                      this.updateWorldMatrix(!0, !1),
                      this.matrixWorld.decompose(Fr, t, Ur),
                      t
                    );
                  }
                  getWorldScale(t) {
                    return (
                      this.updateWorldMatrix(!0, !1),
                      this.matrixWorld.decompose(Fr, Br, t),
                      t
                    );
                  }
                  getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize();
                  }
                  raycast() {}
                  traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t);
                  }
                  traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++)
                      e[n].traverseVisible(t);
                  }
                  traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t));
                  }
                  updateMatrix() {
                    this.matrix.compose(
                      this.position,
                      this.quaternion,
                      this.scale
                    ),
                      (this.matrixWorldNeedsUpdate = !0);
                  }
                  updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                      (this.matrixWorldNeedsUpdate || t) &&
                        (null === this.parent
                          ? this.matrixWorld.copy(this.matrix)
                          : this.matrixWorld.multiplyMatrices(
                              this.parent.matrixWorld,
                              this.matrix
                            ),
                        (this.matrixWorldNeedsUpdate = !1),
                        (t = !0));
                    const e = this.children;
                    for (let n = 0, r = e.length; n < r; n++)
                      e[n].updateMatrixWorld(t);
                  }
                  updateWorldMatrix(t, e) {
                    const n = this.parent;
                    if (
                      (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                      this.matrixAutoUpdate && this.updateMatrix(),
                      null === this.parent
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                            this.parent.matrixWorld,
                            this.matrix
                          ),
                      !0 === e)
                    ) {
                      const t = this.children;
                      for (let e = 0, n = t.length; e < n; e++)
                        t[e].updateWorldMatrix(!1, !0);
                    }
                  }
                  toJSON(t) {
                    const e = void 0 === t || "string" === typeof t,
                      n = {};
                    e &&
                      ((t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {},
                      }),
                      (n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON",
                      }));
                    const r = {};
                    function i(e, n) {
                      return (
                        void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                        n.uuid
                      );
                    }
                    if (
                      ((r.uuid = this.uuid),
                      (r.type = this.type),
                      "" !== this.name && (r.name = this.name),
                      !0 === this.castShadow && (r.castShadow = !0),
                      !0 === this.receiveShadow && (r.receiveShadow = !0),
                      !1 === this.visible && (r.visible = !1),
                      !1 === this.frustumCulled && (r.frustumCulled = !1),
                      0 !== this.renderOrder &&
                        (r.renderOrder = this.renderOrder),
                      "{}" !== JSON.stringify(this.userData) &&
                        (r.userData = this.userData),
                      (r.layers = this.layers.mask),
                      (r.matrix = this.matrix.toArray()),
                      !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                      this.isInstancedMesh &&
                        ((r.type = "InstancedMesh"),
                        (r.count = this.count),
                        (r.instanceMatrix = this.instanceMatrix.toJSON()),
                        null !== this.instanceColor &&
                          (r.instanceColor = this.instanceColor.toJSON())),
                      this.isScene)
                    )
                      this.background &&
                        (this.background.isColor
                          ? (r.background = this.background.toJSON())
                          : this.background.isTexture &&
                            (r.background = this.background.toJSON(t).uuid)),
                        this.environment &&
                          this.environment.isTexture &&
                          (r.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                      r.geometry = i(t.geometries, this.geometry);
                      const e = this.geometry.parameters;
                      if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                          for (let e = 0, r = n.length; e < r; e++) {
                            const r = n[e];
                            i(t.shapes, r);
                          }
                        else i(t.shapes, n);
                      }
                    }
                    if (
                      (this.isSkinnedMesh &&
                        ((r.bindMode = this.bindMode),
                        (r.bindMatrix = this.bindMatrix.toArray()),
                        void 0 !== this.skeleton &&
                          (i(t.skeletons, this.skeleton),
                          (r.skeleton = this.skeleton.uuid))),
                      void 0 !== this.material)
                    )
                      if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, r = this.material.length; n < r; n++)
                          e.push(i(t.materials, this.material[n]));
                        r.material = e;
                      } else r.material = i(t.materials, this.material);
                    if (this.children.length > 0) {
                      r.children = [];
                      for (let e = 0; e < this.children.length; e++)
                        r.children.push(this.children[e].toJSON(t).object);
                    }
                    if (this.animations.length > 0) {
                      r.animations = [];
                      for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        r.animations.push(i(t.animations, n));
                      }
                    }
                    if (e) {
                      const e = a(t.geometries),
                        r = a(t.materials),
                        i = a(t.textures),
                        o = a(t.images),
                        s = a(t.shapes),
                        c = a(t.skeletons),
                        l = a(t.animations),
                        u = a(t.nodes);
                      e.length > 0 && (n.geometries = e),
                        r.length > 0 && (n.materials = r),
                        i.length > 0 && (n.textures = i),
                        o.length > 0 && (n.images = o),
                        s.length > 0 && (n.shapes = s),
                        c.length > 0 && (n.skeletons = c),
                        l.length > 0 && (n.animations = l),
                        u.length > 0 && (n.nodes = u);
                    }
                    return (n.object = r), n;
                    function a(t) {
                      const e = [];
                      for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r);
                      }
                      return e;
                    }
                  }
                  clone(t) {
                    return new this.constructor().copy(this, t);
                  }
                  copy(t, e = !0) {
                    if (
                      ((this.name = t.name),
                      this.up.copy(t.up),
                      this.position.copy(t.position),
                      (this.rotation.order = t.rotation.order),
                      this.quaternion.copy(t.quaternion),
                      this.scale.copy(t.scale),
                      this.matrix.copy(t.matrix),
                      this.matrixWorld.copy(t.matrixWorld),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                      (this.layers.mask = t.layers.mask),
                      (this.visible = t.visible),
                      (this.castShadow = t.castShadow),
                      (this.receiveShadow = t.receiveShadow),
                      (this.frustumCulled = t.frustumCulled),
                      (this.renderOrder = t.renderOrder),
                      (this.userData = JSON.parse(JSON.stringify(t.userData))),
                      !0 === e)
                    )
                      for (let n = 0; n < t.children.length; n++) {
                        const e = t.children[n];
                        this.add(e.clone());
                      }
                    return this;
                  }
                }
                (qr.DefaultUp = new Gn(0, 1, 0)),
                  (qr.DefaultMatrixAutoUpdate = !0);
                const Xr = new Gn(),
                  $r = new Gn(),
                  Yr = new Gn(),
                  Jr = new Gn(),
                  Kr = new Gn(),
                  Zr = new Gn(),
                  Qr = new Gn(),
                  ti = new Gn(),
                  ei = new Gn(),
                  ni = new Gn();
                class ri {
                  constructor(t = new Gn(), e = new Gn(), n = new Gn()) {
                    (this.a = t), (this.b = e), (this.c = n);
                  }
                  static getNormal(t, e, n, r) {
                    r.subVectors(n, e), Xr.subVectors(t, e), r.cross(Xr);
                    const i = r.lengthSq();
                    return i > 0
                      ? r.multiplyScalar(1 / Math.sqrt(i))
                      : r.set(0, 0, 0);
                  }
                  static getBarycoord(t, e, n, r, i) {
                    Xr.subVectors(r, e),
                      $r.subVectors(n, e),
                      Yr.subVectors(t, e);
                    const a = Xr.dot(Xr),
                      o = Xr.dot($r),
                      s = Xr.dot(Yr),
                      c = $r.dot($r),
                      l = $r.dot(Yr),
                      u = a * c - o * o;
                    if (0 === u) return i.set(-2, -1, -1);
                    const h = 1 / u,
                      d = (c * s - o * l) * h,
                      f = (a * l - o * s) * h;
                    return i.set(1 - d - f, f, d);
                  }
                  static containsPoint(t, e, n, r) {
                    return (
                      this.getBarycoord(t, e, n, r, Jr),
                      Jr.x >= 0 && Jr.y >= 0 && Jr.x + Jr.y <= 1
                    );
                  }
                  static getUV(t, e, n, r, i, a, o, s) {
                    return (
                      this.getBarycoord(t, e, n, r, Jr),
                      s.set(0, 0),
                      s.addScaledVector(i, Jr.x),
                      s.addScaledVector(a, Jr.y),
                      s.addScaledVector(o, Jr.z),
                      s
                    );
                  }
                  static isFrontFacing(t, e, n, r) {
                    return (
                      Xr.subVectors(n, e),
                      $r.subVectors(t, e),
                      Xr.cross($r).dot(r) < 0
                    );
                  }
                  set(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
                  }
                  setFromPointsAndIndices(t, e, n, r) {
                    return (
                      this.a.copy(t[e]),
                      this.b.copy(t[n]),
                      this.c.copy(t[r]),
                      this
                    );
                  }
                  setFromAttributeAndIndices(t, e, n, r) {
                    return (
                      this.a.fromBufferAttribute(t, e),
                      this.b.fromBufferAttribute(t, n),
                      this.c.fromBufferAttribute(t, r),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    return (
                      this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    );
                  }
                  getArea() {
                    return (
                      Xr.subVectors(this.c, this.b),
                      $r.subVectors(this.a, this.b),
                      0.5 * Xr.cross($r).length()
                    );
                  }
                  getMidpoint(t) {
                    return t
                      .addVectors(this.a, this.b)
                      .add(this.c)
                      .multiplyScalar(1 / 3);
                  }
                  getNormal(t) {
                    return ri.getNormal(this.a, this.b, this.c, t);
                  }
                  getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c);
                  }
                  getBarycoord(t, e) {
                    return ri.getBarycoord(t, this.a, this.b, this.c, e);
                  }
                  getUV(t, e, n, r, i) {
                    return ri.getUV(t, this.a, this.b, this.c, e, n, r, i);
                  }
                  containsPoint(t) {
                    return ri.containsPoint(t, this.a, this.b, this.c);
                  }
                  isFrontFacing(t) {
                    return ri.isFrontFacing(this.a, this.b, this.c, t);
                  }
                  intersectsBox(t) {
                    return t.intersectsTriangle(this);
                  }
                  closestPointToPoint(t, e) {
                    const n = this.a,
                      r = this.b,
                      i = this.c;
                    let a, o;
                    Kr.subVectors(r, n),
                      Zr.subVectors(i, n),
                      ti.subVectors(t, n);
                    const s = Kr.dot(ti),
                      c = Zr.dot(ti);
                    if (s <= 0 && c <= 0) return e.copy(n);
                    ei.subVectors(t, r);
                    const l = Kr.dot(ei),
                      u = Zr.dot(ei);
                    if (l >= 0 && u <= l) return e.copy(r);
                    const h = s * u - l * c;
                    if (h <= 0 && s >= 0 && l <= 0)
                      return (
                        (a = s / (s - l)), e.copy(n).addScaledVector(Kr, a)
                      );
                    ni.subVectors(t, i);
                    const d = Kr.dot(ni),
                      f = Zr.dot(ni);
                    if (f >= 0 && d <= f) return e.copy(i);
                    const p = d * c - s * f;
                    if (p <= 0 && c >= 0 && f <= 0)
                      return (
                        (o = c / (c - f)), e.copy(n).addScaledVector(Zr, o)
                      );
                    const m = l * f - d * u;
                    if (m <= 0 && u - l >= 0 && d - f >= 0)
                      return (
                        Qr.subVectors(i, r),
                        (o = (u - l) / (u - l + (d - f))),
                        e.copy(r).addScaledVector(Qr, o)
                      );
                    const g = 1 / (m + p + h);
                    return (
                      (a = p * g),
                      (o = h * g),
                      e.copy(n).addScaledVector(Kr, a).addScaledVector(Zr, o)
                    );
                  }
                  equals(t) {
                    return (
                      t.a.equals(this.a) &&
                      t.b.equals(this.b) &&
                      t.c.equals(this.c)
                    );
                  }
                }
                let ii = 0;
                class ai extends je {
                  constructor() {
                    super(),
                      (this.isMaterial = !0),
                      Object.defineProperty(this, "id", { value: ii++ }),
                      (this.uuid = qe()),
                      (this.name = ""),
                      (this.type = "Material"),
                      (this.blending = _),
                      (this.side = g),
                      (this.vertexColors = !1),
                      (this.opacity = 1),
                      (this.transparent = !1),
                      (this.blendSrc = N),
                      (this.blendDst = D),
                      (this.blendEquation = E),
                      (this.blendSrcAlpha = null),
                      (this.blendDstAlpha = null),
                      (this.blendEquationAlpha = null),
                      (this.depthFunc = W),
                      (this.depthTest = !0),
                      (this.depthWrite = !0),
                      (this.stencilWriteMask = 255),
                      (this.stencilFunc = ze),
                      (this.stencilRef = 0),
                      (this.stencilFuncMask = 255),
                      (this.stencilFail = De),
                      (this.stencilZFail = De),
                      (this.stencilZPass = De),
                      (this.stencilWrite = !1),
                      (this.clippingPlanes = null),
                      (this.clipIntersection = !1),
                      (this.clipShadows = !1),
                      (this.shadowSide = null),
                      (this.colorWrite = !0),
                      (this.precision = null),
                      (this.polygonOffset = !1),
                      (this.polygonOffsetFactor = 0),
                      (this.polygonOffsetUnits = 0),
                      (this.dithering = !1),
                      (this.alphaToCoverage = !1),
                      (this.premultipliedAlpha = !1),
                      (this.visible = !0),
                      (this.toneMapped = !0),
                      (this.userData = {}),
                      (this.version = 0),
                      (this._alphaTest = 0);
                  }
                  get alphaTest() {
                    return this._alphaTest;
                  }
                  set alphaTest(t) {
                    this._alphaTest > 0 !== t > 0 && this.version++,
                      (this._alphaTest = t);
                  }
                  onBuild() {}
                  onBeforeRender() {}
                  onBeforeCompile() {}
                  customProgramCacheKey() {
                    return this.onBeforeCompile.toString();
                  }
                  setValues(t) {
                    if (void 0 !== t)
                      for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                          console.warn(
                            "THREE.Material: '" +
                              e +
                              "' parameter is undefined."
                          );
                          continue;
                        }
                        if ("shading" === e) {
                          console.warn(
                            "THREE." +
                              this.type +
                              ": .shading has been removed. Use the boolean .flatShading instead."
                          ),
                            (this.flatShading = n === b);
                          continue;
                        }
                        const r = this[e];
                        void 0 !== r
                          ? r && r.isColor
                            ? r.set(n)
                            : r && r.isVector3 && n && n.isVector3
                            ? r.copy(n)
                            : (this[e] = n)
                          : console.warn(
                              "THREE." +
                                this.type +
                                ": '" +
                                e +
                                "' is not a property of this material."
                            );
                      }
                  }
                  toJSON(t) {
                    const e = void 0 === t || "string" === typeof t;
                    e && (t = { textures: {}, images: {} });
                    const n = {
                      metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON",
                      },
                    };
                    function r(t) {
                      const e = [];
                      for (const n in t) {
                        const r = t[n];
                        delete r.metadata, e.push(r);
                      }
                      return e;
                    }
                    if (
                      ((n.uuid = this.uuid),
                      (n.type = this.type),
                      "" !== this.name && (n.name = this.name),
                      this.color &&
                        this.color.isColor &&
                        (n.color = this.color.getHex()),
                      void 0 !== this.roughness &&
                        (n.roughness = this.roughness),
                      void 0 !== this.metalness &&
                        (n.metalness = this.metalness),
                      void 0 !== this.sheen && (n.sheen = this.sheen),
                      this.sheenColor &&
                        this.sheenColor.isColor &&
                        (n.sheenColor = this.sheenColor.getHex()),
                      void 0 !== this.sheenRoughness &&
                        (n.sheenRoughness = this.sheenRoughness),
                      this.emissive &&
                        this.emissive.isColor &&
                        (n.emissive = this.emissive.getHex()),
                      this.emissiveIntensity &&
                        1 !== this.emissiveIntensity &&
                        (n.emissiveIntensity = this.emissiveIntensity),
                      this.specular &&
                        this.specular.isColor &&
                        (n.specular = this.specular.getHex()),
                      void 0 !== this.specularIntensity &&
                        (n.specularIntensity = this.specularIntensity),
                      this.specularColor &&
                        this.specularColor.isColor &&
                        (n.specularColor = this.specularColor.getHex()),
                      void 0 !== this.shininess &&
                        (n.shininess = this.shininess),
                      void 0 !== this.clearcoat &&
                        (n.clearcoat = this.clearcoat),
                      void 0 !== this.clearcoatRoughness &&
                        (n.clearcoatRoughness = this.clearcoatRoughness),
                      this.clearcoatMap &&
                        this.clearcoatMap.isTexture &&
                        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                      this.clearcoatRoughnessMap &&
                        this.clearcoatRoughnessMap.isTexture &&
                        (n.clearcoatRoughnessMap =
                          this.clearcoatRoughnessMap.toJSON(t).uuid),
                      this.clearcoatNormalMap &&
                        this.clearcoatNormalMap.isTexture &&
                        ((n.clearcoatNormalMap =
                          this.clearcoatNormalMap.toJSON(t).uuid),
                        (n.clearcoatNormalScale =
                          this.clearcoatNormalScale.toArray())),
                      void 0 !== this.iridescence &&
                        (n.iridescence = this.iridescence),
                      void 0 !== this.iridescenceIOR &&
                        (n.iridescenceIOR = this.iridescenceIOR),
                      void 0 !== this.iridescenceThicknessRange &&
                        (n.iridescenceThicknessRange =
                          this.iridescenceThicknessRange),
                      this.iridescenceMap &&
                        this.iridescenceMap.isTexture &&
                        (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
                      this.iridescenceThicknessMap &&
                        this.iridescenceThicknessMap.isTexture &&
                        (n.iridescenceThicknessMap =
                          this.iridescenceThicknessMap.toJSON(t).uuid),
                      this.map &&
                        this.map.isTexture &&
                        (n.map = this.map.toJSON(t).uuid),
                      this.matcap &&
                        this.matcap.isTexture &&
                        (n.matcap = this.matcap.toJSON(t).uuid),
                      this.alphaMap &&
                        this.alphaMap.isTexture &&
                        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                      this.lightMap &&
                        this.lightMap.isTexture &&
                        ((n.lightMap = this.lightMap.toJSON(t).uuid),
                        (n.lightMapIntensity = this.lightMapIntensity)),
                      this.aoMap &&
                        this.aoMap.isTexture &&
                        ((n.aoMap = this.aoMap.toJSON(t).uuid),
                        (n.aoMapIntensity = this.aoMapIntensity)),
                      this.bumpMap &&
                        this.bumpMap.isTexture &&
                        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                        (n.bumpScale = this.bumpScale)),
                      this.normalMap &&
                        this.normalMap.isTexture &&
                        ((n.normalMap = this.normalMap.toJSON(t).uuid),
                        (n.normalMapType = this.normalMapType),
                        (n.normalScale = this.normalScale.toArray())),
                      this.displacementMap &&
                        this.displacementMap.isTexture &&
                        ((n.displacementMap =
                          this.displacementMap.toJSON(t).uuid),
                        (n.displacementScale = this.displacementScale),
                        (n.displacementBias = this.displacementBias)),
                      this.roughnessMap &&
                        this.roughnessMap.isTexture &&
                        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                      this.metalnessMap &&
                        this.metalnessMap.isTexture &&
                        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                      this.emissiveMap &&
                        this.emissiveMap.isTexture &&
                        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                      this.specularMap &&
                        this.specularMap.isTexture &&
                        (n.specularMap = this.specularMap.toJSON(t).uuid),
                      this.specularIntensityMap &&
                        this.specularIntensityMap.isTexture &&
                        (n.specularIntensityMap =
                          this.specularIntensityMap.toJSON(t).uuid),
                      this.specularColorMap &&
                        this.specularColorMap.isTexture &&
                        (n.specularColorMap =
                          this.specularColorMap.toJSON(t).uuid),
                      this.envMap &&
                        this.envMap.isTexture &&
                        ((n.envMap = this.envMap.toJSON(t).uuid),
                        void 0 !== this.combine && (n.combine = this.combine)),
                      void 0 !== this.envMapIntensity &&
                        (n.envMapIntensity = this.envMapIntensity),
                      void 0 !== this.reflectivity &&
                        (n.reflectivity = this.reflectivity),
                      void 0 !== this.refractionRatio &&
                        (n.refractionRatio = this.refractionRatio),
                      this.gradientMap &&
                        this.gradientMap.isTexture &&
                        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                      void 0 !== this.transmission &&
                        (n.transmission = this.transmission),
                      this.transmissionMap &&
                        this.transmissionMap.isTexture &&
                        (n.transmissionMap =
                          this.transmissionMap.toJSON(t).uuid),
                      void 0 !== this.thickness &&
                        (n.thickness = this.thickness),
                      this.thicknessMap &&
                        this.thicknessMap.isTexture &&
                        (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                      void 0 !== this.attenuationDistance &&
                        (n.attenuationDistance = this.attenuationDistance),
                      void 0 !== this.attenuationColor &&
                        (n.attenuationColor = this.attenuationColor.getHex()),
                      void 0 !== this.size && (n.size = this.size),
                      null !== this.shadowSide &&
                        (n.shadowSide = this.shadowSide),
                      void 0 !== this.sizeAttenuation &&
                        (n.sizeAttenuation = this.sizeAttenuation),
                      this.blending !== _ && (n.blending = this.blending),
                      this.side !== g && (n.side = this.side),
                      this.vertexColors && (n.vertexColors = !0),
                      this.opacity < 1 && (n.opacity = this.opacity),
                      !0 === this.transparent &&
                        (n.transparent = this.transparent),
                      (n.depthFunc = this.depthFunc),
                      (n.depthTest = this.depthTest),
                      (n.depthWrite = this.depthWrite),
                      (n.colorWrite = this.colorWrite),
                      (n.stencilWrite = this.stencilWrite),
                      (n.stencilWriteMask = this.stencilWriteMask),
                      (n.stencilFunc = this.stencilFunc),
                      (n.stencilRef = this.stencilRef),
                      (n.stencilFuncMask = this.stencilFuncMask),
                      (n.stencilFail = this.stencilFail),
                      (n.stencilZFail = this.stencilZFail),
                      (n.stencilZPass = this.stencilZPass),
                      void 0 !== this.rotation &&
                        0 !== this.rotation &&
                        (n.rotation = this.rotation),
                      !0 === this.polygonOffset && (n.polygonOffset = !0),
                      0 !== this.polygonOffsetFactor &&
                        (n.polygonOffsetFactor = this.polygonOffsetFactor),
                      0 !== this.polygonOffsetUnits &&
                        (n.polygonOffsetUnits = this.polygonOffsetUnits),
                      void 0 !== this.linewidth &&
                        1 !== this.linewidth &&
                        (n.linewidth = this.linewidth),
                      void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                      void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                      void 0 !== this.scale && (n.scale = this.scale),
                      !0 === this.dithering && (n.dithering = !0),
                      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                      !0 === this.alphaToCoverage &&
                        (n.alphaToCoverage = this.alphaToCoverage),
                      !0 === this.premultipliedAlpha &&
                        (n.premultipliedAlpha = this.premultipliedAlpha),
                      !0 === this.wireframe && (n.wireframe = this.wireframe),
                      this.wireframeLinewidth > 1 &&
                        (n.wireframeLinewidth = this.wireframeLinewidth),
                      "round" !== this.wireframeLinecap &&
                        (n.wireframeLinecap = this.wireframeLinecap),
                      "round" !== this.wireframeLinejoin &&
                        (n.wireframeLinejoin = this.wireframeLinejoin),
                      !0 === this.flatShading &&
                        (n.flatShading = this.flatShading),
                      !1 === this.visible && (n.visible = !1),
                      !1 === this.toneMapped && (n.toneMapped = !1),
                      !1 === this.fog && (n.fog = !1),
                      "{}" !== JSON.stringify(this.userData) &&
                        (n.userData = this.userData),
                      e)
                    ) {
                      const e = r(t.textures),
                        i = r(t.images);
                      e.length > 0 && (n.textures = e),
                        i.length > 0 && (n.images = i);
                    }
                    return n;
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    (this.name = t.name),
                      (this.blending = t.blending),
                      (this.side = t.side),
                      (this.vertexColors = t.vertexColors),
                      (this.opacity = t.opacity),
                      (this.transparent = t.transparent),
                      (this.blendSrc = t.blendSrc),
                      (this.blendDst = t.blendDst),
                      (this.blendEquation = t.blendEquation),
                      (this.blendSrcAlpha = t.blendSrcAlpha),
                      (this.blendDstAlpha = t.blendDstAlpha),
                      (this.blendEquationAlpha = t.blendEquationAlpha),
                      (this.depthFunc = t.depthFunc),
                      (this.depthTest = t.depthTest),
                      (this.depthWrite = t.depthWrite),
                      (this.stencilWriteMask = t.stencilWriteMask),
                      (this.stencilFunc = t.stencilFunc),
                      (this.stencilRef = t.stencilRef),
                      (this.stencilFuncMask = t.stencilFuncMask),
                      (this.stencilFail = t.stencilFail),
                      (this.stencilZFail = t.stencilZFail),
                      (this.stencilZPass = t.stencilZPass),
                      (this.stencilWrite = t.stencilWrite);
                    const e = t.clippingPlanes;
                    let n = null;
                    if (null !== e) {
                      const t = e.length;
                      n = new Array(t);
                      for (let r = 0; r !== t; ++r) n[r] = e[r].clone();
                    }
                    return (
                      (this.clippingPlanes = n),
                      (this.clipIntersection = t.clipIntersection),
                      (this.clipShadows = t.clipShadows),
                      (this.shadowSide = t.shadowSide),
                      (this.colorWrite = t.colorWrite),
                      (this.precision = t.precision),
                      (this.polygonOffset = t.polygonOffset),
                      (this.polygonOffsetFactor = t.polygonOffsetFactor),
                      (this.polygonOffsetUnits = t.polygonOffsetUnits),
                      (this.dithering = t.dithering),
                      (this.alphaTest = t.alphaTest),
                      (this.alphaToCoverage = t.alphaToCoverage),
                      (this.premultipliedAlpha = t.premultipliedAlpha),
                      (this.visible = t.visible),
                      (this.toneMapped = t.toneMapped),
                      (this.userData = JSON.parse(JSON.stringify(t.userData))),
                      this
                    );
                  }
                  dispose() {
                    this.dispatchEvent({ type: "dispose" });
                  }
                  set needsUpdate(t) {
                    !0 === t && this.version++;
                  }
                }
                class oi extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshBasicMaterial = !0),
                      (this.type = "MeshBasicMaterial"),
                      (this.color = new In(16777215)),
                      (this.map = null),
                      (this.lightMap = null),
                      (this.lightMapIntensity = 1),
                      (this.aoMap = null),
                      (this.aoMapIntensity = 1),
                      (this.specularMap = null),
                      (this.alphaMap = null),
                      (this.envMap = null),
                      (this.combine = J),
                      (this.reflectivity = 1),
                      (this.refractionRatio = 0.98),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.wireframeLinecap = "round"),
                      (this.wireframeLinejoin = "round"),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.map = t.map),
                      (this.lightMap = t.lightMap),
                      (this.lightMapIntensity = t.lightMapIntensity),
                      (this.aoMap = t.aoMap),
                      (this.aoMapIntensity = t.aoMapIntensity),
                      (this.specularMap = t.specularMap),
                      (this.alphaMap = t.alphaMap),
                      (this.envMap = t.envMap),
                      (this.combine = t.combine),
                      (this.reflectivity = t.reflectivity),
                      (this.refractionRatio = t.refractionRatio),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.wireframeLinecap = t.wireframeLinecap),
                      (this.wireframeLinejoin = t.wireframeLinejoin),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                const si = new Gn(),
                  ci = new gn();
                class li {
                  constructor(t, e, n) {
                    if (Array.isArray(t))
                      throw new TypeError(
                        "THREE.BufferAttribute: array should be a Typed Array."
                      );
                    (this.isBufferAttribute = !0),
                      (this.name = ""),
                      (this.array = t),
                      (this.itemSize = e),
                      (this.count = void 0 !== t ? t.length / e : 0),
                      (this.normalized = !0 === n),
                      (this.usage = Fe),
                      (this.updateRange = { offset: 0, count: -1 }),
                      (this.version = 0);
                  }
                  onUploadCallback() {}
                  set needsUpdate(t) {
                    !0 === t && this.version++;
                  }
                  setUsage(t) {
                    return (this.usage = t), this;
                  }
                  copy(t) {
                    return (
                      (this.name = t.name),
                      (this.array = new t.array.constructor(t.array)),
                      (this.itemSize = t.itemSize),
                      (this.count = t.count),
                      (this.normalized = t.normalized),
                      (this.usage = t.usage),
                      this
                    );
                  }
                  copyAt(t, e, n) {
                    (t *= this.itemSize), (n *= e.itemSize);
                    for (let r = 0, i = this.itemSize; r < i; r++)
                      this.array[t + r] = e.array[n + r];
                    return this;
                  }
                  copyArray(t) {
                    return this.array.set(t), this;
                  }
                  copyColorsArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                      let i = t[r];
                      void 0 === i &&
                        (console.warn(
                          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                          r
                        ),
                        (i = new In())),
                        (e[n++] = i.r),
                        (e[n++] = i.g),
                        (e[n++] = i.b);
                    }
                    return this;
                  }
                  copyVector2sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                      let i = t[r];
                      void 0 === i &&
                        (console.warn(
                          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                          r
                        ),
                        (i = new gn())),
                        (e[n++] = i.x),
                        (e[n++] = i.y);
                    }
                    return this;
                  }
                  copyVector3sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                      let i = t[r];
                      void 0 === i &&
                        (console.warn(
                          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                          r
                        ),
                        (i = new Gn())),
                        (e[n++] = i.x),
                        (e[n++] = i.y),
                        (e[n++] = i.z);
                    }
                    return this;
                  }
                  copyVector4sArray(t) {
                    const e = this.array;
                    let n = 0;
                    for (let r = 0, i = t.length; r < i; r++) {
                      let i = t[r];
                      void 0 === i &&
                        (console.warn(
                          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                          r
                        ),
                        (i = new Un())),
                        (e[n++] = i.x),
                        (e[n++] = i.y),
                        (e[n++] = i.z),
                        (e[n++] = i.w);
                    }
                    return this;
                  }
                  applyMatrix3(t) {
                    if (2 === this.itemSize)
                      for (let e = 0, n = this.count; e < n; e++)
                        ci.fromBufferAttribute(this, e),
                          ci.applyMatrix3(t),
                          this.setXY(e, ci.x, ci.y);
                    else if (3 === this.itemSize)
                      for (let e = 0, n = this.count; e < n; e++)
                        si.fromBufferAttribute(this, e),
                          si.applyMatrix3(t),
                          this.setXYZ(e, si.x, si.y, si.z);
                    return this;
                  }
                  applyMatrix4(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                      si.fromBufferAttribute(this, e),
                        si.applyMatrix4(t),
                        this.setXYZ(e, si.x, si.y, si.z);
                    return this;
                  }
                  applyNormalMatrix(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                      si.fromBufferAttribute(this, e),
                        si.applyNormalMatrix(t),
                        this.setXYZ(e, si.x, si.y, si.z);
                    return this;
                  }
                  transformDirection(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                      si.fromBufferAttribute(this, e),
                        si.transformDirection(t),
                        this.setXYZ(e, si.x, si.y, si.z);
                    return this;
                  }
                  set(t, e = 0) {
                    return this.array.set(t, e), this;
                  }
                  getX(t) {
                    return this.array[t * this.itemSize];
                  }
                  setX(t, e) {
                    return (this.array[t * this.itemSize] = e), this;
                  }
                  getY(t) {
                    return this.array[t * this.itemSize + 1];
                  }
                  setY(t, e) {
                    return (this.array[t * this.itemSize + 1] = e), this;
                  }
                  getZ(t) {
                    return this.array[t * this.itemSize + 2];
                  }
                  setZ(t, e) {
                    return (this.array[t * this.itemSize + 2] = e), this;
                  }
                  getW(t) {
                    return this.array[t * this.itemSize + 3];
                  }
                  setW(t, e) {
                    return (this.array[t * this.itemSize + 3] = e), this;
                  }
                  setXY(t, e, n) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      this
                    );
                  }
                  setXYZ(t, e, n, r) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      (this.array[t + 2] = r),
                      this
                    );
                  }
                  setXYZW(t, e, n, r, i) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      (this.array[t + 2] = r),
                      (this.array[t + 3] = i),
                      this
                    );
                  }
                  onUpload(t) {
                    return (this.onUploadCallback = t), this;
                  }
                  clone() {
                    return new this.constructor(this.array, this.itemSize).copy(
                      this
                    );
                  }
                  toJSON() {
                    const t = {
                      itemSize: this.itemSize,
                      type: this.array.constructor.name,
                      array: Array.from(this.array),
                      normalized: this.normalized,
                    };
                    return (
                      "" !== this.name && (t.name = this.name),
                      this.usage !== Fe && (t.usage = this.usage),
                      (0 === this.updateRange.offset &&
                        -1 === this.updateRange.count) ||
                        (t.updateRange = this.updateRange),
                      t
                    );
                  }
                }
                class ui extends li {
                  constructor(t, e, n) {
                    super(new Uint16Array(t), e, n);
                  }
                }
                class hi extends li {
                  constructor(t, e, n) {
                    super(new Uint32Array(t), e, n);
                  }
                }
                class di extends li {
                  constructor(t, e, n) {
                    super(new Float32Array(t), e, n);
                  }
                }
                let fi = 0;
                const pi = new _r(),
                  mi = new qr(),
                  gi = new Gn(),
                  vi = new Xn(),
                  yi = new Xn(),
                  bi = new Gn();
                class xi extends je {
                  constructor() {
                    super(),
                      (this.isBufferGeometry = !0),
                      Object.defineProperty(this, "id", { value: fi++ }),
                      (this.uuid = qe()),
                      (this.name = ""),
                      (this.type = "BufferGeometry"),
                      (this.index = null),
                      (this.attributes = {}),
                      (this.morphAttributes = {}),
                      (this.morphTargetsRelative = !1),
                      (this.groups = []),
                      (this.boundingBox = null),
                      (this.boundingSphere = null),
                      (this.drawRange = { start: 0, count: 1 / 0 }),
                      (this.userData = {});
                  }
                  getIndex() {
                    return this.index;
                  }
                  setIndex(t) {
                    return (
                      Array.isArray(t)
                        ? (this.index = new (yn(t) ? hi : ui)(t, 1))
                        : (this.index = t),
                      this
                    );
                  }
                  getAttribute(t) {
                    return this.attributes[t];
                  }
                  setAttribute(t, e) {
                    return (this.attributes[t] = e), this;
                  }
                  deleteAttribute(t) {
                    return delete this.attributes[t], this;
                  }
                  hasAttribute(t) {
                    return void 0 !== this.attributes[t];
                  }
                  addGroup(t, e, n = 0) {
                    this.groups.push({ start: t, count: e, materialIndex: n });
                  }
                  clearGroups() {
                    this.groups = [];
                  }
                  setDrawRange(t, e) {
                    (this.drawRange.start = t), (this.drawRange.count = e);
                  }
                  applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                      const e = new vn().getNormalMatrix(t);
                      n.applyNormalMatrix(e), (n.needsUpdate = !0);
                    }
                    const r = this.attributes.tangent;
                    return (
                      void 0 !== r &&
                        (r.transformDirection(t), (r.needsUpdate = !0)),
                      null !== this.boundingBox && this.computeBoundingBox(),
                      null !== this.boundingSphere &&
                        this.computeBoundingSphere(),
                      this
                    );
                  }
                  applyQuaternion(t) {
                    return (
                      pi.makeRotationFromQuaternion(t),
                      this.applyMatrix4(pi),
                      this
                    );
                  }
                  rotateX(t) {
                    return pi.makeRotationX(t), this.applyMatrix4(pi), this;
                  }
                  rotateY(t) {
                    return pi.makeRotationY(t), this.applyMatrix4(pi), this;
                  }
                  rotateZ(t) {
                    return pi.makeRotationZ(t), this.applyMatrix4(pi), this;
                  }
                  translate(t, e, n) {
                    return (
                      pi.makeTranslation(t, e, n), this.applyMatrix4(pi), this
                    );
                  }
                  scale(t, e, n) {
                    return pi.makeScale(t, e, n), this.applyMatrix4(pi), this;
                  }
                  lookAt(t) {
                    return (
                      mi.lookAt(t),
                      mi.updateMatrix(),
                      this.applyMatrix4(mi.matrix),
                      this
                    );
                  }
                  center() {
                    return (
                      this.computeBoundingBox(),
                      this.boundingBox.getCenter(gi).negate(),
                      this.translate(gi.x, gi.y, gi.z),
                      this
                    );
                  }
                  setFromPoints(t) {
                    const e = [];
                    for (let n = 0, r = t.length; n < r; n++) {
                      const r = t[n];
                      e.push(r.x, r.y, r.z || 0);
                    }
                    return this.setAttribute("position", new di(e, 3)), this;
                  }
                  computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new Xn());
                    const t = this.attributes.position,
                      e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute)
                      return (
                        console.error(
                          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                          this
                        ),
                        void this.boundingBox.set(
                          new Gn(-1 / 0, -1 / 0, -1 / 0),
                          new Gn(1 / 0, 1 / 0, 1 / 0)
                        )
                      );
                    if (void 0 !== t) {
                      if ((this.boundingBox.setFromBufferAttribute(t), e))
                        for (let n = 0, r = e.length; n < r; n++) {
                          const t = e[n];
                          vi.setFromBufferAttribute(t),
                            this.morphTargetsRelative
                              ? (bi.addVectors(this.boundingBox.min, vi.min),
                                this.boundingBox.expandByPoint(bi),
                                bi.addVectors(this.boundingBox.max, vi.max),
                                this.boundingBox.expandByPoint(bi))
                              : (this.boundingBox.expandByPoint(vi.min),
                                this.boundingBox.expandByPoint(vi.max));
                        }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) ||
                      isNaN(this.boundingBox.min.y) ||
                      isNaN(this.boundingBox.min.z)) &&
                      console.error(
                        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                        this
                      );
                  }
                  computeBoundingSphere() {
                    null === this.boundingSphere &&
                      (this.boundingSphere = new dr());
                    const t = this.attributes.position,
                      e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute)
                      return (
                        console.error(
                          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                          this
                        ),
                        void this.boundingSphere.set(new Gn(), 1 / 0)
                      );
                    if (t) {
                      const n = this.boundingSphere.center;
                      if ((vi.setFromBufferAttribute(t), e))
                        for (let t = 0, i = e.length; t < i; t++) {
                          const n = e[t];
                          yi.setFromBufferAttribute(n),
                            this.morphTargetsRelative
                              ? (bi.addVectors(vi.min, yi.min),
                                vi.expandByPoint(bi),
                                bi.addVectors(vi.max, yi.max),
                                vi.expandByPoint(bi))
                              : (vi.expandByPoint(yi.min),
                                vi.expandByPoint(yi.max));
                        }
                      vi.getCenter(n);
                      let r = 0;
                      for (let e = 0, i = t.count; e < i; e++)
                        bi.fromBufferAttribute(t, e),
                          (r = Math.max(r, n.distanceToSquared(bi)));
                      if (e)
                        for (let i = 0, a = e.length; i < a; i++) {
                          const a = e[i],
                            o = this.morphTargetsRelative;
                          for (let e = 0, i = a.count; e < i; e++)
                            bi.fromBufferAttribute(a, e),
                              o && (gi.fromBufferAttribute(t, e), bi.add(gi)),
                              (r = Math.max(r, n.distanceToSquared(bi)));
                        }
                      (this.boundingSphere.radius = Math.sqrt(r)),
                        isNaN(this.boundingSphere.radius) &&
                          console.error(
                            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                            this
                          );
                    }
                  }
                  computeTangents() {
                    const t = this.index,
                      e = this.attributes;
                    if (
                      null === t ||
                      void 0 === e.position ||
                      void 0 === e.normal ||
                      void 0 === e.uv
                    )
                      return void console.error(
                        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
                      );
                    const n = t.array,
                      r = e.position.array,
                      i = e.normal.array,
                      a = e.uv.array,
                      o = r.length / 3;
                    !1 === this.hasAttribute("tangent") &&
                      this.setAttribute(
                        "tangent",
                        new li(new Float32Array(4 * o), 4)
                      );
                    const s = this.getAttribute("tangent").array,
                      c = [],
                      l = [];
                    for (let T = 0; T < o; T++)
                      (c[T] = new Gn()), (l[T] = new Gn());
                    const u = new Gn(),
                      h = new Gn(),
                      d = new Gn(),
                      f = new gn(),
                      p = new gn(),
                      m = new gn(),
                      g = new Gn(),
                      v = new Gn();
                    function y(t, e, n) {
                      u.fromArray(r, 3 * t),
                        h.fromArray(r, 3 * e),
                        d.fromArray(r, 3 * n),
                        f.fromArray(a, 2 * t),
                        p.fromArray(a, 2 * e),
                        m.fromArray(a, 2 * n),
                        h.sub(u),
                        d.sub(u),
                        p.sub(f),
                        m.sub(f);
                      const i = 1 / (p.x * m.y - m.x * p.y);
                      isFinite(i) &&
                        (g
                          .copy(h)
                          .multiplyScalar(m.y)
                          .addScaledVector(d, -p.y)
                          .multiplyScalar(i),
                        v
                          .copy(d)
                          .multiplyScalar(p.x)
                          .addScaledVector(h, -m.x)
                          .multiplyScalar(i),
                        c[t].add(g),
                        c[e].add(g),
                        c[n].add(g),
                        l[t].add(v),
                        l[e].add(v),
                        l[n].add(v));
                    }
                    let b = this.groups;
                    0 === b.length && (b = [{ start: 0, count: n.length }]);
                    for (let T = 0, E = b.length; T < E; ++T) {
                      const t = b[T],
                        e = t.start,
                        r = t.count;
                      for (let i = e, a = e + r; i < a; i += 3)
                        y(n[i + 0], n[i + 1], n[i + 2]);
                    }
                    const x = new Gn(),
                      _ = new Gn(),
                      w = new Gn(),
                      S = new Gn();
                    function M(t) {
                      w.fromArray(i, 3 * t), S.copy(w);
                      const e = c[t];
                      x.copy(e),
                        x.sub(w.multiplyScalar(w.dot(e))).normalize(),
                        _.crossVectors(S, e);
                      const n = _.dot(l[t]),
                        r = n < 0 ? -1 : 1;
                      (s[4 * t] = x.x),
                        (s[4 * t + 1] = x.y),
                        (s[4 * t + 2] = x.z),
                        (s[4 * t + 3] = r);
                    }
                    for (let T = 0, E = b.length; T < E; ++T) {
                      const t = b[T],
                        e = t.start,
                        r = t.count;
                      for (let i = e, a = e + r; i < a; i += 3)
                        M(n[i + 0]), M(n[i + 1]), M(n[i + 2]);
                    }
                  }
                  computeVertexNormals() {
                    const t = this.index,
                      e = this.getAttribute("position");
                    if (void 0 !== e) {
                      let n = this.getAttribute("normal");
                      if (void 0 === n)
                        (n = new li(new Float32Array(3 * e.count), 3)),
                          this.setAttribute("normal", n);
                      else
                        for (let t = 0, e = n.count; t < e; t++)
                          n.setXYZ(t, 0, 0, 0);
                      const r = new Gn(),
                        i = new Gn(),
                        a = new Gn(),
                        o = new Gn(),
                        s = new Gn(),
                        c = new Gn(),
                        l = new Gn(),
                        u = new Gn();
                      if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                          const d = t.getX(h + 0),
                            f = t.getX(h + 1),
                            p = t.getX(h + 2);
                          r.fromBufferAttribute(e, d),
                            i.fromBufferAttribute(e, f),
                            a.fromBufferAttribute(e, p),
                            l.subVectors(a, i),
                            u.subVectors(r, i),
                            l.cross(u),
                            o.fromBufferAttribute(n, d),
                            s.fromBufferAttribute(n, f),
                            c.fromBufferAttribute(n, p),
                            o.add(l),
                            s.add(l),
                            c.add(l),
                            n.setXYZ(d, o.x, o.y, o.z),
                            n.setXYZ(f, s.x, s.y, s.z),
                            n.setXYZ(p, c.x, c.y, c.z);
                        }
                      else
                        for (let t = 0, h = e.count; t < h; t += 3)
                          r.fromBufferAttribute(e, t + 0),
                            i.fromBufferAttribute(e, t + 1),
                            a.fromBufferAttribute(e, t + 2),
                            l.subVectors(a, i),
                            u.subVectors(r, i),
                            l.cross(u),
                            n.setXYZ(t + 0, l.x, l.y, l.z),
                            n.setXYZ(t + 1, l.x, l.y, l.z),
                            n.setXYZ(t + 2, l.x, l.y, l.z);
                      this.normalizeNormals(), (n.needsUpdate = !0);
                    }
                  }
                  merge(t, e) {
                    if (!t || !t.isBufferGeometry)
                      return void console.error(
                        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                        t
                      );
                    void 0 === e &&
                      ((e = 0),
                      console.warn(
                        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                      ));
                    const n = this.attributes;
                    for (const r in n) {
                      if (void 0 === t.attributes[r]) continue;
                      const i = n[r],
                        a = i.array,
                        o = t.attributes[r],
                        s = o.array,
                        c = o.itemSize * e,
                        l = Math.min(s.length, a.length - c);
                      for (let t = 0, e = c; t < l; t++, e++) a[e] = s[t];
                    }
                    return this;
                  }
                  normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let e = 0, n = t.count; e < n; e++)
                      bi.fromBufferAttribute(t, e),
                        bi.normalize(),
                        t.setXYZ(e, bi.x, bi.y, bi.z);
                  }
                  toNonIndexed() {
                    function t(t, e) {
                      const n = t.array,
                        r = t.itemSize,
                        i = t.normalized,
                        a = new n.constructor(e.length * r);
                      let o = 0,
                        s = 0;
                      for (let c = 0, l = e.length; c < l; c++) {
                        o = t.isInterleavedBufferAttribute
                          ? e[c] * t.data.stride + t.offset
                          : e[c] * r;
                        for (let t = 0; t < r; t++) a[s++] = n[o++];
                      }
                      return new li(a, r, i);
                    }
                    if (null === this.index)
                      return (
                        console.warn(
                          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                        ),
                        this
                      );
                    const e = new xi(),
                      n = this.index.array,
                      r = this.attributes;
                    for (const o in r) {
                      const i = r[o],
                        a = t(i, n);
                      e.setAttribute(o, a);
                    }
                    const i = this.morphAttributes;
                    for (const o in i) {
                      const r = [],
                        a = i[o];
                      for (let e = 0, i = a.length; e < i; e++) {
                        const i = a[e],
                          o = t(i, n);
                        r.push(o);
                      }
                      e.morphAttributes[o] = r;
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const a = this.groups;
                    for (let o = 0, s = a.length; o < s; o++) {
                      const t = a[o];
                      e.addGroup(t.start, t.count, t.materialIndex);
                    }
                    return e;
                  }
                  toJSON() {
                    const t = {
                      metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON",
                      },
                    };
                    if (
                      ((t.uuid = this.uuid),
                      (t.type = this.type),
                      "" !== this.name && (t.name = this.name),
                      Object.keys(this.userData).length > 0 &&
                        (t.userData = this.userData),
                      void 0 !== this.parameters)
                    ) {
                      const e = this.parameters;
                      for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                      return t;
                    }
                    t.data = { attributes: {} };
                    const e = this.index;
                    null !== e &&
                      (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array),
                      });
                    const n = this.attributes;
                    for (const s in n) {
                      const e = n[s];
                      t.data.attributes[s] = e.toJSON(t.data);
                    }
                    const r = {};
                    let i = !1;
                    for (const s in this.morphAttributes) {
                      const e = this.morphAttributes[s],
                        n = [];
                      for (let r = 0, i = e.length; r < i; r++) {
                        const i = e[r];
                        n.push(i.toJSON(t.data));
                      }
                      n.length > 0 && ((r[s] = n), (i = !0));
                    }
                    i &&
                      ((t.data.morphAttributes = r),
                      (t.data.morphTargetsRelative =
                        this.morphTargetsRelative));
                    const a = this.groups;
                    a.length > 0 &&
                      (t.data.groups = JSON.parse(JSON.stringify(a)));
                    const o = this.boundingSphere;
                    return (
                      null !== o &&
                        (t.data.boundingSphere = {
                          center: o.center.toArray(),
                          radius: o.radius,
                        }),
                      t
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    (this.index = null),
                      (this.attributes = {}),
                      (this.morphAttributes = {}),
                      (this.groups = []),
                      (this.boundingBox = null),
                      (this.boundingSphere = null);
                    const e = {};
                    this.name = t.name;
                    const n = t.index;
                    null !== n && this.setIndex(n.clone(e));
                    const r = t.attributes;
                    for (const c in r) {
                      const t = r[c];
                      this.setAttribute(c, t.clone(e));
                    }
                    const i = t.morphAttributes;
                    for (const c in i) {
                      const t = [],
                        n = i[c];
                      for (let r = 0, i = n.length; r < i; r++)
                        t.push(n[r].clone(e));
                      this.morphAttributes[c] = t;
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const a = t.groups;
                    for (let c = 0, l = a.length; c < l; c++) {
                      const t = a[c];
                      this.addGroup(t.start, t.count, t.materialIndex);
                    }
                    const o = t.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const s = t.boundingSphere;
                    return (
                      null !== s && (this.boundingSphere = s.clone()),
                      (this.drawRange.start = t.drawRange.start),
                      (this.drawRange.count = t.drawRange.count),
                      (this.userData = t.userData),
                      void 0 !== t.parameters &&
                        (this.parameters = Object.assign({}, t.parameters)),
                      this
                    );
                  }
                  dispose() {
                    this.dispatchEvent({ type: "dispose" });
                  }
                }
                const _i = new _r(),
                  wi = new xr(),
                  Si = new dr(),
                  Mi = new Gn(),
                  Ti = new Gn(),
                  Ei = new Gn(),
                  Ai = new Gn(),
                  Ci = new Gn(),
                  Li = new Gn(),
                  Ri = new Gn(),
                  Pi = new Gn(),
                  Ii = new Gn(),
                  Oi = new gn(),
                  ki = new gn(),
                  Ni = new gn(),
                  Di = new Gn(),
                  zi = new Gn();
                class Fi extends qr {
                  constructor(t = new xi(), e = new oi()) {
                    super(),
                      (this.isMesh = !0),
                      (this.type = "Mesh"),
                      (this.geometry = t),
                      (this.material = e),
                      this.updateMorphTargets();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      void 0 !== t.morphTargetInfluences &&
                        (this.morphTargetInfluences =
                          t.morphTargetInfluences.slice()),
                      void 0 !== t.morphTargetDictionary &&
                        (this.morphTargetDictionary = Object.assign(
                          {},
                          t.morphTargetDictionary
                        )),
                      (this.material = t.material),
                      (this.geometry = t.geometry),
                      this
                    );
                  }
                  updateMorphTargets() {
                    const t = this.geometry,
                      e = t.morphAttributes,
                      n = Object.keys(e);
                    if (n.length > 0) {
                      const t = e[n[0]];
                      if (void 0 !== t) {
                        (this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {});
                        for (let e = 0, n = t.length; e < n; e++) {
                          const n = t[e].name || String(e);
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[n] = e);
                        }
                      }
                    }
                  }
                  raycast(t, e) {
                    const n = this.geometry,
                      r = this.material,
                      i = this.matrixWorld;
                    if (void 0 === r) return;
                    if (
                      (null === n.boundingSphere && n.computeBoundingSphere(),
                      Si.copy(n.boundingSphere),
                      Si.applyMatrix4(i),
                      !1 === t.ray.intersectsSphere(Si))
                    )
                      return;
                    if (
                      (_i.copy(i).invert(),
                      wi.copy(t.ray).applyMatrix4(_i),
                      null !== n.boundingBox &&
                        !1 === wi.intersectsBox(n.boundingBox))
                    )
                      return;
                    let a;
                    const o = n.index,
                      s = n.attributes.position,
                      c = n.morphAttributes.position,
                      l = n.morphTargetsRelative,
                      u = n.attributes.uv,
                      h = n.attributes.uv2,
                      d = n.groups,
                      f = n.drawRange;
                    if (null !== o)
                      if (Array.isArray(r))
                        for (let p = 0, m = d.length; p < m; p++) {
                          const n = d[p],
                            i = r[n.materialIndex],
                            m = Math.max(n.start, f.start),
                            g = Math.min(
                              o.count,
                              Math.min(n.start + n.count, f.start + f.count)
                            );
                          for (let r = m, d = g; r < d; r += 3) {
                            const d = o.getX(r),
                              f = o.getX(r + 1),
                              p = o.getX(r + 2);
                            (a = Bi(this, i, t, wi, s, c, l, u, h, d, f, p)),
                              a &&
                                ((a.faceIndex = Math.floor(r / 3)),
                                (a.face.materialIndex = n.materialIndex),
                                e.push(a));
                          }
                        }
                      else {
                        const n = Math.max(0, f.start),
                          i = Math.min(o.count, f.start + f.count);
                        for (let d = n, f = i; d < f; d += 3) {
                          const n = o.getX(d),
                            i = o.getX(d + 1),
                            f = o.getX(d + 2);
                          (a = Bi(this, r, t, wi, s, c, l, u, h, n, i, f)),
                            a && ((a.faceIndex = Math.floor(d / 3)), e.push(a));
                        }
                      }
                    else if (void 0 !== s)
                      if (Array.isArray(r))
                        for (let p = 0, m = d.length; p < m; p++) {
                          const n = d[p],
                            i = r[n.materialIndex],
                            o = Math.max(n.start, f.start),
                            m = Math.min(
                              s.count,
                              Math.min(n.start + n.count, f.start + f.count)
                            );
                          for (let r = o, d = m; r < d; r += 3) {
                            const o = r,
                              d = r + 1,
                              f = r + 2;
                            (a = Bi(this, i, t, wi, s, c, l, u, h, o, d, f)),
                              a &&
                                ((a.faceIndex = Math.floor(r / 3)),
                                (a.face.materialIndex = n.materialIndex),
                                e.push(a));
                          }
                        }
                      else {
                        const n = Math.max(0, f.start),
                          i = Math.min(s.count, f.start + f.count);
                        for (let o = n, d = i; o < d; o += 3) {
                          const n = o,
                            i = o + 1,
                            d = o + 2;
                          (a = Bi(this, r, t, wi, s, c, l, u, h, n, i, d)),
                            a && ((a.faceIndex = Math.floor(o / 3)), e.push(a));
                        }
                      }
                  }
                }
                function Ui(t, e, n, r, i, a, o, s) {
                  let c;
                  if (
                    ((c =
                      e.side === v
                        ? r.intersectTriangle(o, a, i, !0, s)
                        : r.intersectTriangle(i, a, o, e.side !== y, s)),
                    null === c)
                  )
                    return null;
                  zi.copy(s), zi.applyMatrix4(t.matrixWorld);
                  const l = n.ray.origin.distanceTo(zi);
                  return l < n.near || l > n.far
                    ? null
                    : { distance: l, point: zi.clone(), object: t };
                }
                function Bi(t, e, n, r, i, a, o, s, c, l, u, h) {
                  Mi.fromBufferAttribute(i, l),
                    Ti.fromBufferAttribute(i, u),
                    Ei.fromBufferAttribute(i, h);
                  const d = t.morphTargetInfluences;
                  if (a && d) {
                    Ri.set(0, 0, 0), Pi.set(0, 0, 0), Ii.set(0, 0, 0);
                    for (let t = 0, e = a.length; t < e; t++) {
                      const e = d[t],
                        n = a[t];
                      0 !== e &&
                        (Ai.fromBufferAttribute(n, l),
                        Ci.fromBufferAttribute(n, u),
                        Li.fromBufferAttribute(n, h),
                        o
                          ? (Ri.addScaledVector(Ai, e),
                            Pi.addScaledVector(Ci, e),
                            Ii.addScaledVector(Li, e))
                          : (Ri.addScaledVector(Ai.sub(Mi), e),
                            Pi.addScaledVector(Ci.sub(Ti), e),
                            Ii.addScaledVector(Li.sub(Ei), e)));
                    }
                    Mi.add(Ri), Ti.add(Pi), Ei.add(Ii);
                  }
                  t.isSkinnedMesh &&
                    (t.boneTransform(l, Mi),
                    t.boneTransform(u, Ti),
                    t.boneTransform(h, Ei));
                  const f = Ui(t, e, n, r, Mi, Ti, Ei, Di);
                  if (f) {
                    s &&
                      (Oi.fromBufferAttribute(s, l),
                      ki.fromBufferAttribute(s, u),
                      Ni.fromBufferAttribute(s, h),
                      (f.uv = ri.getUV(Di, Mi, Ti, Ei, Oi, ki, Ni, new gn()))),
                      c &&
                        (Oi.fromBufferAttribute(c, l),
                        ki.fromBufferAttribute(c, u),
                        Ni.fromBufferAttribute(c, h),
                        (f.uv2 = ri.getUV(
                          Di,
                          Mi,
                          Ti,
                          Ei,
                          Oi,
                          ki,
                          Ni,
                          new gn()
                        )));
                    const t = {
                      a: l,
                      b: u,
                      c: h,
                      normal: new Gn(),
                      materialIndex: 0,
                    };
                    ri.getNormal(Mi, Ti, Ei, t.normal), (f.face = t);
                  }
                  return f;
                }
                class ji extends xi {
                  constructor(t = 1, e = 1, n = 1, r = 1, i = 1, a = 1) {
                    super(),
                      (this.type = "BoxGeometry"),
                      (this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: a,
                      });
                    const o = this;
                    (r = Math.floor(r)),
                      (i = Math.floor(i)),
                      (a = Math.floor(a));
                    const s = [],
                      c = [],
                      l = [],
                      u = [];
                    let h = 0,
                      d = 0;
                    function f(t, e, n, r, i, a, f, p, m, g, v) {
                      const y = a / m,
                        b = f / g,
                        x = a / 2,
                        _ = f / 2,
                        w = p / 2,
                        S = m + 1,
                        M = g + 1;
                      let T = 0,
                        E = 0;
                      const A = new Gn();
                      for (let o = 0; o < M; o++) {
                        const a = o * b - _;
                        for (let s = 0; s < S; s++) {
                          const h = s * y - x;
                          (A[t] = h * r),
                            (A[e] = a * i),
                            (A[n] = w),
                            c.push(A.x, A.y, A.z),
                            (A[t] = 0),
                            (A[e] = 0),
                            (A[n] = p > 0 ? 1 : -1),
                            l.push(A.x, A.y, A.z),
                            u.push(s / m),
                            u.push(1 - o / g),
                            (T += 1);
                        }
                      }
                      for (let o = 0; o < g; o++)
                        for (let t = 0; t < m; t++) {
                          const e = h + t + S * o,
                            n = h + t + S * (o + 1),
                            r = h + (t + 1) + S * (o + 1),
                            i = h + (t + 1) + S * o;
                          s.push(e, n, i), s.push(n, r, i), (E += 6);
                        }
                      o.addGroup(d, E, v), (d += E), (h += T);
                    }
                    f("z", "y", "x", -1, -1, n, e, t, a, i, 0),
                      f("z", "y", "x", 1, -1, n, e, -t, a, i, 1),
                      f("x", "z", "y", 1, 1, t, n, e, r, a, 2),
                      f("x", "z", "y", 1, -1, t, n, -e, r, a, 3),
                      f("x", "y", "z", 1, -1, t, e, n, r, i, 4),
                      f("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
                      this.setIndex(s),
                      this.setAttribute("position", new di(c, 3)),
                      this.setAttribute("normal", new di(l, 3)),
                      this.setAttribute("uv", new di(u, 2));
                  }
                  static fromJSON(t) {
                    return new ji(
                      t.width,
                      t.height,
                      t.depth,
                      t.widthSegments,
                      t.heightSegments,
                      t.depthSegments
                    );
                  }
                }
                function Hi(t) {
                  const e = {};
                  for (const n in t) {
                    e[n] = {};
                    for (const r in t[n]) {
                      const i = t[n][r];
                      i &&
                      (i.isColor ||
                        i.isMatrix3 ||
                        i.isMatrix4 ||
                        i.isVector2 ||
                        i.isVector3 ||
                        i.isVector4 ||
                        i.isTexture ||
                        i.isQuaternion)
                        ? (e[n][r] = i.clone())
                        : Array.isArray(i)
                        ? (e[n][r] = i.slice())
                        : (e[n][r] = i);
                    }
                  }
                  return e;
                }
                function Vi(t) {
                  const e = {};
                  for (let n = 0; n < t.length; n++) {
                    const r = Hi(t[n]);
                    for (const t in r) e[t] = r[t];
                  }
                  return e;
                }
                const Gi = { clone: Hi, merge: Vi };
                var Wi =
                    "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                  qi =
                    "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
                class Xi extends ai {
                  constructor(t) {
                    super(),
                      (this.isShaderMaterial = !0),
                      (this.type = "ShaderMaterial"),
                      (this.defines = {}),
                      (this.uniforms = {}),
                      (this.vertexShader = Wi),
                      (this.fragmentShader = qi),
                      (this.linewidth = 1),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.fog = !1),
                      (this.lights = !1),
                      (this.clipping = !1),
                      (this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1,
                      }),
                      (this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0],
                      }),
                      (this.index0AttributeName = void 0),
                      (this.uniformsNeedUpdate = !1),
                      (this.glslVersion = null),
                      void 0 !== t &&
                        (void 0 !== t.attributes &&
                          console.error(
                            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                          ),
                        this.setValues(t));
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.fragmentShader = t.fragmentShader),
                      (this.vertexShader = t.vertexShader),
                      (this.uniforms = Hi(t.uniforms)),
                      (this.defines = Object.assign({}, t.defines)),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.fog = t.fog),
                      (this.lights = t.lights),
                      (this.clipping = t.clipping),
                      (this.extensions = Object.assign({}, t.extensions)),
                      (this.glslVersion = t.glslVersion),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    (e.glslVersion = this.glslVersion), (e.uniforms = {});
                    for (const r in this.uniforms) {
                      const n = this.uniforms[r],
                        i = n.value;
                      i && i.isTexture
                        ? (e.uniforms[r] = {
                            type: "t",
                            value: i.toJSON(t).uuid,
                          })
                        : i && i.isColor
                        ? (e.uniforms[r] = { type: "c", value: i.getHex() })
                        : i && i.isVector2
                        ? (e.uniforms[r] = { type: "v2", value: i.toArray() })
                        : i && i.isVector3
                        ? (e.uniforms[r] = { type: "v3", value: i.toArray() })
                        : i && i.isVector4
                        ? (e.uniforms[r] = { type: "v4", value: i.toArray() })
                        : i && i.isMatrix3
                        ? (e.uniforms[r] = { type: "m3", value: i.toArray() })
                        : i && i.isMatrix4
                        ? (e.uniforms[r] = { type: "m4", value: i.toArray() })
                        : (e.uniforms[r] = { value: i });
                    }
                    Object.keys(this.defines).length > 0 &&
                      (e.defines = this.defines),
                      (e.vertexShader = this.vertexShader),
                      (e.fragmentShader = this.fragmentShader);
                    const n = {};
                    for (const r in this.extensions)
                      !0 === this.extensions[r] && (n[r] = !0);
                    return Object.keys(n).length > 0 && (e.extensions = n), e;
                  }
                }
                class $i extends qr {
                  constructor() {
                    super(),
                      (this.isCamera = !0),
                      (this.type = "Camera"),
                      (this.matrixWorldInverse = new _r()),
                      (this.projectionMatrix = new _r()),
                      (this.projectionMatrixInverse = new _r());
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      this.matrixWorldInverse.copy(t.matrixWorldInverse),
                      this.projectionMatrix.copy(t.projectionMatrix),
                      this.projectionMatrixInverse.copy(
                        t.projectionMatrixInverse
                      ),
                      this
                    );
                  }
                  getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize();
                  }
                  updateMatrixWorld(t) {
                    super.updateMatrixWorld(t),
                      this.matrixWorldInverse.copy(this.matrixWorld).invert();
                  }
                  updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e),
                      this.matrixWorldInverse.copy(this.matrixWorld).invert();
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                class Yi extends $i {
                  constructor(t = 50, e = 1, n = 0.1, r = 2e3) {
                    super(),
                      (this.isPerspectiveCamera = !0),
                      (this.type = "PerspectiveCamera"),
                      (this.fov = t),
                      (this.zoom = 1),
                      (this.near = n),
                      (this.far = r),
                      (this.focus = 10),
                      (this.aspect = e),
                      (this.view = null),
                      (this.filmGauge = 35),
                      (this.filmOffset = 0),
                      this.updateProjectionMatrix();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.fov = t.fov),
                      (this.zoom = t.zoom),
                      (this.near = t.near),
                      (this.far = t.far),
                      (this.focus = t.focus),
                      (this.aspect = t.aspect),
                      (this.view =
                        null === t.view ? null : Object.assign({}, t.view)),
                      (this.filmGauge = t.filmGauge),
                      (this.filmOffset = t.filmOffset),
                      this
                    );
                  }
                  setFocalLength(t) {
                    const e = (0.5 * this.getFilmHeight()) / t;
                    (this.fov = 2 * We * Math.atan(e)),
                      this.updateProjectionMatrix();
                  }
                  getFocalLength() {
                    const t = Math.tan(0.5 * Ge * this.fov);
                    return (0.5 * this.getFilmHeight()) / t;
                  }
                  getEffectiveFOV() {
                    return (
                      2 *
                      We *
                      Math.atan(Math.tan(0.5 * Ge * this.fov) / this.zoom)
                    );
                  }
                  getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1);
                  }
                  getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1);
                  }
                  setViewOffset(t, e, n, r, i, a) {
                    (this.aspect = t / e),
                      null === this.view &&
                        (this.view = {
                          enabled: !0,
                          fullWidth: 1,
                          fullHeight: 1,
                          offsetX: 0,
                          offsetY: 0,
                          width: 1,
                          height: 1,
                        }),
                      (this.view.enabled = !0),
                      (this.view.fullWidth = t),
                      (this.view.fullHeight = e),
                      (this.view.offsetX = n),
                      (this.view.offsetY = r),
                      (this.view.width = i),
                      (this.view.height = a),
                      this.updateProjectionMatrix();
                  }
                  clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                      this.updateProjectionMatrix();
                  }
                  updateProjectionMatrix() {
                    const t = this.near;
                    let e = (t * Math.tan(0.5 * Ge * this.fov)) / this.zoom,
                      n = 2 * e,
                      r = this.aspect * n,
                      i = -0.5 * r;
                    const a = this.view;
                    if (null !== this.view && this.view.enabled) {
                      const t = a.fullWidth,
                        o = a.fullHeight;
                      (i += (a.offsetX * r) / t),
                        (e -= (a.offsetY * n) / o),
                        (r *= a.width / t),
                        (n *= a.height / o);
                    }
                    const o = this.filmOffset;
                    0 !== o && (i += (t * o) / this.getFilmWidth()),
                      this.projectionMatrix.makePerspective(
                        i,
                        i + r,
                        e,
                        e - n,
                        t,
                        this.far
                      ),
                      this.projectionMatrixInverse
                        .copy(this.projectionMatrix)
                        .invert();
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                      (e.object.fov = this.fov),
                      (e.object.zoom = this.zoom),
                      (e.object.near = this.near),
                      (e.object.far = this.far),
                      (e.object.focus = this.focus),
                      (e.object.aspect = this.aspect),
                      null !== this.view &&
                        (e.object.view = Object.assign({}, this.view)),
                      (e.object.filmGauge = this.filmGauge),
                      (e.object.filmOffset = this.filmOffset),
                      e
                    );
                  }
                }
                const Ji = 90,
                  Ki = 1;
                class Zi extends qr {
                  constructor(t, e, n) {
                    if (
                      (super(),
                      (this.type = "CubeCamera"),
                      !0 !== n.isWebGLCubeRenderTarget)
                    )
                      return void console.error(
                        "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
                      );
                    this.renderTarget = n;
                    const r = new Yi(Ji, Ki, t, e);
                    (r.layers = this.layers),
                      r.up.set(0, -1, 0),
                      r.lookAt(new Gn(1, 0, 0)),
                      this.add(r);
                    const i = new Yi(Ji, Ki, t, e);
                    (i.layers = this.layers),
                      i.up.set(0, -1, 0),
                      i.lookAt(new Gn(-1, 0, 0)),
                      this.add(i);
                    const a = new Yi(Ji, Ki, t, e);
                    (a.layers = this.layers),
                      a.up.set(0, 0, 1),
                      a.lookAt(new Gn(0, 1, 0)),
                      this.add(a);
                    const o = new Yi(Ji, Ki, t, e);
                    (o.layers = this.layers),
                      o.up.set(0, 0, -1),
                      o.lookAt(new Gn(0, -1, 0)),
                      this.add(o);
                    const s = new Yi(Ji, Ki, t, e);
                    (s.layers = this.layers),
                      s.up.set(0, -1, 0),
                      s.lookAt(new Gn(0, 0, 1)),
                      this.add(s);
                    const c = new Yi(Ji, Ki, t, e);
                    (c.layers = this.layers),
                      c.up.set(0, -1, 0),
                      c.lookAt(new Gn(0, 0, -1)),
                      this.add(c);
                  }
                  update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const n = this.renderTarget,
                      [r, i, a, o, s, c] = this.children,
                      l = t.getRenderTarget(),
                      u = t.toneMapping,
                      h = t.xr.enabled;
                    (t.toneMapping = Q), (t.xr.enabled = !1);
                    const d = n.texture.generateMipmaps;
                    (n.texture.generateMipmaps = !1),
                      t.setRenderTarget(n, 0),
                      t.render(e, r),
                      t.setRenderTarget(n, 1),
                      t.render(e, i),
                      t.setRenderTarget(n, 2),
                      t.render(e, a),
                      t.setRenderTarget(n, 3),
                      t.render(e, o),
                      t.setRenderTarget(n, 4),
                      t.render(e, s),
                      (n.texture.generateMipmaps = d),
                      t.setRenderTarget(n, 5),
                      t.render(e, c),
                      t.setRenderTarget(l),
                      (t.toneMapping = u),
                      (t.xr.enabled = h),
                      (n.texture.needsPMREMUpdate = !0);
                  }
                }
                class Qi extends Fn {
                  constructor(t, e, n, r, i, a, o, s, c, l) {
                    (t = void 0 !== t ? t : []),
                      (e = void 0 !== e ? e : ot),
                      super(t, e, n, r, i, a, o, s, c, l),
                      (this.isCubeTexture = !0),
                      (this.flipY = !1);
                  }
                  get images() {
                    return this.image;
                  }
                  set images(t) {
                    this.image = t;
                  }
                }
                class ta extends Bn {
                  constructor(t, e = {}) {
                    super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
                    const n = { width: t, height: t, depth: 1 },
                      r = [n, n, n, n, n, n];
                    (this.texture = new Qi(
                      r,
                      e.mapping,
                      e.wrapS,
                      e.wrapT,
                      e.magFilter,
                      e.minFilter,
                      e.format,
                      e.type,
                      e.anisotropy,
                      e.encoding
                    )),
                      (this.texture.isRenderTargetTexture = !0),
                      (this.texture.generateMipmaps =
                        void 0 !== e.generateMipmaps && e.generateMipmaps),
                      (this.texture.minFilter =
                        void 0 !== e.minFilter ? e.minFilter : vt);
                  }
                  fromEquirectangularTexture(t, e) {
                    (this.texture.type = e.type),
                      (this.texture.encoding = e.encoding),
                      (this.texture.generateMipmaps = e.generateMipmaps),
                      (this.texture.minFilter = e.minFilter),
                      (this.texture.magFilter = e.magFilter);
                    const n = {
                        uniforms: { tEquirect: { value: null } },
                        vertexShader:
                          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader:
                          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                      },
                      r = new ji(5, 5, 5),
                      i = new Xi({
                        name: "CubemapFromEquirect",
                        uniforms: Hi(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: v,
                        blending: x,
                      });
                    i.uniforms.tEquirect.value = e;
                    const a = new Fi(r, i),
                      o = e.minFilter;
                    e.minFilter === bt && (e.minFilter = vt);
                    const s = new Zi(1, 10, this);
                    return (
                      s.update(t, a),
                      (e.minFilter = o),
                      a.geometry.dispose(),
                      a.material.dispose(),
                      this
                    );
                  }
                  clear(t, e, n, r) {
                    const i = t.getRenderTarget();
                    for (let a = 0; a < 6; a++)
                      t.setRenderTarget(this, a), t.clear(e, n, r);
                    t.setRenderTarget(i);
                  }
                }
                const ea = new Gn(),
                  na = new Gn(),
                  ra = new vn();
                class ia {
                  constructor(t = new Gn(1, 0, 0), e = 0) {
                    (this.isPlane = !0), (this.normal = t), (this.constant = e);
                  }
                  set(t, e) {
                    return this.normal.copy(t), (this.constant = e), this;
                  }
                  setComponents(t, e, n, r) {
                    return this.normal.set(t, e, n), (this.constant = r), this;
                  }
                  setFromNormalAndCoplanarPoint(t, e) {
                    return (
                      this.normal.copy(t),
                      (this.constant = -e.dot(this.normal)),
                      this
                    );
                  }
                  setFromCoplanarPoints(t, e, n) {
                    const r = ea
                      .subVectors(n, e)
                      .cross(na.subVectors(t, e))
                      .normalize();
                    return this.setFromNormalAndCoplanarPoint(r, t), this;
                  }
                  copy(t) {
                    return (
                      this.normal.copy(t.normal),
                      (this.constant = t.constant),
                      this
                    );
                  }
                  normalize() {
                    const t = 1 / this.normal.length();
                    return (
                      this.normal.multiplyScalar(t), (this.constant *= t), this
                    );
                  }
                  negate() {
                    return (this.constant *= -1), this.normal.negate(), this;
                  }
                  distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant;
                  }
                  distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius;
                  }
                  projectPoint(t, e) {
                    return e
                      .copy(this.normal)
                      .multiplyScalar(-this.distanceToPoint(t))
                      .add(t);
                  }
                  intersectLine(t, e) {
                    const n = t.delta(ea),
                      r = this.normal.dot(n);
                    if (0 === r)
                      return 0 === this.distanceToPoint(t.start)
                        ? e.copy(t.start)
                        : null;
                    const i = -(t.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1
                      ? null
                      : e.copy(n).multiplyScalar(i).add(t.start);
                  }
                  intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                      n = this.distanceToPoint(t.end);
                    return (e < 0 && n > 0) || (n < 0 && e > 0);
                  }
                  intersectsBox(t) {
                    return t.intersectsPlane(this);
                  }
                  intersectsSphere(t) {
                    return t.intersectsPlane(this);
                  }
                  coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant);
                  }
                  applyMatrix4(t, e) {
                    const n = e || ra.getNormalMatrix(t),
                      r = this.coplanarPoint(ea).applyMatrix4(t),
                      i = this.normal.applyMatrix3(n).normalize();
                    return (this.constant = -r.dot(i)), this;
                  }
                  translate(t) {
                    return (this.constant -= t.dot(this.normal)), this;
                  }
                  equals(t) {
                    return (
                      t.normal.equals(this.normal) &&
                      t.constant === this.constant
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                const aa = new dr(),
                  oa = new Gn();
                class sa {
                  constructor(
                    t = new ia(),
                    e = new ia(),
                    n = new ia(),
                    r = new ia(),
                    i = new ia(),
                    a = new ia()
                  ) {
                    this.planes = [t, e, n, r, i, a];
                  }
                  set(t, e, n, r, i, a) {
                    const o = this.planes;
                    return (
                      o[0].copy(t),
                      o[1].copy(e),
                      o[2].copy(n),
                      o[3].copy(r),
                      o[4].copy(i),
                      o[5].copy(a),
                      this
                    );
                  }
                  copy(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this;
                  }
                  setFromProjectionMatrix(t) {
                    const e = this.planes,
                      n = t.elements,
                      r = n[0],
                      i = n[1],
                      a = n[2],
                      o = n[3],
                      s = n[4],
                      c = n[5],
                      l = n[6],
                      u = n[7],
                      h = n[8],
                      d = n[9],
                      f = n[10],
                      p = n[11],
                      m = n[12],
                      g = n[13],
                      v = n[14],
                      y = n[15];
                    return (
                      e[0]
                        .setComponents(o - r, u - s, p - h, y - m)
                        .normalize(),
                      e[1]
                        .setComponents(o + r, u + s, p + h, y + m)
                        .normalize(),
                      e[2]
                        .setComponents(o + i, u + c, p + d, y + g)
                        .normalize(),
                      e[3]
                        .setComponents(o - i, u - c, p - d, y - g)
                        .normalize(),
                      e[4]
                        .setComponents(o - a, u - l, p - f, y - v)
                        .normalize(),
                      e[5]
                        .setComponents(o + a, u + l, p + f, y + v)
                        .normalize(),
                      this
                    );
                  }
                  intersectsObject(t) {
                    const e = t.geometry;
                    return (
                      null === e.boundingSphere && e.computeBoundingSphere(),
                      aa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                      this.intersectsSphere(aa)
                    );
                  }
                  intersectsSprite(t) {
                    return (
                      aa.center.set(0, 0, 0),
                      (aa.radius = 0.7071067811865476),
                      aa.applyMatrix4(t.matrixWorld),
                      this.intersectsSphere(aa)
                    );
                  }
                  intersectsSphere(t) {
                    const e = this.planes,
                      n = t.center,
                      r = -t.radius;
                    for (let i = 0; i < 6; i++) {
                      const t = e[i].distanceToPoint(n);
                      if (t < r) return !1;
                    }
                    return !0;
                  }
                  intersectsBox(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) {
                      const r = e[n];
                      if (
                        ((oa.x = r.normal.x > 0 ? t.max.x : t.min.x),
                        (oa.y = r.normal.y > 0 ? t.max.y : t.min.y),
                        (oa.z = r.normal.z > 0 ? t.max.z : t.min.z),
                        r.distanceToPoint(oa) < 0)
                      )
                        return !1;
                    }
                    return !0;
                  }
                  containsPoint(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++)
                      if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0;
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                function ca() {
                  let t = null,
                    e = !1,
                    n = null,
                    r = null;
                  function i(e, a) {
                    n(e, a), (r = t.requestAnimationFrame(i));
                  }
                  return {
                    start: function () {
                      !0 !== e &&
                        null !== n &&
                        ((r = t.requestAnimationFrame(i)), (e = !0));
                    },
                    stop: function () {
                      t.cancelAnimationFrame(r), (e = !1);
                    },
                    setAnimationLoop: function (t) {
                      n = t;
                    },
                    setContext: function (e) {
                      t = e;
                    },
                  };
                }
                function la(t, e) {
                  const n = e.isWebGL2,
                    r = new WeakMap();
                  function i(e, r) {
                    const i = e.array,
                      a = e.usage,
                      o = t.createBuffer();
                    let s;
                    if (
                      (t.bindBuffer(r, o),
                      t.bufferData(r, i, a),
                      e.onUploadCallback(),
                      i instanceof Float32Array)
                    )
                      s = 5126;
                    else if (i instanceof Uint16Array)
                      if (e.isFloat16BufferAttribute) {
                        if (!n)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        s = 5131;
                      } else s = 5123;
                    else if (i instanceof Int16Array) s = 5122;
                    else if (i instanceof Uint32Array) s = 5125;
                    else if (i instanceof Int32Array) s = 5124;
                    else if (i instanceof Int8Array) s = 5120;
                    else if (i instanceof Uint8Array) s = 5121;
                    else {
                      if (!(i instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " +
                            i
                        );
                      s = 5121;
                    }
                    return {
                      buffer: o,
                      type: s,
                      bytesPerElement: i.BYTES_PER_ELEMENT,
                      version: e.version,
                    };
                  }
                  function a(e, r, i) {
                    const a = r.array,
                      o = r.updateRange;
                    t.bindBuffer(i, e),
                      -1 === o.count
                        ? t.bufferSubData(i, 0, a)
                        : (n
                            ? t.bufferSubData(
                                i,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a,
                                o.offset,
                                o.count
                              )
                            : t.bufferSubData(
                                i,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a.subarray(o.offset, o.offset + o.count)
                              ),
                          (o.count = -1));
                  }
                  function o(t) {
                    return (
                      t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                    );
                  }
                  function s(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = r.get(e);
                    n && (t.deleteBuffer(n.buffer), r.delete(e));
                  }
                  function c(t, e) {
                    if (t.isGLBufferAttribute) {
                      const e = r.get(t);
                      return void (
                        (!e || e.version < t.version) &&
                        r.set(t, {
                          buffer: t.buffer,
                          type: t.type,
                          bytesPerElement: t.elementSize,
                          version: t.version,
                        })
                      );
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const n = r.get(t);
                    void 0 === n
                      ? r.set(t, i(t, e))
                      : n.version < t.version &&
                        (a(n.buffer, t, e), (n.version = t.version));
                  }
                  return { get: o, remove: s, update: c };
                }
                class ua extends xi {
                  constructor(t = 1, e = 1, n = 1, r = 1) {
                    super(),
                      (this.type = "PlaneGeometry"),
                      (this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: r,
                      });
                    const i = t / 2,
                      a = e / 2,
                      o = Math.floor(n),
                      s = Math.floor(r),
                      c = o + 1,
                      l = s + 1,
                      u = t / o,
                      h = e / s,
                      d = [],
                      f = [],
                      p = [],
                      m = [];
                    for (let g = 0; g < l; g++) {
                      const t = g * h - a;
                      for (let e = 0; e < c; e++) {
                        const n = e * u - i;
                        f.push(n, -t, 0),
                          p.push(0, 0, 1),
                          m.push(e / o),
                          m.push(1 - g / s);
                      }
                    }
                    for (let g = 0; g < s; g++)
                      for (let t = 0; t < o; t++) {
                        const e = t + c * g,
                          n = t + c * (g + 1),
                          r = t + 1 + c * (g + 1),
                          i = t + 1 + c * g;
                        d.push(e, n, i), d.push(n, r, i);
                      }
                    this.setIndex(d),
                      this.setAttribute("position", new di(f, 3)),
                      this.setAttribute("normal", new di(p, 3)),
                      this.setAttribute("uv", new di(m, 2));
                  }
                  static fromJSON(t) {
                    return new ua(
                      t.width,
                      t.height,
                      t.widthSegments,
                      t.heightSegments
                    );
                  }
                }
                var ha =
                    "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                  da =
                    "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                  fa =
                    "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                  pa =
                    "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                  ma =
                    "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                  ga =
                    "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                  va = "vec3 transformed = vec3( position );",
                  ya =
                    "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                  ba =
                    "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                  xa =
                    "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
                  _a =
                    "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                  wa =
                    "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                  Sa =
                    "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                  Ma =
                    "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                  Ta =
                    "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                  Ea =
                    "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                  Aa =
                    "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                  Ca =
                    "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                  La =
                    "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                  Ra =
                    "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                  Pa =
                    "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                  Ia =
                    "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                  Oa =
                    "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                  ka =
                    "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                  Na =
                    "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                  Da =
                    "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                  za = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                  Fa =
                    "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                  Ua =
                    "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                  Ba =
                    "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                  ja =
                    "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                  Ha =
                    "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                  Va =
                    "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                  Ga = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                  Wa = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                  qa =
                    "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                  Xa =
                    "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                  $a =
                    "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                  Ya =
                    "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                  Ja =
                    "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                  Ka =
                    "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                  Za =
                    "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                  Qa =
                    "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                  to =
                    "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                  eo =
                    "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                  no =
                    "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                  ro =
                    "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                  io =
                    "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                  ao =
                    "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                  oo =
                    "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                  so =
                    "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                  co =
                    "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                  lo =
                    "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                  uo =
                    "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                  ho =
                    "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                  fo =
                    "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                  po =
                    "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                  mo = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                  go =
                    "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                  vo =
                    "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                  yo =
                    "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                  bo =
                    "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                  xo =
                    "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                  _o =
                    "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                  wo =
                    "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                  So =
                    "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                  Mo =
                    "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                  To =
                    "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                  Eo =
                    "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                  Ao =
                    "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                  Co =
                    "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                  Lo =
                    "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                  Ro =
                    "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                  Po =
                    "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                  Io =
                    "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                  Oo =
                    "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                  ko =
                    "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                  No =
                    "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                  Do =
                    "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                  zo =
                    "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                  Fo =
                    "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                  Uo =
                    "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                  Bo =
                    "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                  jo =
                    "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                  Ho =
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                  Vo =
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                  Go =
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                  Wo =
                    "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                  qo =
                    "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                  Xo =
                    "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                  $o =
                    "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                  Yo =
                    "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                  Jo =
                    "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                  Ko =
                    "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                  Zo =
                    "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                  Qo =
                    "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                  ts =
                    "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                  es =
                    "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                  ns =
                    "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                  rs =
                    "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                  is =
                    "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                  as =
                    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                  os =
                    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                  ss =
                    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                  cs =
                    "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
                const ls =
                    "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                  us =
                    "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                  hs =
                    "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                  ds =
                    "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                  fs =
                    "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                  ps =
                    "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                  ms =
                    "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                  gs =
                    "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                  vs =
                    "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                  ys =
                    "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                  bs =
                    "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                  xs =
                    "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                  _s =
                    "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                  ws =
                    "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  Ss =
                    "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                  Ms =
                    "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  Ts =
                    "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                  Es =
                    "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  As =
                    "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                  Cs =
                    "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                  Ls =
                    "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                  Rs =
                    "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  Ps =
                    "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                  Is =
                    "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  Os =
                    "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                  ks =
                    "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                  Ns =
                    "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                  Ds =
                    "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                  zs =
                    "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                  Fs =
                    "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                  Us =
                    "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                  Bs =
                    "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                  js = {
                    alphamap_fragment: ha,
                    alphamap_pars_fragment: da,
                    alphatest_fragment: fa,
                    alphatest_pars_fragment: pa,
                    aomap_fragment: ma,
                    aomap_pars_fragment: ga,
                    begin_vertex: va,
                    beginnormal_vertex: ya,
                    bsdfs: ba,
                    iridescence_fragment: xa,
                    bumpmap_pars_fragment: _a,
                    clipping_planes_fragment: wa,
                    clipping_planes_pars_fragment: Sa,
                    clipping_planes_pars_vertex: Ma,
                    clipping_planes_vertex: Ta,
                    color_fragment: Ea,
                    color_pars_fragment: Aa,
                    color_pars_vertex: Ca,
                    color_vertex: La,
                    common: Ra,
                    cube_uv_reflection_fragment: Pa,
                    defaultnormal_vertex: Ia,
                    displacementmap_pars_vertex: Oa,
                    displacementmap_vertex: ka,
                    emissivemap_fragment: Na,
                    emissivemap_pars_fragment: Da,
                    encodings_fragment: za,
                    encodings_pars_fragment: Fa,
                    envmap_fragment: Ua,
                    envmap_common_pars_fragment: Ba,
                    envmap_pars_fragment: ja,
                    envmap_pars_vertex: Ha,
                    envmap_physical_pars_fragment: Qa,
                    envmap_vertex: Va,
                    fog_vertex: Ga,
                    fog_pars_vertex: Wa,
                    fog_fragment: qa,
                    fog_pars_fragment: Xa,
                    gradientmap_pars_fragment: $a,
                    lightmap_fragment: Ya,
                    lightmap_pars_fragment: Ja,
                    lights_lambert_vertex: Ka,
                    lights_pars_begin: Za,
                    lights_toon_fragment: to,
                    lights_toon_pars_fragment: eo,
                    lights_phong_fragment: no,
                    lights_phong_pars_fragment: ro,
                    lights_physical_fragment: io,
                    lights_physical_pars_fragment: ao,
                    lights_fragment_begin: oo,
                    lights_fragment_maps: so,
                    lights_fragment_end: co,
                    logdepthbuf_fragment: lo,
                    logdepthbuf_pars_fragment: uo,
                    logdepthbuf_pars_vertex: ho,
                    logdepthbuf_vertex: fo,
                    map_fragment: po,
                    map_pars_fragment: mo,
                    map_particle_fragment: go,
                    map_particle_pars_fragment: vo,
                    metalnessmap_fragment: yo,
                    metalnessmap_pars_fragment: bo,
                    morphcolor_vertex: xo,
                    morphnormal_vertex: _o,
                    morphtarget_pars_vertex: wo,
                    morphtarget_vertex: So,
                    normal_fragment_begin: Mo,
                    normal_fragment_maps: To,
                    normal_pars_fragment: Eo,
                    normal_pars_vertex: Ao,
                    normal_vertex: Co,
                    normalmap_pars_fragment: Lo,
                    clearcoat_normal_fragment_begin: Ro,
                    clearcoat_normal_fragment_maps: Po,
                    clearcoat_pars_fragment: Io,
                    iridescence_pars_fragment: Oo,
                    output_fragment: ko,
                    packing: No,
                    premultiplied_alpha_fragment: Do,
                    project_vertex: zo,
                    dithering_fragment: Fo,
                    dithering_pars_fragment: Uo,
                    roughnessmap_fragment: Bo,
                    roughnessmap_pars_fragment: jo,
                    shadowmap_pars_fragment: Ho,
                    shadowmap_pars_vertex: Vo,
                    shadowmap_vertex: Go,
                    shadowmask_pars_fragment: Wo,
                    skinbase_vertex: qo,
                    skinning_pars_vertex: Xo,
                    skinning_vertex: $o,
                    skinnormal_vertex: Yo,
                    specularmap_fragment: Jo,
                    specularmap_pars_fragment: Ko,
                    tonemapping_fragment: Zo,
                    tonemapping_pars_fragment: Qo,
                    transmission_fragment: ts,
                    transmission_pars_fragment: es,
                    uv_pars_fragment: ns,
                    uv_pars_vertex: rs,
                    uv_vertex: is,
                    uv2_pars_fragment: as,
                    uv2_pars_vertex: os,
                    uv2_vertex: ss,
                    worldpos_vertex: cs,
                    background_vert: ls,
                    background_frag: us,
                    cube_vert: hs,
                    cube_frag: ds,
                    depth_vert: fs,
                    depth_frag: ps,
                    distanceRGBA_vert: ms,
                    distanceRGBA_frag: gs,
                    equirect_vert: vs,
                    equirect_frag: ys,
                    linedashed_vert: bs,
                    linedashed_frag: xs,
                    meshbasic_vert: _s,
                    meshbasic_frag: ws,
                    meshlambert_vert: Ss,
                    meshlambert_frag: Ms,
                    meshmatcap_vert: Ts,
                    meshmatcap_frag: Es,
                    meshnormal_vert: As,
                    meshnormal_frag: Cs,
                    meshphong_vert: Ls,
                    meshphong_frag: Rs,
                    meshphysical_vert: Ps,
                    meshphysical_frag: Is,
                    meshtoon_vert: Os,
                    meshtoon_frag: ks,
                    points_vert: Ns,
                    points_frag: Ds,
                    shadow_vert: zs,
                    shadow_frag: Fs,
                    sprite_vert: Us,
                    sprite_frag: Bs,
                  },
                  Hs = {
                    common: {
                      diffuse: { value: new In(16777215) },
                      opacity: { value: 1 },
                      map: { value: null },
                      uvTransform: { value: new vn() },
                      uv2Transform: { value: new vn() },
                      alphaMap: { value: null },
                      alphaTest: { value: 0 },
                    },
                    specularmap: { specularMap: { value: null } },
                    envmap: {
                      envMap: { value: null },
                      flipEnvMap: { value: -1 },
                      reflectivity: { value: 1 },
                      ior: { value: 1.5 },
                      refractionRatio: { value: 0.98 },
                    },
                    aomap: {
                      aoMap: { value: null },
                      aoMapIntensity: { value: 1 },
                    },
                    lightmap: {
                      lightMap: { value: null },
                      lightMapIntensity: { value: 1 },
                    },
                    emissivemap: { emissiveMap: { value: null } },
                    bumpmap: {
                      bumpMap: { value: null },
                      bumpScale: { value: 1 },
                    },
                    normalmap: {
                      normalMap: { value: null },
                      normalScale: { value: new gn(1, 1) },
                    },
                    displacementmap: {
                      displacementMap: { value: null },
                      displacementScale: { value: 1 },
                      displacementBias: { value: 0 },
                    },
                    roughnessmap: { roughnessMap: { value: null } },
                    metalnessmap: { metalnessMap: { value: null } },
                    gradientmap: { gradientMap: { value: null } },
                    fog: {
                      fogDensity: { value: 25e-5 },
                      fogNear: { value: 1 },
                      fogFar: { value: 2e3 },
                      fogColor: { value: new In(16777215) },
                    },
                    lights: {
                      ambientLightColor: { value: [] },
                      lightProbe: { value: [] },
                      directionalLights: {
                        value: [],
                        properties: { direction: {}, color: {} },
                      },
                      directionalLightShadows: {
                        value: [],
                        properties: {
                          shadowBias: {},
                          shadowNormalBias: {},
                          shadowRadius: {},
                          shadowMapSize: {},
                        },
                      },
                      directionalShadowMap: { value: [] },
                      directionalShadowMatrix: { value: [] },
                      spotLights: {
                        value: [],
                        properties: {
                          color: {},
                          position: {},
                          direction: {},
                          distance: {},
                          coneCos: {},
                          penumbraCos: {},
                          decay: {},
                        },
                      },
                      spotLightShadows: {
                        value: [],
                        properties: {
                          shadowBias: {},
                          shadowNormalBias: {},
                          shadowRadius: {},
                          shadowMapSize: {},
                        },
                      },
                      spotShadowMap: { value: [] },
                      spotShadowMatrix: { value: [] },
                      pointLights: {
                        value: [],
                        properties: {
                          color: {},
                          position: {},
                          decay: {},
                          distance: {},
                        },
                      },
                      pointLightShadows: {
                        value: [],
                        properties: {
                          shadowBias: {},
                          shadowNormalBias: {},
                          shadowRadius: {},
                          shadowMapSize: {},
                          shadowCameraNear: {},
                          shadowCameraFar: {},
                        },
                      },
                      pointShadowMap: { value: [] },
                      pointShadowMatrix: { value: [] },
                      hemisphereLights: {
                        value: [],
                        properties: {
                          direction: {},
                          skyColor: {},
                          groundColor: {},
                        },
                      },
                      rectAreaLights: {
                        value: [],
                        properties: {
                          color: {},
                          position: {},
                          width: {},
                          height: {},
                        },
                      },
                      ltc_1: { value: null },
                      ltc_2: { value: null },
                    },
                    points: {
                      diffuse: { value: new In(16777215) },
                      opacity: { value: 1 },
                      size: { value: 1 },
                      scale: { value: 1 },
                      map: { value: null },
                      alphaMap: { value: null },
                      alphaTest: { value: 0 },
                      uvTransform: { value: new vn() },
                    },
                    sprite: {
                      diffuse: { value: new In(16777215) },
                      opacity: { value: 1 },
                      center: { value: new gn(0.5, 0.5) },
                      rotation: { value: 0 },
                      map: { value: null },
                      alphaMap: { value: null },
                      alphaTest: { value: 0 },
                      uvTransform: { value: new vn() },
                    },
                  },
                  Vs = {
                    basic: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.specularmap,
                        Hs.envmap,
                        Hs.aomap,
                        Hs.lightmap,
                        Hs.fog,
                      ]),
                      vertexShader: js.meshbasic_vert,
                      fragmentShader: js.meshbasic_frag,
                    },
                    lambert: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.specularmap,
                        Hs.envmap,
                        Hs.aomap,
                        Hs.lightmap,
                        Hs.emissivemap,
                        Hs.fog,
                        Hs.lights,
                        { emissive: { value: new In(0) } },
                      ]),
                      vertexShader: js.meshlambert_vert,
                      fragmentShader: js.meshlambert_frag,
                    },
                    phong: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.specularmap,
                        Hs.envmap,
                        Hs.aomap,
                        Hs.lightmap,
                        Hs.emissivemap,
                        Hs.bumpmap,
                        Hs.normalmap,
                        Hs.displacementmap,
                        Hs.fog,
                        Hs.lights,
                        {
                          emissive: { value: new In(0) },
                          specular: { value: new In(1118481) },
                          shininess: { value: 30 },
                        },
                      ]),
                      vertexShader: js.meshphong_vert,
                      fragmentShader: js.meshphong_frag,
                    },
                    standard: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.envmap,
                        Hs.aomap,
                        Hs.lightmap,
                        Hs.emissivemap,
                        Hs.bumpmap,
                        Hs.normalmap,
                        Hs.displacementmap,
                        Hs.roughnessmap,
                        Hs.metalnessmap,
                        Hs.fog,
                        Hs.lights,
                        {
                          emissive: { value: new In(0) },
                          roughness: { value: 1 },
                          metalness: { value: 0 },
                          envMapIntensity: { value: 1 },
                        },
                      ]),
                      vertexShader: js.meshphysical_vert,
                      fragmentShader: js.meshphysical_frag,
                    },
                    toon: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.aomap,
                        Hs.lightmap,
                        Hs.emissivemap,
                        Hs.bumpmap,
                        Hs.normalmap,
                        Hs.displacementmap,
                        Hs.gradientmap,
                        Hs.fog,
                        Hs.lights,
                        { emissive: { value: new In(0) } },
                      ]),
                      vertexShader: js.meshtoon_vert,
                      fragmentShader: js.meshtoon_frag,
                    },
                    matcap: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.bumpmap,
                        Hs.normalmap,
                        Hs.displacementmap,
                        Hs.fog,
                        { matcap: { value: null } },
                      ]),
                      vertexShader: js.meshmatcap_vert,
                      fragmentShader: js.meshmatcap_frag,
                    },
                    points: {
                      uniforms: Vi([Hs.points, Hs.fog]),
                      vertexShader: js.points_vert,
                      fragmentShader: js.points_frag,
                    },
                    dashed: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.fog,
                        {
                          scale: { value: 1 },
                          dashSize: { value: 1 },
                          totalSize: { value: 2 },
                        },
                      ]),
                      vertexShader: js.linedashed_vert,
                      fragmentShader: js.linedashed_frag,
                    },
                    depth: {
                      uniforms: Vi([Hs.common, Hs.displacementmap]),
                      vertexShader: js.depth_vert,
                      fragmentShader: js.depth_frag,
                    },
                    normal: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.bumpmap,
                        Hs.normalmap,
                        Hs.displacementmap,
                        { opacity: { value: 1 } },
                      ]),
                      vertexShader: js.meshnormal_vert,
                      fragmentShader: js.meshnormal_frag,
                    },
                    sprite: {
                      uniforms: Vi([Hs.sprite, Hs.fog]),
                      vertexShader: js.sprite_vert,
                      fragmentShader: js.sprite_frag,
                    },
                    background: {
                      uniforms: {
                        uvTransform: { value: new vn() },
                        t2D: { value: null },
                      },
                      vertexShader: js.background_vert,
                      fragmentShader: js.background_frag,
                    },
                    cube: {
                      uniforms: Vi([Hs.envmap, { opacity: { value: 1 } }]),
                      vertexShader: js.cube_vert,
                      fragmentShader: js.cube_frag,
                    },
                    equirect: {
                      uniforms: { tEquirect: { value: null } },
                      vertexShader: js.equirect_vert,
                      fragmentShader: js.equirect_frag,
                    },
                    distanceRGBA: {
                      uniforms: Vi([
                        Hs.common,
                        Hs.displacementmap,
                        {
                          referencePosition: { value: new Gn() },
                          nearDistance: { value: 1 },
                          farDistance: { value: 1e3 },
                        },
                      ]),
                      vertexShader: js.distanceRGBA_vert,
                      fragmentShader: js.distanceRGBA_frag,
                    },
                    shadow: {
                      uniforms: Vi([
                        Hs.lights,
                        Hs.fog,
                        { color: { value: new In(0) }, opacity: { value: 1 } },
                      ]),
                      vertexShader: js.shadow_vert,
                      fragmentShader: js.shadow_frag,
                    },
                  };
                function Gs(t, e, n, r, i, a) {
                  const o = new In(0);
                  let s,
                    c,
                    l = !0 === i ? 0 : 1,
                    u = null,
                    h = 0,
                    d = null;
                  function f(n, i) {
                    let a = !1,
                      f = !0 === i.isScene ? i.background : null;
                    f && f.isTexture && (f = e.get(f));
                    const m = t.xr,
                      y = m.getSession && m.getSession();
                    y && "additive" === y.environmentBlendMode && (f = null),
                      null === f
                        ? p(o, l)
                        : f && f.isColor && (p(f, 1), (a = !0)),
                      (t.autoClear || a) &&
                        t.clear(
                          t.autoClearColor,
                          t.autoClearDepth,
                          t.autoClearStencil
                        ),
                      f && (f.isCubeTexture || f.mapping === ut)
                        ? (void 0 === c &&
                            ((c = new Fi(
                              new ji(1, 1, 1),
                              new Xi({
                                name: "BackgroundCubeMaterial",
                                uniforms: Hi(Vs.cube.uniforms),
                                vertexShader: Vs.cube.vertexShader,
                                fragmentShader: Vs.cube.fragmentShader,
                                side: v,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1,
                              })
                            )),
                            c.geometry.deleteAttribute("normal"),
                            c.geometry.deleteAttribute("uv"),
                            (c.onBeforeRender = function (t, e, n) {
                              this.matrixWorld.copyPosition(n.matrixWorld);
                            }),
                            Object.defineProperty(c.material, "envMap", {
                              get: function () {
                                return this.uniforms.envMap.value;
                              },
                            }),
                            r.update(c)),
                          (c.material.uniforms.envMap.value = f),
                          (c.material.uniforms.flipEnvMap.value =
                            f.isCubeTexture && !1 === f.isRenderTargetTexture
                              ? -1
                              : 1),
                          (u === f && h === f.version && d === t.toneMapping) ||
                            ((c.material.needsUpdate = !0),
                            (u = f),
                            (h = f.version),
                            (d = t.toneMapping)),
                          c.layers.enableAll(),
                          n.unshift(c, c.geometry, c.material, 0, 0, null))
                        : f &&
                          f.isTexture &&
                          (void 0 === s &&
                            ((s = new Fi(
                              new ua(2, 2),
                              new Xi({
                                name: "BackgroundMaterial",
                                uniforms: Hi(Vs.background.uniforms),
                                vertexShader: Vs.background.vertexShader,
                                fragmentShader: Vs.background.fragmentShader,
                                side: g,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1,
                              })
                            )),
                            s.geometry.deleteAttribute("normal"),
                            Object.defineProperty(s.material, "map", {
                              get: function () {
                                return this.uniforms.t2D.value;
                              },
                            }),
                            r.update(s)),
                          (s.material.uniforms.t2D.value = f),
                          !0 === f.matrixAutoUpdate && f.updateMatrix(),
                          s.material.uniforms.uvTransform.value.copy(f.matrix),
                          (u === f && h === f.version && d === t.toneMapping) ||
                            ((s.material.needsUpdate = !0),
                            (u = f),
                            (h = f.version),
                            (d = t.toneMapping)),
                          s.layers.enableAll(),
                          n.unshift(s, s.geometry, s.material, 0, 0, null));
                  }
                  function p(t, e) {
                    n.buffers.color.setClear(t.r, t.g, t.b, e, a);
                  }
                  return {
                    getClearColor: function () {
                      return o;
                    },
                    setClearColor: function (t, e = 1) {
                      o.set(t), (l = e), p(o, l);
                    },
                    getClearAlpha: function () {
                      return l;
                    },
                    setClearAlpha: function (t) {
                      (l = t), p(o, l);
                    },
                    render: f,
                  };
                }
                function Ws(t, e, n, r) {
                  const i = t.getParameter(34921),
                    a = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    o = r.isWebGL2 || null !== a,
                    s = {},
                    c = g(null);
                  let l = c,
                    u = !1;
                  function h(e, r, i, a, s) {
                    let c = !1;
                    if (o) {
                      const t = m(a, i, r);
                      l !== t && ((l = t), f(l.object)),
                        (c = v(e, a, i, s)),
                        c && y(e, a, i, s);
                    } else {
                      const t = !0 === r.wireframe;
                      (l.geometry === a.id &&
                        l.program === i.id &&
                        l.wireframe === t) ||
                        ((l.geometry = a.id),
                        (l.program = i.id),
                        (l.wireframe = t),
                        (c = !0));
                    }
                    null !== s && n.update(s, 34963),
                      (c || u) &&
                        ((u = !1),
                        M(e, r, i, a),
                        null !== s && t.bindBuffer(34963, n.get(s).buffer));
                  }
                  function d() {
                    return r.isWebGL2
                      ? t.createVertexArray()
                      : a.createVertexArrayOES();
                  }
                  function f(e) {
                    return r.isWebGL2
                      ? t.bindVertexArray(e)
                      : a.bindVertexArrayOES(e);
                  }
                  function p(e) {
                    return r.isWebGL2
                      ? t.deleteVertexArray(e)
                      : a.deleteVertexArrayOES(e);
                  }
                  function m(t, e, n) {
                    const r = !0 === n.wireframe;
                    let i = s[t.id];
                    void 0 === i && ((i = {}), (s[t.id] = i));
                    let a = i[e.id];
                    void 0 === a && ((a = {}), (i[e.id] = a));
                    let o = a[r];
                    return void 0 === o && ((o = g(d())), (a[r] = o)), o;
                  }
                  function g(t) {
                    const e = [],
                      n = [],
                      r = [];
                    for (let a = 0; a < i; a++)
                      (e[a] = 0), (n[a] = 0), (r[a] = 0);
                    return {
                      geometry: null,
                      program: null,
                      wireframe: !1,
                      newAttributes: e,
                      enabledAttributes: n,
                      attributeDivisors: r,
                      object: t,
                      attributes: {},
                      index: null,
                    };
                  }
                  function v(t, e, n, r) {
                    const i = l.attributes,
                      a = e.attributes;
                    let o = 0;
                    const s = n.getAttributes();
                    for (const c in s) {
                      const e = s[c];
                      if (e.location >= 0) {
                        const e = i[c];
                        let n = a[c];
                        if (
                          (void 0 === n &&
                            ("instanceMatrix" === c &&
                              t.instanceMatrix &&
                              (n = t.instanceMatrix),
                            "instanceColor" === c &&
                              t.instanceColor &&
                              (n = t.instanceColor)),
                          void 0 === e)
                        )
                          return !0;
                        if (e.attribute !== n) return !0;
                        if (n && e.data !== n.data) return !0;
                        o++;
                      }
                    }
                    return l.attributesNum !== o || l.index !== r;
                  }
                  function y(t, e, n, r) {
                    const i = {},
                      a = e.attributes;
                    let o = 0;
                    const s = n.getAttributes();
                    for (const c in s) {
                      const e = s[c];
                      if (e.location >= 0) {
                        let e = a[c];
                        void 0 === e &&
                          ("instanceMatrix" === c &&
                            t.instanceMatrix &&
                            (e = t.instanceMatrix),
                          "instanceColor" === c &&
                            t.instanceColor &&
                            (e = t.instanceColor));
                        const n = {};
                        (n.attribute = e),
                          e && e.data && (n.data = e.data),
                          (i[c] = n),
                          o++;
                      }
                    }
                    (l.attributes = i), (l.attributesNum = o), (l.index = r);
                  }
                  function b() {
                    const t = l.newAttributes;
                    for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
                  }
                  function x(t) {
                    _(t, 0);
                  }
                  function _(n, i) {
                    const a = l.newAttributes,
                      o = l.enabledAttributes,
                      s = l.attributeDivisors;
                    if (
                      ((a[n] = 1),
                      0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
                      s[n] !== i)
                    ) {
                      const a = r.isWebGL2
                        ? t
                        : e.get("ANGLE_instanced_arrays");
                      a[
                        r.isWebGL2
                          ? "vertexAttribDivisor"
                          : "vertexAttribDivisorANGLE"
                      ](n, i),
                        (s[n] = i);
                    }
                  }
                  function w() {
                    const e = l.newAttributes,
                      n = l.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++)
                      n[r] !== e[r] &&
                        (t.disableVertexAttribArray(r), (n[r] = 0));
                  }
                  function S(e, n, i, a, o, s) {
                    !0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
                      ? t.vertexAttribPointer(e, n, i, a, o, s)
                      : t.vertexAttribIPointer(e, n, i, o, s);
                  }
                  function M(i, a, o, s) {
                    if (
                      !1 === r.isWebGL2 &&
                      (i.isInstancedMesh || s.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    b();
                    const c = s.attributes,
                      l = o.getAttributes(),
                      u = a.defaultAttributeValues;
                    for (const e in l) {
                      const r = l[e];
                      if (r.location >= 0) {
                        let a = c[e];
                        if (
                          (void 0 === a &&
                            ("instanceMatrix" === e &&
                              i.instanceMatrix &&
                              (a = i.instanceMatrix),
                            "instanceColor" === e &&
                              i.instanceColor &&
                              (a = i.instanceColor)),
                          void 0 !== a)
                        ) {
                          const e = a.normalized,
                            o = a.itemSize,
                            c = n.get(a);
                          if (void 0 === c) continue;
                          const l = c.buffer,
                            u = c.type,
                            h = c.bytesPerElement;
                          if (a.isInterleavedBufferAttribute) {
                            const n = a.data,
                              c = n.stride,
                              d = a.offset;
                            if (n.isInstancedInterleavedBuffer) {
                              for (let t = 0; t < r.locationSize; t++)
                                _(r.location + t, n.meshPerAttribute);
                              !0 !== i.isInstancedMesh &&
                                void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  n.meshPerAttribute * n.count);
                            } else
                              for (let t = 0; t < r.locationSize; t++)
                                x(r.location + t);
                            t.bindBuffer(34962, l);
                            for (let t = 0; t < r.locationSize; t++)
                              S(
                                r.location + t,
                                o / r.locationSize,
                                u,
                                e,
                                c * h,
                                (d + (o / r.locationSize) * t) * h
                              );
                          } else {
                            if (a.isInstancedBufferAttribute) {
                              for (let t = 0; t < r.locationSize; t++)
                                _(r.location + t, a.meshPerAttribute);
                              !0 !== i.isInstancedMesh &&
                                void 0 === s._maxInstanceCount &&
                                (s._maxInstanceCount =
                                  a.meshPerAttribute * a.count);
                            } else
                              for (let t = 0; t < r.locationSize; t++)
                                x(r.location + t);
                            t.bindBuffer(34962, l);
                            for (let t = 0; t < r.locationSize; t++)
                              S(
                                r.location + t,
                                o / r.locationSize,
                                u,
                                e,
                                o * h,
                                (o / r.locationSize) * t * h
                              );
                          }
                        } else if (void 0 !== u) {
                          const n = u[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(r.location, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(r.location, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(r.location, n);
                                break;
                              default:
                                t.vertexAttrib1fv(r.location, n);
                            }
                        }
                      }
                    }
                    w();
                  }
                  function T() {
                    C();
                    for (const t in s) {
                      const e = s[t];
                      for (const t in e) {
                        const n = e[t];
                        for (const t in n) p(n[t].object), delete n[t];
                        delete e[t];
                      }
                      delete s[t];
                    }
                  }
                  function E(t) {
                    if (void 0 === s[t.id]) return;
                    const e = s[t.id];
                    for (const n in e) {
                      const t = e[n];
                      for (const e in t) p(t[e].object), delete t[e];
                      delete e[n];
                    }
                    delete s[t.id];
                  }
                  function A(t) {
                    for (const e in s) {
                      const n = s[e];
                      if (void 0 === n[t.id]) continue;
                      const r = n[t.id];
                      for (const t in r) p(r[t].object), delete r[t];
                      delete n[t.id];
                    }
                  }
                  function C() {
                    L(), (u = !0), l !== c && ((l = c), f(l.object));
                  }
                  function L() {
                    (c.geometry = null), (c.program = null), (c.wireframe = !1);
                  }
                  return {
                    setup: h,
                    reset: C,
                    resetDefaultState: L,
                    dispose: T,
                    releaseStatesOfGeometry: E,
                    releaseStatesOfProgram: A,
                    initAttributes: b,
                    enableAttribute: x,
                    disableUnusedAttributes: w,
                  };
                }
                function qs(t, e, n, r) {
                  const i = r.isWebGL2;
                  let a;
                  function o(t) {
                    a = t;
                  }
                  function s(e, r) {
                    t.drawArrays(a, e, r), n.update(r, a, 1);
                  }
                  function c(r, o, s) {
                    if (0 === s) return;
                    let c, l;
                    if (i) (c = t), (l = "drawArraysInstanced");
                    else if (
                      ((c = e.get("ANGLE_instanced_arrays")),
                      (l = "drawArraysInstancedANGLE"),
                      null === c)
                    )
                      return void console.error(
                        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                      );
                    c[l](a, r, o, s), n.update(o, a, s);
                  }
                  (this.setMode = o),
                    (this.render = s),
                    (this.renderInstances = c);
                }
                function Xs(t, e, n) {
                  let r;
                  function i() {
                    if (void 0 !== r) return r;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                      const n = e.get("EXT_texture_filter_anisotropic");
                      r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                    } else r = 0;
                    return r;
                  }
                  function a(e) {
                    if ("highp" === e) {
                      if (
                        t.getShaderPrecisionFormat(35633, 36338).precision >
                          0 &&
                        t.getShaderPrecisionFormat(35632, 36338).precision > 0
                      )
                        return "highp";
                      e = "mediump";
                    }
                    return "mediump" === e &&
                      t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
                      t.getShaderPrecisionFormat(35632, 36337).precision > 0
                      ? "mediump"
                      : "lowp";
                  }
                  const o =
                    ("undefined" !== typeof WebGL2RenderingContext &&
                      t instanceof WebGL2RenderingContext) ||
                    ("undefined" !== typeof WebGL2ComputeRenderingContext &&
                      t instanceof WebGL2ComputeRenderingContext);
                  let s = void 0 !== n.precision ? n.precision : "highp";
                  const c = a(s);
                  c !== s &&
                    (console.warn(
                      "THREE.WebGLRenderer:",
                      s,
                      "not supported, using",
                      c,
                      "instead."
                    ),
                    (s = c));
                  const l = o || e.has("WEBGL_draw_buffers"),
                    u = !0 === n.logarithmicDepthBuffer,
                    h = t.getParameter(34930),
                    d = t.getParameter(35660),
                    f = t.getParameter(3379),
                    p = t.getParameter(34076),
                    m = t.getParameter(34921),
                    g = t.getParameter(36347),
                    v = t.getParameter(36348),
                    y = t.getParameter(36349),
                    b = d > 0,
                    x = o || e.has("OES_texture_float"),
                    _ = b && x,
                    w = o ? t.getParameter(36183) : 0;
                  return {
                    isWebGL2: o,
                    drawBuffers: l,
                    getMaxAnisotropy: i,
                    getMaxPrecision: a,
                    precision: s,
                    logarithmicDepthBuffer: u,
                    maxTextures: h,
                    maxVertexTextures: d,
                    maxTextureSize: f,
                    maxCubemapSize: p,
                    maxAttributes: m,
                    maxVertexUniforms: g,
                    maxVaryings: v,
                    maxFragmentUniforms: y,
                    vertexTextures: b,
                    floatFragmentTextures: x,
                    floatVertexTextures: _,
                    maxSamples: w,
                  };
                }
                function $s(t) {
                  const e = this;
                  let n = null,
                    r = 0,
                    i = !1,
                    a = !1;
                  const o = new ia(),
                    s = new vn(),
                    c = { value: null, needsUpdate: !1 };
                  function l() {
                    c.value !== n && ((c.value = n), (c.needsUpdate = r > 0)),
                      (e.numPlanes = r),
                      (e.numIntersection = 0);
                  }
                  function u(t, n, r, i) {
                    const a = null !== t ? t.length : 0;
                    let l = null;
                    if (0 !== a) {
                      if (((l = c.value), !0 !== i || null === l)) {
                        const e = r + 4 * a,
                          i = n.matrixWorldInverse;
                        s.getNormalMatrix(i),
                          (null === l || l.length < e) &&
                            (l = new Float32Array(e));
                        for (let n = 0, c = r; n !== a; ++n, c += 4)
                          o.copy(t[n]).applyMatrix4(i, s),
                            o.normal.toArray(l, c),
                            (l[c + 3] = o.constant);
                      }
                      (c.value = l), (c.needsUpdate = !0);
                    }
                    return (e.numPlanes = a), (e.numIntersection = 0), l;
                  }
                  (this.uniform = c),
                    (this.numPlanes = 0),
                    (this.numIntersection = 0),
                    (this.init = function (t, e, a) {
                      const o = 0 !== t.length || e || 0 !== r || i;
                      return (i = e), (n = u(t, a, 0)), (r = t.length), o;
                    }),
                    (this.beginShadows = function () {
                      (a = !0), u(null);
                    }),
                    (this.endShadows = function () {
                      (a = !1), l();
                    }),
                    (this.setState = function (e, o, s) {
                      const h = e.clippingPlanes,
                        d = e.clipIntersection,
                        f = e.clipShadows,
                        p = t.get(e);
                      if (!i || null === h || 0 === h.length || (a && !f))
                        a ? u(null) : l();
                      else {
                        const t = a ? 0 : r,
                          e = 4 * t;
                        let i = p.clippingState || null;
                        (c.value = i), (i = u(h, o, e, s));
                        for (let r = 0; r !== e; ++r) i[r] = n[r];
                        (p.clippingState = i),
                          (this.numIntersection = d ? this.numPlanes : 0),
                          (this.numPlanes += t);
                      }
                    });
                }
                function Ys(t) {
                  let e = new WeakMap();
                  function n(t, e) {
                    return (
                      e === ct
                        ? (t.mapping = ot)
                        : e === lt && (t.mapping = st),
                      t
                    );
                  }
                  function r(r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                      const a = r.mapping;
                      if (a === ct || a === lt) {
                        if (e.has(r)) {
                          const t = e.get(r).texture;
                          return n(t, r.mapping);
                        }
                        {
                          const a = r.image;
                          if (a && a.height > 0) {
                            const o = new ta(a.height / 2);
                            return (
                              o.fromEquirectangularTexture(t, r),
                              e.set(r, o),
                              r.addEventListener("dispose", i),
                              n(o.texture, r.mapping)
                            );
                          }
                          return null;
                        }
                      }
                    }
                    return r;
                  }
                  function i(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", i);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose());
                  }
                  function a() {
                    e = new WeakMap();
                  }
                  return { get: r, dispose: a };
                }
                Vs.physical = {
                  uniforms: Vi([
                    Vs.standard.uniforms,
                    {
                      clearcoat: { value: 0 },
                      clearcoatMap: { value: null },
                      clearcoatRoughness: { value: 0 },
                      clearcoatRoughnessMap: { value: null },
                      clearcoatNormalScale: { value: new gn(1, 1) },
                      clearcoatNormalMap: { value: null },
                      iridescence: { value: 0 },
                      iridescenceMap: { value: null },
                      iridescenceIOR: { value: 1.3 },
                      iridescenceThicknessMinimum: { value: 100 },
                      iridescenceThicknessMaximum: { value: 400 },
                      iridescenceThicknessMap: { value: null },
                      sheen: { value: 0 },
                      sheenColor: { value: new In(0) },
                      sheenColorMap: { value: null },
                      sheenRoughness: { value: 1 },
                      sheenRoughnessMap: { value: null },
                      transmission: { value: 0 },
                      transmissionMap: { value: null },
                      transmissionSamplerSize: { value: new gn() },
                      transmissionSamplerMap: { value: null },
                      thickness: { value: 0 },
                      thicknessMap: { value: null },
                      attenuationDistance: { value: 0 },
                      attenuationColor: { value: new In(0) },
                      specularIntensity: { value: 1 },
                      specularIntensityMap: { value: null },
                      specularColor: { value: new In(1, 1, 1) },
                      specularColorMap: { value: null },
                    },
                  ]),
                  vertexShader: js.meshphysical_vert,
                  fragmentShader: js.meshphysical_frag,
                };
                class Js extends $i {
                  constructor(t = -1, e = 1, n = 1, r = -1, i = 0.1, a = 2e3) {
                    super(),
                      (this.isOrthographicCamera = !0),
                      (this.type = "OrthographicCamera"),
                      (this.zoom = 1),
                      (this.view = null),
                      (this.left = t),
                      (this.right = e),
                      (this.top = n),
                      (this.bottom = r),
                      (this.near = i),
                      (this.far = a),
                      this.updateProjectionMatrix();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.left = t.left),
                      (this.right = t.right),
                      (this.top = t.top),
                      (this.bottom = t.bottom),
                      (this.near = t.near),
                      (this.far = t.far),
                      (this.zoom = t.zoom),
                      (this.view =
                        null === t.view ? null : Object.assign({}, t.view)),
                      this
                    );
                  }
                  setViewOffset(t, e, n, r, i, a) {
                    null === this.view &&
                      (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1,
                      }),
                      (this.view.enabled = !0),
                      (this.view.fullWidth = t),
                      (this.view.fullHeight = e),
                      (this.view.offsetX = n),
                      (this.view.offsetY = r),
                      (this.view.width = i),
                      (this.view.height = a),
                      this.updateProjectionMatrix();
                  }
                  clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                      this.updateProjectionMatrix();
                  }
                  updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                      e = (this.top - this.bottom) / (2 * this.zoom),
                      n = (this.right + this.left) / 2,
                      r = (this.top + this.bottom) / 2;
                    let i = n - t,
                      a = n + t,
                      o = r + e,
                      s = r - e;
                    if (null !== this.view && this.view.enabled) {
                      const t =
                          (this.right - this.left) /
                          this.view.fullWidth /
                          this.zoom,
                        e =
                          (this.top - this.bottom) /
                          this.view.fullHeight /
                          this.zoom;
                      (i += t * this.view.offsetX),
                        (a = i + t * this.view.width),
                        (o -= e * this.view.offsetY),
                        (s = o - e * this.view.height);
                    }
                    this.projectionMatrix.makeOrthographic(
                      i,
                      a,
                      o,
                      s,
                      this.near,
                      this.far
                    ),
                      this.projectionMatrixInverse
                        .copy(this.projectionMatrix)
                        .invert();
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                      (e.object.zoom = this.zoom),
                      (e.object.left = this.left),
                      (e.object.right = this.right),
                      (e.object.top = this.top),
                      (e.object.bottom = this.bottom),
                      (e.object.near = this.near),
                      (e.object.far = this.far),
                      null !== this.view &&
                        (e.object.view = Object.assign({}, this.view)),
                      e
                    );
                  }
                }
                const Ks = 4,
                  Zs = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                  Qs = 20,
                  tc = new Js(),
                  ec = new In();
                let nc = null;
                const rc = (1 + Math.sqrt(5)) / 2,
                  ic = 1 / rc,
                  ac = [
                    new Gn(1, 1, 1),
                    new Gn(-1, 1, 1),
                    new Gn(1, 1, -1),
                    new Gn(-1, 1, -1),
                    new Gn(0, rc, ic),
                    new Gn(0, rc, -ic),
                    new Gn(ic, 0, rc),
                    new Gn(-ic, 0, rc),
                    new Gn(rc, ic, 0),
                    new Gn(-rc, ic, 0),
                  ];
                class oc {
                  constructor(t) {
                    (this._renderer = t),
                      (this._pingPongRenderTarget = null),
                      (this._lodMax = 0),
                      (this._cubeSize = 0),
                      (this._lodPlanes = []),
                      (this._sizeLods = []),
                      (this._sigmas = []),
                      (this._blurMaterial = null),
                      (this._cubemapMaterial = null),
                      (this._equirectMaterial = null),
                      this._compileMaterial(this._blurMaterial);
                  }
                  fromScene(t, e = 0, n = 0.1, r = 100) {
                    (nc = this._renderer.getRenderTarget()), this._setSize(256);
                    const i = this._allocateTargets();
                    return (
                      (i.depthBuffer = !0),
                      this._sceneToCubeUV(t, n, r, i),
                      e > 0 && this._blur(i, 0, 0, e),
                      this._applyPMREM(i),
                      this._cleanup(i),
                      i
                    );
                  }
                  fromEquirectangular(t, e = null) {
                    return this._fromTexture(t, e);
                  }
                  fromCubemap(t, e = null) {
                    return this._fromTexture(t, e);
                  }
                  compileCubemapShader() {
                    null === this._cubemapMaterial &&
                      ((this._cubemapMaterial = dc()),
                      this._compileMaterial(this._cubemapMaterial));
                  }
                  compileEquirectangularShader() {
                    null === this._equirectMaterial &&
                      ((this._equirectMaterial = hc()),
                      this._compileMaterial(this._equirectMaterial));
                  }
                  dispose() {
                    this._dispose(),
                      null !== this._cubemapMaterial &&
                        this._cubemapMaterial.dispose(),
                      null !== this._equirectMaterial &&
                        this._equirectMaterial.dispose();
                  }
                  _setSize(t) {
                    (this._lodMax = Math.floor(Math.log2(t))),
                      (this._cubeSize = Math.pow(2, this._lodMax));
                  }
                  _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(),
                      null !== this._pingPongRenderTarget &&
                        this._pingPongRenderTarget.dispose();
                    for (let t = 0; t < this._lodPlanes.length; t++)
                      this._lodPlanes[t].dispose();
                  }
                  _cleanup(t) {
                    this._renderer.setRenderTarget(nc),
                      (t.scissorTest = !1),
                      lc(t, 0, 0, t.width, t.height);
                  }
                  _fromTexture(t, e) {
                    t.mapping === ot || t.mapping === st
                      ? this._setSize(
                          0 === t.image.length
                            ? 16
                            : t.image[0].width || t.image[0].image.width
                        )
                      : this._setSize(t.image.width / 4),
                      (nc = this._renderer.getRenderTarget());
                    const n = e || this._allocateTargets();
                    return (
                      this._textureToCubeUV(t, n),
                      this._applyPMREM(n),
                      this._cleanup(n),
                      n
                    );
                  }
                  _allocateTargets() {
                    const t = 3 * Math.max(this._cubeSize, 112),
                      e = 4 * this._cubeSize,
                      n = {
                        magFilter: vt,
                        minFilter: vt,
                        generateMipmaps: !1,
                        type: At,
                        format: Ot,
                        encoding: Ce,
                        depthBuffer: !1,
                      },
                      r = cc(t, e, n);
                    if (
                      null === this._pingPongRenderTarget ||
                      this._pingPongRenderTarget.width !== t
                    ) {
                      null !== this._pingPongRenderTarget && this._dispose(),
                        (this._pingPongRenderTarget = cc(t, e, n));
                      const { _lodMax: r } = this;
                      ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas,
                      } = sc(r)),
                        (this._blurMaterial = uc(r, t, e));
                    }
                    return r;
                  }
                  _compileMaterial(t) {
                    const e = new Fi(this._lodPlanes[0], t);
                    this._renderer.compile(e, tc);
                  }
                  _sceneToCubeUV(t, e, n, r) {
                    const i = 90,
                      a = 1,
                      o = new Yi(i, a, e, n),
                      s = [1, -1, 1, 1, 1, 1],
                      c = [1, 1, 1, -1, -1, -1],
                      l = this._renderer,
                      u = l.autoClear,
                      h = l.toneMapping;
                    l.getClearColor(ec),
                      (l.toneMapping = Q),
                      (l.autoClear = !1);
                    const d = new oi({
                        name: "PMREM.Background",
                        side: v,
                        depthWrite: !1,
                        depthTest: !1,
                      }),
                      f = new Fi(new ji(), d);
                    let p = !1;
                    const m = t.background;
                    m
                      ? m.isColor &&
                        (d.color.copy(m), (t.background = null), (p = !0))
                      : (d.color.copy(ec), (p = !0));
                    for (let g = 0; g < 6; g++) {
                      const e = g % 3;
                      0 === e
                        ? (o.up.set(0, s[g], 0), o.lookAt(c[g], 0, 0))
                        : 1 === e
                        ? (o.up.set(0, 0, s[g]), o.lookAt(0, c[g], 0))
                        : (o.up.set(0, s[g], 0), o.lookAt(0, 0, c[g]));
                      const n = this._cubeSize;
                      lc(r, e * n, g > 2 ? n : 0, n, n),
                        l.setRenderTarget(r),
                        p && l.render(f, o),
                        l.render(t, o);
                    }
                    f.geometry.dispose(),
                      f.material.dispose(),
                      (l.toneMapping = h),
                      (l.autoClear = u),
                      (t.background = m);
                  }
                  _textureToCubeUV(t, e) {
                    const n = this._renderer,
                      r = t.mapping === ot || t.mapping === st;
                    r
                      ? (null === this._cubemapMaterial &&
                          (this._cubemapMaterial = dc()),
                        (this._cubemapMaterial.uniforms.flipEnvMap.value =
                          !1 === t.isRenderTargetTexture ? -1 : 1))
                      : null === this._equirectMaterial &&
                        (this._equirectMaterial = hc());
                    const i = r
                        ? this._cubemapMaterial
                        : this._equirectMaterial,
                      a = new Fi(this._lodPlanes[0], i),
                      o = i.uniforms;
                    o["envMap"].value = t;
                    const s = this._cubeSize;
                    lc(e, 0, 0, 3 * s, 2 * s),
                      n.setRenderTarget(e),
                      n.render(a, tc);
                  }
                  _applyPMREM(t) {
                    const e = this._renderer,
                      n = e.autoClear;
                    e.autoClear = !1;
                    for (let r = 1; r < this._lodPlanes.length; r++) {
                      const e = Math.sqrt(
                          this._sigmas[r] * this._sigmas[r] -
                            this._sigmas[r - 1] * this._sigmas[r - 1]
                        ),
                        n = ac[(r - 1) % ac.length];
                      this._blur(t, r - 1, r, e, n);
                    }
                    e.autoClear = n;
                  }
                  _blur(t, e, n, r, i) {
                    const a = this._pingPongRenderTarget;
                    this._halfBlur(t, a, e, n, r, "latitudinal", i),
                      this._halfBlur(a, t, n, n, r, "longitudinal", i);
                  }
                  _halfBlur(t, e, n, r, i, a, o) {
                    const s = this._renderer,
                      c = this._blurMaterial;
                    "latitudinal" !== a &&
                      "longitudinal" !== a &&
                      console.error(
                        "blur direction must be either latitudinal or longitudinal!"
                      );
                    const l = 3,
                      u = new Fi(this._lodPlanes[r], c),
                      h = c.uniforms,
                      d = this._sizeLods[n] - 1,
                      f = isFinite(i)
                        ? Math.PI / (2 * d)
                        : (2 * Math.PI) / (2 * Qs - 1),
                      p = i / f,
                      m = isFinite(i) ? 1 + Math.floor(l * p) : Qs;
                    m > Qs &&
                      console.warn(
                        `sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Qs}`
                      );
                    const g = [];
                    let v = 0;
                    for (let w = 0; w < Qs; ++w) {
                      const t = w / p,
                        e = Math.exp((-t * t) / 2);
                      g.push(e), 0 === w ? (v += e) : w < m && (v += 2 * e);
                    }
                    for (let w = 0; w < g.length; w++) g[w] = g[w] / v;
                    (h["envMap"].value = t.texture),
                      (h["samples"].value = m),
                      (h["weights"].value = g),
                      (h["latitudinal"].value = "latitudinal" === a),
                      o && (h["poleAxis"].value = o);
                    const { _lodMax: y } = this;
                    (h["dTheta"].value = f), (h["mipInt"].value = y - n);
                    const b = this._sizeLods[r],
                      x = 3 * b * (r > y - Ks ? r - y + Ks : 0),
                      _ = 4 * (this._cubeSize - b);
                    lc(e, x, _, 3 * b, 2 * b),
                      s.setRenderTarget(e),
                      s.render(u, tc);
                  }
                }
                function sc(t) {
                  const e = [],
                    n = [],
                    r = [];
                  let i = t;
                  const a = t - Ks + 1 + Zs.length;
                  for (let o = 0; o < a; o++) {
                    const a = Math.pow(2, i);
                    n.push(a);
                    let s = 1 / a;
                    o > t - Ks ? (s = Zs[o - t + Ks - 1]) : 0 === o && (s = 0),
                      r.push(s);
                    const c = 1 / (a - 2),
                      l = -c,
                      u = 1 + c,
                      h = [l, l, u, l, u, u, l, l, u, u, l, u],
                      d = 6,
                      f = 6,
                      p = 3,
                      m = 2,
                      g = 1,
                      v = new Float32Array(p * f * d),
                      y = new Float32Array(m * f * d),
                      b = new Float32Array(g * f * d);
                    for (let t = 0; t < d; t++) {
                      const e = ((t % 3) * 2) / 3 - 1,
                        n = t > 2 ? 0 : -1,
                        r = [
                          e,
                          n,
                          0,
                          e + 2 / 3,
                          n,
                          0,
                          e + 2 / 3,
                          n + 1,
                          0,
                          e,
                          n,
                          0,
                          e + 2 / 3,
                          n + 1,
                          0,
                          e,
                          n + 1,
                          0,
                        ];
                      v.set(r, p * f * t), y.set(h, m * f * t);
                      const i = [t, t, t, t, t, t];
                      b.set(i, g * f * t);
                    }
                    const x = new xi();
                    x.setAttribute("position", new li(v, p)),
                      x.setAttribute("uv", new li(y, m)),
                      x.setAttribute("faceIndex", new li(b, g)),
                      e.push(x),
                      i > Ks && i--;
                  }
                  return { lodPlanes: e, sizeLods: n, sigmas: r };
                }
                function cc(t, e, n) {
                  const r = new Bn(t, e, n);
                  return (
                    (r.texture.mapping = ut),
                    (r.texture.name = "PMREM.cubeUv"),
                    (r.scissorTest = !0),
                    r
                  );
                }
                function lc(t, e, n, r, i) {
                  t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
                }
                function uc(t, e, n) {
                  const r = new Float32Array(Qs),
                    i = new Gn(0, 1, 0),
                    a = new Xi({
                      name: "SphericalGaussianBlur",
                      defines: {
                        n: Qs,
                        CUBEUV_TEXEL_WIDTH: 1 / e,
                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                        CUBEUV_MAX_MIP: `${t}.0`,
                      },
                      uniforms: {
                        envMap: { value: null },
                        samples: { value: 1 },
                        weights: { value: r },
                        latitudinal: { value: !1 },
                        dTheta: { value: 0 },
                        mipInt: { value: 0 },
                        poleAxis: { value: i },
                      },
                      vertexShader: fc(),
                      fragmentShader:
                        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                      blending: x,
                      depthTest: !1,
                      depthWrite: !1,
                    });
                  return a;
                }
                function hc() {
                  return new Xi({
                    name: "EquirectangularToCubeUV",
                    uniforms: { envMap: { value: null } },
                    vertexShader: fc(),
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: x,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                }
                function dc() {
                  return new Xi({
                    name: "CubemapToCubeUV",
                    uniforms: {
                      envMap: { value: null },
                      flipEnvMap: { value: -1 },
                    },
                    vertexShader: fc(),
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: x,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                }
                function fc() {
                  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
                }
                function pc(t) {
                  let e = new WeakMap(),
                    n = null;
                  function r(r) {
                    if (r && r.isTexture) {
                      const o = r.mapping,
                        s = o === ct || o === lt,
                        c = o === ot || o === st;
                      if (s || c) {
                        if (
                          r.isRenderTargetTexture &&
                          !0 === r.needsPMREMUpdate
                        ) {
                          r.needsPMREMUpdate = !1;
                          let i = e.get(r);
                          return (
                            null === n && (n = new oc(t)),
                            (i = s
                              ? n.fromEquirectangular(r, i)
                              : n.fromCubemap(r, i)),
                            e.set(r, i),
                            i.texture
                          );
                        }
                        if (e.has(r)) return e.get(r).texture;
                        {
                          const o = r.image;
                          if ((s && o && o.height > 0) || (c && o && i(o))) {
                            null === n && (n = new oc(t));
                            const i = s
                              ? n.fromEquirectangular(r)
                              : n.fromCubemap(r);
                            return (
                              e.set(r, i),
                              r.addEventListener("dispose", a),
                              i.texture
                            );
                          }
                          return null;
                        }
                      }
                    }
                    return r;
                  }
                  function i(t) {
                    let e = 0;
                    const n = 6;
                    for (let r = 0; r < n; r++) void 0 !== t[r] && e++;
                    return e === n;
                  }
                  function a(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", a);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose());
                  }
                  function o() {
                    (e = new WeakMap()),
                      null !== n && (n.dispose(), (n = null));
                  }
                  return { get: r, dispose: o };
                }
                function mc(t) {
                  const e = {};
                  function n(n) {
                    if (void 0 !== e[n]) return e[n];
                    let r;
                    switch (n) {
                      case "WEBGL_depth_texture":
                        r =
                          t.getExtension("WEBGL_depth_texture") ||
                          t.getExtension("MOZ_WEBGL_depth_texture") ||
                          t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                      case "EXT_texture_filter_anisotropic":
                        r =
                          t.getExtension("EXT_texture_filter_anisotropic") ||
                          t.getExtension(
                            "MOZ_EXT_texture_filter_anisotropic"
                          ) ||
                          t.getExtension(
                            "WEBKIT_EXT_texture_filter_anisotropic"
                          );
                        break;
                      case "WEBGL_compressed_texture_s3tc":
                        r =
                          t.getExtension("WEBGL_compressed_texture_s3tc") ||
                          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                          t.getExtension(
                            "WEBKIT_WEBGL_compressed_texture_s3tc"
                          );
                        break;
                      case "WEBGL_compressed_texture_pvrtc":
                        r =
                          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                          t.getExtension(
                            "WEBKIT_WEBGL_compressed_texture_pvrtc"
                          );
                        break;
                      default:
                        r = t.getExtension(n);
                    }
                    return (e[n] = r), r;
                  }
                  return {
                    has: function (t) {
                      return null !== n(t);
                    },
                    init: function (t) {
                      t.isWebGL2
                        ? n("EXT_color_buffer_float")
                        : (n("WEBGL_depth_texture"),
                          n("OES_texture_float"),
                          n("OES_texture_half_float"),
                          n("OES_texture_half_float_linear"),
                          n("OES_standard_derivatives"),
                          n("OES_element_index_uint"),
                          n("OES_vertex_array_object"),
                          n("ANGLE_instanced_arrays")),
                        n("OES_texture_float_linear"),
                        n("EXT_color_buffer_half_float"),
                        n("WEBGL_multisampled_render_to_texture");
                    },
                    get: function (t) {
                      const e = n(t);
                      return (
                        null === e &&
                          console.warn(
                            "THREE.WebGLRenderer: " +
                              t +
                              " extension not supported."
                          ),
                        e
                      );
                    },
                  };
                }
                function gc(t, e, n, r) {
                  const i = {},
                    a = new WeakMap();
                  function o(t) {
                    const s = t.target;
                    null !== s.index && e.remove(s.index);
                    for (const n in s.attributes) e.remove(s.attributes[n]);
                    s.removeEventListener("dispose", o), delete i[s.id];
                    const c = a.get(s);
                    c && (e.remove(c), a.delete(s)),
                      r.releaseStatesOfGeometry(s),
                      !0 === s.isInstancedBufferGeometry &&
                        delete s._maxInstanceCount,
                      n.memory.geometries--;
                  }
                  function s(t, e) {
                    return (
                      !0 === i[e.id] ||
                        (e.addEventListener("dispose", o),
                        (i[e.id] = !0),
                        n.memory.geometries++),
                      e
                    );
                  }
                  function c(t) {
                    const n = t.attributes;
                    for (const i in n) e.update(n[i], 34962);
                    const r = t.morphAttributes;
                    for (const i in r) {
                      const t = r[i];
                      for (let n = 0, r = t.length; n < r; n++)
                        e.update(t[n], 34962);
                    }
                  }
                  function l(t) {
                    const n = [],
                      r = t.index,
                      i = t.attributes.position;
                    let o = 0;
                    if (null !== r) {
                      const t = r.array;
                      o = r.version;
                      for (let e = 0, r = t.length; e < r; e += 3) {
                        const r = t[e + 0],
                          i = t[e + 1],
                          a = t[e + 2];
                        n.push(r, i, i, a, a, r);
                      }
                    } else {
                      const t = i.array;
                      o = i.version;
                      for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                        const t = e + 0,
                          r = e + 1,
                          i = e + 2;
                        n.push(t, r, r, i, i, t);
                      }
                    }
                    const s = new (yn(n) ? hi : ui)(n, 1);
                    s.version = o;
                    const c = a.get(t);
                    c && e.remove(c), a.set(t, s);
                  }
                  function u(t) {
                    const e = a.get(t);
                    if (e) {
                      const n = t.index;
                      null !== n && e.version < n.version && l(t);
                    } else l(t);
                    return a.get(t);
                  }
                  return { get: s, update: c, getWireframeAttribute: u };
                }
                function vc(t, e, n, r) {
                  const i = r.isWebGL2;
                  let a, o, s;
                  function c(t) {
                    a = t;
                  }
                  function l(t) {
                    (o = t.type), (s = t.bytesPerElement);
                  }
                  function u(e, r) {
                    t.drawElements(a, r, o, e * s), n.update(r, a, 1);
                  }
                  function h(r, c, l) {
                    if (0 === l) return;
                    let u, h;
                    if (i) (u = t), (h = "drawElementsInstanced");
                    else if (
                      ((u = e.get("ANGLE_instanced_arrays")),
                      (h = "drawElementsInstancedANGLE"),
                      null === u)
                    )
                      return void console.error(
                        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                      );
                    u[h](a, c, o, r * s, l), n.update(c, a, l);
                  }
                  (this.setMode = c),
                    (this.setIndex = l),
                    (this.render = u),
                    (this.renderInstances = h);
                }
                function yc(t) {
                  const e = { geometries: 0, textures: 0 },
                    n = {
                      frame: 0,
                      calls: 0,
                      triangles: 0,
                      points: 0,
                      lines: 0,
                    };
                  function r(t, e, r) {
                    switch ((n.calls++, e)) {
                      case 4:
                        n.triangles += r * (t / 3);
                        break;
                      case 1:
                        n.lines += r * (t / 2);
                        break;
                      case 3:
                        n.lines += r * (t - 1);
                        break;
                      case 2:
                        n.lines += r * t;
                        break;
                      case 0:
                        n.points += r * t;
                        break;
                      default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", e);
                        break;
                    }
                  }
                  function i() {
                    n.frame++,
                      (n.calls = 0),
                      (n.triangles = 0),
                      (n.points = 0),
                      (n.lines = 0);
                  }
                  return {
                    memory: e,
                    render: n,
                    programs: null,
                    autoReset: !0,
                    reset: i,
                    update: r,
                  };
                }
                function bc(t, e) {
                  return t[0] - e[0];
                }
                function xc(t, e) {
                  return Math.abs(e[1]) - Math.abs(t[1]);
                }
                function _c(t, e) {
                  let n = 1;
                  const r = e.isInterleavedBufferAttribute
                    ? e.data.array
                    : e.array;
                  r instanceof Int8Array
                    ? (n = 127)
                    : r instanceof Uint8Array
                    ? (n = 255)
                    : r instanceof Uint16Array
                    ? (n = 65535)
                    : r instanceof Int16Array
                    ? (n = 32767)
                    : r instanceof Int32Array
                    ? (n = 2147483647)
                    : console.error(
                        "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
                        r
                      ),
                    t.divideScalar(n);
                }
                function wc(t, e, n) {
                  const r = {},
                    i = new Float32Array(8),
                    a = new WeakMap(),
                    o = new Un(),
                    s = [];
                  for (let l = 0; l < 8; l++) s[l] = [l, 0];
                  function c(c, l, u, h) {
                    const d = c.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                      const f =
                          l.morphAttributes.position ||
                          l.morphAttributes.normal ||
                          l.morphAttributes.color,
                        p = void 0 !== f ? f.length : 0;
                      let m = a.get(l);
                      if (void 0 === m || m.count !== p) {
                        void 0 !== m && m.texture.dispose();
                        const y = void 0 !== l.morphAttributes.position,
                          b = void 0 !== l.morphAttributes.normal,
                          x = void 0 !== l.morphAttributes.color,
                          _ = l.morphAttributes.position || [],
                          w = l.morphAttributes.normal || [],
                          S = l.morphAttributes.color || [];
                        let M = 0;
                        !0 === y && (M = 1),
                          !0 === b && (M = 2),
                          !0 === x && (M = 3);
                        let T = l.attributes.position.count * M,
                          E = 1;
                        T > e.maxTextureSize &&
                          ((E = Math.ceil(T / e.maxTextureSize)),
                          (T = e.maxTextureSize));
                        const A = new Float32Array(T * E * 4 * p),
                          C = new jn(A, T, E, p);
                        (C.type = Et), (C.needsUpdate = !0);
                        const L = 4 * M;
                        for (let P = 0; P < p; P++) {
                          const I = _[P],
                            O = w[P],
                            k = S[P],
                            N = T * E * 4 * P;
                          for (let D = 0; D < I.count; D++) {
                            const z = D * L;
                            !0 === y &&
                              (o.fromBufferAttribute(I, D),
                              !0 === I.normalized && _c(o, I),
                              (A[N + z + 0] = o.x),
                              (A[N + z + 1] = o.y),
                              (A[N + z + 2] = o.z),
                              (A[N + z + 3] = 0)),
                              !0 === b &&
                                (o.fromBufferAttribute(O, D),
                                !0 === O.normalized && _c(o, O),
                                (A[N + z + 4] = o.x),
                                (A[N + z + 5] = o.y),
                                (A[N + z + 6] = o.z),
                                (A[N + z + 7] = 0)),
                              !0 === x &&
                                (o.fromBufferAttribute(k, D),
                                !0 === k.normalized && _c(o, k),
                                (A[N + z + 8] = o.x),
                                (A[N + z + 9] = o.y),
                                (A[N + z + 10] = o.z),
                                (A[N + z + 11] = 4 === k.itemSize ? o.w : 1));
                          }
                        }
                        function R() {
                          C.dispose(),
                            a.delete(l),
                            l.removeEventListener("dispose", R);
                        }
                        (m = { count: p, texture: C, size: new gn(T, E) }),
                          a.set(l, m),
                          l.addEventListener("dispose", R);
                      }
                      let g = 0;
                      for (let F = 0; F < d.length; F++) g += d[F];
                      const v = l.morphTargetsRelative ? 1 : 1 - g;
                      h
                        .getUniforms()
                        .setValue(t, "morphTargetBaseInfluence", v),
                        h.getUniforms().setValue(t, "morphTargetInfluences", d),
                        h
                          .getUniforms()
                          .setValue(t, "morphTargetsTexture", m.texture, n),
                        h
                          .getUniforms()
                          .setValue(t, "morphTargetsTextureSize", m.size);
                    } else {
                      const U = void 0 === d ? 0 : d.length;
                      let B = r[l.id];
                      if (void 0 === B || B.length !== U) {
                        B = [];
                        for (let W = 0; W < U; W++) B[W] = [W, 0];
                        r[l.id] = B;
                      }
                      for (let q = 0; q < U; q++) {
                        const X = B[q];
                        (X[0] = q), (X[1] = d[q]);
                      }
                      B.sort(xc);
                      for (let $ = 0; $ < 8; $++)
                        $ < U && B[$][1]
                          ? ((s[$][0] = B[$][0]), (s[$][1] = B[$][1]))
                          : ((s[$][0] = Number.MAX_SAFE_INTEGER),
                            (s[$][1] = 0));
                      s.sort(bc);
                      const j = l.morphAttributes.position,
                        H = l.morphAttributes.normal;
                      let V = 0;
                      for (let Y = 0; Y < 8; Y++) {
                        const J = s[Y],
                          K = J[0],
                          Z = J[1];
                        K !== Number.MAX_SAFE_INTEGER && Z
                          ? (j &&
                              l.getAttribute("morphTarget" + Y) !== j[K] &&
                              l.setAttribute("morphTarget" + Y, j[K]),
                            H &&
                              l.getAttribute("morphNormal" + Y) !== H[K] &&
                              l.setAttribute("morphNormal" + Y, H[K]),
                            (i[Y] = Z),
                            (V += Z))
                          : (j &&
                              !0 === l.hasAttribute("morphTarget" + Y) &&
                              l.deleteAttribute("morphTarget" + Y),
                            H &&
                              !0 === l.hasAttribute("morphNormal" + Y) &&
                              l.deleteAttribute("morphNormal" + Y),
                            (i[Y] = 0));
                      }
                      const G = l.morphTargetsRelative ? 1 : 1 - V;
                      h
                        .getUniforms()
                        .setValue(t, "morphTargetBaseInfluence", G),
                        h.getUniforms().setValue(t, "morphTargetInfluences", i);
                    }
                  }
                  return { update: c };
                }
                function Sc(t, e, n, r) {
                  let i = new WeakMap();
                  function a(t) {
                    const a = r.render.frame,
                      o = t.geometry,
                      c = e.get(t, o);
                    return (
                      i.get(c) !== a && (e.update(c), i.set(c, a)),
                      t.isInstancedMesh &&
                        (!1 === t.hasEventListener("dispose", s) &&
                          t.addEventListener("dispose", s),
                        n.update(t.instanceMatrix, 34962),
                        null !== t.instanceColor &&
                          n.update(t.instanceColor, 34962)),
                      c
                    );
                  }
                  function o() {
                    i = new WeakMap();
                  }
                  function s(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", s),
                      n.remove(e.instanceMatrix),
                      null !== e.instanceColor && n.remove(e.instanceColor);
                  }
                  return { update: a, dispose: o };
                }
                const Mc = new Fn(),
                  Tc = new jn(),
                  Ec = new Hn(),
                  Ac = new Qi(),
                  Cc = [],
                  Lc = [],
                  Rc = new Float32Array(16),
                  Pc = new Float32Array(9),
                  Ic = new Float32Array(4);
                function Oc(t, e, n) {
                  const r = t[0];
                  if (r <= 0 || r > 0) return t;
                  const i = e * n;
                  let a = Cc[i];
                  if (
                    (void 0 === a && ((a = new Float32Array(i)), (Cc[i] = a)),
                    0 !== e)
                  ) {
                    r.toArray(a, 0);
                    for (let r = 1, i = 0; r !== e; ++r)
                      (i += n), t[r].toArray(a, i);
                  }
                  return a;
                }
                function kc(t, e) {
                  if (t.length !== e.length) return !1;
                  for (let n = 0, r = t.length; n < r; n++)
                    if (t[n] !== e[n]) return !1;
                  return !0;
                }
                function Nc(t, e) {
                  for (let n = 0, r = e.length; n < r; n++) t[n] = e[n];
                }
                function Dc(t, e) {
                  let n = Lc[e];
                  void 0 === n && ((n = new Int32Array(e)), (Lc[e] = n));
                  for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
                  return n;
                }
                function zc(t, e) {
                  const n = this.cache;
                  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
                }
                function Fc(t, e) {
                  const n = this.cache;
                  if (void 0 !== e.x)
                    (n[0] === e.x && n[1] === e.y) ||
                      (t.uniform2f(this.addr, e.x, e.y),
                      (n[0] = e.x),
                      (n[1] = e.y));
                  else {
                    if (kc(n, e)) return;
                    t.uniform2fv(this.addr, e), Nc(n, e);
                  }
                }
                function Uc(t, e) {
                  const n = this.cache;
                  if (void 0 !== e.x)
                    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                      (t.uniform3f(this.addr, e.x, e.y, e.z),
                      (n[0] = e.x),
                      (n[1] = e.y),
                      (n[2] = e.z));
                  else if (void 0 !== e.r)
                    (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                      (t.uniform3f(this.addr, e.r, e.g, e.b),
                      (n[0] = e.r),
                      (n[1] = e.g),
                      (n[2] = e.b));
                  else {
                    if (kc(n, e)) return;
                    t.uniform3fv(this.addr, e), Nc(n, e);
                  }
                }
                function Bc(t, e) {
                  const n = this.cache;
                  if (void 0 !== e.x)
                    (n[0] === e.x &&
                      n[1] === e.y &&
                      n[2] === e.z &&
                      n[3] === e.w) ||
                      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                      (n[0] = e.x),
                      (n[1] = e.y),
                      (n[2] = e.z),
                      (n[3] = e.w));
                  else {
                    if (kc(n, e)) return;
                    t.uniform4fv(this.addr, e), Nc(n, e);
                  }
                }
                function jc(t, e) {
                  const n = this.cache,
                    r = e.elements;
                  if (void 0 === r) {
                    if (kc(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Nc(n, e);
                  } else {
                    if (kc(n, r)) return;
                    Ic.set(r), t.uniformMatrix2fv(this.addr, !1, Ic), Nc(n, r);
                  }
                }
                function Hc(t, e) {
                  const n = this.cache,
                    r = e.elements;
                  if (void 0 === r) {
                    if (kc(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Nc(n, e);
                  } else {
                    if (kc(n, r)) return;
                    Pc.set(r), t.uniformMatrix3fv(this.addr, !1, Pc), Nc(n, r);
                  }
                }
                function Vc(t, e) {
                  const n = this.cache,
                    r = e.elements;
                  if (void 0 === r) {
                    if (kc(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Nc(n, e);
                  } else {
                    if (kc(n, r)) return;
                    Rc.set(r), t.uniformMatrix4fv(this.addr, !1, Rc), Nc(n, r);
                  }
                }
                function Gc(t, e) {
                  const n = this.cache;
                  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
                }
                function Wc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform2iv(this.addr, e), Nc(n, e));
                }
                function qc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform3iv(this.addr, e), Nc(n, e));
                }
                function Xc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform4iv(this.addr, e), Nc(n, e));
                }
                function $c(t, e) {
                  const n = this.cache;
                  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
                }
                function Yc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform2uiv(this.addr, e), Nc(n, e));
                }
                function Jc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform3uiv(this.addr, e), Nc(n, e));
                }
                function Kc(t, e) {
                  const n = this.cache;
                  kc(n, e) || (t.uniform4uiv(this.addr, e), Nc(n, e));
                }
                function Zc(t, e, n) {
                  const r = this.cache,
                    i = n.allocateTextureUnit();
                  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                    n.setTexture2D(e || Mc, i);
                }
                function Qc(t, e, n) {
                  const r = this.cache,
                    i = n.allocateTextureUnit();
                  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                    n.setTexture3D(e || Ec, i);
                }
                function tl(t, e, n) {
                  const r = this.cache,
                    i = n.allocateTextureUnit();
                  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                    n.setTextureCube(e || Ac, i);
                }
                function el(t, e, n) {
                  const r = this.cache,
                    i = n.allocateTextureUnit();
                  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                    n.setTexture2DArray(e || Tc, i);
                }
                function nl(t) {
                  switch (t) {
                    case 5126:
                      return zc;
                    case 35664:
                      return Fc;
                    case 35665:
                      return Uc;
                    case 35666:
                      return Bc;
                    case 35674:
                      return jc;
                    case 35675:
                      return Hc;
                    case 35676:
                      return Vc;
                    case 5124:
                    case 35670:
                      return Gc;
                    case 35667:
                    case 35671:
                      return Wc;
                    case 35668:
                    case 35672:
                      return qc;
                    case 35669:
                    case 35673:
                      return Xc;
                    case 5125:
                      return $c;
                    case 36294:
                      return Yc;
                    case 36295:
                      return Jc;
                    case 36296:
                      return Kc;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                      return Zc;
                    case 35679:
                    case 36299:
                    case 36307:
                      return Qc;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                      return tl;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                      return el;
                  }
                }
                function rl(t, e) {
                  t.uniform1fv(this.addr, e);
                }
                function il(t, e) {
                  const n = Oc(e, this.size, 2);
                  t.uniform2fv(this.addr, n);
                }
                function al(t, e) {
                  const n = Oc(e, this.size, 3);
                  t.uniform3fv(this.addr, n);
                }
                function ol(t, e) {
                  const n = Oc(e, this.size, 4);
                  t.uniform4fv(this.addr, n);
                }
                function sl(t, e) {
                  const n = Oc(e, this.size, 4);
                  t.uniformMatrix2fv(this.addr, !1, n);
                }
                function cl(t, e) {
                  const n = Oc(e, this.size, 9);
                  t.uniformMatrix3fv(this.addr, !1, n);
                }
                function ll(t, e) {
                  const n = Oc(e, this.size, 16);
                  t.uniformMatrix4fv(this.addr, !1, n);
                }
                function ul(t, e) {
                  t.uniform1iv(this.addr, e);
                }
                function hl(t, e) {
                  t.uniform2iv(this.addr, e);
                }
                function dl(t, e) {
                  t.uniform3iv(this.addr, e);
                }
                function fl(t, e) {
                  t.uniform4iv(this.addr, e);
                }
                function pl(t, e) {
                  t.uniform1uiv(this.addr, e);
                }
                function ml(t, e) {
                  t.uniform2uiv(this.addr, e);
                }
                function gl(t, e) {
                  t.uniform3uiv(this.addr, e);
                }
                function vl(t, e) {
                  t.uniform4uiv(this.addr, e);
                }
                function yl(t, e, n) {
                  const r = e.length,
                    i = Dc(n, r);
                  t.uniform1iv(this.addr, i);
                  for (let a = 0; a !== r; ++a)
                    n.setTexture2D(e[a] || Mc, i[a]);
                }
                function bl(t, e, n) {
                  const r = e.length,
                    i = Dc(n, r);
                  t.uniform1iv(this.addr, i);
                  for (let a = 0; a !== r; ++a)
                    n.setTexture3D(e[a] || Ec, i[a]);
                }
                function xl(t, e, n) {
                  const r = e.length,
                    i = Dc(n, r);
                  t.uniform1iv(this.addr, i);
                  for (let a = 0; a !== r; ++a)
                    n.setTextureCube(e[a] || Ac, i[a]);
                }
                function _l(t, e, n) {
                  const r = e.length,
                    i = Dc(n, r);
                  t.uniform1iv(this.addr, i);
                  for (let a = 0; a !== r; ++a)
                    n.setTexture2DArray(e[a] || Tc, i[a]);
                }
                function wl(t) {
                  switch (t) {
                    case 5126:
                      return rl;
                    case 35664:
                      return il;
                    case 35665:
                      return al;
                    case 35666:
                      return ol;
                    case 35674:
                      return sl;
                    case 35675:
                      return cl;
                    case 35676:
                      return ll;
                    case 5124:
                    case 35670:
                      return ul;
                    case 35667:
                    case 35671:
                      return hl;
                    case 35668:
                    case 35672:
                      return dl;
                    case 35669:
                    case 35673:
                      return fl;
                    case 5125:
                      return pl;
                    case 36294:
                      return ml;
                    case 36295:
                      return gl;
                    case 36296:
                      return vl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                      return yl;
                    case 35679:
                    case 36299:
                    case 36307:
                      return bl;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                      return xl;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                      return _l;
                  }
                }
                class Sl {
                  constructor(t, e, n) {
                    (this.id = t),
                      (this.addr = n),
                      (this.cache = []),
                      (this.setValue = nl(e.type));
                  }
                }
                class Ml {
                  constructor(t, e, n) {
                    (this.id = t),
                      (this.addr = n),
                      (this.cache = []),
                      (this.size = e.size),
                      (this.setValue = wl(e.type));
                  }
                }
                class Tl {
                  constructor(t) {
                    (this.id = t), (this.seq = []), (this.map = {});
                  }
                  setValue(t, e, n) {
                    const r = this.seq;
                    for (let i = 0, a = r.length; i !== a; ++i) {
                      const a = r[i];
                      a.setValue(t, e[a.id], n);
                    }
                  }
                }
                const El = /(\w+)(\])?(\[|\.)?/g;
                function Al(t, e) {
                  t.seq.push(e), (t.map[e.id] = e);
                }
                function Cl(t, e, n) {
                  const r = t.name,
                    i = r.length;
                  El.lastIndex = 0;
                  while (1) {
                    const a = El.exec(r),
                      o = El.lastIndex;
                    let s = a[1];
                    const c = "]" === a[2],
                      l = a[3];
                    if (
                      (c && (s |= 0),
                      void 0 === l || ("[" === l && o + 2 === i))
                    ) {
                      Al(n, void 0 === l ? new Sl(s, t, e) : new Ml(s, t, e));
                      break;
                    }
                    {
                      const t = n.map;
                      let e = t[s];
                      void 0 === e && ((e = new Tl(s)), Al(n, e)), (n = e);
                    }
                  }
                }
                class Ll {
                  constructor(t, e) {
                    (this.seq = []), (this.map = {});
                    const n = t.getProgramParameter(e, 35718);
                    for (let r = 0; r < n; ++r) {
                      const n = t.getActiveUniform(e, r),
                        i = t.getUniformLocation(e, n.name);
                      Cl(n, i, this);
                    }
                  }
                  setValue(t, e, n, r) {
                    const i = this.map[e];
                    void 0 !== i && i.setValue(t, n, r);
                  }
                  setOptional(t, e, n) {
                    const r = e[n];
                    void 0 !== r && this.setValue(t, n, r);
                  }
                  static upload(t, e, n, r) {
                    for (let i = 0, a = e.length; i !== a; ++i) {
                      const a = e[i],
                        o = n[a.id];
                      !1 !== o.needsUpdate && a.setValue(t, o.value, r);
                    }
                  }
                  static seqWithValue(t, e) {
                    const n = [];
                    for (let r = 0, i = t.length; r !== i; ++r) {
                      const i = t[r];
                      i.id in e && n.push(i);
                    }
                    return n;
                  }
                }
                function Rl(t, e, n) {
                  const r = t.createShader(e);
                  return t.shaderSource(r, n), t.compileShader(r), r;
                }
                let Pl = 0;
                function Il(t, e) {
                  const n = t.split("\n"),
                    r = [],
                    i = Math.max(e - 6, 0),
                    a = Math.min(e + 6, n.length);
                  for (let o = i; o < a; o++) {
                    const t = o + 1;
                    r.push(`${t === e ? ">" : " "} ${t}: ${n[o]}`);
                  }
                  return r.join("\n");
                }
                function Ol(t) {
                  switch (t) {
                    case Ce:
                      return ["Linear", "( value )"];
                    case Le:
                      return ["sRGB", "( value )"];
                    default:
                      return (
                        console.warn(
                          "THREE.WebGLProgram: Unsupported encoding:",
                          t
                        ),
                        ["Linear", "( value )"]
                      );
                  }
                }
                function kl(t, e, n) {
                  const r = t.getShaderParameter(e, 35713),
                    i = t.getShaderInfoLog(e).trim();
                  if (r && "" === i) return "";
                  const a = /ERROR: 0:(\d+)/.exec(i);
                  if (a) {
                    const r = parseInt(a[1]);
                    return (
                      n.toUpperCase() +
                      "\n\n" +
                      i +
                      "\n\n" +
                      Il(t.getShaderSource(e), r)
                    );
                  }
                  return i;
                }
                function Nl(t, e) {
                  const n = Ol(e);
                  return (
                    "vec4 " +
                    t +
                    "( vec4 value ) { return LinearTo" +
                    n[0] +
                    n[1] +
                    "; }"
                  );
                }
                function Dl(t, e) {
                  let n;
                  switch (e) {
                    case tt:
                      n = "Linear";
                      break;
                    case et:
                      n = "Reinhard";
                      break;
                    case nt:
                      n = "OptimizedCineon";
                      break;
                    case rt:
                      n = "ACESFilmic";
                      break;
                    case it:
                      n = "Custom";
                      break;
                    default:
                      console.warn(
                        "THREE.WebGLProgram: Unsupported toneMapping:",
                        e
                      ),
                        (n = "Linear");
                  }
                  return (
                    "vec3 " +
                    t +
                    "( vec3 color ) { return " +
                    n +
                    "ToneMapping( color ); }"
                  );
                }
                function zl(t) {
                  const e = [
                    t.extensionDerivatives ||
                    t.envMapCubeUVHeight ||
                    t.bumpMap ||
                    t.tangentSpaceNormalMap ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD ||
                      t.envMap ||
                      t.transmission) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ];
                  return e.filter(Bl).join("\n");
                }
                function Fl(t) {
                  const e = [];
                  for (const n in t) {
                    const r = t[n];
                    !1 !== r && e.push("#define " + n + " " + r);
                  }
                  return e.join("\n");
                }
                function Ul(t, e) {
                  const n = {},
                    r = t.getProgramParameter(e, 35721);
                  for (let i = 0; i < r; i++) {
                    const r = t.getActiveAttrib(e, i),
                      a = r.name;
                    let o = 1;
                    35674 === r.type && (o = 2),
                      35675 === r.type && (o = 3),
                      35676 === r.type && (o = 4),
                      (n[a] = {
                        type: r.type,
                        location: t.getAttribLocation(e, a),
                        locationSize: o,
                      });
                  }
                  return n;
                }
                function Bl(t) {
                  return "" !== t;
                }
                function jl(t, e) {
                  return t
                    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
                    .replace(
                      /NUM_POINT_LIGHT_SHADOWS/g,
                      e.numPointLightShadows
                    );
                }
                function Hl(t, e) {
                  return t
                    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                    .replace(
                      /UNION_CLIPPING_PLANES/g,
                      e.numClippingPlanes - e.numClipIntersection
                    );
                }
                const Vl = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function Gl(t) {
                  return t.replace(Vl, Wl);
                }
                function Wl(t, e) {
                  const n = js[e];
                  if (void 0 === n)
                    throw new Error("Can not resolve #include <" + e + ">");
                  return Gl(n);
                }
                const ql =
                    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                  Xl =
                    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function $l(t) {
                  return t.replace(Xl, Jl).replace(ql, Yl);
                }
                function Yl(t, e, n, r) {
                  return (
                    console.warn(
                      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
                    ),
                    Jl(t, e, n, r)
                  );
                }
                function Jl(t, e, n, r) {
                  let i = "";
                  for (let a = parseInt(e); a < parseInt(n); a++)
                    i += r
                      .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
                      .replace(/UNROLLED_LOOP_INDEX/g, a);
                  return i;
                }
                function Kl(t) {
                  let e =
                    "precision " +
                    t.precision +
                    " float;\nprecision " +
                    t.precision +
                    " int;";
                  return (
                    "highp" === t.precision
                      ? (e += "\n#define HIGH_PRECISION")
                      : "mediump" === t.precision
                      ? (e += "\n#define MEDIUM_PRECISION")
                      : "lowp" === t.precision &&
                        (e += "\n#define LOW_PRECISION"),
                    e
                  );
                }
                function Zl(t) {
                  let e = "SHADOWMAP_TYPE_BASIC";
                  return (
                    t.shadowMapType === f
                      ? (e = "SHADOWMAP_TYPE_PCF")
                      : t.shadowMapType === p
                      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                      : t.shadowMapType === m && (e = "SHADOWMAP_TYPE_VSM"),
                    e
                  );
                }
                function Ql(t) {
                  let e = "ENVMAP_TYPE_CUBE";
                  if (t.envMap)
                    switch (t.envMapMode) {
                      case ot:
                      case st:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                      case ut:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    }
                  return e;
                }
                function tu(t) {
                  let e = "ENVMAP_MODE_REFLECTION";
                  if (t.envMap)
                    switch (t.envMapMode) {
                      case st:
                        e = "ENVMAP_MODE_REFRACTION";
                        break;
                    }
                  return e;
                }
                function eu(t) {
                  let e = "ENVMAP_BLENDING_NONE";
                  if (t.envMap)
                    switch (t.combine) {
                      case J:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                      case K:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                      case Z:
                        e = "ENVMAP_BLENDING_ADD";
                        break;
                    }
                  return e;
                }
                function nu(t) {
                  const e = t.envMapCubeUVHeight;
                  if (null === e) return null;
                  const n = Math.log2(e) - 2,
                    r = 1 / e,
                    i = 1 / (3 * Math.max(Math.pow(2, n), 112));
                  return { texelWidth: i, texelHeight: r, maxMip: n };
                }
                function ru(t, e, n, r) {
                  const i = t.getContext(),
                    a = n.defines;
                  let o = n.vertexShader,
                    s = n.fragmentShader;
                  const c = Zl(n),
                    l = Ql(n),
                    u = tu(n),
                    h = eu(n),
                    d = nu(n),
                    f = n.isWebGL2 ? "" : zl(n),
                    p = Fl(a),
                    m = i.createProgram();
                  let g,
                    v,
                    y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                  n.isRawShaderMaterial
                    ? ((g = [p].filter(Bl).join("\n")),
                      g.length > 0 && (g += "\n"),
                      (v = [f, p].filter(Bl).join("\n")),
                      v.length > 0 && (v += "\n"))
                    : ((g = [
                        Kl(n),
                        "#define SHADER_NAME " + n.shaderName,
                        p,
                        n.instancing ? "#define USE_INSTANCING" : "",
                        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                        n.supportsVertexTextures
                          ? "#define VERTEX_TEXTURES"
                          : "",
                        n.useFog && n.fog ? "#define USE_FOG" : "",
                        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                        n.map ? "#define USE_MAP" : "",
                        n.envMap ? "#define USE_ENVMAP" : "",
                        n.envMap ? "#define " + u : "",
                        n.lightMap ? "#define USE_LIGHTMAP" : "",
                        n.aoMap ? "#define USE_AOMAP" : "",
                        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                        n.bumpMap ? "#define USE_BUMPMAP" : "",
                        n.normalMap ? "#define USE_NORMALMAP" : "",
                        n.normalMap && n.objectSpaceNormalMap
                          ? "#define OBJECTSPACE_NORMALMAP"
                          : "",
                        n.normalMap && n.tangentSpaceNormalMap
                          ? "#define TANGENTSPACE_NORMALMAP"
                          : "",
                        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                        n.clearcoatRoughnessMap
                          ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                          : "",
                        n.clearcoatNormalMap
                          ? "#define USE_CLEARCOAT_NORMALMAP"
                          : "",
                        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                        n.iridescenceThicknessMap
                          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                          : "",
                        n.displacementMap && n.supportsVertexTextures
                          ? "#define USE_DISPLACEMENTMAP"
                          : "",
                        n.specularMap ? "#define USE_SPECULARMAP" : "",
                        n.specularIntensityMap
                          ? "#define USE_SPECULARINTENSITYMAP"
                          : "",
                        n.specularColorMap
                          ? "#define USE_SPECULARCOLORMAP"
                          : "",
                        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                        n.alphaMap ? "#define USE_ALPHAMAP" : "",
                        n.transmission ? "#define USE_TRANSMISSION" : "",
                        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                        n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
                        n.sheenRoughnessMap
                          ? "#define USE_SHEENROUGHNESSMAP"
                          : "",
                        n.vertexTangents ? "#define USE_TANGENT" : "",
                        n.vertexColors ? "#define USE_COLOR" : "",
                        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                        n.vertexUvs ? "#define USE_UV" : "",
                        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                        n.flatShading ? "#define FLAT_SHADED" : "",
                        n.skinning ? "#define USE_SKINNING" : "",
                        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                        n.morphNormals && !1 === n.flatShading
                          ? "#define USE_MORPHNORMALS"
                          : "",
                        n.morphColors && n.isWebGL2
                          ? "#define USE_MORPHCOLORS"
                          : "",
                        n.morphTargetsCount > 0 && n.isWebGL2
                          ? "#define MORPHTARGETS_TEXTURE"
                          : "",
                        n.morphTargetsCount > 0 && n.isWebGL2
                          ? "#define MORPHTARGETS_TEXTURE_STRIDE " +
                            n.morphTextureStride
                          : "",
                        n.morphTargetsCount > 0 && n.isWebGL2
                          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                          : "",
                        n.doubleSided ? "#define DOUBLE_SIDED" : "",
                        n.flipSided ? "#define FLIP_SIDED" : "",
                        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                        n.shadowMapEnabled ? "#define " + c : "",
                        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                        n.logarithmicDepthBuffer
                          ? "#define USE_LOGDEPTHBUF"
                          : "",
                        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                          ? "#define USE_LOGDEPTHBUF_EXT"
                          : "",
                        "uniform mat4 modelMatrix;",
                        "uniform mat4 modelViewMatrix;",
                        "uniform mat4 projectionMatrix;",
                        "uniform mat4 viewMatrix;",
                        "uniform mat3 normalMatrix;",
                        "uniform vec3 cameraPosition;",
                        "uniform bool isOrthographic;",
                        "#ifdef USE_INSTANCING",
                        "\tattribute mat4 instanceMatrix;",
                        "#endif",
                        "#ifdef USE_INSTANCING_COLOR",
                        "\tattribute vec3 instanceColor;",
                        "#endif",
                        "attribute vec3 position;",
                        "attribute vec3 normal;",
                        "attribute vec2 uv;",
                        "#ifdef USE_TANGENT",
                        "\tattribute vec4 tangent;",
                        "#endif",
                        "#if defined( USE_COLOR_ALPHA )",
                        "\tattribute vec4 color;",
                        "#elif defined( USE_COLOR )",
                        "\tattribute vec3 color;",
                        "#endif",
                        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                        "\tattribute vec3 morphTarget0;",
                        "\tattribute vec3 morphTarget1;",
                        "\tattribute vec3 morphTarget2;",
                        "\tattribute vec3 morphTarget3;",
                        "\t#ifdef USE_MORPHNORMALS",
                        "\t\tattribute vec3 morphNormal0;",
                        "\t\tattribute vec3 morphNormal1;",
                        "\t\tattribute vec3 morphNormal2;",
                        "\t\tattribute vec3 morphNormal3;",
                        "\t#else",
                        "\t\tattribute vec3 morphTarget4;",
                        "\t\tattribute vec3 morphTarget5;",
                        "\t\tattribute vec3 morphTarget6;",
                        "\t\tattribute vec3 morphTarget7;",
                        "\t#endif",
                        "#endif",
                        "#ifdef USE_SKINNING",
                        "\tattribute vec4 skinIndex;",
                        "\tattribute vec4 skinWeight;",
                        "#endif",
                        "\n",
                      ]
                        .filter(Bl)
                        .join("\n")),
                      (v = [
                        f,
                        Kl(n),
                        "#define SHADER_NAME " + n.shaderName,
                        p,
                        n.useFog && n.fog ? "#define USE_FOG" : "",
                        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                        n.map ? "#define USE_MAP" : "",
                        n.matcap ? "#define USE_MATCAP" : "",
                        n.envMap ? "#define USE_ENVMAP" : "",
                        n.envMap ? "#define " + l : "",
                        n.envMap ? "#define " + u : "",
                        n.envMap ? "#define " + h : "",
                        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
                        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
                        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
                        n.lightMap ? "#define USE_LIGHTMAP" : "",
                        n.aoMap ? "#define USE_AOMAP" : "",
                        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                        n.bumpMap ? "#define USE_BUMPMAP" : "",
                        n.normalMap ? "#define USE_NORMALMAP" : "",
                        n.normalMap && n.objectSpaceNormalMap
                          ? "#define OBJECTSPACE_NORMALMAP"
                          : "",
                        n.normalMap && n.tangentSpaceNormalMap
                          ? "#define TANGENTSPACE_NORMALMAP"
                          : "",
                        n.clearcoat ? "#define USE_CLEARCOAT" : "",
                        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                        n.clearcoatRoughnessMap
                          ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                          : "",
                        n.clearcoatNormalMap
                          ? "#define USE_CLEARCOAT_NORMALMAP"
                          : "",
                        n.iridescence ? "#define USE_IRIDESCENCE" : "",
                        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                        n.iridescenceThicknessMap
                          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                          : "",
                        n.specularMap ? "#define USE_SPECULARMAP" : "",
                        n.specularIntensityMap
                          ? "#define USE_SPECULARINTENSITYMAP"
                          : "",
                        n.specularColorMap
                          ? "#define USE_SPECULARCOLORMAP"
                          : "",
                        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                        n.alphaMap ? "#define USE_ALPHAMAP" : "",
                        n.alphaTest ? "#define USE_ALPHATEST" : "",
                        n.sheen ? "#define USE_SHEEN" : "",
                        n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
                        n.sheenRoughnessMap
                          ? "#define USE_SHEENROUGHNESSMAP"
                          : "",
                        n.transmission ? "#define USE_TRANSMISSION" : "",
                        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                        n.decodeVideoTexture
                          ? "#define DECODE_VIDEO_TEXTURE"
                          : "",
                        n.vertexTangents ? "#define USE_TANGENT" : "",
                        n.vertexColors || n.instancingColor
                          ? "#define USE_COLOR"
                          : "",
                        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                        n.vertexUvs ? "#define USE_UV" : "",
                        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                        n.flatShading ? "#define FLAT_SHADED" : "",
                        n.doubleSided ? "#define DOUBLE_SIDED" : "",
                        n.flipSided ? "#define FLIP_SIDED" : "",
                        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                        n.shadowMapEnabled ? "#define " + c : "",
                        n.premultipliedAlpha
                          ? "#define PREMULTIPLIED_ALPHA"
                          : "",
                        n.physicallyCorrectLights
                          ? "#define PHYSICALLY_CORRECT_LIGHTS"
                          : "",
                        n.logarithmicDepthBuffer
                          ? "#define USE_LOGDEPTHBUF"
                          : "",
                        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                          ? "#define USE_LOGDEPTHBUF_EXT"
                          : "",
                        "uniform mat4 viewMatrix;",
                        "uniform vec3 cameraPosition;",
                        "uniform bool isOrthographic;",
                        n.toneMapping !== Q ? "#define TONE_MAPPING" : "",
                        n.toneMapping !== Q
                          ? js["tonemapping_pars_fragment"]
                          : "",
                        n.toneMapping !== Q
                          ? Dl("toneMapping", n.toneMapping)
                          : "",
                        n.dithering ? "#define DITHERING" : "",
                        n.opaque ? "#define OPAQUE" : "",
                        js["encodings_pars_fragment"],
                        Nl("linearToOutputTexel", n.outputEncoding),
                        n.useDepthPacking
                          ? "#define DEPTH_PACKING " + n.depthPacking
                          : "",
                        "\n",
                      ]
                        .filter(Bl)
                        .join("\n"))),
                    (o = Gl(o)),
                    (o = jl(o, n)),
                    (o = Hl(o, n)),
                    (s = Gl(s)),
                    (s = jl(s, n)),
                    (s = Hl(s, n)),
                    (o = $l(o)),
                    (s = $l(s)),
                    n.isWebGL2 &&
                      !0 !== n.isRawShaderMaterial &&
                      ((y = "#version 300 es\n"),
                      (g =
                        [
                          "precision mediump sampler2DArray;",
                          "#define attribute in",
                          "#define varying out",
                          "#define texture2D texture",
                        ].join("\n") +
                        "\n" +
                        g),
                      (v =
                        [
                          "#define varying in",
                          n.glslVersion === Ue
                            ? ""
                            : "layout(location = 0) out highp vec4 pc_fragColor;",
                          n.glslVersion === Ue
                            ? ""
                            : "#define gl_FragColor pc_fragColor",
                          "#define gl_FragDepthEXT gl_FragDepth",
                          "#define texture2D texture",
                          "#define textureCube texture",
                          "#define texture2DProj textureProj",
                          "#define texture2DLodEXT textureLod",
                          "#define texture2DProjLodEXT textureProjLod",
                          "#define textureCubeLodEXT textureLod",
                          "#define texture2DGradEXT textureGrad",
                          "#define texture2DProjGradEXT textureProjGrad",
                          "#define textureCubeGradEXT textureGrad",
                        ].join("\n") +
                        "\n" +
                        v));
                  const b = y + g + o,
                    x = y + v + s,
                    _ = Rl(i, 35633, b),
                    w = Rl(i, 35632, x);
                  if (
                    (i.attachShader(m, _),
                    i.attachShader(m, w),
                    void 0 !== n.index0AttributeName
                      ? i.bindAttribLocation(m, 0, n.index0AttributeName)
                      : !0 === n.morphTargets &&
                        i.bindAttribLocation(m, 0, "position"),
                    i.linkProgram(m),
                    t.debug.checkShaderErrors)
                  ) {
                    const t = i.getProgramInfoLog(m).trim(),
                      e = i.getShaderInfoLog(_).trim(),
                      n = i.getShaderInfoLog(w).trim();
                    let r = !0,
                      a = !0;
                    if (!1 === i.getProgramParameter(m, 35714)) {
                      r = !1;
                      const e = kl(i, _, "vertex"),
                        n = kl(i, w, "fragment");
                      console.error(
                        "THREE.WebGLProgram: Shader Error " +
                          i.getError() +
                          " - VALIDATE_STATUS " +
                          i.getProgramParameter(m, 35715) +
                          "\n\nProgram Info Log: " +
                          t +
                          "\n" +
                          e +
                          "\n" +
                          n
                      );
                    } else
                      "" !== t
                        ? console.warn(
                            "THREE.WebGLProgram: Program Info Log:",
                            t
                          )
                        : ("" !== e && "" !== n) || (a = !1);
                    a &&
                      (this.diagnostics = {
                        runnable: r,
                        programLog: t,
                        vertexShader: { log: e, prefix: g },
                        fragmentShader: { log: n, prefix: v },
                      });
                  }
                  let S, M;
                  return (
                    i.deleteShader(_),
                    i.deleteShader(w),
                    (this.getUniforms = function () {
                      return void 0 === S && (S = new Ll(i, m)), S;
                    }),
                    (this.getAttributes = function () {
                      return void 0 === M && (M = Ul(i, m)), M;
                    }),
                    (this.destroy = function () {
                      r.releaseStatesOfProgram(this),
                        i.deleteProgram(m),
                        (this.program = void 0);
                    }),
                    (this.name = n.shaderName),
                    (this.id = Pl++),
                    (this.cacheKey = e),
                    (this.usedTimes = 1),
                    (this.program = m),
                    (this.vertexShader = _),
                    (this.fragmentShader = w),
                    this
                  );
                }
                let iu = 0;
                class au {
                  constructor() {
                    (this.shaderCache = new Map()),
                      (this.materialCache = new Map());
                  }
                  update(t) {
                    const e = t.vertexShader,
                      n = t.fragmentShader,
                      r = this._getShaderStage(e),
                      i = this._getShaderStage(n),
                      a = this._getShaderCacheForMaterial(t);
                    return (
                      !1 === a.has(r) && (a.add(r), r.usedTimes++),
                      !1 === a.has(i) && (a.add(i), i.usedTimes++),
                      this
                    );
                  }
                  remove(t) {
                    const e = this.materialCache.get(t);
                    for (const n of e)
                      n.usedTimes--,
                        0 === n.usedTimes && this.shaderCache.delete(n.code);
                    return this.materialCache.delete(t), this;
                  }
                  getVertexShaderID(t) {
                    return this._getShaderStage(t.vertexShader).id;
                  }
                  getFragmentShaderID(t) {
                    return this._getShaderStage(t.fragmentShader).id;
                  }
                  dispose() {
                    this.shaderCache.clear(), this.materialCache.clear();
                  }
                  _getShaderCacheForMaterial(t) {
                    const e = this.materialCache;
                    return !1 === e.has(t) && e.set(t, new Set()), e.get(t);
                  }
                  _getShaderStage(t) {
                    const e = this.shaderCache;
                    if (!1 === e.has(t)) {
                      const n = new ou(t);
                      e.set(t, n);
                    }
                    return e.get(t);
                  }
                }
                class ou {
                  constructor(t) {
                    (this.id = iu++), (this.code = t), (this.usedTimes = 0);
                  }
                }
                function su(t, e, n, r, i, a, o) {
                  const s = new Ir(),
                    c = new au(),
                    l = [],
                    u = i.isWebGL2,
                    h = i.logarithmicDepthBuffer,
                    d = i.vertexTextures;
                  let f = i.precision;
                  const p = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite",
                  };
                  function m(a, s, l, m, g) {
                    const b = m.fog,
                      x = g.geometry,
                      w = a.isMeshStandardMaterial ? m.environment : null,
                      S = (a.isMeshStandardMaterial ? n : e).get(a.envMap || w),
                      M = S && S.mapping === ut ? S.image.height : null,
                      T = p[a.type];
                    null !== a.precision &&
                      ((f = i.getMaxPrecision(a.precision)),
                      f !== a.precision &&
                        console.warn(
                          "THREE.WebGLProgram.getParameters:",
                          a.precision,
                          "not supported, using",
                          f,
                          "instead."
                        ));
                    const E =
                        x.morphAttributes.position ||
                        x.morphAttributes.normal ||
                        x.morphAttributes.color,
                      A = void 0 !== E ? E.length : 0;
                    let C,
                      L,
                      R,
                      P,
                      I = 0;
                    if (
                      (void 0 !== x.morphAttributes.position && (I = 1),
                      void 0 !== x.morphAttributes.normal && (I = 2),
                      void 0 !== x.morphAttributes.color && (I = 3),
                      T)
                    ) {
                      const t = Vs[T];
                      (C = t.vertexShader), (L = t.fragmentShader);
                    } else
                      (C = a.vertexShader),
                        (L = a.fragmentShader),
                        c.update(a),
                        (R = c.getVertexShaderID(a)),
                        (P = c.getFragmentShaderID(a));
                    const O = t.getRenderTarget(),
                      k = a.alphaTest > 0,
                      N = a.clearcoat > 0,
                      D = a.iridescence > 0,
                      z = {
                        isWebGL2: u,
                        shaderID: T,
                        shaderName: a.type,
                        vertexShader: C,
                        fragmentShader: L,
                        defines: a.defines,
                        customVertexShaderID: R,
                        customFragmentShaderID: P,
                        isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                        glslVersion: a.glslVersion,
                        precision: f,
                        instancing: !0 === g.isInstancedMesh,
                        instancingColor:
                          !0 === g.isInstancedMesh && null !== g.instanceColor,
                        supportsVertexTextures: d,
                        outputEncoding:
                          null === O
                            ? t.outputEncoding
                            : !0 === O.isXRRenderTarget
                            ? O.texture.encoding
                            : Ce,
                        map: !!a.map,
                        matcap: !!a.matcap,
                        envMap: !!S,
                        envMapMode: S && S.mapping,
                        envMapCubeUVHeight: M,
                        lightMap: !!a.lightMap,
                        aoMap: !!a.aoMap,
                        emissiveMap: !!a.emissiveMap,
                        bumpMap: !!a.bumpMap,
                        normalMap: !!a.normalMap,
                        objectSpaceNormalMap: a.normalMapType === Oe,
                        tangentSpaceNormalMap: a.normalMapType === Ie,
                        decodeVideoTexture:
                          !!a.map &&
                          !0 === a.map.isVideoTexture &&
                          a.map.encoding === Le,
                        clearcoat: N,
                        clearcoatMap: N && !!a.clearcoatMap,
                        clearcoatRoughnessMap: N && !!a.clearcoatRoughnessMap,
                        clearcoatNormalMap: N && !!a.clearcoatNormalMap,
                        iridescence: D,
                        iridescenceMap: D && !!a.iridescenceMap,
                        iridescenceThicknessMap:
                          D && !!a.iridescenceThicknessMap,
                        displacementMap: !!a.displacementMap,
                        roughnessMap: !!a.roughnessMap,
                        metalnessMap: !!a.metalnessMap,
                        specularMap: !!a.specularMap,
                        specularIntensityMap: !!a.specularIntensityMap,
                        specularColorMap: !!a.specularColorMap,
                        opaque: !1 === a.transparent && a.blending === _,
                        alphaMap: !!a.alphaMap,
                        alphaTest: k,
                        gradientMap: !!a.gradientMap,
                        sheen: a.sheen > 0,
                        sheenColorMap: !!a.sheenColorMap,
                        sheenRoughnessMap: !!a.sheenRoughnessMap,
                        transmission: a.transmission > 0,
                        transmissionMap: !!a.transmissionMap,
                        thicknessMap: !!a.thicknessMap,
                        combine: a.combine,
                        vertexTangents: !!a.normalMap && !!x.attributes.tangent,
                        vertexColors: a.vertexColors,
                        vertexAlphas:
                          !0 === a.vertexColors &&
                          !!x.attributes.color &&
                          4 === x.attributes.color.itemSize,
                        vertexUvs:
                          !!a.map ||
                          !!a.bumpMap ||
                          !!a.normalMap ||
                          !!a.specularMap ||
                          !!a.alphaMap ||
                          !!a.emissiveMap ||
                          !!a.roughnessMap ||
                          !!a.metalnessMap ||
                          !!a.clearcoatMap ||
                          !!a.clearcoatRoughnessMap ||
                          !!a.clearcoatNormalMap ||
                          !!a.iridescenceMap ||
                          !!a.iridescenceThicknessMap ||
                          !!a.displacementMap ||
                          !!a.transmissionMap ||
                          !!a.thicknessMap ||
                          !!a.specularIntensityMap ||
                          !!a.specularColorMap ||
                          !!a.sheenColorMap ||
                          !!a.sheenRoughnessMap,
                        uvsVertexOnly:
                          !(
                            a.map ||
                            a.bumpMap ||
                            a.normalMap ||
                            a.specularMap ||
                            a.alphaMap ||
                            a.emissiveMap ||
                            a.roughnessMap ||
                            a.metalnessMap ||
                            a.clearcoatNormalMap ||
                            a.iridescenceMap ||
                            a.iridescenceThicknessMap ||
                            a.transmission > 0 ||
                            a.transmissionMap ||
                            a.thicknessMap ||
                            a.specularIntensityMap ||
                            a.specularColorMap ||
                            a.sheen > 0 ||
                            a.sheenColorMap ||
                            a.sheenRoughnessMap
                          ) && !!a.displacementMap,
                        fog: !!b,
                        useFog: !0 === a.fog,
                        fogExp2: b && b.isFogExp2,
                        flatShading: !!a.flatShading,
                        sizeAttenuation: a.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === g.isSkinnedMesh,
                        morphTargets: void 0 !== x.morphAttributes.position,
                        morphNormals: void 0 !== x.morphAttributes.normal,
                        morphColors: void 0 !== x.morphAttributes.color,
                        morphTargetsCount: A,
                        morphTextureStride: I,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numRectAreaLights: s.rectArea.length,
                        numHemiLights: s.hemi.length,
                        numDirLightShadows: s.directionalShadowMap.length,
                        numPointLightShadows: s.pointShadowMap.length,
                        numSpotLightShadows: s.spotShadowMap.length,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: a.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && l.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: a.toneMapped ? t.toneMapping : Q,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: a.premultipliedAlpha,
                        doubleSided: a.side === y,
                        flipSided: a.side === v,
                        useDepthPacking: !!a.depthPacking,
                        depthPacking: a.depthPacking || 0,
                        index0AttributeName: a.index0AttributeName,
                        extensionDerivatives:
                          a.extensions && a.extensions.derivatives,
                        extensionFragDepth:
                          a.extensions && a.extensions.fragDepth,
                        extensionDrawBuffers:
                          a.extensions && a.extensions.drawBuffers,
                        extensionShaderTextureLOD:
                          a.extensions && a.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth:
                          u || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers:
                          u || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod:
                          u || r.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: a.customProgramCacheKey(),
                      };
                    return z;
                  }
                  function g(e) {
                    const n = [];
                    if (
                      (e.shaderID
                        ? n.push(e.shaderID)
                        : (n.push(e.customVertexShaderID),
                          n.push(e.customFragmentShaderID)),
                      void 0 !== e.defines)
                    )
                      for (const t in e.defines)
                        n.push(t), n.push(e.defines[t]);
                    return (
                      !1 === e.isRawShaderMaterial &&
                        (b(n, e), x(n, e), n.push(t.outputEncoding)),
                      n.push(e.customProgramCacheKey),
                      n.join()
                    );
                  }
                  function b(t, e) {
                    t.push(e.precision),
                      t.push(e.outputEncoding),
                      t.push(e.envMapMode),
                      t.push(e.envMapCubeUVHeight),
                      t.push(e.combine),
                      t.push(e.vertexUvs),
                      t.push(e.fogExp2),
                      t.push(e.sizeAttenuation),
                      t.push(e.morphTargetsCount),
                      t.push(e.morphAttributeCount),
                      t.push(e.numDirLights),
                      t.push(e.numPointLights),
                      t.push(e.numSpotLights),
                      t.push(e.numHemiLights),
                      t.push(e.numRectAreaLights),
                      t.push(e.numDirLightShadows),
                      t.push(e.numPointLightShadows),
                      t.push(e.numSpotLightShadows),
                      t.push(e.shadowMapType),
                      t.push(e.toneMapping),
                      t.push(e.numClippingPlanes),
                      t.push(e.numClipIntersection),
                      t.push(e.depthPacking);
                  }
                  function x(t, e) {
                    s.disableAll(),
                      e.isWebGL2 && s.enable(0),
                      e.supportsVertexTextures && s.enable(1),
                      e.instancing && s.enable(2),
                      e.instancingColor && s.enable(3),
                      e.map && s.enable(4),
                      e.matcap && s.enable(5),
                      e.envMap && s.enable(6),
                      e.lightMap && s.enable(7),
                      e.aoMap && s.enable(8),
                      e.emissiveMap && s.enable(9),
                      e.bumpMap && s.enable(10),
                      e.normalMap && s.enable(11),
                      e.objectSpaceNormalMap && s.enable(12),
                      e.tangentSpaceNormalMap && s.enable(13),
                      e.clearcoat && s.enable(14),
                      e.clearcoatMap && s.enable(15),
                      e.clearcoatRoughnessMap && s.enable(16),
                      e.clearcoatNormalMap && s.enable(17),
                      e.iridescence && s.enable(18),
                      e.iridescenceMap && s.enable(19),
                      e.iridescenceThicknessMap && s.enable(20),
                      e.displacementMap && s.enable(21),
                      e.specularMap && s.enable(22),
                      e.roughnessMap && s.enable(23),
                      e.metalnessMap && s.enable(24),
                      e.gradientMap && s.enable(25),
                      e.alphaMap && s.enable(26),
                      e.alphaTest && s.enable(27),
                      e.vertexColors && s.enable(28),
                      e.vertexAlphas && s.enable(29),
                      e.vertexUvs && s.enable(30),
                      e.vertexTangents && s.enable(31),
                      e.uvsVertexOnly && s.enable(32),
                      e.fog && s.enable(33),
                      t.push(s.mask),
                      s.disableAll(),
                      e.useFog && s.enable(0),
                      e.flatShading && s.enable(1),
                      e.logarithmicDepthBuffer && s.enable(2),
                      e.skinning && s.enable(3),
                      e.morphTargets && s.enable(4),
                      e.morphNormals && s.enable(5),
                      e.morphColors && s.enable(6),
                      e.premultipliedAlpha && s.enable(7),
                      e.shadowMapEnabled && s.enable(8),
                      e.physicallyCorrectLights && s.enable(9),
                      e.doubleSided && s.enable(10),
                      e.flipSided && s.enable(11),
                      e.useDepthPacking && s.enable(12),
                      e.dithering && s.enable(13),
                      e.specularIntensityMap && s.enable(14),
                      e.specularColorMap && s.enable(15),
                      e.transmission && s.enable(16),
                      e.transmissionMap && s.enable(17),
                      e.thicknessMap && s.enable(18),
                      e.sheen && s.enable(19),
                      e.sheenColorMap && s.enable(20),
                      e.sheenRoughnessMap && s.enable(21),
                      e.decodeVideoTexture && s.enable(22),
                      e.opaque && s.enable(23),
                      t.push(s.mask);
                  }
                  function w(t) {
                    const e = p[t.type];
                    let n;
                    if (e) {
                      const t = Vs[e];
                      n = Gi.clone(t.uniforms);
                    } else n = t.uniforms;
                    return n;
                  }
                  function S(e, n) {
                    let r;
                    for (let t = 0, i = l.length; t < i; t++) {
                      const e = l[t];
                      if (e.cacheKey === n) {
                        (r = e), ++r.usedTimes;
                        break;
                      }
                    }
                    return (
                      void 0 === r && ((r = new ru(t, n, e, a)), l.push(r)), r
                    );
                  }
                  function M(t) {
                    if (0 === --t.usedTimes) {
                      const e = l.indexOf(t);
                      (l[e] = l[l.length - 1]), l.pop(), t.destroy();
                    }
                  }
                  function T(t) {
                    c.remove(t);
                  }
                  function E() {
                    c.dispose();
                  }
                  return {
                    getParameters: m,
                    getProgramCacheKey: g,
                    getUniforms: w,
                    acquireProgram: S,
                    releaseProgram: M,
                    releaseShaderCache: T,
                    programs: l,
                    dispose: E,
                  };
                }
                function cu() {
                  let t = new WeakMap();
                  function e(e) {
                    let n = t.get(e);
                    return void 0 === n && ((n = {}), t.set(e, n)), n;
                  }
                  function n(e) {
                    t.delete(e);
                  }
                  function r(e, n, r) {
                    t.get(e)[n] = r;
                  }
                  function i() {
                    t = new WeakMap();
                  }
                  return { get: e, remove: n, update: r, dispose: i };
                }
                function lu(t, e) {
                  return t.groupOrder !== e.groupOrder
                    ? t.groupOrder - e.groupOrder
                    : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.material.id !== e.material.id
                    ? t.material.id - e.material.id
                    : t.z !== e.z
                    ? t.z - e.z
                    : t.id - e.id;
                }
                function uu(t, e) {
                  return t.groupOrder !== e.groupOrder
                    ? t.groupOrder - e.groupOrder
                    : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.z !== e.z
                    ? e.z - t.z
                    : t.id - e.id;
                }
                function hu() {
                  const t = [];
                  let e = 0;
                  const n = [],
                    r = [],
                    i = [];
                  function a() {
                    (e = 0), (n.length = 0), (r.length = 0), (i.length = 0);
                  }
                  function o(n, r, i, a, o, s) {
                    let c = t[e];
                    return (
                      void 0 === c
                        ? ((c = {
                            id: n.id,
                            object: n,
                            geometry: r,
                            material: i,
                            groupOrder: a,
                            renderOrder: n.renderOrder,
                            z: o,
                            group: s,
                          }),
                          (t[e] = c))
                        : ((c.id = n.id),
                          (c.object = n),
                          (c.geometry = r),
                          (c.material = i),
                          (c.groupOrder = a),
                          (c.renderOrder = n.renderOrder),
                          (c.z = o),
                          (c.group = s)),
                      e++,
                      c
                    );
                  }
                  function s(t, e, a, s, c, l) {
                    const u = o(t, e, a, s, c, l);
                    a.transmission > 0
                      ? r.push(u)
                      : !0 === a.transparent
                      ? i.push(u)
                      : n.push(u);
                  }
                  function c(t, e, a, s, c, l) {
                    const u = o(t, e, a, s, c, l);
                    a.transmission > 0
                      ? r.unshift(u)
                      : !0 === a.transparent
                      ? i.unshift(u)
                      : n.unshift(u);
                  }
                  function l(t, e) {
                    n.length > 1 && n.sort(t || lu),
                      r.length > 1 && r.sort(e || uu),
                      i.length > 1 && i.sort(e || uu);
                  }
                  function u() {
                    for (let n = e, r = t.length; n < r; n++) {
                      const e = t[n];
                      if (null === e.id) break;
                      (e.id = null),
                        (e.object = null),
                        (e.geometry = null),
                        (e.material = null),
                        (e.group = null);
                    }
                  }
                  return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: a,
                    push: s,
                    unshift: c,
                    finish: u,
                    sort: l,
                  };
                }
                function du() {
                  let t = new WeakMap();
                  function e(e, n) {
                    let r;
                    return (
                      !1 === t.has(e)
                        ? ((r = new hu()), t.set(e, [r]))
                        : n >= t.get(e).length
                        ? ((r = new hu()), t.get(e).push(r))
                        : (r = t.get(e)[n]),
                      r
                    );
                  }
                  function n() {
                    t = new WeakMap();
                  }
                  return { get: e, dispose: n };
                }
                function fu() {
                  const t = {};
                  return {
                    get: function (e) {
                      if (void 0 !== t[e.id]) return t[e.id];
                      let n;
                      switch (e.type) {
                        case "DirectionalLight":
                          n = { direction: new Gn(), color: new In() };
                          break;
                        case "SpotLight":
                          n = {
                            position: new Gn(),
                            direction: new Gn(),
                            color: new In(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                          };
                          break;
                        case "PointLight":
                          n = {
                            position: new Gn(),
                            color: new In(),
                            distance: 0,
                            decay: 0,
                          };
                          break;
                        case "HemisphereLight":
                          n = {
                            direction: new Gn(),
                            skyColor: new In(),
                            groundColor: new In(),
                          };
                          break;
                        case "RectAreaLight":
                          n = {
                            color: new In(),
                            position: new Gn(),
                            halfWidth: new Gn(),
                            halfHeight: new Gn(),
                          };
                          break;
                      }
                      return (t[e.id] = n), n;
                    },
                  };
                }
                function pu() {
                  const t = {};
                  return {
                    get: function (e) {
                      if (void 0 !== t[e.id]) return t[e.id];
                      let n;
                      switch (e.type) {
                        case "DirectionalLight":
                          n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new gn(),
                          };
                          break;
                        case "SpotLight":
                          n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new gn(),
                          };
                          break;
                        case "PointLight":
                          n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new gn(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3,
                          };
                          break;
                      }
                      return (t[e.id] = n), n;
                    },
                  };
                }
                let mu = 0;
                function gu(t, e) {
                  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
                }
                function vu(t, e) {
                  const n = new fu(),
                    r = pu(),
                    i = {
                      version: 0,
                      hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                      },
                      ambient: [0, 0, 0],
                      probe: [],
                      directional: [],
                      directionalShadow: [],
                      directionalShadowMap: [],
                      directionalShadowMatrix: [],
                      spot: [],
                      spotShadow: [],
                      spotShadowMap: [],
                      spotShadowMatrix: [],
                      rectArea: [],
                      rectAreaLTC1: null,
                      rectAreaLTC2: null,
                      point: [],
                      pointShadow: [],
                      pointShadowMap: [],
                      pointShadowMatrix: [],
                      hemi: [],
                    };
                  for (let u = 0; u < 9; u++) i.probe.push(new Gn());
                  const a = new Gn(),
                    o = new _r(),
                    s = new _r();
                  function c(a, o) {
                    let s = 0,
                      c = 0,
                      l = 0;
                    for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                    let u = 0,
                      h = 0,
                      d = 0,
                      f = 0,
                      p = 0,
                      m = 0,
                      g = 0,
                      v = 0;
                    a.sort(gu);
                    const y = !0 !== o ? Math.PI : 1;
                    for (let t = 0, e = a.length; t < e; t++) {
                      const e = a[t],
                        o = e.color,
                        b = e.intensity,
                        x = e.distance,
                        _ =
                          e.shadow && e.shadow.map
                            ? e.shadow.map.texture
                            : null;
                      if (e.isAmbientLight)
                        (s += o.r * b * y),
                          (c += o.g * b * y),
                          (l += o.b * b * y);
                      else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++)
                          i.probe[t].addScaledVector(e.sh.coefficients[t], b);
                      else if (e.isDirectionalLight) {
                        const t = n.get(e);
                        if (
                          (t.color
                            .copy(e.color)
                            .multiplyScalar(e.intensity * y),
                          e.castShadow)
                        ) {
                          const t = e.shadow,
                            n = r.get(e);
                          (n.shadowBias = t.bias),
                            (n.shadowNormalBias = t.normalBias),
                            (n.shadowRadius = t.radius),
                            (n.shadowMapSize = t.mapSize),
                            (i.directionalShadow[u] = n),
                            (i.directionalShadowMap[u] = _),
                            (i.directionalShadowMatrix[u] = e.shadow.matrix),
                            m++;
                        }
                        (i.directional[u] = t), u++;
                      } else if (e.isSpotLight) {
                        const t = n.get(e);
                        if (
                          (t.position.setFromMatrixPosition(e.matrixWorld),
                          t.color.copy(o).multiplyScalar(b * y),
                          (t.distance = x),
                          (t.coneCos = Math.cos(e.angle)),
                          (t.penumbraCos = Math.cos(
                            e.angle * (1 - e.penumbra)
                          )),
                          (t.decay = e.decay),
                          e.castShadow)
                        ) {
                          const t = e.shadow,
                            n = r.get(e);
                          (n.shadowBias = t.bias),
                            (n.shadowNormalBias = t.normalBias),
                            (n.shadowRadius = t.radius),
                            (n.shadowMapSize = t.mapSize),
                            (i.spotShadow[d] = n),
                            (i.spotShadowMap[d] = _),
                            (i.spotShadowMatrix[d] = e.shadow.matrix),
                            v++;
                        }
                        (i.spot[d] = t), d++;
                      } else if (e.isRectAreaLight) {
                        const t = n.get(e);
                        t.color.copy(o).multiplyScalar(b),
                          t.halfWidth.set(0.5 * e.width, 0, 0),
                          t.halfHeight.set(0, 0.5 * e.height, 0),
                          (i.rectArea[f] = t),
                          f++;
                      } else if (e.isPointLight) {
                        const t = n.get(e);
                        if (
                          (t.color
                            .copy(e.color)
                            .multiplyScalar(e.intensity * y),
                          (t.distance = e.distance),
                          (t.decay = e.decay),
                          e.castShadow)
                        ) {
                          const t = e.shadow,
                            n = r.get(e);
                          (n.shadowBias = t.bias),
                            (n.shadowNormalBias = t.normalBias),
                            (n.shadowRadius = t.radius),
                            (n.shadowMapSize = t.mapSize),
                            (n.shadowCameraNear = t.camera.near),
                            (n.shadowCameraFar = t.camera.far),
                            (i.pointShadow[h] = n),
                            (i.pointShadowMap[h] = _),
                            (i.pointShadowMatrix[h] = e.shadow.matrix),
                            g++;
                        }
                        (i.point[h] = t), h++;
                      } else if (e.isHemisphereLight) {
                        const t = n.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(b * y),
                          t.groundColor
                            .copy(e.groundColor)
                            .multiplyScalar(b * y),
                          (i.hemi[p] = t),
                          p++;
                      }
                    }
                    f > 0 &&
                      (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                        ? ((i.rectAreaLTC1 = Hs.LTC_FLOAT_1),
                          (i.rectAreaLTC2 = Hs.LTC_FLOAT_2))
                        : !0 === t.has("OES_texture_half_float_linear")
                        ? ((i.rectAreaLTC1 = Hs.LTC_HALF_1),
                          (i.rectAreaLTC2 = Hs.LTC_HALF_2))
                        : console.error(
                            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                          )),
                      (i.ambient[0] = s),
                      (i.ambient[1] = c),
                      (i.ambient[2] = l);
                    const b = i.hash;
                    (b.directionalLength === u &&
                      b.pointLength === h &&
                      b.spotLength === d &&
                      b.rectAreaLength === f &&
                      b.hemiLength === p &&
                      b.numDirectionalShadows === m &&
                      b.numPointShadows === g &&
                      b.numSpotShadows === v) ||
                      ((i.directional.length = u),
                      (i.spot.length = d),
                      (i.rectArea.length = f),
                      (i.point.length = h),
                      (i.hemi.length = p),
                      (i.directionalShadow.length = m),
                      (i.directionalShadowMap.length = m),
                      (i.pointShadow.length = g),
                      (i.pointShadowMap.length = g),
                      (i.spotShadow.length = v),
                      (i.spotShadowMap.length = v),
                      (i.directionalShadowMatrix.length = m),
                      (i.pointShadowMatrix.length = g),
                      (i.spotShadowMatrix.length = v),
                      (b.directionalLength = u),
                      (b.pointLength = h),
                      (b.spotLength = d),
                      (b.rectAreaLength = f),
                      (b.hemiLength = p),
                      (b.numDirectionalShadows = m),
                      (b.numPointShadows = g),
                      (b.numSpotShadows = v),
                      (i.version = mu++));
                  }
                  function l(t, e) {
                    let n = 0,
                      r = 0,
                      c = 0,
                      l = 0,
                      u = 0;
                    const h = e.matrixWorldInverse;
                    for (let d = 0, f = t.length; d < f; d++) {
                      const e = t[d];
                      if (e.isDirectionalLight) {
                        const t = i.directional[n];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                          a.setFromMatrixPosition(e.target.matrixWorld),
                          t.direction.sub(a),
                          t.direction.transformDirection(h),
                          n++;
                      } else if (e.isSpotLight) {
                        const t = i.spot[c];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                          t.position.applyMatrix4(h),
                          t.direction.setFromMatrixPosition(e.matrixWorld),
                          a.setFromMatrixPosition(e.target.matrixWorld),
                          t.direction.sub(a),
                          t.direction.transformDirection(h),
                          c++;
                      } else if (e.isRectAreaLight) {
                        const t = i.rectArea[l];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                          t.position.applyMatrix4(h),
                          s.identity(),
                          o.copy(e.matrixWorld),
                          o.premultiply(h),
                          s.extractRotation(o),
                          t.halfWidth.set(0.5 * e.width, 0, 0),
                          t.halfHeight.set(0, 0.5 * e.height, 0),
                          t.halfWidth.applyMatrix4(s),
                          t.halfHeight.applyMatrix4(s),
                          l++;
                      } else if (e.isPointLight) {
                        const t = i.point[r];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                          t.position.applyMatrix4(h),
                          r++;
                      } else if (e.isHemisphereLight) {
                        const t = i.hemi[u];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                          t.direction.transformDirection(h),
                          u++;
                      }
                    }
                  }
                  return { setup: c, setupView: l, state: i };
                }
                function yu(t, e) {
                  const n = new vu(t, e),
                    r = [],
                    i = [];
                  function a() {
                    (r.length = 0), (i.length = 0);
                  }
                  function o(t) {
                    r.push(t);
                  }
                  function s(t) {
                    i.push(t);
                  }
                  function c(t) {
                    n.setup(r, t);
                  }
                  function l(t) {
                    n.setupView(r, t);
                  }
                  const u = { lightsArray: r, shadowsArray: i, lights: n };
                  return {
                    init: a,
                    state: u,
                    setupLights: c,
                    setupLightsView: l,
                    pushLight: o,
                    pushShadow: s,
                  };
                }
                function bu(t, e) {
                  let n = new WeakMap();
                  function r(r, i = 0) {
                    let a;
                    return (
                      !1 === n.has(r)
                        ? ((a = new yu(t, e)), n.set(r, [a]))
                        : i >= n.get(r).length
                        ? ((a = new yu(t, e)), n.get(r).push(a))
                        : (a = n.get(r)[i]),
                      a
                    );
                  }
                  function i() {
                    n = new WeakMap();
                  }
                  return { get: r, dispose: i };
                }
                class xu extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshDepthMaterial = !0),
                      (this.type = "MeshDepthMaterial"),
                      (this.depthPacking = Re),
                      (this.map = null),
                      (this.alphaMap = null),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.depthPacking = t.depthPacking),
                      (this.map = t.map),
                      (this.alphaMap = t.alphaMap),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      this
                    );
                  }
                }
                class _u extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshDistanceMaterial = !0),
                      (this.type = "MeshDistanceMaterial"),
                      (this.referencePosition = new Gn()),
                      (this.nearDistance = 1),
                      (this.farDistance = 1e3),
                      (this.map = null),
                      (this.alphaMap = null),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.referencePosition.copy(t.referencePosition),
                      (this.nearDistance = t.nearDistance),
                      (this.farDistance = t.farDistance),
                      (this.map = t.map),
                      (this.alphaMap = t.alphaMap),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      this
                    );
                  }
                }
                const wu =
                    "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                  Su =
                    "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
                function Mu(t, e, n) {
                  let r = new sa();
                  const i = new gn(),
                    a = new gn(),
                    o = new Un(),
                    s = new xu({ depthPacking: Pe }),
                    c = new _u(),
                    l = {},
                    u = n.maxTextureSize,
                    h = { 0: v, 1: g, 2: y },
                    d = new Xi({
                      defines: { VSM_SAMPLES: 8 },
                      uniforms: {
                        shadow_pass: { value: null },
                        resolution: { value: new gn() },
                        radius: { value: 4 },
                      },
                      vertexShader: wu,
                      fragmentShader: Su,
                    }),
                    p = d.clone();
                  p.defines.HORIZONTAL_PASS = 1;
                  const b = new xi();
                  b.setAttribute(
                    "position",
                    new li(
                      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
                      3
                    )
                  );
                  const _ = new Fi(b, d),
                    w = this;
                  function S(n, r) {
                    const a = e.update(_);
                    d.defines.VSM_SAMPLES !== n.blurSamples &&
                      ((d.defines.VSM_SAMPLES = n.blurSamples),
                      (p.defines.VSM_SAMPLES = n.blurSamples),
                      (d.needsUpdate = !0),
                      (p.needsUpdate = !0)),
                      null === n.mapPass && (n.mapPass = new Bn(i.x, i.y)),
                      (d.uniforms.shadow_pass.value = n.map.texture),
                      (d.uniforms.resolution.value = n.mapSize),
                      (d.uniforms.radius.value = n.radius),
                      t.setRenderTarget(n.mapPass),
                      t.clear(),
                      t.renderBufferDirect(r, null, a, d, _, null),
                      (p.uniforms.shadow_pass.value = n.mapPass.texture),
                      (p.uniforms.resolution.value = n.mapSize),
                      (p.uniforms.radius.value = n.radius),
                      t.setRenderTarget(n.map),
                      t.clear(),
                      t.renderBufferDirect(r, null, a, p, _, null);
                  }
                  function M(e, n, r, i, a, o) {
                    let u = null;
                    const d =
                      !0 === r.isPointLight
                        ? e.customDistanceMaterial
                        : e.customDepthMaterial;
                    if (
                      ((u = void 0 !== d ? d : !0 === r.isPointLight ? c : s),
                      (t.localClippingEnabled &&
                        !0 === n.clipShadows &&
                        Array.isArray(n.clippingPlanes) &&
                        0 !== n.clippingPlanes.length) ||
                        (n.displacementMap && 0 !== n.displacementScale) ||
                        (n.alphaMap && n.alphaTest > 0))
                    ) {
                      const t = u.uuid,
                        e = n.uuid;
                      let r = l[t];
                      void 0 === r && ((r = {}), (l[t] = r));
                      let i = r[e];
                      void 0 === i && ((i = u.clone()), (r[e] = i)), (u = i);
                    }
                    return (
                      (u.visible = n.visible),
                      (u.wireframe = n.wireframe),
                      (u.side =
                        o === m
                          ? null !== n.shadowSide
                            ? n.shadowSide
                            : n.side
                          : null !== n.shadowSide
                          ? n.shadowSide
                          : h[n.side]),
                      (u.alphaMap = n.alphaMap),
                      (u.alphaTest = n.alphaTest),
                      (u.clipShadows = n.clipShadows),
                      (u.clippingPlanes = n.clippingPlanes),
                      (u.clipIntersection = n.clipIntersection),
                      (u.displacementMap = n.displacementMap),
                      (u.displacementScale = n.displacementScale),
                      (u.displacementBias = n.displacementBias),
                      (u.wireframeLinewidth = n.wireframeLinewidth),
                      (u.linewidth = n.linewidth),
                      !0 === r.isPointLight &&
                        !0 === u.isMeshDistanceMaterial &&
                        (u.referencePosition.setFromMatrixPosition(
                          r.matrixWorld
                        ),
                        (u.nearDistance = i),
                        (u.farDistance = a)),
                      u
                    );
                  }
                  function T(n, i, a, o, s) {
                    if (!1 === n.visible) return;
                    const c = n.layers.test(i.layers);
                    if (
                      c &&
                      (n.isMesh || n.isLine || n.isPoints) &&
                      (n.castShadow || (n.receiveShadow && s === m)) &&
                      (!n.frustumCulled || r.intersectsObject(n))
                    ) {
                      n.modelViewMatrix.multiplyMatrices(
                        a.matrixWorldInverse,
                        n.matrixWorld
                      );
                      const r = e.update(n),
                        i = n.material;
                      if (Array.isArray(i)) {
                        const e = r.groups;
                        for (let c = 0, l = e.length; c < l; c++) {
                          const l = e[c],
                            u = i[l.materialIndex];
                          if (u && u.visible) {
                            const e = M(n, u, o, a.near, a.far, s);
                            t.renderBufferDirect(a, null, r, e, n, l);
                          }
                        }
                      } else if (i.visible) {
                        const e = M(n, i, o, a.near, a.far, s);
                        t.renderBufferDirect(a, null, r, e, n, null);
                      }
                    }
                    const l = n.children;
                    for (let t = 0, e = l.length; t < e; t++)
                      T(l[t], i, a, o, s);
                  }
                  (this.enabled = !1),
                    (this.autoUpdate = !0),
                    (this.needsUpdate = !1),
                    (this.type = f),
                    (this.render = function (e, n, s) {
                      if (!1 === w.enabled) return;
                      if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
                      if (0 === e.length) return;
                      const c = t.getRenderTarget(),
                        l = t.getActiveCubeFace(),
                        h = t.getActiveMipmapLevel(),
                        d = t.state;
                      d.setBlending(x),
                        d.buffers.color.setClear(1, 1, 1, 1),
                        d.buffers.depth.setTest(!0),
                        d.setScissorTest(!1);
                      for (let f = 0, p = e.length; f < p; f++) {
                        const c = e[f],
                          l = c.shadow;
                        if (void 0 === l) {
                          console.warn(
                            "THREE.WebGLShadowMap:",
                            c,
                            "has no shadow."
                          );
                          continue;
                        }
                        if (!1 === l.autoUpdate && !1 === l.needsUpdate)
                          continue;
                        i.copy(l.mapSize);
                        const h = l.getFrameExtents();
                        if (
                          (i.multiply(h),
                          a.copy(l.mapSize),
                          (i.x > u || i.y > u) &&
                            (i.x > u &&
                              ((a.x = Math.floor(u / h.x)),
                              (i.x = a.x * h.x),
                              (l.mapSize.x = a.x)),
                            i.y > u &&
                              ((a.y = Math.floor(u / h.y)),
                              (i.y = a.y * h.y),
                              (l.mapSize.y = a.y))),
                          null === l.map)
                        ) {
                          const t =
                            this.type !== m
                              ? { minFilter: pt, magFilter: pt }
                              : {};
                          (l.map = new Bn(i.x, i.y, t)),
                            (l.map.texture.name = c.name + ".shadowMap"),
                            l.camera.updateProjectionMatrix();
                        }
                        t.setRenderTarget(l.map), t.clear();
                        const p = l.getViewportCount();
                        for (let t = 0; t < p; t++) {
                          const e = l.getViewport(t);
                          o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w),
                            d.viewport(o),
                            l.updateMatrices(c, t),
                            (r = l.getFrustum()),
                            T(n, s, l.camera, c, this.type);
                        }
                        !0 !== l.isPointLightShadow &&
                          this.type === m &&
                          S(l, s),
                          (l.needsUpdate = !1);
                      }
                      (w.needsUpdate = !1), t.setRenderTarget(c, l, h);
                    });
                }
                function Tu(t, e, n) {
                  const r = n.isWebGL2;
                  function i() {
                    let e = !1;
                    const n = new Un();
                    let r = null;
                    const i = new Un(0, 0, 0, 0);
                    return {
                      setMask: function (n) {
                        r === n || e || (t.colorMask(n, n, n, n), (r = n));
                      },
                      setLocked: function (t) {
                        e = t;
                      },
                      setClear: function (e, r, a, o, s) {
                        !0 === s && ((e *= o), (r *= o), (a *= o)),
                          n.set(e, r, a, o),
                          !1 === i.equals(n) &&
                            (t.clearColor(e, r, a, o), i.copy(n));
                      },
                      reset: function () {
                        (e = !1), (r = null), i.set(-1, 0, 0, 0);
                      },
                    };
                  }
                  function a() {
                    let e = !1,
                      n = null,
                      r = null,
                      i = null;
                    return {
                      setTest: function (t) {
                        t ? wt(2929) : St(2929);
                      },
                      setMask: function (r) {
                        n === r || e || (t.depthMask(r), (n = r));
                      },
                      setFunc: function (e) {
                        if (r !== e) {
                          if (e)
                            switch (e) {
                              case H:
                                t.depthFunc(512);
                                break;
                              case V:
                                t.depthFunc(519);
                                break;
                              case G:
                                t.depthFunc(513);
                                break;
                              case W:
                                t.depthFunc(515);
                                break;
                              case q:
                                t.depthFunc(514);
                                break;
                              case X:
                                t.depthFunc(518);
                                break;
                              case $:
                                t.depthFunc(516);
                                break;
                              case Y:
                                t.depthFunc(517);
                                break;
                              default:
                                t.depthFunc(515);
                            }
                          else t.depthFunc(515);
                          r = e;
                        }
                      },
                      setLocked: function (t) {
                        e = t;
                      },
                      setClear: function (e) {
                        i !== e && (t.clearDepth(e), (i = e));
                      },
                      reset: function () {
                        (e = !1), (n = null), (r = null), (i = null);
                      },
                    };
                  }
                  function o() {
                    let e = !1,
                      n = null,
                      r = null,
                      i = null,
                      a = null,
                      o = null,
                      s = null,
                      c = null,
                      l = null;
                    return {
                      setTest: function (t) {
                        e || (t ? wt(2960) : St(2960));
                      },
                      setMask: function (r) {
                        n === r || e || (t.stencilMask(r), (n = r));
                      },
                      setFunc: function (e, n, o) {
                        (r === e && i === n && a === o) ||
                          (t.stencilFunc(e, n, o), (r = e), (i = n), (a = o));
                      },
                      setOp: function (e, n, r) {
                        (o === e && s === n && c === r) ||
                          (t.stencilOp(e, n, r), (o = e), (s = n), (c = r));
                      },
                      setLocked: function (t) {
                        e = t;
                      },
                      setClear: function (e) {
                        l !== e && (t.clearStencil(e), (l = e));
                      },
                      reset: function () {
                        (e = !1),
                          (n = null),
                          (r = null),
                          (i = null),
                          (a = null),
                          (o = null),
                          (s = null),
                          (c = null),
                          (l = null);
                      },
                    };
                  }
                  const s = new i(),
                    c = new a(),
                    l = new o();
                  let f = {},
                    p = {},
                    m = new WeakMap(),
                    g = [],
                    b = null,
                    J = !1,
                    K = null,
                    Z = null,
                    Q = null,
                    tt = null,
                    et = null,
                    nt = null,
                    rt = null,
                    it = !1,
                    at = null,
                    ot = null,
                    st = null,
                    ct = null,
                    lt = null;
                  const ut = t.getParameter(35661);
                  let ht = !1,
                    dt = 0;
                  const ft = t.getParameter(7938);
                  -1 !== ft.indexOf("WebGL")
                    ? ((dt = parseFloat(/^WebGL (\d)/.exec(ft)[1])),
                      (ht = dt >= 1))
                    : -1 !== ft.indexOf("OpenGL ES") &&
                      ((dt = parseFloat(/^OpenGL ES (\d)/.exec(ft)[1])),
                      (ht = dt >= 2));
                  let pt = null,
                    mt = {};
                  const gt = t.getParameter(3088),
                    vt = t.getParameter(2978),
                    yt = new Un().fromArray(gt),
                    bt = new Un().fromArray(vt);
                  function xt(e, n, r) {
                    const i = new Uint8Array(4),
                      a = t.createTexture();
                    t.bindTexture(e, a),
                      t.texParameteri(e, 10241, 9728),
                      t.texParameteri(e, 10240, 9728);
                    for (let o = 0; o < r; o++)
                      t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return a;
                  }
                  const _t = {};
                  function wt(e) {
                    !0 !== f[e] && (t.enable(e), (f[e] = !0));
                  }
                  function St(e) {
                    !1 !== f[e] && (t.disable(e), (f[e] = !1));
                  }
                  function Mt(e, n) {
                    return (
                      p[e] !== n &&
                      (t.bindFramebuffer(e, n),
                      (p[e] = n),
                      r &&
                        (36009 === e && (p[36160] = n),
                        36160 === e && (p[36009] = n)),
                      !0)
                    );
                  }
                  function Tt(r, i) {
                    let a = g,
                      o = !1;
                    if (r)
                      if (
                        ((a = m.get(i)),
                        void 0 === a && ((a = []), m.set(i, a)),
                        r.isWebGLMultipleRenderTargets)
                      ) {
                        const t = r.texture;
                        if (a.length !== t.length || 36064 !== a[0]) {
                          for (let e = 0, n = t.length; e < n; e++)
                            a[e] = 36064 + e;
                          (a.length = t.length), (o = !0);
                        }
                      } else 36064 !== a[0] && ((a[0] = 36064), (o = !0));
                    else 1029 !== a[0] && ((a[0] = 1029), (o = !0));
                    o &&
                      (n.isWebGL2
                        ? t.drawBuffers(a)
                        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a));
                  }
                  function Et(e) {
                    return b !== e && (t.useProgram(e), (b = e), !0);
                  }
                  (_t[3553] = xt(3553, 3553, 1)),
                    (_t[34067] = xt(34067, 34069, 6)),
                    s.setClear(0, 0, 0, 1),
                    c.setClear(1),
                    l.setClear(0),
                    wt(2929),
                    c.setFunc(W),
                    Pt(!1),
                    It(h),
                    wt(2884),
                    Lt(x);
                  const At = { [E]: 32774, [A]: 32778, [C]: 32779 };
                  if (r) (At[L] = 32775), (At[R] = 32776);
                  else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && ((At[L] = t.MIN_EXT), (At[R] = t.MAX_EXT));
                  }
                  const Ct = {
                    [P]: 0,
                    [I]: 1,
                    [O]: 768,
                    [N]: 770,
                    [j]: 776,
                    [U]: 774,
                    [z]: 772,
                    [k]: 769,
                    [D]: 771,
                    [B]: 775,
                    [F]: 773,
                  };
                  function Lt(e, n, r, i, a, o, s, c) {
                    if (e !== x) {
                      if ((!1 === J && (wt(3042), (J = !0)), e === T))
                        (a = a || n),
                          (o = o || r),
                          (s = s || i),
                          (n === Z && a === et) ||
                            (t.blendEquationSeparate(At[n], At[a]),
                            (Z = n),
                            (et = a)),
                          (r === Q && i === tt && o === nt && s === rt) ||
                            (t.blendFuncSeparate(Ct[r], Ct[i], Ct[o], Ct[s]),
                            (Q = r),
                            (tt = i),
                            (nt = o),
                            (rt = s)),
                          (K = e),
                          (it = null);
                      else if (e !== K || c !== it) {
                        if (
                          ((Z === E && et === E) ||
                            (t.blendEquation(32774), (Z = E), (et = E)),
                          c)
                        )
                          switch (e) {
                            case _:
                              t.blendFuncSeparate(1, 771, 1, 771);
                              break;
                            case w:
                              t.blendFunc(1, 1);
                              break;
                            case S:
                              t.blendFuncSeparate(0, 769, 0, 1);
                              break;
                            case M:
                              t.blendFuncSeparate(0, 768, 0, 770);
                              break;
                            default:
                              console.error(
                                "THREE.WebGLState: Invalid blending: ",
                                e
                              );
                              break;
                          }
                        else
                          switch (e) {
                            case _:
                              t.blendFuncSeparate(770, 771, 1, 771);
                              break;
                            case w:
                              t.blendFunc(770, 1);
                              break;
                            case S:
                              t.blendFuncSeparate(0, 769, 0, 1);
                              break;
                            case M:
                              t.blendFunc(0, 768);
                              break;
                            default:
                              console.error(
                                "THREE.WebGLState: Invalid blending: ",
                                e
                              );
                              break;
                          }
                        (Q = null),
                          (tt = null),
                          (nt = null),
                          (rt = null),
                          (K = e),
                          (it = c);
                      }
                    } else !0 === J && (St(3042), (J = !1));
                  }
                  function Rt(t, e) {
                    t.side === y ? St(2884) : wt(2884);
                    let n = t.side === v;
                    e && (n = !n),
                      Pt(n),
                      t.blending === _ && !1 === t.transparent
                        ? Lt(x)
                        : Lt(
                            t.blending,
                            t.blendEquation,
                            t.blendSrc,
                            t.blendDst,
                            t.blendEquationAlpha,
                            t.blendSrcAlpha,
                            t.blendDstAlpha,
                            t.premultipliedAlpha
                          ),
                      c.setFunc(t.depthFunc),
                      c.setTest(t.depthTest),
                      c.setMask(t.depthWrite),
                      s.setMask(t.colorWrite);
                    const r = t.stencilWrite;
                    l.setTest(r),
                      r &&
                        (l.setMask(t.stencilWriteMask),
                        l.setFunc(
                          t.stencilFunc,
                          t.stencilRef,
                          t.stencilFuncMask
                        ),
                        l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                      kt(
                        t.polygonOffset,
                        t.polygonOffsetFactor,
                        t.polygonOffsetUnits
                      ),
                      !0 === t.alphaToCoverage ? wt(32926) : St(32926);
                  }
                  function Pt(e) {
                    at !== e &&
                      (e ? t.frontFace(2304) : t.frontFace(2305), (at = e));
                  }
                  function It(e) {
                    e !== u
                      ? (wt(2884),
                        e !== ot &&
                          (e === h
                            ? t.cullFace(1029)
                            : e === d
                            ? t.cullFace(1028)
                            : t.cullFace(1032)))
                      : St(2884),
                      (ot = e);
                  }
                  function Ot(e) {
                    e !== st && (ht && t.lineWidth(e), (st = e));
                  }
                  function kt(e, n, r) {
                    e
                      ? (wt(32823),
                        (ct === n && lt === r) ||
                          (t.polygonOffset(n, r), (ct = n), (lt = r)))
                      : St(32823);
                  }
                  function Nt(t) {
                    t ? wt(3089) : St(3089);
                  }
                  function Dt(e) {
                    void 0 === e && (e = 33984 + ut - 1),
                      pt !== e && (t.activeTexture(e), (pt = e));
                  }
                  function zt(e, n) {
                    null === pt && Dt();
                    let r = mt[pt];
                    void 0 === r &&
                      ((r = { type: void 0, texture: void 0 }), (mt[pt] = r)),
                      (r.type === e && r.texture === n) ||
                        (t.bindTexture(e, n || _t[e]),
                        (r.type = e),
                        (r.texture = n));
                  }
                  function Ft() {
                    const e = mt[pt];
                    void 0 !== e &&
                      void 0 !== e.type &&
                      (t.bindTexture(e.type, null),
                      (e.type = void 0),
                      (e.texture = void 0));
                  }
                  function Ut() {
                    try {
                      t.compressedTexImage2D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Bt() {
                    try {
                      t.texSubImage2D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function jt() {
                    try {
                      t.texSubImage3D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Ht() {
                    try {
                      t.compressedTexSubImage2D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Vt() {
                    try {
                      t.texStorage2D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Gt() {
                    try {
                      t.texStorage3D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Wt() {
                    try {
                      t.texImage2D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function qt() {
                    try {
                      t.texImage3D.apply(t, arguments);
                    } catch (e) {
                      console.error("THREE.WebGLState:", e);
                    }
                  }
                  function Xt(e) {
                    !1 === yt.equals(e) &&
                      (t.scissor(e.x, e.y, e.z, e.w), yt.copy(e));
                  }
                  function $t(e) {
                    !1 === bt.equals(e) &&
                      (t.viewport(e.x, e.y, e.z, e.w), bt.copy(e));
                  }
                  function Yt() {
                    t.disable(3042),
                      t.disable(2884),
                      t.disable(2929),
                      t.disable(32823),
                      t.disable(3089),
                      t.disable(2960),
                      t.disable(32926),
                      t.blendEquation(32774),
                      t.blendFunc(1, 0),
                      t.blendFuncSeparate(1, 0, 1, 0),
                      t.colorMask(!0, !0, !0, !0),
                      t.clearColor(0, 0, 0, 0),
                      t.depthMask(!0),
                      t.depthFunc(513),
                      t.clearDepth(1),
                      t.stencilMask(4294967295),
                      t.stencilFunc(519, 0, 4294967295),
                      t.stencilOp(7680, 7680, 7680),
                      t.clearStencil(0),
                      t.cullFace(1029),
                      t.frontFace(2305),
                      t.polygonOffset(0, 0),
                      t.activeTexture(33984),
                      t.bindFramebuffer(36160, null),
                      !0 === r &&
                        (t.bindFramebuffer(36009, null),
                        t.bindFramebuffer(36008, null)),
                      t.useProgram(null),
                      t.lineWidth(1),
                      t.scissor(0, 0, t.canvas.width, t.canvas.height),
                      t.viewport(0, 0, t.canvas.width, t.canvas.height),
                      (f = {}),
                      (pt = null),
                      (mt = {}),
                      (p = {}),
                      (m = new WeakMap()),
                      (g = []),
                      (b = null),
                      (J = !1),
                      (K = null),
                      (Z = null),
                      (Q = null),
                      (tt = null),
                      (et = null),
                      (nt = null),
                      (rt = null),
                      (it = !1),
                      (at = null),
                      (ot = null),
                      (st = null),
                      (ct = null),
                      (lt = null),
                      yt.set(0, 0, t.canvas.width, t.canvas.height),
                      bt.set(0, 0, t.canvas.width, t.canvas.height),
                      s.reset(),
                      c.reset(),
                      l.reset();
                  }
                  return {
                    buffers: { color: s, depth: c, stencil: l },
                    enable: wt,
                    disable: St,
                    bindFramebuffer: Mt,
                    drawBuffers: Tt,
                    useProgram: Et,
                    setBlending: Lt,
                    setMaterial: Rt,
                    setFlipSided: Pt,
                    setCullFace: It,
                    setLineWidth: Ot,
                    setPolygonOffset: kt,
                    setScissorTest: Nt,
                    activeTexture: Dt,
                    bindTexture: zt,
                    unbindTexture: Ft,
                    compressedTexImage2D: Ut,
                    texImage2D: Wt,
                    texImage3D: qt,
                    texStorage2D: Vt,
                    texStorage3D: Gt,
                    texSubImage2D: Bt,
                    texSubImage3D: jt,
                    compressedTexSubImage2D: Ht,
                    scissor: Xt,
                    viewport: $t,
                    reset: Yt,
                  };
                }
                function Eu(t, e, n, r, i, a, o) {
                  const s = i.isWebGL2,
                    c = i.maxTextures,
                    l = i.maxCubemapSize,
                    u = i.maxTextureSize,
                    h = i.maxSamples,
                    d = e.has("WEBGL_multisampled_render_to_texture")
                      ? e.get("WEBGL_multisampled_render_to_texture")
                      : null,
                    f = /OculusBrowser/g.test(navigator.userAgent),
                    p = new WeakMap();
                  let m;
                  const g = new WeakMap();
                  let v = !1;
                  try {
                    v =
                      "undefined" !== typeof OffscreenCanvas &&
                      null !== new OffscreenCanvas(1, 1).getContext("2d");
                  } catch (it) {}
                  function y(t, e) {
                    return v ? new OffscreenCanvas(t, e) : _n("canvas");
                  }
                  function b(t, e, n, r) {
                    let i = 1;
                    if (
                      ((t.width > r || t.height > r) &&
                        (i = r / Math.max(t.width, t.height)),
                      i < 1 || !0 === e)
                    ) {
                      if (
                        ("undefined" !== typeof HTMLImageElement &&
                          t instanceof HTMLImageElement) ||
                        ("undefined" !== typeof HTMLCanvasElement &&
                          t instanceof HTMLCanvasElement) ||
                        ("undefined" !== typeof ImageBitmap &&
                          t instanceof ImageBitmap)
                      ) {
                        const r = e ? hn : Math.floor,
                          a = r(i * t.width),
                          o = r(i * t.height);
                        void 0 === m && (m = y(a, o));
                        const s = n ? y(a, o) : m;
                        (s.width = a), (s.height = o);
                        const c = s.getContext("2d");
                        return (
                          c.drawImage(t, 0, 0, a, o),
                          console.warn(
                            "THREE.WebGLRenderer: Texture has been resized from (" +
                              t.width +
                              "x" +
                              t.height +
                              ") to (" +
                              a +
                              "x" +
                              o +
                              ")."
                          ),
                          s
                        );
                      }
                      return (
                        "data" in t &&
                          console.warn(
                            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                              t.width +
                              "x" +
                              t.height +
                              ")."
                          ),
                        t
                      );
                    }
                    return t;
                  }
                  function x(t) {
                    return ln(t.width) && ln(t.height);
                  }
                  function _(t) {
                    return (
                      !s &&
                      (t.wrapS !== dt ||
                        t.wrapT !== dt ||
                        (t.minFilter !== pt && t.minFilter !== vt))
                    );
                  }
                  function w(t, e) {
                    return (
                      t.generateMipmaps &&
                      e &&
                      t.minFilter !== pt &&
                      t.minFilter !== vt
                    );
                  }
                  function S(e) {
                    t.generateMipmap(e);
                  }
                  function M(n, r, i, a, o = !1) {
                    if (!1 === s) return r;
                    if (null !== n) {
                      if (void 0 !== t[n]) return t[n];
                      console.warn(
                        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                          n +
                          "'"
                      );
                    }
                    let c = r;
                    return (
                      6403 === r &&
                        (5126 === i && (c = 33326),
                        5131 === i && (c = 33325),
                        5121 === i && (c = 33321)),
                      33319 === r &&
                        (5126 === i && (c = 33328),
                        5131 === i && (c = 33327),
                        5121 === i && (c = 33323)),
                      6408 === r &&
                        (5126 === i && (c = 34836),
                        5131 === i && (c = 34842),
                        5121 === i &&
                          (c = a === Le && !1 === o ? 35907 : 32856),
                        32819 === i && (c = 32854),
                        32820 === i && (c = 32855)),
                      (33325 !== c &&
                        33326 !== c &&
                        33327 !== c &&
                        33328 !== c &&
                        34842 !== c &&
                        34836 !== c) ||
                        e.get("EXT_color_buffer_float"),
                      c
                    );
                  }
                  function T(t, e, n) {
                    return !0 === w(t, n) ||
                      (t.isFramebufferTexture &&
                        t.minFilter !== pt &&
                        t.minFilter !== vt)
                      ? Math.log2(Math.max(e.width, e.height)) + 1
                      : void 0 !== t.mipmaps && t.mipmaps.length > 0
                      ? t.mipmaps.length
                      : t.isCompressedTexture && Array.isArray(t.image)
                      ? e.mipmaps.length
                      : 1;
                  }
                  function E(t) {
                    return t === pt || t === mt || t === gt ? 9728 : 9729;
                  }
                  function A(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", A),
                      L(e),
                      e.isVideoTexture && p.delete(e);
                  }
                  function C(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", C), P(e);
                  }
                  function L(t) {
                    const e = r.get(t);
                    if (void 0 === e.__webglInit) return;
                    const n = t.source,
                      i = g.get(n);
                    if (i) {
                      const r = i[e.__cacheKey];
                      r.usedTimes--,
                        0 === r.usedTimes && R(t),
                        0 === Object.keys(i).length && g.delete(n);
                    }
                    r.remove(t);
                  }
                  function R(e) {
                    const n = r.get(e);
                    t.deleteTexture(n.__webglTexture);
                    const i = e.source,
                      a = g.get(i);
                    delete a[n.__cacheKey], o.memory.textures--;
                  }
                  function P(e) {
                    const n = e.texture,
                      i = r.get(e),
                      a = r.get(n);
                    if (
                      (void 0 !== a.__webglTexture &&
                        (t.deleteTexture(a.__webglTexture),
                        o.memory.textures--),
                      e.depthTexture && e.depthTexture.dispose(),
                      e.isWebGLCubeRenderTarget)
                    )
                      for (let r = 0; r < 6; r++)
                        t.deleteFramebuffer(i.__webglFramebuffer[r]),
                          i.__webglDepthbuffer &&
                            t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                    else {
                      if (
                        (t.deleteFramebuffer(i.__webglFramebuffer),
                        i.__webglDepthbuffer &&
                          t.deleteRenderbuffer(i.__webglDepthbuffer),
                        i.__webglMultisampledFramebuffer &&
                          t.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                        i.__webglColorRenderbuffer)
                      )
                        for (
                          let e = 0;
                          e < i.__webglColorRenderbuffer.length;
                          e++
                        )
                          i.__webglColorRenderbuffer[e] &&
                            t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]);
                      i.__webglDepthRenderbuffer &&
                        t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                    }
                    if (e.isWebGLMultipleRenderTargets)
                      for (let s = 0, c = n.length; s < c; s++) {
                        const e = r.get(n[s]);
                        e.__webglTexture &&
                          (t.deleteTexture(e.__webglTexture),
                          o.memory.textures--),
                          r.remove(n[s]);
                      }
                    r.remove(n), r.remove(e);
                  }
                  let I = 0;
                  function O() {
                    I = 0;
                  }
                  function k() {
                    const t = I;
                    return (
                      t >= c &&
                        console.warn(
                          "THREE.WebGLTextures: Trying to use " +
                            t +
                            " texture units while this GPU supports only " +
                            c
                        ),
                      (I += 1),
                      t
                    );
                  }
                  function N(t) {
                    const e = [];
                    return (
                      e.push(t.wrapS),
                      e.push(t.wrapT),
                      e.push(t.magFilter),
                      e.push(t.minFilter),
                      e.push(t.anisotropy),
                      e.push(t.internalFormat),
                      e.push(t.format),
                      e.push(t.type),
                      e.push(t.generateMipmaps),
                      e.push(t.premultiplyAlpha),
                      e.push(t.flipY),
                      e.push(t.unpackAlignment),
                      e.push(t.encoding),
                      e.join()
                    );
                  }
                  function D(t, e) {
                    const i = r.get(t);
                    if (
                      (t.isVideoTexture && nt(t),
                      !1 === t.isRenderTargetTexture &&
                        t.version > 0 &&
                        i.__version !== t.version)
                    ) {
                      const n = t.image;
                      if (null === n)
                        console.warn(
                          "THREE.WebGLRenderer: Texture marked for update but no image data found."
                        );
                      else {
                        if (!1 !== n.complete) return void G(i, t, e);
                        console.warn(
                          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                        );
                      }
                    }
                    n.activeTexture(33984 + e),
                      n.bindTexture(3553, i.__webglTexture);
                  }
                  function z(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version
                      ? G(i, t, e)
                      : (n.activeTexture(33984 + e),
                        n.bindTexture(35866, i.__webglTexture));
                  }
                  function F(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version
                      ? G(i, t, e)
                      : (n.activeTexture(33984 + e),
                        n.bindTexture(32879, i.__webglTexture));
                  }
                  function U(t, e) {
                    const i = r.get(t);
                    t.version > 0 && i.__version !== t.version
                      ? W(i, t, e)
                      : (n.activeTexture(33984 + e),
                        n.bindTexture(34067, i.__webglTexture));
                  }
                  const B = { [ht]: 10497, [dt]: 33071, [ft]: 33648 },
                    j = {
                      [pt]: 9728,
                      [mt]: 9984,
                      [gt]: 9986,
                      [vt]: 9729,
                      [yt]: 9985,
                      [bt]: 9987,
                    };
                  function H(n, a, o) {
                    if (
                      (o
                        ? (t.texParameteri(n, 10242, B[a.wrapS]),
                          t.texParameteri(n, 10243, B[a.wrapT]),
                          (32879 !== n && 35866 !== n) ||
                            t.texParameteri(n, 32882, B[a.wrapR]),
                          t.texParameteri(n, 10240, j[a.magFilter]),
                          t.texParameteri(n, 10241, j[a.minFilter]))
                        : (t.texParameteri(n, 10242, 33071),
                          t.texParameteri(n, 10243, 33071),
                          (32879 !== n && 35866 !== n) ||
                            t.texParameteri(n, 32882, 33071),
                          (a.wrapS === dt && a.wrapT === dt) ||
                            console.warn(
                              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                            ),
                          t.texParameteri(n, 10240, E(a.magFilter)),
                          t.texParameteri(n, 10241, E(a.minFilter)),
                          a.minFilter !== pt &&
                            a.minFilter !== vt &&
                            console.warn(
                              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                            )),
                      !0 === e.has("EXT_texture_filter_anisotropic"))
                    ) {
                      const o = e.get("EXT_texture_filter_anisotropic");
                      if (
                        a.type === Et &&
                        !1 === e.has("OES_texture_float_linear")
                      )
                        return;
                      if (
                        !1 === s &&
                        a.type === At &&
                        !1 === e.has("OES_texture_half_float_linear")
                      )
                        return;
                      (a.anisotropy > 1 || r.get(a).__currentAnisotropy) &&
                        (t.texParameterf(
                          n,
                          o.TEXTURE_MAX_ANISOTROPY_EXT,
                          Math.min(a.anisotropy, i.getMaxAnisotropy())
                        ),
                        (r.get(a).__currentAnisotropy = a.anisotropy));
                    }
                  }
                  function V(e, n) {
                    let r = !1;
                    void 0 === e.__webglInit &&
                      ((e.__webglInit = !0), n.addEventListener("dispose", A));
                    const i = n.source;
                    let a = g.get(i);
                    void 0 === a && ((a = {}), g.set(i, a));
                    const s = N(n);
                    if (s !== e.__cacheKey) {
                      void 0 === a[s] &&
                        ((a[s] = { texture: t.createTexture(), usedTimes: 0 }),
                        o.memory.textures++,
                        (r = !0)),
                        a[s].usedTimes++;
                      const i = a[e.__cacheKey];
                      void 0 !== i &&
                        (a[e.__cacheKey].usedTimes--,
                        0 === i.usedTimes && R(n)),
                        (e.__cacheKey = s),
                        (e.__webglTexture = a[s].texture);
                    }
                    return r;
                  }
                  function G(e, r, i) {
                    let o = 3553;
                    r.isDataArrayTexture && (o = 35866),
                      r.isData3DTexture && (o = 32879);
                    const c = V(e, r),
                      l = r.source;
                    if (
                      (n.activeTexture(33984 + i),
                      n.bindTexture(o, e.__webglTexture),
                      l.version !== l.__currentVersion || !0 === c)
                    ) {
                      t.pixelStorei(37440, r.flipY),
                        t.pixelStorei(37441, r.premultiplyAlpha),
                        t.pixelStorei(3317, r.unpackAlignment),
                        t.pixelStorei(37443, 0);
                      const e = _(r) && !1 === x(r.image);
                      let i = b(r.image, e, !1, u);
                      i = rt(r, i);
                      const h = x(i) || s,
                        d = a.convert(r.format, r.encoding);
                      let f,
                        p = a.convert(r.type),
                        m = M(
                          r.internalFormat,
                          d,
                          p,
                          r.encoding,
                          r.isVideoTexture
                        );
                      H(o, r, h);
                      const g = r.mipmaps,
                        v = s && !0 !== r.isVideoTexture,
                        y = void 0 === l.__currentVersion || !0 === c,
                        E = T(r, i, h);
                      if (r.isDepthTexture)
                        (m = 6402),
                          s
                            ? (m =
                                r.type === Et
                                  ? 36012
                                  : r.type === Tt
                                  ? 33190
                                  : r.type === Rt
                                  ? 35056
                                  : 33189)
                            : r.type === Et &&
                              console.error(
                                "WebGLRenderer: Floating point depth texture requires WebGL2."
                              ),
                          r.format === Dt &&
                            6402 === m &&
                            r.type !== St &&
                            r.type !== Tt &&
                            (console.warn(
                              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                            ),
                            (r.type = Tt),
                            (p = a.convert(r.type))),
                          r.format === zt &&
                            6402 === m &&
                            ((m = 34041),
                            r.type !== Rt &&
                              (console.warn(
                                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                              ),
                              (r.type = Rt),
                              (p = a.convert(r.type)))),
                          y &&
                            (v
                              ? n.texStorage2D(3553, 1, m, i.width, i.height)
                              : n.texImage2D(
                                  3553,
                                  0,
                                  m,
                                  i.width,
                                  i.height,
                                  0,
                                  d,
                                  p,
                                  null
                                ));
                      else if (r.isDataTexture)
                        if (g.length > 0 && h) {
                          v &&
                            y &&
                            n.texStorage2D(3553, E, m, g[0].width, g[0].height);
                          for (let t = 0, e = g.length; t < e; t++)
                            (f = g[t]),
                              v
                                ? n.texSubImage2D(
                                    3553,
                                    t,
                                    0,
                                    0,
                                    f.width,
                                    f.height,
                                    d,
                                    p,
                                    f.data
                                  )
                                : n.texImage2D(
                                    3553,
                                    t,
                                    m,
                                    f.width,
                                    f.height,
                                    0,
                                    d,
                                    p,
                                    f.data
                                  );
                          r.generateMipmaps = !1;
                        } else
                          v
                            ? (y &&
                                n.texStorage2D(3553, E, m, i.width, i.height),
                              n.texSubImage2D(
                                3553,
                                0,
                                0,
                                0,
                                i.width,
                                i.height,
                                d,
                                p,
                                i.data
                              ))
                            : n.texImage2D(
                                3553,
                                0,
                                m,
                                i.width,
                                i.height,
                                0,
                                d,
                                p,
                                i.data
                              );
                      else if (r.isCompressedTexture) {
                        v &&
                          y &&
                          n.texStorage2D(3553, E, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++)
                          (f = g[t]),
                            r.format !== Ot
                              ? null !== d
                                ? v
                                  ? n.compressedTexSubImage2D(
                                      3553,
                                      t,
                                      0,
                                      0,
                                      f.width,
                                      f.height,
                                      d,
                                      f.data
                                    )
                                  : n.compressedTexImage2D(
                                      3553,
                                      t,
                                      m,
                                      f.width,
                                      f.height,
                                      0,
                                      f.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                                  )
                              : v
                              ? n.texSubImage2D(
                                  3553,
                                  t,
                                  0,
                                  0,
                                  f.width,
                                  f.height,
                                  d,
                                  p,
                                  f.data
                                )
                              : n.texImage2D(
                                  3553,
                                  t,
                                  m,
                                  f.width,
                                  f.height,
                                  0,
                                  d,
                                  p,
                                  f.data
                                );
                      } else if (r.isDataArrayTexture)
                        v
                          ? (y &&
                              n.texStorage3D(
                                35866,
                                E,
                                m,
                                i.width,
                                i.height,
                                i.depth
                              ),
                            n.texSubImage3D(
                              35866,
                              0,
                              0,
                              0,
                              0,
                              i.width,
                              i.height,
                              i.depth,
                              d,
                              p,
                              i.data
                            ))
                          : n.texImage3D(
                              35866,
                              0,
                              m,
                              i.width,
                              i.height,
                              i.depth,
                              0,
                              d,
                              p,
                              i.data
                            );
                      else if (r.isData3DTexture)
                        v
                          ? (y &&
                              n.texStorage3D(
                                32879,
                                E,
                                m,
                                i.width,
                                i.height,
                                i.depth
                              ),
                            n.texSubImage3D(
                              32879,
                              0,
                              0,
                              0,
                              0,
                              i.width,
                              i.height,
                              i.depth,
                              d,
                              p,
                              i.data
                            ))
                          : n.texImage3D(
                              32879,
                              0,
                              m,
                              i.width,
                              i.height,
                              i.depth,
                              0,
                              d,
                              p,
                              i.data
                            );
                      else if (r.isFramebufferTexture) {
                        if (y)
                          if (v) n.texStorage2D(3553, E, m, i.width, i.height);
                          else {
                            let t = i.width,
                              e = i.height;
                            for (let r = 0; r < E; r++)
                              n.texImage2D(3553, r, m, t, e, 0, d, p, null),
                                (t >>= 1),
                                (e >>= 1);
                          }
                      } else if (g.length > 0 && h) {
                        v &&
                          y &&
                          n.texStorage2D(3553, E, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++)
                          (f = g[t]),
                            v
                              ? n.texSubImage2D(3553, t, 0, 0, d, p, f)
                              : n.texImage2D(3553, t, m, d, p, f);
                        r.generateMipmaps = !1;
                      } else
                        v
                          ? (y && n.texStorage2D(3553, E, m, i.width, i.height),
                            n.texSubImage2D(3553, 0, 0, 0, d, p, i))
                          : n.texImage2D(3553, 0, m, d, p, i);
                      w(r, h) && S(o),
                        (l.__currentVersion = l.version),
                        r.onUpdate && r.onUpdate(r);
                    }
                    e.__version = r.version;
                  }
                  function W(e, r, i) {
                    if (6 !== r.image.length) return;
                    const o = V(e, r),
                      c = r.source;
                    if (
                      (n.activeTexture(33984 + i),
                      n.bindTexture(34067, e.__webglTexture),
                      c.version !== c.__currentVersion || !0 === o)
                    ) {
                      t.pixelStorei(37440, r.flipY),
                        t.pixelStorei(37441, r.premultiplyAlpha),
                        t.pixelStorei(3317, r.unpackAlignment),
                        t.pixelStorei(37443, 0);
                      const e =
                          r.isCompressedTexture ||
                          r.image[0].isCompressedTexture,
                        i = r.image[0] && r.image[0].isDataTexture,
                        u = [];
                      for (let t = 0; t < 6; t++)
                        (u[t] =
                          e || i
                            ? i
                              ? r.image[t].image
                              : r.image[t]
                            : b(r.image[t], !1, !0, l)),
                          (u[t] = rt(r, u[t]));
                      const h = u[0],
                        d = x(h) || s,
                        f = a.convert(r.format, r.encoding),
                        p = a.convert(r.type),
                        m = M(r.internalFormat, f, p, r.encoding),
                        g = s && !0 !== r.isVideoTexture,
                        v = void 0 === c.__currentVersion || !0 === o;
                      let y,
                        _ = T(r, h, d);
                      if ((H(34067, r, d), e)) {
                        g &&
                          v &&
                          n.texStorage2D(34067, _, m, h.width, h.height);
                        for (let t = 0; t < 6; t++) {
                          y = u[t].mipmaps;
                          for (let e = 0; e < y.length; e++) {
                            const i = y[e];
                            r.format !== Ot
                              ? null !== f
                                ? g
                                  ? n.compressedTexSubImage2D(
                                      34069 + t,
                                      e,
                                      0,
                                      0,
                                      i.width,
                                      i.height,
                                      f,
                                      i.data
                                    )
                                  : n.compressedTexImage2D(
                                      34069 + t,
                                      e,
                                      m,
                                      i.width,
                                      i.height,
                                      0,
                                      i.data
                                    )
                                : console.warn(
                                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                  )
                              : g
                              ? n.texSubImage2D(
                                  34069 + t,
                                  e,
                                  0,
                                  0,
                                  i.width,
                                  i.height,
                                  f,
                                  p,
                                  i.data
                                )
                              : n.texImage2D(
                                  34069 + t,
                                  e,
                                  m,
                                  i.width,
                                  i.height,
                                  0,
                                  f,
                                  p,
                                  i.data
                                );
                          }
                        }
                      } else {
                        (y = r.mipmaps),
                          g &&
                            v &&
                            (y.length > 0 && _++,
                            n.texStorage2D(
                              34067,
                              _,
                              m,
                              u[0].width,
                              u[0].height
                            ));
                        for (let t = 0; t < 6; t++)
                          if (i) {
                            g
                              ? n.texSubImage2D(
                                  34069 + t,
                                  0,
                                  0,
                                  0,
                                  u[t].width,
                                  u[t].height,
                                  f,
                                  p,
                                  u[t].data
                                )
                              : n.texImage2D(
                                  34069 + t,
                                  0,
                                  m,
                                  u[t].width,
                                  u[t].height,
                                  0,
                                  f,
                                  p,
                                  u[t].data
                                );
                            for (let e = 0; e < y.length; e++) {
                              const r = y[e],
                                i = r.image[t].image;
                              g
                                ? n.texSubImage2D(
                                    34069 + t,
                                    e + 1,
                                    0,
                                    0,
                                    i.width,
                                    i.height,
                                    f,
                                    p,
                                    i.data
                                  )
                                : n.texImage2D(
                                    34069 + t,
                                    e + 1,
                                    m,
                                    i.width,
                                    i.height,
                                    0,
                                    f,
                                    p,
                                    i.data
                                  );
                            }
                          } else {
                            g
                              ? n.texSubImage2D(34069 + t, 0, 0, 0, f, p, u[t])
                              : n.texImage2D(34069 + t, 0, m, f, p, u[t]);
                            for (let e = 0; e < y.length; e++) {
                              const r = y[e];
                              g
                                ? n.texSubImage2D(
                                    34069 + t,
                                    e + 1,
                                    0,
                                    0,
                                    f,
                                    p,
                                    r.image[t]
                                  )
                                : n.texImage2D(
                                    34069 + t,
                                    e + 1,
                                    m,
                                    f,
                                    p,
                                    r.image[t]
                                  );
                            }
                          }
                      }
                      w(r, d) && S(34067),
                        (c.__currentVersion = c.version),
                        r.onUpdate && r.onUpdate(r);
                    }
                    e.__version = r.version;
                  }
                  function q(e, i, o, s, c) {
                    const l = a.convert(o.format, o.encoding),
                      u = a.convert(o.type),
                      h = M(o.internalFormat, l, u, o.encoding),
                      f = r.get(i);
                    f.__hasExternalTextures ||
                      (32879 === c || 35866 === c
                        ? n.texImage3D(
                            c,
                            0,
                            h,
                            i.width,
                            i.height,
                            i.depth,
                            0,
                            l,
                            u,
                            null
                          )
                        : n.texImage2D(
                            c,
                            0,
                            h,
                            i.width,
                            i.height,
                            0,
                            l,
                            u,
                            null
                          )),
                      n.bindFramebuffer(36160, e),
                      et(i)
                        ? d.framebufferTexture2DMultisampleEXT(
                            36160,
                            s,
                            c,
                            r.get(o).__webglTexture,
                            0,
                            tt(i)
                          )
                        : t.framebufferTexture2D(
                            36160,
                            s,
                            c,
                            r.get(o).__webglTexture,
                            0
                          ),
                      n.bindFramebuffer(36160, null);
                  }
                  function X(e, n, r) {
                    if (
                      (t.bindRenderbuffer(36161, e),
                      n.depthBuffer && !n.stencilBuffer)
                    ) {
                      let i = 33189;
                      if (r || et(n)) {
                        const e = n.depthTexture;
                        e &&
                          e.isDepthTexture &&
                          (e.type === Et
                            ? (i = 36012)
                            : e.type === Tt && (i = 33190));
                        const r = tt(n);
                        et(n)
                          ? d.renderbufferStorageMultisampleEXT(
                              36161,
                              r,
                              i,
                              n.width,
                              n.height
                            )
                          : t.renderbufferStorageMultisample(
                              36161,
                              r,
                              i,
                              n.width,
                              n.height
                            );
                      } else t.renderbufferStorage(36161, i, n.width, n.height);
                      t.framebufferRenderbuffer(36160, 36096, 36161, e);
                    } else if (n.depthBuffer && n.stencilBuffer) {
                      const i = tt(n);
                      r && !1 === et(n)
                        ? t.renderbufferStorageMultisample(
                            36161,
                            i,
                            35056,
                            n.width,
                            n.height
                          )
                        : et(n)
                        ? d.renderbufferStorageMultisampleEXT(
                            36161,
                            i,
                            35056,
                            n.width,
                            n.height
                          )
                        : t.renderbufferStorage(
                            36161,
                            34041,
                            n.width,
                            n.height
                          ),
                        t.framebufferRenderbuffer(36160, 33306, 36161, e);
                    } else {
                      const e =
                        !0 === n.isWebGLMultipleRenderTargets
                          ? n.texture
                          : [n.texture];
                      for (let i = 0; i < e.length; i++) {
                        const o = e[i],
                          s = a.convert(o.format, o.encoding),
                          c = a.convert(o.type),
                          l = M(o.internalFormat, s, c, o.encoding),
                          u = tt(n);
                        r && !1 === et(n)
                          ? t.renderbufferStorageMultisample(
                              36161,
                              u,
                              l,
                              n.width,
                              n.height
                            )
                          : et(n)
                          ? d.renderbufferStorageMultisampleEXT(
                              36161,
                              u,
                              l,
                              n.width,
                              n.height
                            )
                          : t.renderbufferStorage(36161, l, n.width, n.height);
                      }
                    }
                    t.bindRenderbuffer(36161, null);
                  }
                  function $(e, i) {
                    const a = i && i.isWebGLCubeRenderTarget;
                    if (a)
                      throw new Error(
                        "Depth Texture with cube render targets is not supported"
                      );
                    if (
                      (n.bindFramebuffer(36160, e),
                      !i.depthTexture || !i.depthTexture.isDepthTexture)
                    )
                      throw new Error(
                        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                      );
                    (r.get(i.depthTexture).__webglTexture &&
                      i.depthTexture.image.width === i.width &&
                      i.depthTexture.image.height === i.height) ||
                      ((i.depthTexture.image.width = i.width),
                      (i.depthTexture.image.height = i.height),
                      (i.depthTexture.needsUpdate = !0)),
                      D(i.depthTexture, 0);
                    const o = r.get(i.depthTexture).__webglTexture,
                      s = tt(i);
                    if (i.depthTexture.format === Dt)
                      et(i)
                        ? d.framebufferTexture2DMultisampleEXT(
                            36160,
                            36096,
                            3553,
                            o,
                            0,
                            s
                          )
                        : t.framebufferTexture2D(36160, 36096, 3553, o, 0);
                    else {
                      if (i.depthTexture.format !== zt)
                        throw new Error("Unknown depthTexture format");
                      et(i)
                        ? d.framebufferTexture2DMultisampleEXT(
                            36160,
                            33306,
                            3553,
                            o,
                            0,
                            s
                          )
                        : t.framebufferTexture2D(36160, 33306, 3553, o, 0);
                    }
                  }
                  function Y(e) {
                    const i = r.get(e),
                      a = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture && !i.__autoAllocateDepthBuffer) {
                      if (a)
                        throw new Error(
                          "target.depthTexture not supported in Cube render targets"
                        );
                      $(i.__webglFramebuffer, e);
                    } else if (a) {
                      i.__webglDepthbuffer = [];
                      for (let r = 0; r < 6; r++)
                        n.bindFramebuffer(36160, i.__webglFramebuffer[r]),
                          (i.__webglDepthbuffer[r] = t.createRenderbuffer()),
                          X(i.__webglDepthbuffer[r], e, !1);
                    } else
                      n.bindFramebuffer(36160, i.__webglFramebuffer),
                        (i.__webglDepthbuffer = t.createRenderbuffer()),
                        X(i.__webglDepthbuffer, e, !1);
                    n.bindFramebuffer(36160, null);
                  }
                  function J(t, e, n) {
                    const i = r.get(t);
                    void 0 !== e &&
                      q(i.__webglFramebuffer, t, t.texture, 36064, 3553),
                      void 0 !== n && Y(t);
                  }
                  function K(e) {
                    const c = e.texture,
                      l = r.get(e),
                      u = r.get(c);
                    e.addEventListener("dispose", C),
                      !0 !== e.isWebGLMultipleRenderTargets &&
                        (void 0 === u.__webglTexture &&
                          (u.__webglTexture = t.createTexture()),
                        (u.__version = c.version),
                        o.memory.textures++);
                    const h = !0 === e.isWebGLCubeRenderTarget,
                      d = !0 === e.isWebGLMultipleRenderTargets,
                      f = x(e) || s;
                    if (h) {
                      l.__webglFramebuffer = [];
                      for (let e = 0; e < 6; e++)
                        l.__webglFramebuffer[e] = t.createFramebuffer();
                    } else {
                      if (((l.__webglFramebuffer = t.createFramebuffer()), d))
                        if (i.drawBuffers) {
                          const n = e.texture;
                          for (let e = 0, i = n.length; e < i; e++) {
                            const i = r.get(n[e]);
                            void 0 === i.__webglTexture &&
                              ((i.__webglTexture = t.createTexture()),
                              o.memory.textures++);
                          }
                        } else
                          console.warn(
                            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                          );
                      if (s && e.samples > 0 && !1 === et(e)) {
                        const r = d ? c : [c];
                        (l.__webglMultisampledFramebuffer =
                          t.createFramebuffer()),
                          (l.__webglColorRenderbuffer = []),
                          n.bindFramebuffer(
                            36160,
                            l.__webglMultisampledFramebuffer
                          );
                        for (let n = 0; n < r.length; n++) {
                          const i = r[n];
                          (l.__webglColorRenderbuffer[n] =
                            t.createRenderbuffer()),
                            t.bindRenderbuffer(
                              36161,
                              l.__webglColorRenderbuffer[n]
                            );
                          const o = a.convert(i.format, i.encoding),
                            s = a.convert(i.type),
                            c = M(i.internalFormat, o, s, i.encoding),
                            u = tt(e);
                          t.renderbufferStorageMultisample(
                            36161,
                            u,
                            c,
                            e.width,
                            e.height
                          ),
                            t.framebufferRenderbuffer(
                              36160,
                              36064 + n,
                              36161,
                              l.__webglColorRenderbuffer[n]
                            );
                        }
                        t.bindRenderbuffer(36161, null),
                          e.depthBuffer &&
                            ((l.__webglDepthRenderbuffer =
                              t.createRenderbuffer()),
                            X(l.__webglDepthRenderbuffer, e, !0)),
                          n.bindFramebuffer(36160, null);
                      }
                    }
                    if (h) {
                      n.bindTexture(34067, u.__webglTexture), H(34067, c, f);
                      for (let t = 0; t < 6; t++)
                        q(l.__webglFramebuffer[t], e, c, 36064, 34069 + t);
                      w(c, f) && S(34067), n.unbindTexture();
                    } else if (d) {
                      const t = e.texture;
                      for (let i = 0, a = t.length; i < a; i++) {
                        const a = t[i],
                          o = r.get(a);
                        n.bindTexture(3553, o.__webglTexture),
                          H(3553, a, f),
                          q(l.__webglFramebuffer, e, a, 36064 + i, 3553),
                          w(a, f) && S(3553);
                      }
                      n.unbindTexture();
                    } else {
                      let t = 3553;
                      (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                        (s
                          ? (t = e.isWebGL3DRenderTarget ? 32879 : 35866)
                          : console.error(
                              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                            )),
                        n.bindTexture(t, u.__webglTexture),
                        H(t, c, f),
                        q(l.__webglFramebuffer, e, c, 36064, t),
                        w(c, f) && S(t),
                        n.unbindTexture();
                    }
                    e.depthBuffer && Y(e);
                  }
                  function Z(t) {
                    const e = x(t) || s,
                      i =
                        !0 === t.isWebGLMultipleRenderTargets
                          ? t.texture
                          : [t.texture];
                    for (let a = 0, o = i.length; a < o; a++) {
                      const o = i[a];
                      if (w(o, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                          i = r.get(o).__webglTexture;
                        n.bindTexture(e, i), S(e), n.unbindTexture();
                      }
                    }
                  }
                  function Q(e) {
                    if (s && e.samples > 0 && !1 === et(e)) {
                      const i = e.isWebGLMultipleRenderTargets
                          ? e.texture
                          : [e.texture],
                        a = e.width,
                        o = e.height;
                      let s = 16384;
                      const c = [],
                        l = e.stencilBuffer ? 33306 : 36096,
                        u = r.get(e),
                        h = !0 === e.isWebGLMultipleRenderTargets;
                      if (h)
                        for (let e = 0; e < i.length; e++)
                          n.bindFramebuffer(
                            36160,
                            u.__webglMultisampledFramebuffer
                          ),
                            t.framebufferRenderbuffer(
                              36160,
                              36064 + e,
                              36161,
                              null
                            ),
                            n.bindFramebuffer(36160, u.__webglFramebuffer),
                            t.framebufferTexture2D(
                              36009,
                              36064 + e,
                              3553,
                              null,
                              0
                            );
                      n.bindFramebuffer(
                        36008,
                        u.__webglMultisampledFramebuffer
                      ),
                        n.bindFramebuffer(36009, u.__webglFramebuffer);
                      for (let n = 0; n < i.length; n++) {
                        c.push(36064 + n), e.depthBuffer && c.push(l);
                        const d =
                          void 0 !== u.__ignoreDepthValues &&
                          u.__ignoreDepthValues;
                        if (
                          (!1 === d &&
                            (e.depthBuffer && (s |= 256),
                            e.stencilBuffer && (s |= 1024)),
                          h &&
                            t.framebufferRenderbuffer(
                              36008,
                              36064,
                              36161,
                              u.__webglColorRenderbuffer[n]
                            ),
                          !0 === d &&
                            (t.invalidateFramebuffer(36008, [l]),
                            t.invalidateFramebuffer(36009, [l])),
                          h)
                        ) {
                          const e = r.get(i[n]).__webglTexture;
                          t.framebufferTexture2D(36009, 36064, 3553, e, 0);
                        }
                        t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728),
                          f && t.invalidateFramebuffer(36008, c);
                      }
                      if (
                        (n.bindFramebuffer(36008, null),
                        n.bindFramebuffer(36009, null),
                        h)
                      )
                        for (let e = 0; e < i.length; e++) {
                          n.bindFramebuffer(
                            36160,
                            u.__webglMultisampledFramebuffer
                          ),
                            t.framebufferRenderbuffer(
                              36160,
                              36064 + e,
                              36161,
                              u.__webglColorRenderbuffer[e]
                            );
                          const a = r.get(i[e]).__webglTexture;
                          n.bindFramebuffer(36160, u.__webglFramebuffer),
                            t.framebufferTexture2D(
                              36009,
                              36064 + e,
                              3553,
                              a,
                              0
                            );
                        }
                      n.bindFramebuffer(
                        36009,
                        u.__webglMultisampledFramebuffer
                      );
                    }
                  }
                  function tt(t) {
                    return Math.min(h, t.samples);
                  }
                  function et(t) {
                    const n = r.get(t);
                    return (
                      s &&
                      t.samples > 0 &&
                      !0 === e.has("WEBGL_multisampled_render_to_texture") &&
                      !1 !== n.__useRenderToTexture
                    );
                  }
                  function nt(t) {
                    const e = o.render.frame;
                    p.get(t) !== e && (p.set(t, e), t.update());
                  }
                  function rt(t, n) {
                    const r = t.encoding,
                      i = t.format,
                      a = t.type;
                    return (
                      !0 === t.isCompressedTexture ||
                        !0 === t.isVideoTexture ||
                        t.format === Be ||
                        (r !== Ce &&
                          (r === Le
                            ? !1 === s
                              ? !0 === e.has("EXT_sRGB") && i === Ot
                                ? ((t.format = Be),
                                  (t.minFilter = vt),
                                  (t.generateMipmaps = !1))
                                : (n = kn.sRGBToLinear(n))
                              : (i === Ot && a === xt) ||
                                console.warn(
                                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                                )
                            : console.error(
                                "THREE.WebGLTextures: Unsupported texture encoding:",
                                r
                              ))),
                      n
                    );
                  }
                  (this.allocateTextureUnit = k),
                    (this.resetTextureUnits = O),
                    (this.setTexture2D = D),
                    (this.setTexture2DArray = z),
                    (this.setTexture3D = F),
                    (this.setTextureCube = U),
                    (this.rebindTextures = J),
                    (this.setupRenderTarget = K),
                    (this.updateRenderTargetMipmap = Z),
                    (this.updateMultisampleRenderTarget = Q),
                    (this.setupDepthRenderbuffer = Y),
                    (this.setupFrameBufferTexture = q),
                    (this.useMultisampledRTT = et);
                }
                function Au(t, e, n) {
                  const r = n.isWebGL2;
                  function i(n, i = null) {
                    let a;
                    if (n === xt) return 5121;
                    if (n === Ct) return 32819;
                    if (n === Lt) return 32820;
                    if (n === _t) return 5120;
                    if (n === wt) return 5122;
                    if (n === St) return 5123;
                    if (n === Mt) return 5124;
                    if (n === Tt) return 5125;
                    if (n === Et) return 5126;
                    if (n === At)
                      return r
                        ? 5131
                        : ((a = e.get("OES_texture_half_float")),
                          null !== a ? a.HALF_FLOAT_OES : null);
                    if (n === Pt) return 6406;
                    if (n === Ot) return 6408;
                    if (n === kt) return 6409;
                    if (n === Nt) return 6410;
                    if (n === Dt) return 6402;
                    if (n === zt) return 34041;
                    if (n === Ft) return 6403;
                    if (n === It)
                      return (
                        console.warn(
                          "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
                        ),
                        6408
                      );
                    if (n === Be)
                      return (
                        (a = e.get("EXT_sRGB")),
                        null !== a ? a.SRGB_ALPHA_EXT : null
                      );
                    if (n === Ut) return 36244;
                    if (n === Bt) return 33319;
                    if (n === jt) return 33320;
                    if (n === Ht) return 36249;
                    if (n === Vt || n === Gt || n === Wt || n === qt)
                      if (i === Le) {
                        if (
                          ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                          null === a)
                        )
                          return null;
                        if (n === Vt) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === Gt)
                          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === Wt)
                          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === qt)
                          return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                      } else {
                        if (
                          ((a = e.get("WEBGL_compressed_texture_s3tc")),
                          null === a)
                        )
                          return null;
                        if (n === Vt) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (n === Gt) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (n === Wt) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (n === qt) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                      }
                    if (n === Xt || n === $t || n === Yt || n === Jt) {
                      if (
                        ((a = e.get("WEBGL_compressed_texture_pvrtc")),
                        null === a)
                      )
                        return null;
                      if (n === Xt) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                      if (n === $t) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                      if (n === Yt) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                      if (n === Jt) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    }
                    if (n === Kt)
                      return (
                        (a = e.get("WEBGL_compressed_texture_etc1")),
                        null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null
                      );
                    if (n === Zt || n === Qt) {
                      if (
                        ((a = e.get("WEBGL_compressed_texture_etc")),
                        null === a)
                      )
                        return null;
                      if (n === Zt)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ETC2
                          : a.COMPRESSED_RGB8_ETC2;
                      if (n === Qt)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                          : a.COMPRESSED_RGBA8_ETC2_EAC;
                    }
                    if (
                      n === te ||
                      n === ee ||
                      n === ne ||
                      n === re ||
                      n === ie ||
                      n === ae ||
                      n === oe ||
                      n === se ||
                      n === ce ||
                      n === le ||
                      n === ue ||
                      n === he ||
                      n === de ||
                      n === fe
                    ) {
                      if (
                        ((a = e.get("WEBGL_compressed_texture_astc")),
                        null === a)
                      )
                        return null;
                      if (n === te)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                          : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                      if (n === ee)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                          : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                      if (n === ne)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                          : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                      if (n === re)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                          : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                      if (n === ie)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                          : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                      if (n === ae)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                          : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                      if (n === oe)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                          : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                      if (n === se)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                          : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                      if (n === ce)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                          : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                      if (n === le)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                          : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                      if (n === ue)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                          : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                      if (n === he)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                          : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                      if (n === de)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                          : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                      if (n === fe)
                        return i === Le
                          ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                          : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    }
                    if (n === pe) {
                      if (
                        ((a = e.get("EXT_texture_compression_bptc")),
                        null === a)
                      )
                        return null;
                      if (n === pe)
                        return i === Le
                          ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                          : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                    }
                    return n === Rt
                      ? r
                        ? 34042
                        : ((a = e.get("WEBGL_depth_texture")),
                          null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null)
                      : void 0 !== t[n]
                      ? t[n]
                      : null;
                  }
                  return { convert: i };
                }
                class Cu extends Yi {
                  constructor(t = []) {
                    super(), (this.isArrayCamera = !0), (this.cameras = t);
                  }
                }
                class Lu extends qr {
                  constructor() {
                    super(), (this.isGroup = !0), (this.type = "Group");
                  }
                }
                const Ru = { type: "move" };
                class Pu {
                  constructor() {
                    (this._targetRay = null),
                      (this._grip = null),
                      (this._hand = null);
                  }
                  getHandSpace() {
                    return (
                      null === this._hand &&
                        ((this._hand = new Lu()),
                        (this._hand.matrixAutoUpdate = !1),
                        (this._hand.visible = !1),
                        (this._hand.joints = {}),
                        (this._hand.inputState = { pinching: !1 })),
                      this._hand
                    );
                  }
                  getTargetRaySpace() {
                    return (
                      null === this._targetRay &&
                        ((this._targetRay = new Lu()),
                        (this._targetRay.matrixAutoUpdate = !1),
                        (this._targetRay.visible = !1),
                        (this._targetRay.hasLinearVelocity = !1),
                        (this._targetRay.linearVelocity = new Gn()),
                        (this._targetRay.hasAngularVelocity = !1),
                        (this._targetRay.angularVelocity = new Gn())),
                      this._targetRay
                    );
                  }
                  getGripSpace() {
                    return (
                      null === this._grip &&
                        ((this._grip = new Lu()),
                        (this._grip.matrixAutoUpdate = !1),
                        (this._grip.visible = !1),
                        (this._grip.hasLinearVelocity = !1),
                        (this._grip.linearVelocity = new Gn()),
                        (this._grip.hasAngularVelocity = !1),
                        (this._grip.angularVelocity = new Gn())),
                      this._grip
                    );
                  }
                  dispatchEvent(t) {
                    return (
                      null !== this._targetRay &&
                        this._targetRay.dispatchEvent(t),
                      null !== this._grip && this._grip.dispatchEvent(t),
                      null !== this._hand && this._hand.dispatchEvent(t),
                      this
                    );
                  }
                  disconnect(t) {
                    return (
                      this.dispatchEvent({ type: "disconnected", data: t }),
                      null !== this._targetRay &&
                        (this._targetRay.visible = !1),
                      null !== this._grip && (this._grip.visible = !1),
                      null !== this._hand && (this._hand.visible = !1),
                      this
                    );
                  }
                  update(t, e, n) {
                    let r = null,
                      i = null,
                      a = null;
                    const o = this._targetRay,
                      s = this._grip,
                      c = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState) {
                      if (c && t.hand) {
                        a = !0;
                        for (const a of t.hand.values()) {
                          const t = e.getJointPose(a, n);
                          if (void 0 === c.joints[a.jointName]) {
                            const t = new Lu();
                            (t.matrixAutoUpdate = !1),
                              (t.visible = !1),
                              (c.joints[a.jointName] = t),
                              c.add(t);
                          }
                          const r = c.joints[a.jointName];
                          null !== t &&
                            (r.matrix.fromArray(t.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            (r.jointRadius = t.radius)),
                            (r.visible = null !== t);
                        }
                        const r = c.joints["index-finger-tip"],
                          i = c.joints["thumb-tip"],
                          o = r.position.distanceTo(i.position),
                          s = 0.02,
                          l = 0.005;
                        c.inputState.pinching && o > s + l
                          ? ((c.inputState.pinching = !1),
                            this.dispatchEvent({
                              type: "pinchend",
                              handedness: t.handedness,
                              target: this,
                            }))
                          : !c.inputState.pinching &&
                            o <= s - l &&
                            ((c.inputState.pinching = !0),
                            this.dispatchEvent({
                              type: "pinchstart",
                              handedness: t.handedness,
                              target: this,
                            }));
                      } else
                        null !== s &&
                          t.gripSpace &&
                          ((i = e.getPose(t.gripSpace, n)),
                          null !== i &&
                            (s.matrix.fromArray(i.transform.matrix),
                            s.matrix.decompose(s.position, s.rotation, s.scale),
                            i.linearVelocity
                              ? ((s.hasLinearVelocity = !0),
                                s.linearVelocity.copy(i.linearVelocity))
                              : (s.hasLinearVelocity = !1),
                            i.angularVelocity
                              ? ((s.hasAngularVelocity = !0),
                                s.angularVelocity.copy(i.angularVelocity))
                              : (s.hasAngularVelocity = !1)));
                      null !== o &&
                        ((r = e.getPose(t.targetRaySpace, n)),
                        null === r && null !== i && (r = i),
                        null !== r &&
                          (o.matrix.fromArray(r.transform.matrix),
                          o.matrix.decompose(o.position, o.rotation, o.scale),
                          r.linearVelocity
                            ? ((o.hasLinearVelocity = !0),
                              o.linearVelocity.copy(r.linearVelocity))
                            : (o.hasLinearVelocity = !1),
                          r.angularVelocity
                            ? ((o.hasAngularVelocity = !0),
                              o.angularVelocity.copy(r.angularVelocity))
                            : (o.hasAngularVelocity = !1),
                          this.dispatchEvent(Ru)));
                    }
                    return (
                      null !== o && (o.visible = null !== r),
                      null !== s && (s.visible = null !== i),
                      null !== c && (c.visible = null !== a),
                      this
                    );
                  }
                }
                class Iu extends Fn {
                  constructor(t, e, n, r, i, a, o, s, c, l) {
                    if (((l = void 0 !== l ? l : Dt), l !== Dt && l !== zt))
                      throw new Error(
                        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
                      );
                    void 0 === n && l === Dt && (n = Tt),
                      void 0 === n && l === zt && (n = Rt),
                      super(null, r, i, a, o, s, l, n, c),
                      (this.isDepthTexture = !0),
                      (this.image = { width: t, height: e }),
                      (this.magFilter = void 0 !== o ? o : pt),
                      (this.minFilter = void 0 !== s ? s : pt),
                      (this.flipY = !1),
                      (this.generateMipmaps = !1);
                  }
                }
                class Ou extends je {
                  constructor(t, e) {
                    super();
                    const n = this;
                    let r = null,
                      i = 1,
                      a = null,
                      o = "local-floor",
                      s = null,
                      c = null,
                      l = null,
                      u = null,
                      h = null,
                      d = null;
                    const f = e.getContextAttributes();
                    let p = null,
                      m = null;
                    const g = [],
                      v = [],
                      y = new Yi();
                    y.layers.enable(1), (y.viewport = new Un());
                    const b = new Yi();
                    b.layers.enable(2), (b.viewport = new Un());
                    const x = [y, b],
                      _ = new Cu();
                    _.layers.enable(1), _.layers.enable(2);
                    let w = null,
                      S = null;
                    function M(t) {
                      const e = v.indexOf(t.inputSource);
                      if (-1 === e) return;
                      const n = g[e];
                      void 0 !== n &&
                        n.dispatchEvent({ type: t.type, data: t.inputSource });
                    }
                    function T() {
                      r.removeEventListener("select", M),
                        r.removeEventListener("selectstart", M),
                        r.removeEventListener("selectend", M),
                        r.removeEventListener("squeeze", M),
                        r.removeEventListener("squeezestart", M),
                        r.removeEventListener("squeezeend", M),
                        r.removeEventListener("end", T),
                        r.removeEventListener("inputsourceschange", E);
                      for (let t = 0; t < g.length; t++) {
                        const e = v[t];
                        null !== e && ((v[t] = null), g[t].disconnect(e));
                      }
                      (w = null),
                        (S = null),
                        t.setRenderTarget(p),
                        (h = null),
                        (u = null),
                        (l = null),
                        (r = null),
                        (m = null),
                        O.stop(),
                        (n.isPresenting = !1),
                        n.dispatchEvent({ type: "sessionend" });
                    }
                    function E(t) {
                      for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                          r = v.indexOf(n);
                        r >= 0 &&
                          ((v[r] = null),
                          g[r].dispatchEvent({
                            type: "disconnected",
                            data: n,
                          }));
                      }
                      for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let r = v.indexOf(n);
                        if (-1 === r) {
                          for (let t = 0; t < g.length; t++) {
                            if (t >= v.length) {
                              v.push(n), (r = t);
                              break;
                            }
                            if (null === v[t]) {
                              (v[t] = n), (r = t);
                              break;
                            }
                          }
                          if (-1 === r) break;
                        }
                        const i = g[r];
                        i && i.dispatchEvent({ type: "connected", data: n });
                      }
                    }
                    (this.cameraAutoUpdate = !0),
                      (this.enabled = !1),
                      (this.isPresenting = !1),
                      (this.getController = function (t) {
                        let e = g[t];
                        return (
                          void 0 === e && ((e = new Pu()), (g[t] = e)),
                          e.getTargetRaySpace()
                        );
                      }),
                      (this.getControllerGrip = function (t) {
                        let e = g[t];
                        return (
                          void 0 === e && ((e = new Pu()), (g[t] = e)),
                          e.getGripSpace()
                        );
                      }),
                      (this.getHand = function (t) {
                        let e = g[t];
                        return (
                          void 0 === e && ((e = new Pu()), (g[t] = e)),
                          e.getHandSpace()
                        );
                      }),
                      (this.setFramebufferScaleFactor = function (t) {
                        (i = t),
                          !0 === n.isPresenting &&
                            console.warn(
                              "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                            );
                      }),
                      (this.setReferenceSpaceType = function (t) {
                        (o = t),
                          !0 === n.isPresenting &&
                            console.warn(
                              "THREE.WebXRManager: Cannot change reference space type while presenting."
                            );
                      }),
                      (this.getReferenceSpace = function () {
                        return s || a;
                      }),
                      (this.setReferenceSpace = function (t) {
                        s = t;
                      }),
                      (this.getBaseLayer = function () {
                        return null !== u ? u : h;
                      }),
                      (this.getBinding = function () {
                        return l;
                      }),
                      (this.getFrame = function () {
                        return d;
                      }),
                      (this.getSession = function () {
                        return r;
                      }),
                      (this.setSession = async function (c) {
                        if (((r = c), null !== r)) {
                          if (
                            ((p = t.getRenderTarget()),
                            r.addEventListener("select", M),
                            r.addEventListener("selectstart", M),
                            r.addEventListener("selectend", M),
                            r.addEventListener("squeeze", M),
                            r.addEventListener("squeezestart", M),
                            r.addEventListener("squeezeend", M),
                            r.addEventListener("end", T),
                            r.addEventListener("inputsourceschange", E),
                            !0 !== f.xrCompatible &&
                              (await e.makeXRCompatible()),
                            void 0 === r.renderState.layers ||
                              !1 === t.capabilities.isWebGL2)
                          ) {
                            const n = {
                              antialias:
                                void 0 !== r.renderState.layers || f.antialias,
                              alpha: f.alpha,
                              depth: f.depth,
                              stencil: f.stencil,
                              framebufferScaleFactor: i,
                            };
                            (h = new XRWebGLLayer(r, e, n)),
                              r.updateRenderState({ baseLayer: h }),
                              (m = new Bn(
                                h.framebufferWidth,
                                h.framebufferHeight,
                                {
                                  format: Ot,
                                  type: xt,
                                  encoding: t.outputEncoding,
                                }
                              ));
                          } else {
                            let n = null,
                              a = null,
                              o = null;
                            f.depth &&
                              ((o = f.stencil ? 35056 : 33190),
                              (n = f.stencil ? zt : Dt),
                              (a = f.stencil ? Rt : Tt));
                            const s = {
                              colorFormat: 32856,
                              depthFormat: o,
                              scaleFactor: i,
                            };
                            (l = new XRWebGLBinding(r, e)),
                              (u = l.createProjectionLayer(s)),
                              r.updateRenderState({ layers: [u] }),
                              (m = new Bn(u.textureWidth, u.textureHeight, {
                                format: Ot,
                                type: xt,
                                depthTexture: new Iu(
                                  u.textureWidth,
                                  u.textureHeight,
                                  a,
                                  void 0,
                                  void 0,
                                  void 0,
                                  void 0,
                                  void 0,
                                  void 0,
                                  n
                                ),
                                stencilBuffer: f.stencil,
                                encoding: t.outputEncoding,
                                samples: f.antialias ? 4 : 0,
                              }));
                            const c = t.properties.get(m);
                            c.__ignoreDepthValues = u.ignoreDepthValues;
                          }
                          (m.isXRRenderTarget = !0),
                            this.setFoveation(1),
                            (s = null),
                            (a = await r.requestReferenceSpace(o)),
                            O.setContext(r),
                            O.start(),
                            (n.isPresenting = !0),
                            n.dispatchEvent({ type: "sessionstart" });
                        }
                      });
                    const A = new Gn(),
                      C = new Gn();
                    function L(t, e, n) {
                      A.setFromMatrixPosition(e.matrixWorld),
                        C.setFromMatrixPosition(n.matrixWorld);
                      const r = A.distanceTo(C),
                        i = e.projectionMatrix.elements,
                        a = n.projectionMatrix.elements,
                        o = i[14] / (i[10] - 1),
                        s = i[14] / (i[10] + 1),
                        c = (i[9] + 1) / i[5],
                        l = (i[9] - 1) / i[5],
                        u = (i[8] - 1) / i[0],
                        h = (a[8] + 1) / a[0],
                        d = o * u,
                        f = o * h,
                        p = r / (-u + h),
                        m = p * -u;
                      e.matrixWorld.decompose(
                        t.position,
                        t.quaternion,
                        t.scale
                      ),
                        t.translateX(m),
                        t.translateZ(p),
                        t.matrixWorld.compose(
                          t.position,
                          t.quaternion,
                          t.scale
                        ),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                      const g = o + p,
                        v = s + p,
                        y = d - m,
                        b = f + (r - m),
                        x = ((c * s) / v) * g,
                        _ = ((l * s) / v) * g;
                      t.projectionMatrix.makePerspective(y, b, x, _, g, v);
                    }
                    function R(t, e) {
                      null === e
                        ? t.matrixWorld.copy(t.matrix)
                        : t.matrixWorld.multiplyMatrices(
                            e.matrixWorld,
                            t.matrix
                          ),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    }
                    (this.updateCamera = function (t) {
                      if (null === r) return;
                      (_.near = b.near = y.near = t.near),
                        (_.far = b.far = y.far = t.far),
                        (w === _.near && S === _.far) ||
                          (r.updateRenderState({
                            depthNear: _.near,
                            depthFar: _.far,
                          }),
                          (w = _.near),
                          (S = _.far));
                      const e = t.parent,
                        n = _.cameras;
                      R(_, e);
                      for (let r = 0; r < n.length; r++) R(n[r], e);
                      _.matrixWorld.decompose(
                        _.position,
                        _.quaternion,
                        _.scale
                      ),
                        t.position.copy(_.position),
                        t.quaternion.copy(_.quaternion),
                        t.scale.copy(_.scale),
                        t.matrix.copy(_.matrix),
                        t.matrixWorld.copy(_.matrixWorld);
                      const i = t.children;
                      for (let r = 0, a = i.length; r < a; r++)
                        i[r].updateMatrixWorld(!0);
                      2 === n.length
                        ? L(_, y, b)
                        : _.projectionMatrix.copy(y.projectionMatrix);
                    }),
                      (this.getCamera = function () {
                        return _;
                      }),
                      (this.getFoveation = function () {
                        return null !== u
                          ? u.fixedFoveation
                          : null !== h
                          ? h.fixedFoveation
                          : void 0;
                      }),
                      (this.setFoveation = function (t) {
                        null !== u && (u.fixedFoveation = t),
                          null !== h &&
                            void 0 !== h.fixedFoveation &&
                            (h.fixedFoveation = t);
                      });
                    let P = null;
                    function I(e, n) {
                      if (
                        ((c = n.getViewerPose(s || a)), (d = n), null !== c)
                      ) {
                        const e = c.views;
                        null !== h &&
                          (t.setRenderTargetFramebuffer(m, h.framebuffer),
                          t.setRenderTarget(m));
                        let n = !1;
                        e.length !== _.cameras.length &&
                          ((_.cameras.length = 0), (n = !0));
                        for (let r = 0; r < e.length; r++) {
                          const i = e[r];
                          let a = null;
                          if (null !== h) a = h.getViewport(i);
                          else {
                            const e = l.getViewSubImage(u, i);
                            (a = e.viewport),
                              0 === r &&
                                (t.setRenderTargetTextures(
                                  m,
                                  e.colorTexture,
                                  u.ignoreDepthValues
                                    ? void 0
                                    : e.depthStencilTexture
                                ),
                                t.setRenderTarget(m));
                          }
                          let o = x[r];
                          void 0 === o &&
                            ((o = new Yi()),
                            o.layers.enable(r),
                            (o.viewport = new Un()),
                            (x[r] = o)),
                            o.matrix.fromArray(i.transform.matrix),
                            o.projectionMatrix.fromArray(i.projectionMatrix),
                            o.viewport.set(a.x, a.y, a.width, a.height),
                            0 === r && _.matrix.copy(o.matrix),
                            !0 === n && _.cameras.push(o);
                        }
                      }
                      for (let t = 0; t < g.length; t++) {
                        const e = v[t],
                          r = g[t];
                        null !== e && void 0 !== r && r.update(e, n, s || a);
                      }
                      P && P(e, n), (d = null);
                    }
                    const O = new ca();
                    O.setAnimationLoop(I),
                      (this.setAnimationLoop = function (t) {
                        P = t;
                      }),
                      (this.dispose = function () {});
                  }
                }
                function ku(t, e) {
                  function n(t, e) {
                    t.fogColor.value.copy(e.color),
                      e.isFog
                        ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                        : e.isFogExp2 && (t.fogDensity.value = e.density);
                  }
                  function r(t, e, n, r, m) {
                    e.isMeshBasicMaterial || e.isMeshLambertMaterial
                      ? i(t, e)
                      : e.isMeshToonMaterial
                      ? (i(t, e), u(t, e))
                      : e.isMeshPhongMaterial
                      ? (i(t, e), l(t, e))
                      : e.isMeshStandardMaterial
                      ? (i(t, e),
                        h(t, e),
                        e.isMeshPhysicalMaterial && d(t, e, m))
                      : e.isMeshMatcapMaterial
                      ? (i(t, e), f(t, e))
                      : e.isMeshDepthMaterial
                      ? i(t, e)
                      : e.isMeshDistanceMaterial
                      ? (i(t, e), p(t, e))
                      : e.isMeshNormalMaterial
                      ? i(t, e)
                      : e.isLineBasicMaterial
                      ? (a(t, e), e.isLineDashedMaterial && o(t, e))
                      : e.isPointsMaterial
                      ? s(t, e, n, r)
                      : e.isSpriteMaterial
                      ? c(t, e)
                      : e.isShadowMaterial
                      ? (t.color.value.copy(e.color),
                        (t.opacity.value = e.opacity))
                      : e.isShaderMaterial && (e.uniformsNeedUpdate = !1);
                  }
                  function i(n, r) {
                    (n.opacity.value = r.opacity),
                      r.color && n.diffuse.value.copy(r.color),
                      r.emissive &&
                        n.emissive.value
                          .copy(r.emissive)
                          .multiplyScalar(r.emissiveIntensity),
                      r.map && (n.map.value = r.map),
                      r.alphaMap && (n.alphaMap.value = r.alphaMap),
                      r.bumpMap &&
                        ((n.bumpMap.value = r.bumpMap),
                        (n.bumpScale.value = r.bumpScale),
                        r.side === v && (n.bumpScale.value *= -1)),
                      r.displacementMap &&
                        ((n.displacementMap.value = r.displacementMap),
                        (n.displacementScale.value = r.displacementScale),
                        (n.displacementBias.value = r.displacementBias)),
                      r.emissiveMap && (n.emissiveMap.value = r.emissiveMap),
                      r.normalMap &&
                        ((n.normalMap.value = r.normalMap),
                        n.normalScale.value.copy(r.normalScale),
                        r.side === v && n.normalScale.value.negate()),
                      r.specularMap && (n.specularMap.value = r.specularMap),
                      r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
                    const i = e.get(r).envMap;
                    if (
                      (i &&
                        ((n.envMap.value = i),
                        (n.flipEnvMap.value =
                          i.isCubeTexture && !1 === i.isRenderTargetTexture
                            ? -1
                            : 1),
                        (n.reflectivity.value = r.reflectivity),
                        (n.ior.value = r.ior),
                        (n.refractionRatio.value = r.refractionRatio)),
                      r.lightMap)
                    ) {
                      n.lightMap.value = r.lightMap;
                      const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
                      n.lightMapIntensity.value = r.lightMapIntensity * e;
                    }
                    let a, o;
                    r.aoMap &&
                      ((n.aoMap.value = r.aoMap),
                      (n.aoMapIntensity.value = r.aoMapIntensity)),
                      r.map
                        ? (a = r.map)
                        : r.specularMap
                        ? (a = r.specularMap)
                        : r.displacementMap
                        ? (a = r.displacementMap)
                        : r.normalMap
                        ? (a = r.normalMap)
                        : r.bumpMap
                        ? (a = r.bumpMap)
                        : r.roughnessMap
                        ? (a = r.roughnessMap)
                        : r.metalnessMap
                        ? (a = r.metalnessMap)
                        : r.alphaMap
                        ? (a = r.alphaMap)
                        : r.emissiveMap
                        ? (a = r.emissiveMap)
                        : r.clearcoatMap
                        ? (a = r.clearcoatMap)
                        : r.clearcoatNormalMap
                        ? (a = r.clearcoatNormalMap)
                        : r.clearcoatRoughnessMap
                        ? (a = r.clearcoatRoughnessMap)
                        : r.iridescenceMap
                        ? (a = r.iridescenceMap)
                        : r.iridescenceThicknessMap
                        ? (a = r.iridescenceThicknessMap)
                        : r.specularIntensityMap
                        ? (a = r.specularIntensityMap)
                        : r.specularColorMap
                        ? (a = r.specularColorMap)
                        : r.transmissionMap
                        ? (a = r.transmissionMap)
                        : r.thicknessMap
                        ? (a = r.thicknessMap)
                        : r.sheenColorMap
                        ? (a = r.sheenColorMap)
                        : r.sheenRoughnessMap && (a = r.sheenRoughnessMap),
                      void 0 !== a &&
                        (a.isWebGLRenderTarget && (a = a.texture),
                        !0 === a.matrixAutoUpdate && a.updateMatrix(),
                        n.uvTransform.value.copy(a.matrix)),
                      r.aoMap ? (o = r.aoMap) : r.lightMap && (o = r.lightMap),
                      void 0 !== o &&
                        (o.isWebGLRenderTarget && (o = o.texture),
                        !0 === o.matrixAutoUpdate && o.updateMatrix(),
                        n.uv2Transform.value.copy(o.matrix));
                  }
                  function a(t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity);
                  }
                  function o(t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  }
                  function s(t, e, n, r) {
                    let i;
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * n),
                      (t.scale.value = 0.5 * r),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                      e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                      void 0 !== i &&
                        (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix));
                  }
                  function c(t, e) {
                    let n;
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                      e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                      void 0 !== n &&
                        (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                        t.uvTransform.value.copy(n.matrix));
                  }
                  function l(t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4));
                  }
                  function u(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                  }
                  function h(t, n) {
                    (t.roughness.value = n.roughness),
                      (t.metalness.value = n.metalness),
                      n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
                      n.metalnessMap && (t.metalnessMap.value = n.metalnessMap);
                    const r = e.get(n).envMap;
                    r && (t.envMapIntensity.value = n.envMapIntensity);
                  }
                  function d(t, e, n) {
                    (t.ior.value = e.ior),
                      e.sheen > 0 &&
                        (t.sheenColor.value
                          .copy(e.sheenColor)
                          .multiplyScalar(e.sheen),
                        (t.sheenRoughness.value = e.sheenRoughness),
                        e.sheenColorMap &&
                          (t.sheenColorMap.value = e.sheenColorMap),
                        e.sheenRoughnessMap &&
                          (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
                      e.clearcoat > 0 &&
                        ((t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.clearcoatMap &&
                          (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap &&
                          (t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap &&
                          (t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale
                          ),
                          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          e.side === v &&
                            t.clearcoatNormalScale.value.negate())),
                      e.iridescence > 0 &&
                        ((t.iridescence.value = e.iridescence),
                        (t.iridescenceIOR.value = e.iridescenceIOR),
                        (t.iridescenceThicknessMinimum.value =
                          e.iridescenceThicknessRange[0]),
                        (t.iridescenceThicknessMaximum.value =
                          e.iridescenceThicknessRange[1]),
                        e.iridescenceMap &&
                          (t.iridescenceMap.value = e.iridescenceMap),
                        e.iridescenceThicknessMap &&
                          (t.iridescenceThicknessMap.value =
                            e.iridescenceThicknessMap)),
                      e.transmission > 0 &&
                        ((t.transmission.value = e.transmission),
                        (t.transmissionSamplerMap.value = n.texture),
                        t.transmissionSamplerSize.value.set(n.width, n.height),
                        e.transmissionMap &&
                          (t.transmissionMap.value = e.transmissionMap),
                        (t.thickness.value = e.thickness),
                        e.thicknessMap &&
                          (t.thicknessMap.value = e.thicknessMap),
                        (t.attenuationDistance.value = e.attenuationDistance),
                        t.attenuationColor.value.copy(e.attenuationColor)),
                      (t.specularIntensity.value = e.specularIntensity),
                      t.specularColor.value.copy(e.specularColor),
                      e.specularIntensityMap &&
                        (t.specularIntensityMap.value = e.specularIntensityMap),
                      e.specularColorMap &&
                        (t.specularColorMap.value = e.specularColorMap);
                  }
                  function f(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                  }
                  function p(t, e) {
                    t.referencePosition.value.copy(e.referencePosition),
                      (t.nearDistance.value = e.nearDistance),
                      (t.farDistance.value = e.farDistance);
                  }
                  return { refreshFogUniforms: n, refreshMaterialUniforms: r };
                }
                function Nu() {
                  const t = _n("canvas");
                  return (t.style.display = "block"), t;
                }
                function Du(t = {}) {
                  this.isWebGLRenderer = !0;
                  const e = void 0 !== t.canvas ? t.canvas : Nu(),
                    n = void 0 !== t.context ? t.context : null,
                    r = void 0 === t.depth || t.depth,
                    i = void 0 === t.stencil || t.stencil,
                    a = void 0 !== t.antialias && t.antialias,
                    o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    c =
                      void 0 !== t.preserveDrawingBuffer &&
                      t.preserveDrawingBuffer,
                    l =
                      void 0 !== t.powerPreference
                        ? t.powerPreference
                        : "default",
                    u =
                      void 0 !== t.failIfMajorPerformanceCaveat &&
                      t.failIfMajorPerformanceCaveat;
                  let h;
                  h =
                    null !== n
                      ? n.getContextAttributes().alpha
                      : void 0 !== t.alpha && t.alpha;
                  let d = null,
                    f = null;
                  const p = [],
                    m = [];
                  (this.domElement = e),
                    (this.debug = { checkShaderErrors: !0 }),
                    (this.autoClear = !0),
                    (this.autoClearColor = !0),
                    (this.autoClearDepth = !0),
                    (this.autoClearStencil = !0),
                    (this.sortObjects = !0),
                    (this.clippingPlanes = []),
                    (this.localClippingEnabled = !1),
                    (this.outputEncoding = Ce),
                    (this.physicallyCorrectLights = !1),
                    (this.toneMapping = Q),
                    (this.toneMappingExposure = 1),
                    Object.defineProperties(this, {
                      gammaFactor: {
                        get: function () {
                          return (
                            console.warn(
                              "THREE.WebGLRenderer: .gammaFactor has been removed."
                            ),
                            2
                          );
                        },
                        set: function () {
                          console.warn(
                            "THREE.WebGLRenderer: .gammaFactor has been removed."
                          );
                        },
                      },
                    });
                  const b = this;
                  let x = !1,
                    _ = 0,
                    w = 0,
                    S = null,
                    M = -1,
                    T = null;
                  const E = new Un(),
                    A = new Un();
                  let C = null,
                    L = e.width,
                    R = e.height,
                    P = 1,
                    I = null,
                    O = null;
                  const k = new Un(0, 0, L, R),
                    N = new Un(0, 0, L, R);
                  let D = !1;
                  const z = new sa();
                  let F = !1,
                    U = !1,
                    B = null;
                  const j = new _r(),
                    H = new gn(),
                    V = new Gn(),
                    G = {
                      background: null,
                      fog: null,
                      environment: null,
                      overrideMaterial: null,
                      isScene: !0,
                    };
                  function W() {
                    return null === S ? P : 1;
                  }
                  let q,
                    X,
                    $,
                    Y,
                    J,
                    K,
                    Z,
                    tt,
                    et,
                    nt,
                    rt,
                    it,
                    at,
                    ot,
                    st,
                    ct,
                    lt,
                    ut,
                    ht,
                    dt,
                    ft,
                    pt,
                    mt,
                    gt = n;
                  function vt(t, n) {
                    for (let r = 0; r < t.length; r++) {
                      const i = t[r],
                        a = e.getContext(i, n);
                      if (null !== a) return a;
                    }
                    return null;
                  }
                  try {
                    const t = {
                      alpha: !0,
                      depth: r,
                      stencil: i,
                      antialias: a,
                      premultipliedAlpha: o,
                      preserveDrawingBuffer: c,
                      powerPreference: l,
                      failIfMajorPerformanceCaveat: u,
                    };
                    if (
                      ("setAttribute" in e &&
                        e.setAttribute("data-engine", `three.js r${s}`),
                      e.addEventListener("webglcontextlost", wt, !1),
                      e.addEventListener("webglcontextrestored", St, !1),
                      e.addEventListener("webglcontextcreationerror", Mt, !1),
                      null === gt)
                    ) {
                      const e = ["webgl2", "webgl", "experimental-webgl"];
                      if (
                        (!0 === b.isWebGL1Renderer && e.shift(),
                        (gt = vt(e, t)),
                        null === gt)
                      )
                        throw vt(e)
                          ? new Error(
                              "Error creating WebGL context with your selected attributes."
                            )
                          : new Error("Error creating WebGL context.");
                    }
                    void 0 === gt.getShaderPrecisionFormat &&
                      (gt.getShaderPrecisionFormat = function () {
                        return { rangeMin: 1, rangeMax: 1, precision: 1 };
                      });
                  } catch (qt) {
                    throw (
                      (console.error("THREE.WebGLRenderer: " + qt.message), qt)
                    );
                  }
                  function yt() {
                    (q = new mc(gt)),
                      (X = new Xs(gt, q, t)),
                      q.init(X),
                      (pt = new Au(gt, q, X)),
                      ($ = new Tu(gt, q, X)),
                      (Y = new yc()),
                      (J = new cu()),
                      (K = new Eu(gt, q, $, J, X, pt, Y)),
                      (Z = new Ys(b)),
                      (tt = new pc(b)),
                      (et = new la(gt, X)),
                      (mt = new Ws(gt, q, et, X)),
                      (nt = new gc(gt, et, Y, mt)),
                      (rt = new Sc(gt, nt, et, Y)),
                      (ht = new wc(gt, X, K)),
                      (ct = new $s(J)),
                      (it = new su(b, Z, tt, q, X, mt, ct)),
                      (at = new ku(b, J)),
                      (ot = new du()),
                      (st = new bu(q, X)),
                      (ut = new Gs(b, Z, $, rt, h, o)),
                      (lt = new Mu(b, rt, X)),
                      (dt = new qs(gt, q, Y, X)),
                      (ft = new vc(gt, q, Y, X)),
                      (Y.programs = it.programs),
                      (b.capabilities = X),
                      (b.extensions = q),
                      (b.properties = J),
                      (b.renderLists = ot),
                      (b.shadowMap = lt),
                      (b.state = $),
                      (b.info = Y);
                  }
                  yt();
                  const _t = new Ou(b, gt);
                  function wt(t) {
                    t.preventDefault(),
                      console.log("THREE.WebGLRenderer: Context Lost."),
                      (x = !0);
                  }
                  function St() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                      (x = !1);
                    const t = Y.autoReset,
                      e = lt.enabled,
                      n = lt.autoUpdate,
                      r = lt.needsUpdate,
                      i = lt.type;
                    yt(),
                      (Y.autoReset = t),
                      (lt.enabled = e),
                      (lt.autoUpdate = n),
                      (lt.needsUpdate = r),
                      (lt.type = i);
                  }
                  function Mt(t) {
                    console.error(
                      "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
                      t.statusMessage
                    );
                  }
                  function Tt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", Tt), Ct(e);
                  }
                  function Ct(t) {
                    Lt(t), J.remove(t);
                  }
                  function Lt(t) {
                    const e = J.get(t).programs;
                    void 0 !== e &&
                      (e.forEach(function (t) {
                        it.releaseProgram(t);
                      }),
                      t.isShaderMaterial && it.releaseShaderCache(t));
                  }
                  (this.xr = _t),
                    (this.getContext = function () {
                      return gt;
                    }),
                    (this.getContextAttributes = function () {
                      return gt.getContextAttributes();
                    }),
                    (this.forceContextLoss = function () {
                      const t = q.get("WEBGL_lose_context");
                      t && t.loseContext();
                    }),
                    (this.forceContextRestore = function () {
                      const t = q.get("WEBGL_lose_context");
                      t && t.restoreContext();
                    }),
                    (this.getPixelRatio = function () {
                      return P;
                    }),
                    (this.setPixelRatio = function (t) {
                      void 0 !== t && ((P = t), this.setSize(L, R, !1));
                    }),
                    (this.getSize = function (t) {
                      return t.set(L, R);
                    }),
                    (this.setSize = function (t, n, r) {
                      _t.isPresenting
                        ? console.warn(
                            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                          )
                        : ((L = t),
                          (R = n),
                          (e.width = Math.floor(t * P)),
                          (e.height = Math.floor(n * P)),
                          !1 !== r &&
                            ((e.style.width = t + "px"),
                            (e.style.height = n + "px")),
                          this.setViewport(0, 0, t, n));
                    }),
                    (this.getDrawingBufferSize = function (t) {
                      return t.set(L * P, R * P).floor();
                    }),
                    (this.setDrawingBufferSize = function (t, n, r) {
                      (L = t),
                        (R = n),
                        (P = r),
                        (e.width = Math.floor(t * r)),
                        (e.height = Math.floor(n * r)),
                        this.setViewport(0, 0, t, n);
                    }),
                    (this.getCurrentViewport = function (t) {
                      return t.copy(E);
                    }),
                    (this.getViewport = function (t) {
                      return t.copy(k);
                    }),
                    (this.setViewport = function (t, e, n, r) {
                      t.isVector4
                        ? k.set(t.x, t.y, t.z, t.w)
                        : k.set(t, e, n, r),
                        $.viewport(E.copy(k).multiplyScalar(P).floor());
                    }),
                    (this.getScissor = function (t) {
                      return t.copy(N);
                    }),
                    (this.setScissor = function (t, e, n, r) {
                      t.isVector4
                        ? N.set(t.x, t.y, t.z, t.w)
                        : N.set(t, e, n, r),
                        $.scissor(A.copy(N).multiplyScalar(P).floor());
                    }),
                    (this.getScissorTest = function () {
                      return D;
                    }),
                    (this.setScissorTest = function (t) {
                      $.setScissorTest((D = t));
                    }),
                    (this.setOpaqueSort = function (t) {
                      I = t;
                    }),
                    (this.setTransparentSort = function (t) {
                      O = t;
                    }),
                    (this.getClearColor = function (t) {
                      return t.copy(ut.getClearColor());
                    }),
                    (this.setClearColor = function () {
                      ut.setClearColor.apply(ut, arguments);
                    }),
                    (this.getClearAlpha = function () {
                      return ut.getClearAlpha();
                    }),
                    (this.setClearAlpha = function () {
                      ut.setClearAlpha.apply(ut, arguments);
                    }),
                    (this.clear = function (t = !0, e = !0, n = !0) {
                      let r = 0;
                      t && (r |= 16384),
                        e && (r |= 256),
                        n && (r |= 1024),
                        gt.clear(r);
                    }),
                    (this.clearColor = function () {
                      this.clear(!0, !1, !1);
                    }),
                    (this.clearDepth = function () {
                      this.clear(!1, !0, !1);
                    }),
                    (this.clearStencil = function () {
                      this.clear(!1, !1, !0);
                    }),
                    (this.dispose = function () {
                      e.removeEventListener("webglcontextlost", wt, !1),
                        e.removeEventListener("webglcontextrestored", St, !1),
                        e.removeEventListener(
                          "webglcontextcreationerror",
                          Mt,
                          !1
                        ),
                        ot.dispose(),
                        st.dispose(),
                        J.dispose(),
                        Z.dispose(),
                        tt.dispose(),
                        rt.dispose(),
                        mt.dispose(),
                        it.dispose(),
                        _t.dispose(),
                        _t.removeEventListener("sessionstart", It),
                        _t.removeEventListener("sessionend", kt),
                        B && (B.dispose(), (B = null)),
                        Nt.stop();
                    }),
                    (this.renderBufferDirect = function (t, e, n, r, i, a) {
                      null === e && (e = G);
                      const o = i.isMesh && i.matrixWorld.determinant() < 0,
                        s = Vt(t, e, n, r, i);
                      $.setMaterial(r, o);
                      let c = n.index;
                      const l = n.attributes.position;
                      if (null === c) {
                        if (void 0 === l || 0 === l.count) return;
                      } else if (0 === c.count) return;
                      let u,
                        h = 1;
                      !0 === r.wireframe &&
                        ((c = nt.getWireframeAttribute(n)), (h = 2)),
                        mt.setup(i, r, s, n, c);
                      let d = dt;
                      null !== c && ((u = et.get(c)), (d = ft), d.setIndex(u));
                      const f = null !== c ? c.count : l.count,
                        p = n.drawRange.start * h,
                        m = n.drawRange.count * h,
                        g = null !== a ? a.start * h : 0,
                        v = null !== a ? a.count * h : 1 / 0,
                        y = Math.max(p, g),
                        b = Math.min(f, p + m, g + v) - 1,
                        x = Math.max(0, b - y + 1);
                      if (0 !== x) {
                        if (i.isMesh)
                          !0 === r.wireframe
                            ? ($.setLineWidth(r.wireframeLinewidth * W()),
                              d.setMode(1))
                            : d.setMode(4);
                        else if (i.isLine) {
                          let t = r.linewidth;
                          void 0 === t && (t = 1),
                            $.setLineWidth(t * W()),
                            i.isLineSegments
                              ? d.setMode(1)
                              : i.isLineLoop
                              ? d.setMode(2)
                              : d.setMode(3);
                        } else
                          i.isPoints
                            ? d.setMode(0)
                            : i.isSprite && d.setMode(4);
                        if (i.isInstancedMesh) d.renderInstances(y, x, i.count);
                        else if (n.isInstancedBufferGeometry) {
                          const t = Math.min(
                            n.instanceCount,
                            n._maxInstanceCount
                          );
                          d.renderInstances(y, x, t);
                        } else d.render(y, x);
                      }
                    }),
                    (this.compile = function (t, e) {
                      (f = st.get(t)),
                        f.init(),
                        m.push(f),
                        t.traverseVisible(function (t) {
                          t.isLight &&
                            t.layers.test(e.layers) &&
                            (f.pushLight(t), t.castShadow && f.pushShadow(t));
                        }),
                        f.setupLights(b.physicallyCorrectLights),
                        t.traverse(function (e) {
                          const n = e.material;
                          if (n)
                            if (Array.isArray(n))
                              for (let r = 0; r < n.length; r++) {
                                const i = n[r];
                                jt(i, t, e);
                              }
                            else jt(n, t, e);
                        }),
                        m.pop(),
                        (f = null);
                    });
                  let Rt = null;
                  function Pt(t) {
                    Rt && Rt(t);
                  }
                  function It() {
                    Nt.stop();
                  }
                  function kt() {
                    Nt.start();
                  }
                  const Nt = new ca();
                  function Dt(t, e, n, r) {
                    if (!1 === t.visible) return;
                    const i = t.layers.test(e.layers);
                    if (i)
                      if (t.isGroup) n = t.renderOrder;
                      else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                      else if (t.isLight)
                        f.pushLight(t), t.castShadow && f.pushShadow(t);
                      else if (t.isSprite) {
                        if (!t.frustumCulled || z.intersectsSprite(t)) {
                          r &&
                            V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(
                              j
                            );
                          const e = rt.update(t),
                            i = t.material;
                          i.visible && d.push(t, e, i, n, V.z, null);
                        }
                      } else if (
                        (t.isMesh || t.isLine || t.isPoints) &&
                        (t.isSkinnedMesh &&
                          t.skeleton.frame !== Y.render.frame &&
                          (t.skeleton.update(),
                          (t.skeleton.frame = Y.render.frame)),
                        !t.frustumCulled || z.intersectsObject(t))
                      ) {
                        r &&
                          V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(
                            j
                          );
                        const e = rt.update(t),
                          i = t.material;
                        if (Array.isArray(i)) {
                          const r = e.groups;
                          for (let a = 0, o = r.length; a < o; a++) {
                            const o = r[a],
                              s = i[o.materialIndex];
                            s && s.visible && d.push(t, e, s, n, V.z, o);
                          }
                        } else i.visible && d.push(t, e, i, n, V.z, null);
                      }
                    const a = t.children;
                    for (let o = 0, s = a.length; o < s; o++) Dt(a[o], e, n, r);
                  }
                  function zt(t, e, n, r) {
                    const i = t.opaque,
                      a = t.transmissive,
                      o = t.transparent;
                    f.setupLightsView(n),
                      a.length > 0 && Ft(i, e, n),
                      r && $.viewport(E.copy(r)),
                      i.length > 0 && Ut(i, e, n),
                      a.length > 0 && Ut(a, e, n),
                      o.length > 0 && Ut(o, e, n),
                      $.buffers.depth.setTest(!0),
                      $.buffers.depth.setMask(!0),
                      $.buffers.color.setMask(!0),
                      $.setPolygonOffset(!1);
                  }
                  function Ft(t, e, n) {
                    const r = X.isWebGL2;
                    null === B &&
                      (B = new Bn(1, 1, {
                        generateMipmaps: !0,
                        type: q.has("EXT_color_buffer_half_float") ? At : xt,
                        minFilter: bt,
                        samples: r && !0 === a ? 4 : 0,
                      })),
                      b.getDrawingBufferSize(H),
                      r ? B.setSize(H.x, H.y) : B.setSize(hn(H.x), hn(H.y));
                    const i = b.getRenderTarget();
                    b.setRenderTarget(B), b.clear();
                    const o = b.toneMapping;
                    (b.toneMapping = Q),
                      Ut(t, e, n),
                      (b.toneMapping = o),
                      K.updateMultisampleRenderTarget(B),
                      K.updateRenderTargetMipmap(B),
                      b.setRenderTarget(i);
                  }
                  function Ut(t, e, n) {
                    const r = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let i = 0, a = t.length; i < a; i++) {
                      const a = t[i],
                        o = a.object,
                        s = a.geometry,
                        c = null === r ? a.material : r,
                        l = a.group;
                      o.layers.test(n.layers) && Bt(o, e, n, s, c, l);
                    }
                  }
                  function Bt(t, e, n, r, i, a) {
                    t.onBeforeRender(b, e, n, r, i, a),
                      t.modelViewMatrix.multiplyMatrices(
                        n.matrixWorldInverse,
                        t.matrixWorld
                      ),
                      t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                      i.onBeforeRender(b, e, n, r, t, a),
                      !0 === i.transparent && i.side === y
                        ? ((i.side = v),
                          (i.needsUpdate = !0),
                          b.renderBufferDirect(n, e, r, i, t, a),
                          (i.side = g),
                          (i.needsUpdate = !0),
                          b.renderBufferDirect(n, e, r, i, t, a),
                          (i.side = y))
                        : b.renderBufferDirect(n, e, r, i, t, a),
                      t.onAfterRender(b, e, n, r, i, a);
                  }
                  function jt(t, e, n) {
                    !0 !== e.isScene && (e = G);
                    const r = J.get(t),
                      i = f.state.lights,
                      a = f.state.shadowsArray,
                      o = i.state.version,
                      s = it.getParameters(t, i.state, a, e, n),
                      c = it.getProgramCacheKey(s);
                    let l = r.programs;
                    (r.environment = t.isMeshStandardMaterial
                      ? e.environment
                      : null),
                      (r.fog = e.fog),
                      (r.envMap = (t.isMeshStandardMaterial ? tt : Z).get(
                        t.envMap || r.environment
                      )),
                      void 0 === l &&
                        (t.addEventListener("dispose", Tt),
                        (l = new Map()),
                        (r.programs = l));
                    let u = l.get(c);
                    if (void 0 !== u) {
                      if (r.currentProgram === u && r.lightsStateVersion === o)
                        return Ht(t, s), u;
                    } else
                      (s.uniforms = it.getUniforms(t)),
                        t.onBuild(n, s, b),
                        t.onBeforeCompile(s, b),
                        (u = it.acquireProgram(s, c)),
                        l.set(c, u),
                        (r.uniforms = s.uniforms);
                    const h = r.uniforms;
                    ((t.isShaderMaterial || t.isRawShaderMaterial) &&
                      !0 !== t.clipping) ||
                      (h.clippingPlanes = ct.uniform),
                      Ht(t, s),
                      (r.needsLights = Wt(t)),
                      (r.lightsStateVersion = o),
                      r.needsLights &&
                        ((h.ambientLightColor.value = i.state.ambient),
                        (h.lightProbe.value = i.state.probe),
                        (h.directionalLights.value = i.state.directional),
                        (h.directionalLightShadows.value =
                          i.state.directionalShadow),
                        (h.spotLights.value = i.state.spot),
                        (h.spotLightShadows.value = i.state.spotShadow),
                        (h.rectAreaLights.value = i.state.rectArea),
                        (h.ltc_1.value = i.state.rectAreaLTC1),
                        (h.ltc_2.value = i.state.rectAreaLTC2),
                        (h.pointLights.value = i.state.point),
                        (h.pointLightShadows.value = i.state.pointShadow),
                        (h.hemisphereLights.value = i.state.hemi),
                        (h.directionalShadowMap.value =
                          i.state.directionalShadowMap),
                        (h.directionalShadowMatrix.value =
                          i.state.directionalShadowMatrix),
                        (h.spotShadowMap.value = i.state.spotShadowMap),
                        (h.spotShadowMatrix.value = i.state.spotShadowMatrix),
                        (h.pointShadowMap.value = i.state.pointShadowMap),
                        (h.pointShadowMatrix.value =
                          i.state.pointShadowMatrix));
                    const d = u.getUniforms(),
                      p = Ll.seqWithValue(d.seq, h);
                    return (r.currentProgram = u), (r.uniformsList = p), u;
                  }
                  function Ht(t, e) {
                    const n = J.get(t);
                    (n.outputEncoding = e.outputEncoding),
                      (n.instancing = e.instancing),
                      (n.skinning = e.skinning),
                      (n.morphTargets = e.morphTargets),
                      (n.morphNormals = e.morphNormals),
                      (n.morphColors = e.morphColors),
                      (n.morphTargetsCount = e.morphTargetsCount),
                      (n.numClippingPlanes = e.numClippingPlanes),
                      (n.numIntersection = e.numClipIntersection),
                      (n.vertexAlphas = e.vertexAlphas),
                      (n.vertexTangents = e.vertexTangents),
                      (n.toneMapping = e.toneMapping);
                  }
                  function Vt(t, e, n, r, i) {
                    !0 !== e.isScene && (e = G), K.resetTextureUnits();
                    const a = e.fog,
                      o = r.isMeshStandardMaterial ? e.environment : null,
                      s =
                        null === S
                          ? b.outputEncoding
                          : !0 === S.isXRRenderTarget
                          ? S.texture.encoding
                          : Ce,
                      c = (r.isMeshStandardMaterial ? tt : Z).get(
                        r.envMap || o
                      ),
                      l =
                        !0 === r.vertexColors &&
                        !!n.attributes.color &&
                        4 === n.attributes.color.itemSize,
                      u = !!r.normalMap && !!n.attributes.tangent,
                      h = !!n.morphAttributes.position,
                      d = !!n.morphAttributes.normal,
                      p = !!n.morphAttributes.color,
                      m = r.toneMapped ? b.toneMapping : Q,
                      g =
                        n.morphAttributes.position ||
                        n.morphAttributes.normal ||
                        n.morphAttributes.color,
                      v = void 0 !== g ? g.length : 0,
                      y = J.get(r),
                      x = f.state.lights;
                    if (!0 === F && (!0 === U || t !== T)) {
                      const e = t === T && r.id === M;
                      ct.setState(r, t, e);
                    }
                    let _ = !1;
                    r.version === y.__version
                      ? (y.needsLights &&
                          y.lightsStateVersion !== x.state.version) ||
                        y.outputEncoding !== s ||
                        (i.isInstancedMesh && !1 === y.instancing)
                        ? (_ = !0)
                        : i.isInstancedMesh || !0 !== y.instancing
                        ? i.isSkinnedMesh && !1 === y.skinning
                          ? (_ = !0)
                          : i.isSkinnedMesh || !0 !== y.skinning
                          ? y.envMap !== c || (!0 === r.fog && y.fog !== a)
                            ? (_ = !0)
                            : void 0 === y.numClippingPlanes ||
                              (y.numClippingPlanes === ct.numPlanes &&
                                y.numIntersection === ct.numIntersection)
                            ? (y.vertexAlphas !== l ||
                                y.vertexTangents !== u ||
                                y.morphTargets !== h ||
                                y.morphNormals !== d ||
                                y.morphColors !== p ||
                                y.toneMapping !== m ||
                                (!0 === X.isWebGL2 &&
                                  y.morphTargetsCount !== v)) &&
                              (_ = !0)
                            : (_ = !0)
                          : (_ = !0)
                        : (_ = !0)
                      : ((_ = !0), (y.__version = r.version));
                    let w = y.currentProgram;
                    !0 === _ && (w = jt(r, e, i));
                    let E = !1,
                      A = !1,
                      C = !1;
                    const L = w.getUniforms(),
                      I = y.uniforms;
                    if (
                      ($.useProgram(w.program) &&
                        ((E = !0), (A = !0), (C = !0)),
                      r.id !== M && ((M = r.id), (A = !0)),
                      E || T !== t)
                    ) {
                      if (
                        (L.setValue(gt, "projectionMatrix", t.projectionMatrix),
                        X.logarithmicDepthBuffer &&
                          L.setValue(
                            gt,
                            "logDepthBufFC",
                            2 / (Math.log(t.far + 1) / Math.LN2)
                          ),
                        T !== t && ((T = t), (A = !0), (C = !0)),
                        r.isShaderMaterial ||
                          r.isMeshPhongMaterial ||
                          r.isMeshToonMaterial ||
                          r.isMeshStandardMaterial ||
                          r.envMap)
                      ) {
                        const e = L.map.cameraPosition;
                        void 0 !== e &&
                          e.setValue(
                            gt,
                            V.setFromMatrixPosition(t.matrixWorld)
                          );
                      }
                      (r.isMeshPhongMaterial ||
                        r.isMeshToonMaterial ||
                        r.isMeshLambertMaterial ||
                        r.isMeshBasicMaterial ||
                        r.isMeshStandardMaterial ||
                        r.isShaderMaterial) &&
                        L.setValue(
                          gt,
                          "isOrthographic",
                          !0 === t.isOrthographicCamera
                        ),
                        (r.isMeshPhongMaterial ||
                          r.isMeshToonMaterial ||
                          r.isMeshLambertMaterial ||
                          r.isMeshBasicMaterial ||
                          r.isMeshStandardMaterial ||
                          r.isShaderMaterial ||
                          r.isShadowMaterial ||
                          i.isSkinnedMesh) &&
                          L.setValue(gt, "viewMatrix", t.matrixWorldInverse);
                    }
                    if (i.isSkinnedMesh) {
                      L.setOptional(gt, i, "bindMatrix"),
                        L.setOptional(gt, i, "bindMatrixInverse");
                      const t = i.skeleton;
                      t &&
                        (X.floatVertexTextures
                          ? (null === t.boneTexture && t.computeBoneTexture(),
                            L.setValue(gt, "boneTexture", t.boneTexture, K),
                            L.setValue(
                              gt,
                              "boneTextureSize",
                              t.boneTextureSize
                            ))
                          : console.warn(
                              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                            ));
                    }
                    const O = n.morphAttributes;
                    return (
                      (void 0 !== O.position ||
                        void 0 !== O.normal ||
                        (void 0 !== O.color && !0 === X.isWebGL2)) &&
                        ht.update(i, n, r, w),
                      (A || y.receiveShadow !== i.receiveShadow) &&
                        ((y.receiveShadow = i.receiveShadow),
                        L.setValue(gt, "receiveShadow", i.receiveShadow)),
                      A &&
                        (L.setValue(
                          gt,
                          "toneMappingExposure",
                          b.toneMappingExposure
                        ),
                        y.needsLights && Gt(I, C),
                        a && !0 === r.fog && at.refreshFogUniforms(I, a),
                        at.refreshMaterialUniforms(I, r, P, R, B),
                        Ll.upload(gt, y.uniformsList, I, K)),
                      r.isShaderMaterial &&
                        !0 === r.uniformsNeedUpdate &&
                        (Ll.upload(gt, y.uniformsList, I, K),
                        (r.uniformsNeedUpdate = !1)),
                      r.isSpriteMaterial && L.setValue(gt, "center", i.center),
                      L.setValue(gt, "modelViewMatrix", i.modelViewMatrix),
                      L.setValue(gt, "normalMatrix", i.normalMatrix),
                      L.setValue(gt, "modelMatrix", i.matrixWorld),
                      w
                    );
                  }
                  function Gt(t, e) {
                    (t.ambientLightColor.needsUpdate = e),
                      (t.lightProbe.needsUpdate = e),
                      (t.directionalLights.needsUpdate = e),
                      (t.directionalLightShadows.needsUpdate = e),
                      (t.pointLights.needsUpdate = e),
                      (t.pointLightShadows.needsUpdate = e),
                      (t.spotLights.needsUpdate = e),
                      (t.spotLightShadows.needsUpdate = e),
                      (t.rectAreaLights.needsUpdate = e),
                      (t.hemisphereLights.needsUpdate = e);
                  }
                  function Wt(t) {
                    return (
                      t.isMeshLambertMaterial ||
                      t.isMeshToonMaterial ||
                      t.isMeshPhongMaterial ||
                      t.isMeshStandardMaterial ||
                      t.isShadowMaterial ||
                      (t.isShaderMaterial && !0 === t.lights)
                    );
                  }
                  Nt.setAnimationLoop(Pt),
                    "undefined" !== typeof self && Nt.setContext(self),
                    (this.setAnimationLoop = function (t) {
                      (Rt = t),
                        _t.setAnimationLoop(t),
                        null === t ? Nt.stop() : Nt.start();
                    }),
                    _t.addEventListener("sessionstart", It),
                    _t.addEventListener("sessionend", kt),
                    (this.render = function (t, e) {
                      if (void 0 !== e && !0 !== e.isCamera)
                        return void console.error(
                          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                        );
                      if (!0 === x) return;
                      !0 === t.autoUpdate && t.updateMatrixWorld(),
                        null === e.parent && e.updateMatrixWorld(),
                        !0 === _t.enabled &&
                          !0 === _t.isPresenting &&
                          (!0 === _t.cameraAutoUpdate && _t.updateCamera(e),
                          (e = _t.getCamera())),
                        !0 === t.isScene && t.onBeforeRender(b, t, e, S),
                        (f = st.get(t, m.length)),
                        f.init(),
                        m.push(f),
                        j.multiplyMatrices(
                          e.projectionMatrix,
                          e.matrixWorldInverse
                        ),
                        z.setFromProjectionMatrix(j),
                        (U = this.localClippingEnabled),
                        (F = ct.init(this.clippingPlanes, U, e)),
                        (d = ot.get(t, p.length)),
                        d.init(),
                        p.push(d),
                        Dt(t, e, 0, b.sortObjects),
                        d.finish(),
                        !0 === b.sortObjects && d.sort(I, O),
                        !0 === F && ct.beginShadows();
                      const n = f.state.shadowsArray;
                      if (
                        (lt.render(n, t, e),
                        !0 === F && ct.endShadows(),
                        !0 === this.info.autoReset && this.info.reset(),
                        ut.render(d, t),
                        f.setupLights(b.physicallyCorrectLights),
                        e.isArrayCamera)
                      ) {
                        const n = e.cameras;
                        for (let e = 0, r = n.length; e < r; e++) {
                          const r = n[e];
                          zt(d, t, r, r.viewport);
                        }
                      } else zt(d, t, e);
                      null !== S &&
                        (K.updateMultisampleRenderTarget(S),
                        K.updateRenderTargetMipmap(S)),
                        !0 === t.isScene && t.onAfterRender(b, t, e),
                        mt.resetDefaultState(),
                        (M = -1),
                        (T = null),
                        m.pop(),
                        (f = m.length > 0 ? m[m.length - 1] : null),
                        p.pop(),
                        (d = p.length > 0 ? p[p.length - 1] : null);
                    }),
                    (this.getActiveCubeFace = function () {
                      return _;
                    }),
                    (this.getActiveMipmapLevel = function () {
                      return w;
                    }),
                    (this.getRenderTarget = function () {
                      return S;
                    }),
                    (this.setRenderTargetTextures = function (t, e, n) {
                      (J.get(t.texture).__webglTexture = e),
                        (J.get(t.depthTexture).__webglTexture = n);
                      const r = J.get(t);
                      (r.__hasExternalTextures = !0),
                        r.__hasExternalTextures &&
                          ((r.__autoAllocateDepthBuffer = void 0 === n),
                          r.__autoAllocateDepthBuffer ||
                            (!0 ===
                              q.has("WEBGL_multisampled_render_to_texture") &&
                              (console.warn(
                                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                              ),
                              (r.__useRenderToTexture = !1))));
                    }),
                    (this.setRenderTargetFramebuffer = function (t, e) {
                      const n = J.get(t);
                      (n.__webglFramebuffer = e),
                        (n.__useDefaultFramebuffer = void 0 === e);
                    }),
                    (this.setRenderTarget = function (t, e = 0, n = 0) {
                      (S = t), (_ = e), (w = n);
                      let r = !0;
                      if (t) {
                        const e = J.get(t);
                        void 0 !== e.__useDefaultFramebuffer
                          ? ($.bindFramebuffer(36160, null), (r = !1))
                          : void 0 === e.__webglFramebuffer
                          ? K.setupRenderTarget(t)
                          : e.__hasExternalTextures &&
                            K.rebindTextures(
                              t,
                              J.get(t.texture).__webglTexture,
                              J.get(t.depthTexture).__webglTexture
                            );
                      }
                      let i = null,
                        a = !1,
                        o = !1;
                      if (t) {
                        const n = t.texture;
                        (n.isData3DTexture || n.isDataArrayTexture) && (o = !0);
                        const r = J.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget
                          ? ((i = r[e]), (a = !0))
                          : (i =
                              X.isWebGL2 &&
                              t.samples > 0 &&
                              !1 === K.useMultisampledRTT(t)
                                ? J.get(t).__webglMultisampledFramebuffer
                                : r),
                          E.copy(t.viewport),
                          A.copy(t.scissor),
                          (C = t.scissorTest);
                      } else
                        E.copy(k).multiplyScalar(P).floor(),
                          A.copy(N).multiplyScalar(P).floor(),
                          (C = D);
                      const s = $.bindFramebuffer(36160, i);
                      if (
                        (s && X.drawBuffers && r && $.drawBuffers(t, i),
                        $.viewport(E),
                        $.scissor(A),
                        $.setScissorTest(C),
                        a)
                      ) {
                        const r = J.get(t.texture);
                        gt.framebufferTexture2D(
                          36160,
                          36064,
                          34069 + e,
                          r.__webglTexture,
                          n
                        );
                      } else if (o) {
                        const r = J.get(t.texture),
                          i = e || 0;
                        gt.framebufferTextureLayer(
                          36160,
                          36064,
                          r.__webglTexture,
                          n || 0,
                          i
                        );
                      }
                      M = -1;
                    }),
                    (this.readRenderTargetPixels = function (
                      t,
                      e,
                      n,
                      r,
                      i,
                      a,
                      o
                    ) {
                      if (!t || !t.isWebGLRenderTarget)
                        return void console.error(
                          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                        );
                      let s = J.get(t).__webglFramebuffer;
                      if (
                        (t.isWebGLCubeRenderTarget &&
                          void 0 !== o &&
                          (s = s[o]),
                        s)
                      ) {
                        $.bindFramebuffer(36160, s);
                        try {
                          const o = t.texture,
                            s = o.format,
                            c = o.type;
                          if (
                            s !== Ot &&
                            pt.convert(s) !== gt.getParameter(35739)
                          )
                            return void console.error(
                              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                            );
                          const l =
                            c === At &&
                            (q.has("EXT_color_buffer_half_float") ||
                              (X.isWebGL2 && q.has("EXT_color_buffer_float")));
                          if (
                            c !== xt &&
                            pt.convert(c) !== gt.getParameter(35738) &&
                            (c !== Et ||
                              !(
                                X.isWebGL2 ||
                                q.has("OES_texture_float") ||
                                q.has("WEBGL_color_buffer_float")
                              )) &&
                            !l
                          )
                            return void console.error(
                              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                            );
                          e >= 0 &&
                            e <= t.width - r &&
                            n >= 0 &&
                            n <= t.height - i &&
                            gt.readPixels(
                              e,
                              n,
                              r,
                              i,
                              pt.convert(s),
                              pt.convert(c),
                              a
                            );
                        } finally {
                          const t =
                            null !== S ? J.get(S).__webglFramebuffer : null;
                          $.bindFramebuffer(36160, t);
                        }
                      }
                    }),
                    (this.copyFramebufferToTexture = function (t, e, n = 0) {
                      const r = Math.pow(2, -n),
                        i = Math.floor(e.image.width * r),
                        a = Math.floor(e.image.height * r);
                      K.setTexture2D(e, 0),
                        gt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, i, a),
                        $.unbindTexture();
                    }),
                    (this.copyTextureToTexture = function (t, e, n, r = 0) {
                      const i = e.image.width,
                        a = e.image.height,
                        o = pt.convert(n.format),
                        s = pt.convert(n.type);
                      K.setTexture2D(n, 0),
                        gt.pixelStorei(37440, n.flipY),
                        gt.pixelStorei(37441, n.premultiplyAlpha),
                        gt.pixelStorei(3317, n.unpackAlignment),
                        e.isDataTexture
                          ? gt.texSubImage2D(
                              3553,
                              r,
                              t.x,
                              t.y,
                              i,
                              a,
                              o,
                              s,
                              e.image.data
                            )
                          : e.isCompressedTexture
                          ? gt.compressedTexSubImage2D(
                              3553,
                              r,
                              t.x,
                              t.y,
                              e.mipmaps[0].width,
                              e.mipmaps[0].height,
                              o,
                              e.mipmaps[0].data
                            )
                          : gt.texSubImage2D(3553, r, t.x, t.y, o, s, e.image),
                        0 === r && n.generateMipmaps && gt.generateMipmap(3553),
                        $.unbindTexture();
                    }),
                    (this.copyTextureToTexture3D = function (
                      t,
                      e,
                      n,
                      r,
                      i = 0
                    ) {
                      if (b.isWebGL1Renderer)
                        return void console.warn(
                          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                        );
                      const a = t.max.x - t.min.x + 1,
                        o = t.max.y - t.min.y + 1,
                        s = t.max.z - t.min.z + 1,
                        c = pt.convert(r.format),
                        l = pt.convert(r.type);
                      let u;
                      if (r.isData3DTexture) K.setTexture3D(r, 0), (u = 32879);
                      else {
                        if (!r.isDataArrayTexture)
                          return void console.warn(
                            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                          );
                        K.setTexture2DArray(r, 0), (u = 35866);
                      }
                      gt.pixelStorei(37440, r.flipY),
                        gt.pixelStorei(37441, r.premultiplyAlpha),
                        gt.pixelStorei(3317, r.unpackAlignment);
                      const h = gt.getParameter(3314),
                        d = gt.getParameter(32878),
                        f = gt.getParameter(3316),
                        p = gt.getParameter(3315),
                        m = gt.getParameter(32877),
                        g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                      gt.pixelStorei(3314, g.width),
                        gt.pixelStorei(32878, g.height),
                        gt.pixelStorei(3316, t.min.x),
                        gt.pixelStorei(3315, t.min.y),
                        gt.pixelStorei(32877, t.min.z),
                        n.isDataTexture || n.isData3DTexture
                          ? gt.texSubImage3D(
                              u,
                              i,
                              e.x,
                              e.y,
                              e.z,
                              a,
                              o,
                              s,
                              c,
                              l,
                              g.data
                            )
                          : n.isCompressedTexture
                          ? (console.warn(
                              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                            ),
                            gt.compressedTexSubImage3D(
                              u,
                              i,
                              e.x,
                              e.y,
                              e.z,
                              a,
                              o,
                              s,
                              c,
                              g.data
                            ))
                          : gt.texSubImage3D(
                              u,
                              i,
                              e.x,
                              e.y,
                              e.z,
                              a,
                              o,
                              s,
                              c,
                              l,
                              g
                            ),
                        gt.pixelStorei(3314, h),
                        gt.pixelStorei(32878, d),
                        gt.pixelStorei(3316, f),
                        gt.pixelStorei(3315, p),
                        gt.pixelStorei(32877, m),
                        0 === i && r.generateMipmaps && gt.generateMipmap(u),
                        $.unbindTexture();
                    }),
                    (this.initTexture = function (t) {
                      t.isCubeTexture
                        ? K.setTextureCube(t, 0)
                        : t.isData3DTexture
                        ? K.setTexture3D(t, 0)
                        : t.isDataArrayTexture
                        ? K.setTexture2DArray(t, 0)
                        : K.setTexture2D(t, 0),
                        $.unbindTexture();
                    }),
                    (this.resetState = function () {
                      (_ = 0), (w = 0), (S = null), $.reset(), mt.reset();
                    }),
                    "undefined" !== typeof __THREE_DEVTOOLS__ &&
                      __THREE_DEVTOOLS__.dispatchEvent(
                        new CustomEvent("observe", { detail: this })
                      );
                }
                class zu extends Du {}
                zu.prototype.isWebGL1Renderer = !0;
                class Fu {
                  constructor(t, e = 25e-5) {
                    (this.isFogExp2 = !0),
                      (this.name = ""),
                      (this.color = new In(t)),
                      (this.density = e);
                  }
                  clone() {
                    return new Fu(this.color, this.density);
                  }
                  toJSON() {
                    return {
                      type: "FogExp2",
                      color: this.color.getHex(),
                      density: this.density,
                    };
                  }
                }
                class Uu {
                  constructor(t, e = 1, n = 1e3) {
                    (this.isFog = !0),
                      (this.name = ""),
                      (this.color = new In(t)),
                      (this.near = e),
                      (this.far = n);
                  }
                  clone() {
                    return new Uu(this.color, this.near, this.far);
                  }
                  toJSON() {
                    return {
                      type: "Fog",
                      color: this.color.getHex(),
                      near: this.near,
                      far: this.far,
                    };
                  }
                }
                class Bu extends qr {
                  constructor() {
                    super(),
                      (this.isScene = !0),
                      (this.type = "Scene"),
                      (this.background = null),
                      (this.environment = null),
                      (this.fog = null),
                      (this.overrideMaterial = null),
                      (this.autoUpdate = !0),
                      "undefined" !== typeof __THREE_DEVTOOLS__ &&
                        __THREE_DEVTOOLS__.dispatchEvent(
                          new CustomEvent("observe", { detail: this })
                        );
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      null !== t.background &&
                        (this.background = t.background.clone()),
                      null !== t.environment &&
                        (this.environment = t.environment.clone()),
                      null !== t.fog && (this.fog = t.fog.clone()),
                      null !== t.overrideMaterial &&
                        (this.overrideMaterial = t.overrideMaterial.clone()),
                      (this.autoUpdate = t.autoUpdate),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                      null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                    );
                  }
                }
                class ju {
                  constructor(t, e) {
                    (this.isInterleavedBuffer = !0),
                      (this.array = t),
                      (this.stride = e),
                      (this.count = void 0 !== t ? t.length / e : 0),
                      (this.usage = Fe),
                      (this.updateRange = { offset: 0, count: -1 }),
                      (this.version = 0),
                      (this.uuid = qe());
                  }
                  onUploadCallback() {}
                  set needsUpdate(t) {
                    !0 === t && this.version++;
                  }
                  setUsage(t) {
                    return (this.usage = t), this;
                  }
                  copy(t) {
                    return (
                      (this.array = new t.array.constructor(t.array)),
                      (this.count = t.count),
                      (this.stride = t.stride),
                      (this.usage = t.usage),
                      this
                    );
                  }
                  copyAt(t, e, n) {
                    (t *= this.stride), (n *= e.stride);
                    for (let r = 0, i = this.stride; r < i; r++)
                      this.array[t + r] = e.array[n + r];
                    return this;
                  }
                  set(t, e = 0) {
                    return this.array.set(t, e), this;
                  }
                  clone(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                      void 0 === this.array.buffer._uuid &&
                        (this.array.buffer._uuid = qe()),
                      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                        (t.arrayBuffers[this.array.buffer._uuid] =
                          this.array.slice(0).buffer);
                    const e = new this.array.constructor(
                        t.arrayBuffers[this.array.buffer._uuid]
                      ),
                      n = new this.constructor(e, this.stride);
                    return n.setUsage(this.usage), n;
                  }
                  onUpload(t) {
                    return (this.onUploadCallback = t), this;
                  }
                  toJSON(t) {
                    return (
                      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                      void 0 === this.array.buffer._uuid &&
                        (this.array.buffer._uuid = qe()),
                      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                        (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
                          new Uint32Array(this.array.buffer)
                        )),
                      {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride,
                      }
                    );
                  }
                }
                const Hu = new Gn();
                class Vu {
                  constructor(t, e, n, r = !1) {
                    (this.isInterleavedBufferAttribute = !0),
                      (this.name = ""),
                      (this.data = t),
                      (this.itemSize = e),
                      (this.offset = n),
                      (this.normalized = !0 === r);
                  }
                  get count() {
                    return this.data.count;
                  }
                  get array() {
                    return this.data.array;
                  }
                  set needsUpdate(t) {
                    this.data.needsUpdate = t;
                  }
                  applyMatrix4(t) {
                    for (let e = 0, n = this.data.count; e < n; e++)
                      Hu.fromBufferAttribute(this, e),
                        Hu.applyMatrix4(t),
                        this.setXYZ(e, Hu.x, Hu.y, Hu.z);
                    return this;
                  }
                  applyNormalMatrix(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                      Hu.fromBufferAttribute(this, e),
                        Hu.applyNormalMatrix(t),
                        this.setXYZ(e, Hu.x, Hu.y, Hu.z);
                    return this;
                  }
                  transformDirection(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                      Hu.fromBufferAttribute(this, e),
                        Hu.transformDirection(t),
                        this.setXYZ(e, Hu.x, Hu.y, Hu.z);
                    return this;
                  }
                  setX(t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset] = e),
                      this
                    );
                  }
                  setY(t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 1] =
                        e),
                      this
                    );
                  }
                  setZ(t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 2] =
                        e),
                      this
                    );
                  }
                  setW(t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 3] =
                        e),
                      this
                    );
                  }
                  getX(t) {
                    return this.data.array[t * this.data.stride + this.offset];
                  }
                  getY(t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 1
                    ];
                  }
                  getZ(t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 2
                    ];
                  }
                  getW(t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 3
                    ];
                  }
                  setXY(t, e, n) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      this
                    );
                  }
                  setXYZ(t, e, n, r) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      (this.data.array[t + 2] = r),
                      this
                    );
                  }
                  setXYZW(t, e, n, r, i) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      (this.data.array[t + 2] = r),
                      (this.data.array[t + 3] = i),
                      this
                    );
                  }
                  clone(t) {
                    if (void 0 === t) {
                      console.log(
                        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data."
                      );
                      const t = [];
                      for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                          t.push(this.data.array[n + e]);
                      }
                      return new li(
                        new this.array.constructor(t),
                        this.itemSize,
                        this.normalized
                      );
                    }
                    return (
                      void 0 === t.interleavedBuffers &&
                        (t.interleavedBuffers = {}),
                      void 0 === t.interleavedBuffers[this.data.uuid] &&
                        (t.interleavedBuffers[this.data.uuid] =
                          this.data.clone(t)),
                      new Vu(
                        t.interleavedBuffers[this.data.uuid],
                        this.itemSize,
                        this.offset,
                        this.normalized
                      )
                    );
                  }
                  toJSON(t) {
                    if (void 0 === t) {
                      console.log(
                        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data."
                      );
                      const t = [];
                      for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                          t.push(this.data.array[n + e]);
                      }
                      return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized,
                      };
                    }
                    return (
                      void 0 === t.interleavedBuffers &&
                        (t.interleavedBuffers = {}),
                      void 0 === t.interleavedBuffers[this.data.uuid] &&
                        (t.interleavedBuffers[this.data.uuid] =
                          this.data.toJSON(t)),
                      {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized,
                      }
                    );
                  }
                }
                class Gu extends ai {
                  constructor(t) {
                    super(),
                      (this.isSpriteMaterial = !0),
                      (this.type = "SpriteMaterial"),
                      (this.color = new In(16777215)),
                      (this.map = null),
                      (this.alphaMap = null),
                      (this.rotation = 0),
                      (this.sizeAttenuation = !0),
                      (this.transparent = !0),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.map = t.map),
                      (this.alphaMap = t.alphaMap),
                      (this.rotation = t.rotation),
                      (this.sizeAttenuation = t.sizeAttenuation),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                let Wu;
                const qu = new Gn(),
                  Xu = new Gn(),
                  $u = new Gn(),
                  Yu = new gn(),
                  Ju = new gn(),
                  Ku = new _r(),
                  Zu = new Gn(),
                  Qu = new Gn(),
                  th = new Gn(),
                  eh = new gn(),
                  nh = new gn(),
                  rh = new gn();
                class ih extends qr {
                  constructor(t) {
                    if (
                      (super(),
                      (this.isSprite = !0),
                      (this.type = "Sprite"),
                      void 0 === Wu)
                    ) {
                      Wu = new xi();
                      const t = new Float32Array([
                          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0,
                          1, 1, -0.5, 0.5, 0, 0, 1,
                        ]),
                        e = new ju(t, 5);
                      Wu.setIndex([0, 1, 2, 0, 2, 3]),
                        Wu.setAttribute("position", new Vu(e, 3, 0, !1)),
                        Wu.setAttribute("uv", new Vu(e, 2, 3, !1));
                    }
                    (this.geometry = Wu),
                      (this.material = void 0 !== t ? t : new Gu()),
                      (this.center = new gn(0.5, 0.5));
                  }
                  raycast(t, e) {
                    null === t.camera &&
                      console.error(
                        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
                      ),
                      Xu.setFromMatrixScale(this.matrixWorld),
                      Ku.copy(t.camera.matrixWorld),
                      this.modelViewMatrix.multiplyMatrices(
                        t.camera.matrixWorldInverse,
                        this.matrixWorld
                      ),
                      $u.setFromMatrixPosition(this.modelViewMatrix),
                      t.camera.isPerspectiveCamera &&
                        !1 === this.material.sizeAttenuation &&
                        Xu.multiplyScalar(-$u.z);
                    const n = this.material.rotation;
                    let r, i;
                    0 !== n && ((i = Math.cos(n)), (r = Math.sin(n)));
                    const a = this.center;
                    ah(Zu.set(-0.5, -0.5, 0), $u, a, Xu, r, i),
                      ah(Qu.set(0.5, -0.5, 0), $u, a, Xu, r, i),
                      ah(th.set(0.5, 0.5, 0), $u, a, Xu, r, i),
                      eh.set(0, 0),
                      nh.set(1, 0),
                      rh.set(1, 1);
                    let o = t.ray.intersectTriangle(Zu, Qu, th, !1, qu);
                    if (
                      null === o &&
                      (ah(Qu.set(-0.5, 0.5, 0), $u, a, Xu, r, i),
                      nh.set(0, 1),
                      (o = t.ray.intersectTriangle(Zu, th, Qu, !1, qu)),
                      null === o)
                    )
                      return;
                    const s = t.ray.origin.distanceTo(qu);
                    s < t.near ||
                      s > t.far ||
                      e.push({
                        distance: s,
                        point: qu.clone(),
                        uv: ri.getUV(qu, Zu, Qu, th, eh, nh, rh, new gn()),
                        face: null,
                        object: this,
                      });
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      void 0 !== t.center && this.center.copy(t.center),
                      (this.material = t.material),
                      this
                    );
                  }
                }
                function ah(t, e, n, r, i, a) {
                  Yu.subVectors(t, n).addScalar(0.5).multiply(r),
                    void 0 !== i
                      ? ((Ju.x = a * Yu.x - i * Yu.y),
                        (Ju.y = i * Yu.x + a * Yu.y))
                      : Ju.copy(Yu),
                    t.copy(e),
                    (t.x += Ju.x),
                    (t.y += Ju.y),
                    t.applyMatrix4(Ku);
                }
                const oh = new Gn(),
                  sh = new Gn();
                class ch extends qr {
                  constructor() {
                    super(),
                      (this._currentLevel = 0),
                      (this.type = "LOD"),
                      Object.defineProperties(this, {
                        levels: { enumerable: !0, value: [] },
                        isLOD: { value: !0 },
                      }),
                      (this.autoUpdate = !0);
                  }
                  copy(t) {
                    super.copy(t, !1);
                    const e = t.levels;
                    for (let n = 0, r = e.length; n < r; n++) {
                      const t = e[n];
                      this.addLevel(t.object.clone(), t.distance);
                    }
                    return (this.autoUpdate = t.autoUpdate), this;
                  }
                  addLevel(t, e = 0) {
                    e = Math.abs(e);
                    const n = this.levels;
                    let r;
                    for (r = 0; r < n.length; r++) if (e < n[r].distance) break;
                    return (
                      n.splice(r, 0, { distance: e, object: t }),
                      this.add(t),
                      this
                    );
                  }
                  getCurrentLevel() {
                    return this._currentLevel;
                  }
                  getObjectForDistance(t) {
                    const e = this.levels;
                    if (e.length > 0) {
                      let n, r;
                      for (n = 1, r = e.length; n < r; n++)
                        if (t < e[n].distance) break;
                      return e[n - 1].object;
                    }
                    return null;
                  }
                  raycast(t, e) {
                    const n = this.levels;
                    if (n.length > 0) {
                      oh.setFromMatrixPosition(this.matrixWorld);
                      const n = t.ray.origin.distanceTo(oh);
                      this.getObjectForDistance(n).raycast(t, e);
                    }
                  }
                  update(t) {
                    const e = this.levels;
                    if (e.length > 1) {
                      oh.setFromMatrixPosition(t.matrixWorld),
                        sh.setFromMatrixPosition(this.matrixWorld);
                      const n = oh.distanceTo(sh) / t.zoom;
                      let r, i;
                      for (
                        e[0].object.visible = !0, r = 1, i = e.length;
                        r < i;
                        r++
                      ) {
                        if (!(n >= e[r].distance)) break;
                        (e[r - 1].object.visible = !1),
                          (e[r].object.visible = !0);
                      }
                      for (this._currentLevel = r - 1; r < i; r++)
                        e[r].object.visible = !1;
                    }
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    !1 === this.autoUpdate && (e.object.autoUpdate = !1),
                      (e.object.levels = []);
                    const n = this.levels;
                    for (let r = 0, i = n.length; r < i; r++) {
                      const t = n[r];
                      e.object.levels.push({
                        object: t.object.uuid,
                        distance: t.distance,
                      });
                    }
                    return e;
                  }
                }
                const lh = new Gn(),
                  uh = new Un(),
                  hh = new Un(),
                  dh = new Gn(),
                  fh = new _r();
                class ph extends Fi {
                  constructor(t, e) {
                    super(t, e),
                      (this.isSkinnedMesh = !0),
                      (this.type = "SkinnedMesh"),
                      (this.bindMode = "attached"),
                      (this.bindMatrix = new _r()),
                      (this.bindMatrixInverse = new _r());
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.bindMode = t.bindMode),
                      this.bindMatrix.copy(t.bindMatrix),
                      this.bindMatrixInverse.copy(t.bindMatrixInverse),
                      (this.skeleton = t.skeleton),
                      this
                    );
                  }
                  bind(t, e) {
                    (this.skeleton = t),
                      void 0 === e &&
                        (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        (e = this.matrixWorld)),
                      this.bindMatrix.copy(e),
                      this.bindMatrixInverse.copy(e).invert();
                  }
                  pose() {
                    this.skeleton.pose();
                  }
                  normalizeSkinWeights() {
                    const t = new Un(),
                      e = this.geometry.attributes.skinWeight;
                    for (let n = 0, r = e.count; n < r; n++) {
                      t.fromBufferAttribute(e, n);
                      const r = 1 / t.manhattanLength();
                      r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
                        e.setXYZW(n, t.x, t.y, t.z, t.w);
                    }
                  }
                  updateMatrixWorld(t) {
                    super.updateMatrixWorld(t),
                      "attached" === this.bindMode
                        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                        : "detached" === this.bindMode
                        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                        : console.warn(
                            "THREE.SkinnedMesh: Unrecognized bindMode: " +
                              this.bindMode
                          );
                  }
                  boneTransform(t, e) {
                    const n = this.skeleton,
                      r = this.geometry;
                    uh.fromBufferAttribute(r.attributes.skinIndex, t),
                      hh.fromBufferAttribute(r.attributes.skinWeight, t),
                      lh.copy(e).applyMatrix4(this.bindMatrix),
                      e.set(0, 0, 0);
                    for (let i = 0; i < 4; i++) {
                      const t = hh.getComponent(i);
                      if (0 !== t) {
                        const r = uh.getComponent(i);
                        fh.multiplyMatrices(
                          n.bones[r].matrixWorld,
                          n.boneInverses[r]
                        ),
                          e.addScaledVector(dh.copy(lh).applyMatrix4(fh), t);
                      }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse);
                  }
                }
                class mh extends qr {
                  constructor() {
                    super(), (this.isBone = !0), (this.type = "Bone");
                  }
                }
                class gh extends Fn {
                  constructor(
                    t = null,
                    e = 1,
                    n = 1,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c = pt,
                    l = pt,
                    u,
                    h
                  ) {
                    super(null, a, o, s, c, l, r, i, u, h),
                      (this.isDataTexture = !0),
                      (this.image = { data: t, width: e, height: n }),
                      (this.generateMipmaps = !1),
                      (this.flipY = !1),
                      (this.unpackAlignment = 1);
                  }
                }
                const vh = new _r(),
                  yh = new _r();
                class bh {
                  constructor(t = [], e = []) {
                    (this.uuid = qe()),
                      (this.bones = t.slice(0)),
                      (this.boneInverses = e),
                      (this.boneMatrices = null),
                      (this.boneTexture = null),
                      (this.boneTextureSize = 0),
                      (this.frame = -1),
                      this.init();
                  }
                  init() {
                    const t = this.bones,
                      e = this.boneInverses;
                    if (
                      ((this.boneMatrices = new Float32Array(16 * t.length)),
                      0 === e.length)
                    )
                      this.calculateInverses();
                    else if (t.length !== e.length) {
                      console.warn(
                        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
                      ),
                        (this.boneInverses = []);
                      for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new _r());
                    }
                  }
                  calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                      const e = new _r();
                      this.bones[t] &&
                        e.copy(this.bones[t].matrixWorld).invert(),
                        this.boneInverses.push(e);
                    }
                  }
                  pose() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                      const e = this.bones[t];
                      e && e.matrixWorld.copy(this.boneInverses[t]).invert();
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                      const e = this.bones[t];
                      e &&
                        (e.parent && e.parent.isBone
                          ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                            e.matrix.multiply(e.matrixWorld))
                          : e.matrix.copy(e.matrixWorld),
                        e.matrix.decompose(e.position, e.quaternion, e.scale));
                    }
                  }
                  update() {
                    const t = this.bones,
                      e = this.boneInverses,
                      n = this.boneMatrices,
                      r = this.boneTexture;
                    for (let i = 0, a = t.length; i < a; i++) {
                      const r = t[i] ? t[i].matrixWorld : yh;
                      vh.multiplyMatrices(r, e[i]), vh.toArray(n, 16 * i);
                    }
                    null !== r && (r.needsUpdate = !0);
                  }
                  clone() {
                    return new bh(this.bones, this.boneInverses);
                  }
                  computeBoneTexture() {
                    let t = Math.sqrt(4 * this.bones.length);
                    (t = un(t)), (t = Math.max(t, 4));
                    const e = new Float32Array(t * t * 4);
                    e.set(this.boneMatrices);
                    const n = new gh(e, t, t, Ot, Et);
                    return (
                      (n.needsUpdate = !0),
                      (this.boneMatrices = e),
                      (this.boneTexture = n),
                      (this.boneTextureSize = t),
                      this
                    );
                  }
                  getBoneByName(t) {
                    for (let e = 0, n = this.bones.length; e < n; e++) {
                      const n = this.bones[e];
                      if (n.name === t) return n;
                    }
                  }
                  dispose() {
                    null !== this.boneTexture &&
                      (this.boneTexture.dispose(), (this.boneTexture = null));
                  }
                  fromJSON(t, e) {
                    this.uuid = t.uuid;
                    for (let n = 0, r = t.bones.length; n < r; n++) {
                      const r = t.bones[n];
                      let i = e[r];
                      void 0 === i &&
                        (console.warn(
                          "THREE.Skeleton: No bone found with UUID:",
                          r
                        ),
                        (i = new mh())),
                        this.bones.push(i),
                        this.boneInverses.push(
                          new _r().fromArray(t.boneInverses[n])
                        );
                    }
                    return this.init(), this;
                  }
                  toJSON() {
                    const t = {
                      metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON",
                      },
                      bones: [],
                      boneInverses: [],
                    };
                    t.uuid = this.uuid;
                    const e = this.bones,
                      n = this.boneInverses;
                    for (let r = 0, i = e.length; r < i; r++) {
                      const i = e[r];
                      t.bones.push(i.uuid);
                      const a = n[r];
                      t.boneInverses.push(a.toArray());
                    }
                    return t;
                  }
                }
                class xh extends li {
                  constructor(t, e, n, r = 1) {
                    "number" === typeof n &&
                      ((r = n),
                      (n = !1),
                      console.error(
                        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
                      )),
                      super(t, e, n),
                      (this.isInstancedBufferAttribute = !0),
                      (this.meshPerAttribute = r);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.meshPerAttribute = t.meshPerAttribute),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.meshPerAttribute = this.meshPerAttribute),
                      (t.isInstancedBufferAttribute = !0),
                      t
                    );
                  }
                }
                const _h = new _r(),
                  wh = new _r(),
                  Sh = [],
                  Mh = new Fi();
                class Th extends Fi {
                  constructor(t, e, n) {
                    super(t, e),
                      (this.isInstancedMesh = !0),
                      (this.instanceMatrix = new xh(
                        new Float32Array(16 * n),
                        16
                      )),
                      (this.instanceColor = null),
                      (this.count = n),
                      (this.frustumCulled = !1);
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      this.instanceMatrix.copy(t.instanceMatrix),
                      null !== t.instanceColor &&
                        (this.instanceColor = t.instanceColor.clone()),
                      (this.count = t.count),
                      this
                    );
                  }
                  getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t);
                  }
                  getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t);
                  }
                  raycast(t, e) {
                    const n = this.matrixWorld,
                      r = this.count;
                    if (
                      ((Mh.geometry = this.geometry),
                      (Mh.material = this.material),
                      void 0 !== Mh.material)
                    )
                      for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, _h),
                          wh.multiplyMatrices(n, _h),
                          (Mh.matrixWorld = wh),
                          Mh.raycast(t, Sh);
                        for (let t = 0, n = Sh.length; t < n; t++) {
                          const n = Sh[t];
                          (n.instanceId = i), (n.object = this), e.push(n);
                        }
                        Sh.length = 0;
                      }
                  }
                  setColorAt(t, e) {
                    null === this.instanceColor &&
                      (this.instanceColor = new xh(
                        new Float32Array(3 * this.instanceMatrix.count),
                        3
                      )),
                      e.toArray(this.instanceColor.array, 3 * t);
                  }
                  setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t);
                  }
                  updateMorphTargets() {}
                  dispose() {
                    this.dispatchEvent({ type: "dispose" });
                  }
                }
                class Eh extends ai {
                  constructor(t) {
                    super(),
                      (this.isLineBasicMaterial = !0),
                      (this.type = "LineBasicMaterial"),
                      (this.color = new In(16777215)),
                      (this.linewidth = 1),
                      (this.linecap = "round"),
                      (this.linejoin = "round"),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.linewidth = t.linewidth),
                      (this.linecap = t.linecap),
                      (this.linejoin = t.linejoin),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                const Ah = new Gn(),
                  Ch = new Gn(),
                  Lh = new _r(),
                  Rh = new xr(),
                  Ph = new dr();
                class Ih extends qr {
                  constructor(t = new xi(), e = new Eh()) {
                    super(),
                      (this.isLine = !0),
                      (this.type = "Line"),
                      (this.geometry = t),
                      (this.material = e),
                      this.updateMorphTargets();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.material = t.material),
                      (this.geometry = t.geometry),
                      this
                    );
                  }
                  computeLineDistances() {
                    const t = this.geometry;
                    if (null === t.index) {
                      const e = t.attributes.position,
                        n = [0];
                      for (let t = 1, r = e.count; t < r; t++)
                        Ah.fromBufferAttribute(e, t - 1),
                          Ch.fromBufferAttribute(e, t),
                          (n[t] = n[t - 1]),
                          (n[t] += Ah.distanceTo(Ch));
                      t.setAttribute("lineDistance", new di(n, 1));
                    } else
                      console.warn(
                        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                      );
                    return this;
                  }
                  raycast(t, e) {
                    const n = this.geometry,
                      r = this.matrixWorld,
                      i = t.params.Line.threshold,
                      a = n.drawRange;
                    if (
                      (null === n.boundingSphere && n.computeBoundingSphere(),
                      Ph.copy(n.boundingSphere),
                      Ph.applyMatrix4(r),
                      (Ph.radius += i),
                      !1 === t.ray.intersectsSphere(Ph))
                    )
                      return;
                    Lh.copy(r).invert(), Rh.copy(t.ray).applyMatrix4(Lh);
                    const o =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      s = o * o,
                      c = new Gn(),
                      l = new Gn(),
                      u = new Gn(),
                      h = new Gn(),
                      d = this.isLineSegments ? 2 : 1,
                      f = n.index,
                      p = n.attributes,
                      m = p.position;
                    if (null !== f) {
                      const n = Math.max(0, a.start),
                        r = Math.min(f.count, a.start + a.count);
                      for (let i = n, a = r - 1; i < a; i += d) {
                        const n = f.getX(i),
                          r = f.getX(i + 1);
                        c.fromBufferAttribute(m, n),
                          l.fromBufferAttribute(m, r);
                        const a = Rh.distanceSqToSegment(c, l, h, u);
                        if (a > s) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const o = t.ray.origin.distanceTo(h);
                        o < t.near ||
                          o > t.far ||
                          e.push({
                            distance: o,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this,
                          });
                      }
                    } else {
                      const n = Math.max(0, a.start),
                        r = Math.min(m.count, a.start + a.count);
                      for (let i = n, a = r - 1; i < a; i += d) {
                        c.fromBufferAttribute(m, i),
                          l.fromBufferAttribute(m, i + 1);
                        const n = Rh.distanceSqToSegment(c, l, h, u);
                        if (n > s) continue;
                        h.applyMatrix4(this.matrixWorld);
                        const r = t.ray.origin.distanceTo(h);
                        r < t.near ||
                          r > t.far ||
                          e.push({
                            distance: r,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this,
                          });
                      }
                    }
                  }
                  updateMorphTargets() {
                    const t = this.geometry,
                      e = t.morphAttributes,
                      n = Object.keys(e);
                    if (n.length > 0) {
                      const t = e[n[0]];
                      if (void 0 !== t) {
                        (this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {});
                        for (let e = 0, n = t.length; e < n; e++) {
                          const n = t[e].name || String(e);
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[n] = e);
                        }
                      }
                    }
                  }
                }
                const Oh = new Gn(),
                  kh = new Gn();
                class Nh extends Ih {
                  constructor(t, e) {
                    super(t, e),
                      (this.isLineSegments = !0),
                      (this.type = "LineSegments");
                  }
                  computeLineDistances() {
                    const t = this.geometry;
                    if (null === t.index) {
                      const e = t.attributes.position,
                        n = [];
                      for (let t = 0, r = e.count; t < r; t += 2)
                        Oh.fromBufferAttribute(e, t),
                          kh.fromBufferAttribute(e, t + 1),
                          (n[t] = 0 === t ? 0 : n[t - 1]),
                          (n[t + 1] = n[t] + Oh.distanceTo(kh));
                      t.setAttribute("lineDistance", new di(n, 1));
                    } else
                      console.warn(
                        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                      );
                    return this;
                  }
                }
                class Dh extends Ih {
                  constructor(t, e) {
                    super(t, e),
                      (this.isLineLoop = !0),
                      (this.type = "LineLoop");
                  }
                }
                class zh extends ai {
                  constructor(t) {
                    super(),
                      (this.isPointsMaterial = !0),
                      (this.type = "PointsMaterial"),
                      (this.color = new In(16777215)),
                      (this.map = null),
                      (this.alphaMap = null),
                      (this.size = 1),
                      (this.sizeAttenuation = !0),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.map = t.map),
                      (this.alphaMap = t.alphaMap),
                      (this.size = t.size),
                      (this.sizeAttenuation = t.sizeAttenuation),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                const Fh = new _r(),
                  Uh = new xr(),
                  Bh = new dr(),
                  jh = new Gn();
                class Hh extends qr {
                  constructor(t = new xi(), e = new zh()) {
                    super(),
                      (this.isPoints = !0),
                      (this.type = "Points"),
                      (this.geometry = t),
                      (this.material = e),
                      this.updateMorphTargets();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.material = t.material),
                      (this.geometry = t.geometry),
                      this
                    );
                  }
                  raycast(t, e) {
                    const n = this.geometry,
                      r = this.matrixWorld,
                      i = t.params.Points.threshold,
                      a = n.drawRange;
                    if (
                      (null === n.boundingSphere && n.computeBoundingSphere(),
                      Bh.copy(n.boundingSphere),
                      Bh.applyMatrix4(r),
                      (Bh.radius += i),
                      !1 === t.ray.intersectsSphere(Bh))
                    )
                      return;
                    Fh.copy(r).invert(), Uh.copy(t.ray).applyMatrix4(Fh);
                    const o =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      s = o * o,
                      c = n.index,
                      l = n.attributes,
                      u = l.position;
                    if (null !== c) {
                      const n = Math.max(0, a.start),
                        i = Math.min(c.count, a.start + a.count);
                      for (let a = n, o = i; a < o; a++) {
                        const n = c.getX(a);
                        jh.fromBufferAttribute(u, n),
                          Vh(jh, n, s, r, t, e, this);
                      }
                    } else {
                      const n = Math.max(0, a.start),
                        i = Math.min(u.count, a.start + a.count);
                      for (let a = n, o = i; a < o; a++)
                        jh.fromBufferAttribute(u, a),
                          Vh(jh, a, s, r, t, e, this);
                    }
                  }
                  updateMorphTargets() {
                    const t = this.geometry,
                      e = t.morphAttributes,
                      n = Object.keys(e);
                    if (n.length > 0) {
                      const t = e[n[0]];
                      if (void 0 !== t) {
                        (this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {});
                        for (let e = 0, n = t.length; e < n; e++) {
                          const n = t[e].name || String(e);
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[n] = e);
                        }
                      }
                    }
                  }
                }
                function Vh(t, e, n, r, i, a, o) {
                  const s = Uh.distanceSqToPoint(t);
                  if (s < n) {
                    const n = new Gn();
                    Uh.closestPointToPoint(t, n), n.applyMatrix4(r);
                    const c = i.ray.origin.distanceTo(n);
                    if (c < i.near || c > i.far) return;
                    a.push({
                      distance: c,
                      distanceToRay: Math.sqrt(s),
                      point: n,
                      index: e,
                      face: null,
                      object: o,
                    });
                  }
                }
                class Gh extends Fn {
                  constructor(t, e, n, r, i, a, o, s, c, l, u, h) {
                    super(null, a, o, s, c, l, r, i, u, h),
                      (this.isCompressedTexture = !0),
                      (this.image = { width: e, height: n }),
                      (this.mipmaps = t),
                      (this.flipY = !1),
                      (this.generateMipmaps = !1);
                  }
                }
                class Wh {
                  constructor() {
                    (this.type = "Curve"), (this.arcLengthDivisions = 200);
                  }
                  getPoint() {
                    return (
                      console.warn("THREE.Curve: .getPoint() not implemented."),
                      null
                    );
                  }
                  getPointAt(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e);
                  }
                  getPoints(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e;
                  }
                  getSpacedPoints(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e;
                  }
                  getLength() {
                    const t = this.getLengths();
                    return t[t.length - 1];
                  }
                  getLengths(t = this.arcLengthDivisions) {
                    if (
                      this.cacheArcLengths &&
                      this.cacheArcLengths.length === t + 1 &&
                      !this.needsUpdate
                    )
                      return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n,
                      r = this.getPoint(0),
                      i = 0;
                    e.push(0);
                    for (let a = 1; a <= t; a++)
                      (n = this.getPoint(a / t)),
                        (i += n.distanceTo(r)),
                        e.push(i),
                        (r = n);
                    return (this.cacheArcLengths = e), e;
                  }
                  updateArcLengths() {
                    (this.needsUpdate = !0), this.getLengths();
                  }
                  getUtoTmapping(t, e) {
                    const n = this.getLengths();
                    let r = 0;
                    const i = n.length;
                    let a;
                    a = e || t * n[i - 1];
                    let o,
                      s = 0,
                      c = i - 1;
                    while (s <= c)
                      if (
                        ((r = Math.floor(s + (c - s) / 2)),
                        (o = n[r] - a),
                        o < 0)
                      )
                        s = r + 1;
                      else {
                        if (!(o > 0)) {
                          c = r;
                          break;
                        }
                        c = r - 1;
                      }
                    if (((r = c), n[r] === a)) return r / (i - 1);
                    const l = n[r],
                      u = n[r + 1],
                      h = u - l,
                      d = (a - l) / h,
                      f = (r + d) / (i - 1);
                    return f;
                  }
                  getTangent(t, e) {
                    const n = 1e-4;
                    let r = t - n,
                      i = t + n;
                    r < 0 && (r = 0), i > 1 && (i = 1);
                    const a = this.getPoint(r),
                      o = this.getPoint(i),
                      s = e || (a.isVector2 ? new gn() : new Gn());
                    return s.copy(o).sub(a).normalize(), s;
                  }
                  getTangentAt(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e);
                  }
                  computeFrenetFrames(t, e) {
                    const n = new Gn(),
                      r = [],
                      i = [],
                      a = [],
                      o = new Gn(),
                      s = new _r();
                    for (let d = 0; d <= t; d++) {
                      const e = d / t;
                      r[d] = this.getTangentAt(e, new Gn());
                    }
                    (i[0] = new Gn()), (a[0] = new Gn());
                    let c = Number.MAX_VALUE;
                    const l = Math.abs(r[0].x),
                      u = Math.abs(r[0].y),
                      h = Math.abs(r[0].z);
                    l <= c && ((c = l), n.set(1, 0, 0)),
                      u <= c && ((c = u), n.set(0, 1, 0)),
                      h <= c && n.set(0, 0, 1),
                      o.crossVectors(r[0], n).normalize(),
                      i[0].crossVectors(r[0], o),
                      a[0].crossVectors(r[0], i[0]);
                    for (let d = 1; d <= t; d++) {
                      if (
                        ((i[d] = i[d - 1].clone()),
                        (a[d] = a[d - 1].clone()),
                        o.crossVectors(r[d - 1], r[d]),
                        o.length() > Number.EPSILON)
                      ) {
                        o.normalize();
                        const t = Math.acos(Xe(r[d - 1].dot(r[d]), -1, 1));
                        i[d].applyMatrix4(s.makeRotationAxis(o, t));
                      }
                      a[d].crossVectors(r[d], i[d]);
                    }
                    if (!0 === e) {
                      let e = Math.acos(Xe(i[0].dot(i[t]), -1, 1));
                      (e /= t),
                        r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
                      for (let n = 1; n <= t; n++)
                        i[n].applyMatrix4(s.makeRotationAxis(r[n], e * n)),
                          a[n].crossVectors(r[n], i[n]);
                    }
                    return { tangents: r, normals: i, binormals: a };
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  copy(t) {
                    return (
                      (this.arcLengthDivisions = t.arcLengthDivisions), this
                    );
                  }
                  toJSON() {
                    const t = {
                      metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON",
                      },
                    };
                    return (
                      (t.arcLengthDivisions = this.arcLengthDivisions),
                      (t.type = this.type),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      (this.arcLengthDivisions = t.arcLengthDivisions), this
                    );
                  }
                }
                class qh extends Wh {
                  constructor(
                    t = 0,
                    e = 0,
                    n = 1,
                    r = 1,
                    i = 0,
                    a = 2 * Math.PI,
                    o = !1,
                    s = 0
                  ) {
                    super(),
                      (this.isEllipseCurve = !0),
                      (this.type = "EllipseCurve"),
                      (this.aX = t),
                      (this.aY = e),
                      (this.xRadius = n),
                      (this.yRadius = r),
                      (this.aStartAngle = i),
                      (this.aEndAngle = a),
                      (this.aClockwise = o),
                      (this.aRotation = s);
                  }
                  getPoint(t, e) {
                    const n = e || new gn(),
                      r = 2 * Math.PI;
                    let i = this.aEndAngle - this.aStartAngle;
                    const a = Math.abs(i) < Number.EPSILON;
                    while (i < 0) i += r;
                    while (i > r) i -= r;
                    i < Number.EPSILON && (i = a ? 0 : r),
                      !0 !== this.aClockwise ||
                        a ||
                        (i === r ? (i = -r) : (i -= r));
                    const o = this.aStartAngle + t * i;
                    let s = this.aX + this.xRadius * Math.cos(o),
                      c = this.aY + this.yRadius * Math.sin(o);
                    if (0 !== this.aRotation) {
                      const t = Math.cos(this.aRotation),
                        e = Math.sin(this.aRotation),
                        n = s - this.aX,
                        r = c - this.aY;
                      (s = n * t - r * e + this.aX),
                        (c = n * e + r * t + this.aY);
                    }
                    return n.set(s, c);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.aX = t.aX),
                      (this.aY = t.aY),
                      (this.xRadius = t.xRadius),
                      (this.yRadius = t.yRadius),
                      (this.aStartAngle = t.aStartAngle),
                      (this.aEndAngle = t.aEndAngle),
                      (this.aClockwise = t.aClockwise),
                      (this.aRotation = t.aRotation),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.aX = this.aX),
                      (t.aY = this.aY),
                      (t.xRadius = this.xRadius),
                      (t.yRadius = this.yRadius),
                      (t.aStartAngle = this.aStartAngle),
                      (t.aEndAngle = this.aEndAngle),
                      (t.aClockwise = this.aClockwise),
                      (t.aRotation = this.aRotation),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      (this.aX = t.aX),
                      (this.aY = t.aY),
                      (this.xRadius = t.xRadius),
                      (this.yRadius = t.yRadius),
                      (this.aStartAngle = t.aStartAngle),
                      (this.aEndAngle = t.aEndAngle),
                      (this.aClockwise = t.aClockwise),
                      (this.aRotation = t.aRotation),
                      this
                    );
                  }
                }
                class Xh extends qh {
                  constructor(t, e, n, r, i, a) {
                    super(t, e, n, n, r, i, a),
                      (this.isArcCurve = !0),
                      (this.type = "ArcCurve");
                  }
                }
                function $h() {
                  let t = 0,
                    e = 0,
                    n = 0,
                    r = 0;
                  function i(i, a, o, s) {
                    (t = i),
                      (e = o),
                      (n = -3 * i + 3 * a - 2 * o - s),
                      (r = 2 * i - 2 * a + o + s);
                  }
                  return {
                    initCatmullRom: function (t, e, n, r, a) {
                      i(e, n, a * (n - t), a * (r - e));
                    },
                    initNonuniformCatmullRom: function (t, e, n, r, a, o, s) {
                      let c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
                        l = (n - e) / o - (r - e) / (o + s) + (r - n) / s;
                      (c *= o), (l *= o), i(e, n, c, l);
                    },
                    calc: function (i) {
                      const a = i * i,
                        o = a * i;
                      return t + e * i + n * a + r * o;
                    },
                  };
                }
                const Yh = new Gn(),
                  Jh = new $h(),
                  Kh = new $h(),
                  Zh = new $h();
                class Qh extends Wh {
                  constructor(t = [], e = !1, n = "centripetal", r = 0.5) {
                    super(),
                      (this.isCatmullRomCurve3 = !0),
                      (this.type = "CatmullRomCurve3"),
                      (this.points = t),
                      (this.closed = e),
                      (this.curveType = n),
                      (this.tension = r);
                  }
                  getPoint(t, e = new Gn()) {
                    const n = e,
                      r = this.points,
                      i = r.length,
                      a = (i - (this.closed ? 0 : 1)) * t;
                    let o,
                      s,
                      c = Math.floor(a),
                      l = a - c;
                    this.closed
                      ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i)
                      : 0 === l && c === i - 1 && ((c = i - 2), (l = 1)),
                      this.closed || c > 0
                        ? (o = r[(c - 1) % i])
                        : (Yh.subVectors(r[0], r[1]).add(r[0]), (o = Yh));
                    const u = r[c % i],
                      h = r[(c + 1) % i];
                    if (
                      (this.closed || c + 2 < i
                        ? (s = r[(c + 2) % i])
                        : (Yh.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]),
                          (s = Yh)),
                      "centripetal" === this.curveType ||
                        "chordal" === this.curveType)
                    ) {
                      const t = "chordal" === this.curveType ? 0.5 : 0.25;
                      let e = Math.pow(o.distanceToSquared(u), t),
                        n = Math.pow(u.distanceToSquared(h), t),
                        r = Math.pow(h.distanceToSquared(s), t);
                      n < 1e-4 && (n = 1),
                        e < 1e-4 && (e = n),
                        r < 1e-4 && (r = n),
                        Jh.initNonuniformCatmullRom(
                          o.x,
                          u.x,
                          h.x,
                          s.x,
                          e,
                          n,
                          r
                        ),
                        Kh.initNonuniformCatmullRom(
                          o.y,
                          u.y,
                          h.y,
                          s.y,
                          e,
                          n,
                          r
                        ),
                        Zh.initNonuniformCatmullRom(
                          o.z,
                          u.z,
                          h.z,
                          s.z,
                          e,
                          n,
                          r
                        );
                    } else
                      "catmullrom" === this.curveType &&
                        (Jh.initCatmullRom(o.x, u.x, h.x, s.x, this.tension),
                        Kh.initCatmullRom(o.y, u.y, h.y, s.y, this.tension),
                        Zh.initCatmullRom(o.z, u.z, h.z, s.z, this.tension));
                    return n.set(Jh.calc(l), Kh.calc(l), Zh.calc(l)), n;
                  }
                  copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                      const n = t.points[e];
                      this.points.push(n.clone());
                    }
                    return (
                      (this.closed = t.closed),
                      (this.curveType = t.curveType),
                      (this.tension = t.tension),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                      const n = this.points[e];
                      t.points.push(n.toArray());
                    }
                    return (
                      (t.closed = this.closed),
                      (t.curveType = this.curveType),
                      (t.tension = this.tension),
                      t
                    );
                  }
                  fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                      const n = t.points[e];
                      this.points.push(new Gn().fromArray(n));
                    }
                    return (
                      (this.closed = t.closed),
                      (this.curveType = t.curveType),
                      (this.tension = t.tension),
                      this
                    );
                  }
                }
                function td(t, e, n, r, i) {
                  const a = 0.5 * (r - e),
                    o = 0.5 * (i - n),
                    s = t * t,
                    c = t * s;
                  return (
                    (2 * n - 2 * r + a + o) * c +
                    (-3 * n + 3 * r - 2 * a - o) * s +
                    a * t +
                    n
                  );
                }
                function ed(t, e) {
                  const n = 1 - t;
                  return n * n * e;
                }
                function nd(t, e) {
                  return 2 * (1 - t) * t * e;
                }
                function rd(t, e) {
                  return t * t * e;
                }
                function id(t, e, n, r) {
                  return ed(t, e) + nd(t, n) + rd(t, r);
                }
                function ad(t, e) {
                  const n = 1 - t;
                  return n * n * n * e;
                }
                function od(t, e) {
                  const n = 1 - t;
                  return 3 * n * n * t * e;
                }
                function sd(t, e) {
                  return 3 * (1 - t) * t * t * e;
                }
                function cd(t, e) {
                  return t * t * t * e;
                }
                function ld(t, e, n, r, i) {
                  return ad(t, e) + od(t, n) + sd(t, r) + cd(t, i);
                }
                class ud extends Wh {
                  constructor(
                    t = new gn(),
                    e = new gn(),
                    n = new gn(),
                    r = new gn()
                  ) {
                    super(),
                      (this.isCubicBezierCurve = !0),
                      (this.type = "CubicBezierCurve"),
                      (this.v0 = t),
                      (this.v1 = e),
                      (this.v2 = n),
                      (this.v3 = r);
                  }
                  getPoint(t, e = new gn()) {
                    const n = e,
                      r = this.v0,
                      i = this.v1,
                      a = this.v2,
                      o = this.v3;
                    return (
                      n.set(
                        ld(t, r.x, i.x, a.x, o.x),
                        ld(t, r.y, i.y, a.y, o.y)
                      ),
                      n
                    );
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v0.copy(t.v0),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this.v3.copy(t.v3),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v0 = this.v0.toArray()),
                      (t.v1 = this.v1.toArray()),
                      (t.v2 = this.v2.toArray()),
                      (t.v3 = this.v3.toArray()),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v0.fromArray(t.v0),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this.v3.fromArray(t.v3),
                      this
                    );
                  }
                }
                class hd extends Wh {
                  constructor(
                    t = new Gn(),
                    e = new Gn(),
                    n = new Gn(),
                    r = new Gn()
                  ) {
                    super(),
                      (this.isCubicBezierCurve3 = !0),
                      (this.type = "CubicBezierCurve3"),
                      (this.v0 = t),
                      (this.v1 = e),
                      (this.v2 = n),
                      (this.v3 = r);
                  }
                  getPoint(t, e = new Gn()) {
                    const n = e,
                      r = this.v0,
                      i = this.v1,
                      a = this.v2,
                      o = this.v3;
                    return (
                      n.set(
                        ld(t, r.x, i.x, a.x, o.x),
                        ld(t, r.y, i.y, a.y, o.y),
                        ld(t, r.z, i.z, a.z, o.z)
                      ),
                      n
                    );
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v0.copy(t.v0),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this.v3.copy(t.v3),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v0 = this.v0.toArray()),
                      (t.v1 = this.v1.toArray()),
                      (t.v2 = this.v2.toArray()),
                      (t.v3 = this.v3.toArray()),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v0.fromArray(t.v0),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this.v3.fromArray(t.v3),
                      this
                    );
                  }
                }
                class dd extends Wh {
                  constructor(t = new gn(), e = new gn()) {
                    super(),
                      (this.isLineCurve = !0),
                      (this.type = "LineCurve"),
                      (this.v1 = t),
                      (this.v2 = e);
                  }
                  getPoint(t, e = new gn()) {
                    const n = e;
                    return (
                      1 === t
                        ? n.copy(this.v2)
                        : (n.copy(this.v2).sub(this.v1),
                          n.multiplyScalar(t).add(this.v1)),
                      n
                    );
                  }
                  getPointAt(t, e) {
                    return this.getPoint(t, e);
                  }
                  getTangent(t, e) {
                    const n = e || new gn();
                    return n.copy(this.v2).sub(this.v1).normalize(), n;
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this
                    );
                  }
                }
                class fd extends Wh {
                  constructor(t = new Gn(), e = new Gn()) {
                    super(),
                      (this.isLineCurve3 = !0),
                      (this.type = "LineCurve3"),
                      (this.v1 = t),
                      (this.v2 = e);
                  }
                  getPoint(t, e = new Gn()) {
                    const n = e;
                    return (
                      1 === t
                        ? n.copy(this.v2)
                        : (n.copy(this.v2).sub(this.v1),
                          n.multiplyScalar(t).add(this.v1)),
                      n
                    );
                  }
                  getPointAt(t, e) {
                    return this.getPoint(t, e);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this
                    );
                  }
                }
                class pd extends Wh {
                  constructor(t = new gn(), e = new gn(), n = new gn()) {
                    super(),
                      (this.isQuadraticBezierCurve = !0),
                      (this.type = "QuadraticBezierCurve"),
                      (this.v0 = t),
                      (this.v1 = e),
                      (this.v2 = n);
                  }
                  getPoint(t, e = new gn()) {
                    const n = e,
                      r = this.v0,
                      i = this.v1,
                      a = this.v2;
                    return n.set(id(t, r.x, i.x, a.x), id(t, r.y, i.y, a.y)), n;
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v0.copy(t.v0),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v0 = this.v0.toArray()),
                      (t.v1 = this.v1.toArray()),
                      (t.v2 = this.v2.toArray()),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v0.fromArray(t.v0),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this
                    );
                  }
                }
                class md extends Wh {
                  constructor(t = new Gn(), e = new Gn(), n = new Gn()) {
                    super(),
                      (this.isQuadraticBezierCurve3 = !0),
                      (this.type = "QuadraticBezierCurve3"),
                      (this.v0 = t),
                      (this.v1 = e),
                      (this.v2 = n);
                  }
                  getPoint(t, e = new Gn()) {
                    const n = e,
                      r = this.v0,
                      i = this.v1,
                      a = this.v2;
                    return (
                      n.set(
                        id(t, r.x, i.x, a.x),
                        id(t, r.y, i.y, a.y),
                        id(t, r.z, i.z, a.z)
                      ),
                      n
                    );
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.v0.copy(t.v0),
                      this.v1.copy(t.v1),
                      this.v2.copy(t.v2),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (
                      (t.v0 = this.v0.toArray()),
                      (t.v1 = this.v1.toArray()),
                      (t.v2 = this.v2.toArray()),
                      t
                    );
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.v0.fromArray(t.v0),
                      this.v1.fromArray(t.v1),
                      this.v2.fromArray(t.v2),
                      this
                    );
                  }
                }
                class gd extends Wh {
                  constructor(t = []) {
                    super(),
                      (this.isSplineCurve = !0),
                      (this.type = "SplineCurve"),
                      (this.points = t);
                  }
                  getPoint(t, e = new gn()) {
                    const n = e,
                      r = this.points,
                      i = (r.length - 1) * t,
                      a = Math.floor(i),
                      o = i - a,
                      s = r[0 === a ? a : a - 1],
                      c = r[a],
                      l = r[a > r.length - 2 ? r.length - 1 : a + 1],
                      u = r[a > r.length - 3 ? r.length - 1 : a + 2];
                    return (
                      n.set(
                        td(o, s.x, c.x, l.x, u.x),
                        td(o, s.y, c.y, l.y, u.y)
                      ),
                      n
                    );
                  }
                  copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                      const n = t.points[e];
                      this.points.push(n.clone());
                    }
                    return this;
                  }
                  toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                      const n = this.points[e];
                      t.points.push(n.toArray());
                    }
                    return t;
                  }
                  fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, n = t.points.length; e < n; e++) {
                      const n = t.points[e];
                      this.points.push(new gn().fromArray(n));
                    }
                    return this;
                  }
                }
                var vd = Object.freeze({
                  __proto__: null,
                  ArcCurve: Xh,
                  CatmullRomCurve3: Qh,
                  CubicBezierCurve: ud,
                  CubicBezierCurve3: hd,
                  EllipseCurve: qh,
                  LineCurve: dd,
                  LineCurve3: fd,
                  QuadraticBezierCurve: pd,
                  QuadraticBezierCurve3: md,
                  SplineCurve: gd,
                });
                class yd extends Wh {
                  constructor() {
                    super(),
                      (this.type = "CurvePath"),
                      (this.curves = []),
                      (this.autoClose = !1);
                  }
                  add(t) {
                    this.curves.push(t);
                  }
                  closePath() {
                    const t = this.curves[0].getPoint(0),
                      e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new dd(e, t));
                  }
                  getPoint(t, e) {
                    const n = t * this.getLength(),
                      r = this.getCurveLengths();
                    let i = 0;
                    while (i < r.length) {
                      if (r[i] >= n) {
                        const t = r[i] - n,
                          a = this.curves[i],
                          o = a.getLength(),
                          s = 0 === o ? 0 : 1 - t / o;
                        return a.getPointAt(s, e);
                      }
                      i++;
                    }
                    return null;
                  }
                  getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1];
                  }
                  updateArcLengths() {
                    (this.needsUpdate = !0),
                      (this.cacheLengths = null),
                      this.getCurveLengths();
                  }
                  getCurveLengths() {
                    if (
                      this.cacheLengths &&
                      this.cacheLengths.length === this.curves.length
                    )
                      return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let n = 0, r = this.curves.length; n < r; n++)
                      (e += this.curves[n].getLength()), t.push(e);
                    return (this.cacheLengths = t), t;
                  }
                  getSpacedPoints(t = 40) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e;
                  }
                  getPoints(t = 12) {
                    const e = [];
                    let n;
                    for (let r = 0, i = this.curves; r < i.length; r++) {
                      const a = i[r],
                        o = a.isEllipseCurve
                          ? 2 * t
                          : a.isLineCurve || a.isLineCurve3
                          ? 1
                          : a.isSplineCurve
                          ? t * a.points.length
                          : t,
                        s = a.getPoints(o);
                      for (let t = 0; t < s.length; t++) {
                        const r = s[t];
                        (n && n.equals(r)) || (e.push(r), (n = r));
                      }
                    }
                    return (
                      this.autoClose &&
                        e.length > 1 &&
                        !e[e.length - 1].equals(e[0]) &&
                        e.push(e[0]),
                      e
                    );
                  }
                  copy(t) {
                    super.copy(t), (this.curves = []);
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                      const n = t.curves[e];
                      this.curves.push(n.clone());
                    }
                    return (this.autoClose = t.autoClose), this;
                  }
                  toJSON() {
                    const t = super.toJSON();
                    (t.autoClose = this.autoClose), (t.curves = []);
                    for (let e = 0, n = this.curves.length; e < n; e++) {
                      const n = this.curves[e];
                      t.curves.push(n.toJSON());
                    }
                    return t;
                  }
                  fromJSON(t) {
                    super.fromJSON(t),
                      (this.autoClose = t.autoClose),
                      (this.curves = []);
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                      const n = t.curves[e];
                      this.curves.push(new vd[n.type]().fromJSON(n));
                    }
                    return this;
                  }
                }
                class bd extends yd {
                  constructor(t) {
                    super(),
                      (this.type = "Path"),
                      (this.currentPoint = new gn()),
                      t && this.setFromPoints(t);
                  }
                  setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, n = t.length; e < n; e++)
                      this.lineTo(t[e].x, t[e].y);
                    return this;
                  }
                  moveTo(t, e) {
                    return this.currentPoint.set(t, e), this;
                  }
                  lineTo(t, e) {
                    const n = new dd(this.currentPoint.clone(), new gn(t, e));
                    return (
                      this.curves.push(n), this.currentPoint.set(t, e), this
                    );
                  }
                  quadraticCurveTo(t, e, n, r) {
                    const i = new pd(
                      this.currentPoint.clone(),
                      new gn(t, e),
                      new gn(n, r)
                    );
                    return (
                      this.curves.push(i), this.currentPoint.set(n, r), this
                    );
                  }
                  bezierCurveTo(t, e, n, r, i, a) {
                    const o = new ud(
                      this.currentPoint.clone(),
                      new gn(t, e),
                      new gn(n, r),
                      new gn(i, a)
                    );
                    return (
                      this.curves.push(o), this.currentPoint.set(i, a), this
                    );
                  }
                  splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                      n = new gd(e);
                    return (
                      this.curves.push(n),
                      this.currentPoint.copy(t[t.length - 1]),
                      this
                    );
                  }
                  arc(t, e, n, r, i, a) {
                    const o = this.currentPoint.x,
                      s = this.currentPoint.y;
                    return this.absarc(t + o, e + s, n, r, i, a), this;
                  }
                  absarc(t, e, n, r, i, a) {
                    return this.absellipse(t, e, n, n, r, i, a), this;
                  }
                  ellipse(t, e, n, r, i, a, o, s) {
                    const c = this.currentPoint.x,
                      l = this.currentPoint.y;
                    return (
                      this.absellipse(t + c, e + l, n, r, i, a, o, s), this
                    );
                  }
                  absellipse(t, e, n, r, i, a, o, s) {
                    const c = new qh(t, e, n, r, i, a, o, s);
                    if (this.curves.length > 0) {
                      const t = c.getPoint(0);
                      t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
                    }
                    this.curves.push(c);
                    const l = c.getPoint(1);
                    return this.currentPoint.copy(l), this;
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.currentPoint.copy(t.currentPoint),
                      this
                    );
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (t.currentPoint = this.currentPoint.toArray()), t;
                  }
                  fromJSON(t) {
                    return (
                      super.fromJSON(t),
                      this.currentPoint.fromArray(t.currentPoint),
                      this
                    );
                  }
                }
                class xd extends xi {
                  constructor(
                    t = [new gn(0, 0.5), new gn(0.5, 0), new gn(0, -0.5)],
                    e = 12,
                    n = 0,
                    r = 2 * Math.PI
                  ) {
                    super(),
                      (this.type = "LatheGeometry"),
                      (this.parameters = {
                        points: t,
                        segments: e,
                        phiStart: n,
                        phiLength: r,
                      }),
                      (e = Math.floor(e)),
                      (r = Xe(r, 0, 2 * Math.PI));
                    const i = [],
                      a = [],
                      o = [],
                      s = [],
                      c = [],
                      l = 1 / e,
                      u = new Gn(),
                      h = new gn(),
                      d = new Gn(),
                      f = new Gn(),
                      p = new Gn();
                    let m = 0,
                      g = 0;
                    for (let v = 0; v <= t.length - 1; v++)
                      switch (v) {
                        case 0:
                          (m = t[v + 1].x - t[v].x),
                            (g = t[v + 1].y - t[v].y),
                            (d.x = 1 * g),
                            (d.y = -m),
                            (d.z = 0 * g),
                            p.copy(d),
                            d.normalize(),
                            s.push(d.x, d.y, d.z);
                          break;
                        case t.length - 1:
                          s.push(p.x, p.y, p.z);
                          break;
                        default:
                          (m = t[v + 1].x - t[v].x),
                            (g = t[v + 1].y - t[v].y),
                            (d.x = 1 * g),
                            (d.y = -m),
                            (d.z = 0 * g),
                            f.copy(d),
                            (d.x += p.x),
                            (d.y += p.y),
                            (d.z += p.z),
                            d.normalize(),
                            s.push(d.x, d.y, d.z),
                            p.copy(f);
                      }
                    for (let v = 0; v <= e; v++) {
                      const i = n + v * l * r,
                        d = Math.sin(i),
                        f = Math.cos(i);
                      for (let n = 0; n <= t.length - 1; n++) {
                        (u.x = t[n].x * d),
                          (u.y = t[n].y),
                          (u.z = t[n].x * f),
                          a.push(u.x, u.y, u.z),
                          (h.x = v / e),
                          (h.y = n / (t.length - 1)),
                          o.push(h.x, h.y);
                        const r = s[3 * n + 0] * d,
                          i = s[3 * n + 1],
                          l = s[3 * n + 0] * f;
                        c.push(r, i, l);
                      }
                    }
                    for (let v = 0; v < e; v++)
                      for (let e = 0; e < t.length - 1; e++) {
                        const n = e + v * t.length,
                          r = n,
                          a = n + t.length,
                          o = n + t.length + 1,
                          s = n + 1;
                        i.push(r, a, s), i.push(o, s, a);
                      }
                    this.setIndex(i),
                      this.setAttribute("position", new di(a, 3)),
                      this.setAttribute("uv", new di(o, 2)),
                      this.setAttribute("normal", new di(c, 3));
                  }
                  static fromJSON(t) {
                    return new xd(
                      t.points,
                      t.segments,
                      t.phiStart,
                      t.phiLength
                    );
                  }
                }
                class _d extends xd {
                  constructor(t = 1, e = 1, n = 4, r = 8) {
                    const i = new bd();
                    i.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
                      i.absarc(0, e / 2, t, 0, 0.5 * Math.PI),
                      super(i.getPoints(n), r),
                      (this.type = "CapsuleGeometry"),
                      (this.parameters = {
                        radius: t,
                        height: e,
                        capSegments: n,
                        radialSegments: r,
                      });
                  }
                  static fromJSON(t) {
                    return new _d(
                      t.radius,
                      t.length,
                      t.capSegments,
                      t.radialSegments
                    );
                  }
                }
                class wd extends xi {
                  constructor(t = 1, e = 8, n = 0, r = 2 * Math.PI) {
                    super(),
                      (this.type = "CircleGeometry"),
                      (this.parameters = {
                        radius: t,
                        segments: e,
                        thetaStart: n,
                        thetaLength: r,
                      }),
                      (e = Math.max(3, e));
                    const i = [],
                      a = [],
                      o = [],
                      s = [],
                      c = new Gn(),
                      l = new gn();
                    a.push(0, 0, 0), o.push(0, 0, 1), s.push(0.5, 0.5);
                    for (let u = 0, h = 3; u <= e; u++, h += 3) {
                      const i = n + (u / e) * r;
                      (c.x = t * Math.cos(i)),
                        (c.y = t * Math.sin(i)),
                        a.push(c.x, c.y, c.z),
                        o.push(0, 0, 1),
                        (l.x = (a[h] / t + 1) / 2),
                        (l.y = (a[h + 1] / t + 1) / 2),
                        s.push(l.x, l.y);
                    }
                    for (let u = 1; u <= e; u++) i.push(u, u + 1, 0);
                    this.setIndex(i),
                      this.setAttribute("position", new di(a, 3)),
                      this.setAttribute("normal", new di(o, 3)),
                      this.setAttribute("uv", new di(s, 2));
                  }
                  static fromJSON(t) {
                    return new wd(
                      t.radius,
                      t.segments,
                      t.thetaStart,
                      t.thetaLength
                    );
                  }
                }
                class Sd extends xi {
                  constructor(
                    t = 1,
                    e = 1,
                    n = 1,
                    r = 8,
                    i = 1,
                    a = !1,
                    o = 0,
                    s = 2 * Math.PI
                  ) {
                    super(),
                      (this.type = "CylinderGeometry"),
                      (this.parameters = {
                        radiusTop: t,
                        radiusBottom: e,
                        height: n,
                        radialSegments: r,
                        heightSegments: i,
                        openEnded: a,
                        thetaStart: o,
                        thetaLength: s,
                      });
                    const c = this;
                    (r = Math.floor(r)), (i = Math.floor(i));
                    const l = [],
                      u = [],
                      h = [],
                      d = [];
                    let f = 0;
                    const p = [],
                      m = n / 2;
                    let g = 0;
                    function v() {
                      const a = new Gn(),
                        v = new Gn();
                      let y = 0;
                      const b = (e - t) / n;
                      for (let c = 0; c <= i; c++) {
                        const l = [],
                          g = c / i,
                          y = g * (e - t) + t;
                        for (let t = 0; t <= r; t++) {
                          const e = t / r,
                            i = e * s + o,
                            c = Math.sin(i),
                            p = Math.cos(i);
                          (v.x = y * c),
                            (v.y = -g * n + m),
                            (v.z = y * p),
                            u.push(v.x, v.y, v.z),
                            a.set(c, b, p).normalize(),
                            h.push(a.x, a.y, a.z),
                            d.push(e, 1 - g),
                            l.push(f++);
                        }
                        p.push(l);
                      }
                      for (let t = 0; t < r; t++)
                        for (let e = 0; e < i; e++) {
                          const n = p[e][t],
                            r = p[e + 1][t],
                            i = p[e + 1][t + 1],
                            a = p[e][t + 1];
                          l.push(n, r, a), l.push(r, i, a), (y += 6);
                        }
                      c.addGroup(g, y, 0), (g += y);
                    }
                    function y(n) {
                      const i = f,
                        a = new gn(),
                        p = new Gn();
                      let v = 0;
                      const y = !0 === n ? t : e,
                        b = !0 === n ? 1 : -1;
                      for (let t = 1; t <= r; t++)
                        u.push(0, m * b, 0),
                          h.push(0, b, 0),
                          d.push(0.5, 0.5),
                          f++;
                      const x = f;
                      for (let t = 0; t <= r; t++) {
                        const e = t / r,
                          n = e * s + o,
                          i = Math.cos(n),
                          c = Math.sin(n);
                        (p.x = y * c),
                          (p.y = m * b),
                          (p.z = y * i),
                          u.push(p.x, p.y, p.z),
                          h.push(0, b, 0),
                          (a.x = 0.5 * i + 0.5),
                          (a.y = 0.5 * c * b + 0.5),
                          d.push(a.x, a.y),
                          f++;
                      }
                      for (let t = 0; t < r; t++) {
                        const e = i + t,
                          r = x + t;
                        !0 === n ? l.push(r, r + 1, e) : l.push(r + 1, r, e),
                          (v += 3);
                      }
                      c.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
                    }
                    v(),
                      !1 === a && (t > 0 && y(!0), e > 0 && y(!1)),
                      this.setIndex(l),
                      this.setAttribute("position", new di(u, 3)),
                      this.setAttribute("normal", new di(h, 3)),
                      this.setAttribute("uv", new di(d, 2));
                  }
                  static fromJSON(t) {
                    return new Sd(
                      t.radiusTop,
                      t.radiusBottom,
                      t.height,
                      t.radialSegments,
                      t.heightSegments,
                      t.openEnded,
                      t.thetaStart,
                      t.thetaLength
                    );
                  }
                }
                class Md extends Sd {
                  constructor(
                    t = 1,
                    e = 1,
                    n = 8,
                    r = 1,
                    i = !1,
                    a = 0,
                    o = 2 * Math.PI
                  ) {
                    super(0, t, e, n, r, i, a, o),
                      (this.type = "ConeGeometry"),
                      (this.parameters = {
                        radius: t,
                        height: e,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: i,
                        thetaStart: a,
                        thetaLength: o,
                      });
                  }
                  static fromJSON(t) {
                    return new Md(
                      t.radius,
                      t.height,
                      t.radialSegments,
                      t.heightSegments,
                      t.openEnded,
                      t.thetaStart,
                      t.thetaLength
                    );
                  }
                }
                class Td extends xi {
                  constructor(t = [], e = [], n = 1, r = 0) {
                    super(),
                      (this.type = "PolyhedronGeometry"),
                      (this.parameters = {
                        vertices: t,
                        indices: e,
                        radius: n,
                        detail: r,
                      });
                    const i = [],
                      a = [];
                    function o(t) {
                      const n = new Gn(),
                        r = new Gn(),
                        i = new Gn();
                      for (let a = 0; a < e.length; a += 3)
                        d(e[a + 0], n),
                          d(e[a + 1], r),
                          d(e[a + 2], i),
                          s(n, r, i, t);
                    }
                    function s(t, e, n, r) {
                      const i = r + 1,
                        a = [];
                      for (let o = 0; o <= i; o++) {
                        a[o] = [];
                        const r = t.clone().lerp(n, o / i),
                          s = e.clone().lerp(n, o / i),
                          c = i - o;
                        for (let t = 0; t <= c; t++)
                          a[o][t] =
                            0 === t && o === i ? r : r.clone().lerp(s, t / c);
                      }
                      for (let o = 0; o < i; o++)
                        for (let t = 0; t < 2 * (i - o) - 1; t++) {
                          const e = Math.floor(t / 2);
                          t % 2 === 0
                            ? (h(a[o][e + 1]), h(a[o + 1][e]), h(a[o][e]))
                            : (h(a[o][e + 1]),
                              h(a[o + 1][e + 1]),
                              h(a[o + 1][e]));
                        }
                    }
                    function c(t) {
                      const e = new Gn();
                      for (let n = 0; n < i.length; n += 3)
                        (e.x = i[n + 0]),
                          (e.y = i[n + 1]),
                          (e.z = i[n + 2]),
                          e.normalize().multiplyScalar(t),
                          (i[n + 0] = e.x),
                          (i[n + 1] = e.y),
                          (i[n + 2] = e.z);
                    }
                    function l() {
                      const t = new Gn();
                      for (let e = 0; e < i.length; e += 3) {
                        (t.x = i[e + 0]), (t.y = i[e + 1]), (t.z = i[e + 2]);
                        const n = m(t) / 2 / Math.PI + 0.5,
                          r = g(t) / Math.PI + 0.5;
                        a.push(n, 1 - r);
                      }
                      f(), u();
                    }
                    function u() {
                      for (let t = 0; t < a.length; t += 6) {
                        const e = a[t + 0],
                          n = a[t + 2],
                          r = a[t + 4],
                          i = Math.max(e, n, r),
                          o = Math.min(e, n, r);
                        i > 0.9 &&
                          o < 0.1 &&
                          (e < 0.2 && (a[t + 0] += 1),
                          n < 0.2 && (a[t + 2] += 1),
                          r < 0.2 && (a[t + 4] += 1));
                      }
                    }
                    function h(t) {
                      i.push(t.x, t.y, t.z);
                    }
                    function d(e, n) {
                      const r = 3 * e;
                      (n.x = t[r + 0]), (n.y = t[r + 1]), (n.z = t[r + 2]);
                    }
                    function f() {
                      const t = new Gn(),
                        e = new Gn(),
                        n = new Gn(),
                        r = new Gn(),
                        o = new gn(),
                        s = new gn(),
                        c = new gn();
                      for (let l = 0, u = 0; l < i.length; l += 9, u += 6) {
                        t.set(i[l + 0], i[l + 1], i[l + 2]),
                          e.set(i[l + 3], i[l + 4], i[l + 5]),
                          n.set(i[l + 6], i[l + 7], i[l + 8]),
                          o.set(a[u + 0], a[u + 1]),
                          s.set(a[u + 2], a[u + 3]),
                          c.set(a[u + 4], a[u + 5]),
                          r.copy(t).add(e).add(n).divideScalar(3);
                        const h = m(r);
                        p(o, u + 0, t, h), p(s, u + 2, e, h), p(c, u + 4, n, h);
                      }
                    }
                    function p(t, e, n, r) {
                      r < 0 && 1 === t.x && (a[e] = t.x - 1),
                        0 === n.x &&
                          0 === n.z &&
                          (a[e] = r / 2 / Math.PI + 0.5);
                    }
                    function m(t) {
                      return Math.atan2(t.z, -t.x);
                    }
                    function g(t) {
                      return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
                    }
                    o(r),
                      c(n),
                      l(),
                      this.setAttribute("position", new di(i, 3)),
                      this.setAttribute("normal", new di(i.slice(), 3)),
                      this.setAttribute("uv", new di(a, 2)),
                      0 === r
                        ? this.computeVertexNormals()
                        : this.normalizeNormals();
                  }
                  static fromJSON(t) {
                    return new Td(t.vertices, t.indices, t.radius, t.details);
                  }
                }
                class Ed extends Td {
                  constructor(t = 1, e = 0) {
                    const n = (1 + Math.sqrt(5)) / 2,
                      r = 1 / n,
                      i = [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        1,
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1,
                        -1,
                        1,
                        -1,
                        1,
                        1,
                        1,
                        -1,
                        1,
                        1,
                        1,
                        0,
                        -r,
                        -n,
                        0,
                        -r,
                        n,
                        0,
                        r,
                        -n,
                        0,
                        r,
                        n,
                        -r,
                        -n,
                        0,
                        -r,
                        n,
                        0,
                        r,
                        -n,
                        0,
                        r,
                        n,
                        0,
                        -n,
                        0,
                        -r,
                        n,
                        0,
                        -r,
                        -n,
                        0,
                        r,
                        n,
                        0,
                        r,
                      ],
                      a = [
                        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7,
                        6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16,
                        2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6,
                        2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1,
                        9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
                        11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4,
                        19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
                      ];
                    super(i, a, t, e),
                      (this.type = "DodecahedronGeometry"),
                      (this.parameters = { radius: t, detail: e });
                  }
                  static fromJSON(t) {
                    return new Ed(t.radius, t.detail);
                  }
                }
                const Ad = new Gn(),
                  Cd = new Gn(),
                  Ld = new Gn(),
                  Rd = new ri();
                class Pd extends xi {
                  constructor(t = null, e = 1) {
                    if (
                      (super(),
                      (this.type = "EdgesGeometry"),
                      (this.parameters = { geometry: t, thresholdAngle: e }),
                      null !== t)
                    ) {
                      const n = 4,
                        r = Math.pow(10, n),
                        i = Math.cos(Ge * e),
                        a = t.getIndex(),
                        o = t.getAttribute("position"),
                        s = a ? a.count : o.count,
                        c = [0, 0, 0],
                        l = ["a", "b", "c"],
                        u = new Array(3),
                        h = {},
                        d = [];
                      for (let t = 0; t < s; t += 3) {
                        a
                          ? ((c[0] = a.getX(t)),
                            (c[1] = a.getX(t + 1)),
                            (c[2] = a.getX(t + 2)))
                          : ((c[0] = t), (c[1] = t + 1), (c[2] = t + 2));
                        const { a: e, b: n, c: s } = Rd;
                        if (
                          (e.fromBufferAttribute(o, c[0]),
                          n.fromBufferAttribute(o, c[1]),
                          s.fromBufferAttribute(o, c[2]),
                          Rd.getNormal(Ld),
                          (u[0] = `${Math.round(e.x * r)},${Math.round(
                            e.y * r
                          )},${Math.round(e.z * r)}`),
                          (u[1] = `${Math.round(n.x * r)},${Math.round(
                            n.y * r
                          )},${Math.round(n.z * r)}`),
                          (u[2] = `${Math.round(s.x * r)},${Math.round(
                            s.y * r
                          )},${Math.round(s.z * r)}`),
                          u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
                        )
                          for (let t = 0; t < 3; t++) {
                            const e = (t + 1) % 3,
                              n = u[t],
                              r = u[e],
                              a = Rd[l[t]],
                              o = Rd[l[e]],
                              s = `${n}_${r}`,
                              f = `${r}_${n}`;
                            f in h && h[f]
                              ? (Ld.dot(h[f].normal) <= i &&
                                  (d.push(a.x, a.y, a.z),
                                  d.push(o.x, o.y, o.z)),
                                (h[f] = null))
                              : s in h ||
                                (h[s] = {
                                  index0: c[t],
                                  index1: c[e],
                                  normal: Ld.clone(),
                                });
                          }
                      }
                      for (const t in h)
                        if (h[t]) {
                          const { index0: e, index1: n } = h[t];
                          Ad.fromBufferAttribute(o, e),
                            Cd.fromBufferAttribute(o, n),
                            d.push(Ad.x, Ad.y, Ad.z),
                            d.push(Cd.x, Cd.y, Cd.z);
                        }
                      this.setAttribute("position", new di(d, 3));
                    }
                  }
                }
                class Id extends bd {
                  constructor(t) {
                    super(t),
                      (this.uuid = qe()),
                      (this.type = "Shape"),
                      (this.holes = []);
                  }
                  getPointsHoles(t) {
                    const e = [];
                    for (let n = 0, r = this.holes.length; n < r; n++)
                      e[n] = this.holes[n].getPoints(t);
                    return e;
                  }
                  extractPoints(t) {
                    return {
                      shape: this.getPoints(t),
                      holes: this.getPointsHoles(t),
                    };
                  }
                  copy(t) {
                    super.copy(t), (this.holes = []);
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                      const n = t.holes[e];
                      this.holes.push(n.clone());
                    }
                    return this;
                  }
                  toJSON() {
                    const t = super.toJSON();
                    (t.uuid = this.uuid), (t.holes = []);
                    for (let e = 0, n = this.holes.length; e < n; e++) {
                      const n = this.holes[e];
                      t.holes.push(n.toJSON());
                    }
                    return t;
                  }
                  fromJSON(t) {
                    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                      const n = t.holes[e];
                      this.holes.push(new bd().fromJSON(n));
                    }
                    return this;
                  }
                }
                const Od = {
                  triangulate: function (t, e, n = 2) {
                    const r = e && e.length,
                      i = r ? e[0] * n : t.length;
                    let a = kd(t, 0, i, n, !0);
                    const o = [];
                    if (!a || a.next === a.prev) return o;
                    let s, c, l, u, h, d, f;
                    if ((r && (a = jd(t, e, a, n)), t.length > 80 * n)) {
                      (s = l = t[0]), (c = u = t[1]);
                      for (let e = n; e < i; e += n)
                        (h = t[e]),
                          (d = t[e + 1]),
                          h < s && (s = h),
                          d < c && (c = d),
                          h > l && (l = h),
                          d > u && (u = d);
                      (f = Math.max(l - s, u - c)), (f = 0 !== f ? 1 / f : 0);
                    }
                    return Dd(a, o, n, s, c, f), o;
                  },
                };
                function kd(t, e, n, r, i) {
                  let a, o;
                  if (i === hf(t, e, n, r) > 0)
                    for (a = e; a < n; a += r) o = cf(a, t[a], t[a + 1], o);
                  else
                    for (a = n - r; a >= e; a -= r)
                      o = cf(a, t[a], t[a + 1], o);
                  return o && Qd(o, o.next) && (lf(o), (o = o.next)), o;
                }
                function Nd(t, e) {
                  if (!t) return t;
                  e || (e = t);
                  let n,
                    r = t;
                  do {
                    if (
                      ((n = !1),
                      r.steiner ||
                        (!Qd(r, r.next) && 0 !== Zd(r.prev, r, r.next)))
                    )
                      r = r.next;
                    else {
                      if ((lf(r), (r = e = r.prev), r === r.next)) break;
                      n = !0;
                    }
                  } while (n || r !== e);
                  return e;
                }
                function Dd(t, e, n, r, i, a, o) {
                  if (!t) return;
                  !o && a && qd(t, r, i, a);
                  let s,
                    c,
                    l = t;
                  while (t.prev !== t.next)
                    if (
                      ((s = t.prev), (c = t.next), a ? Fd(t, r, i, a) : zd(t))
                    )
                      e.push(s.i / n),
                        e.push(t.i / n),
                        e.push(c.i / n),
                        lf(t),
                        (t = c.next),
                        (l = c.next);
                    else if (((t = c), t === l)) {
                      o
                        ? 1 === o
                          ? ((t = Ud(Nd(t), e, n)), Dd(t, e, n, r, i, a, 2))
                          : 2 === o && Bd(t, e, n, r, i, a)
                        : Dd(Nd(t), e, n, r, i, a, 1);
                      break;
                    }
                }
                function zd(t) {
                  const e = t.prev,
                    n = t,
                    r = t.next;
                  if (Zd(e, n, r) >= 0) return !1;
                  let i = t.next.next;
                  while (i !== t.prev) {
                    if (
                      Jd(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
                      Zd(i.prev, i, i.next) >= 0
                    )
                      return !1;
                    i = i.next;
                  }
                  return !0;
                }
                function Fd(t, e, n, r) {
                  const i = t.prev,
                    a = t,
                    o = t.next;
                  if (Zd(i, a, o) >= 0) return !1;
                  const s =
                      i.x < a.x
                        ? i.x < o.x
                          ? i.x
                          : o.x
                        : a.x < o.x
                        ? a.x
                        : o.x,
                    c =
                      i.y < a.y
                        ? i.y < o.y
                          ? i.y
                          : o.y
                        : a.y < o.y
                        ? a.y
                        : o.y,
                    l =
                      i.x > a.x
                        ? i.x > o.x
                          ? i.x
                          : o.x
                        : a.x > o.x
                        ? a.x
                        : o.x,
                    u =
                      i.y > a.y
                        ? i.y > o.y
                          ? i.y
                          : o.y
                        : a.y > o.y
                        ? a.y
                        : o.y,
                    h = $d(s, c, e, n, r),
                    d = $d(l, u, e, n, r);
                  let f = t.prevZ,
                    p = t.nextZ;
                  while (f && f.z >= h && p && p.z <= d) {
                    if (
                      f !== t.prev &&
                      f !== t.next &&
                      Jd(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
                      Zd(f.prev, f, f.next) >= 0
                    )
                      return !1;
                    if (
                      ((f = f.prevZ),
                      p !== t.prev &&
                        p !== t.next &&
                        Jd(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
                        Zd(p.prev, p, p.next) >= 0)
                    )
                      return !1;
                    p = p.nextZ;
                  }
                  while (f && f.z >= h) {
                    if (
                      f !== t.prev &&
                      f !== t.next &&
                      Jd(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
                      Zd(f.prev, f, f.next) >= 0
                    )
                      return !1;
                    f = f.prevZ;
                  }
                  while (p && p.z <= d) {
                    if (
                      p !== t.prev &&
                      p !== t.next &&
                      Jd(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
                      Zd(p.prev, p, p.next) >= 0
                    )
                      return !1;
                    p = p.nextZ;
                  }
                  return !0;
                }
                function Ud(t, e, n) {
                  let r = t;
                  do {
                    const i = r.prev,
                      a = r.next.next;
                    !Qd(i, a) &&
                      tf(i, r, r.next, a) &&
                      af(i, a) &&
                      af(a, i) &&
                      (e.push(i.i / n),
                      e.push(r.i / n),
                      e.push(a.i / n),
                      lf(r),
                      lf(r.next),
                      (r = t = a)),
                      (r = r.next);
                  } while (r !== t);
                  return Nd(r);
                }
                function Bd(t, e, n, r, i, a) {
                  let o = t;
                  do {
                    let t = o.next.next;
                    while (t !== o.prev) {
                      if (o.i !== t.i && Kd(o, t)) {
                        let s = sf(o, t);
                        return (
                          (o = Nd(o, o.next)),
                          (s = Nd(s, s.next)),
                          Dd(o, e, n, r, i, a),
                          void Dd(s, e, n, r, i, a)
                        );
                      }
                      t = t.next;
                    }
                    o = o.next;
                  } while (o !== t);
                }
                function jd(t, e, n, r) {
                  const i = [];
                  let a, o, s, c, l;
                  for (a = 0, o = e.length; a < o; a++)
                    (s = e[a] * r),
                      (c = a < o - 1 ? e[a + 1] * r : t.length),
                      (l = kd(t, s, c, r, !1)),
                      l === l.next && (l.steiner = !0),
                      i.push(Yd(l));
                  for (i.sort(Hd), a = 0; a < i.length; a++)
                    Vd(i[a], n), (n = Nd(n, n.next));
                  return n;
                }
                function Hd(t, e) {
                  return t.x - e.x;
                }
                function Vd(t, e) {
                  if (((e = Gd(t, e)), e)) {
                    const n = sf(e, t);
                    Nd(e, e.next), Nd(n, n.next);
                  }
                }
                function Gd(t, e) {
                  let n = e;
                  const r = t.x,
                    i = t.y;
                  let a,
                    o = -1 / 0;
                  do {
                    if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                      const t =
                        n.x + ((i - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                      if (t <= r && t > o) {
                        if (((o = t), t === r)) {
                          if (i === n.y) return n;
                          if (i === n.next.y) return n.next;
                        }
                        a = n.x < n.next.x ? n : n.next;
                      }
                    }
                    n = n.next;
                  } while (n !== e);
                  if (!a) return null;
                  if (r === o) return a;
                  const s = a,
                    c = a.x,
                    l = a.y;
                  let u,
                    h = 1 / 0;
                  n = a;
                  do {
                    r >= n.x &&
                      n.x >= c &&
                      r !== n.x &&
                      Jd(i < l ? r : o, i, c, l, i < l ? o : r, i, n.x, n.y) &&
                      ((u = Math.abs(i - n.y) / (r - n.x)),
                      af(n, t) &&
                        (u < h ||
                          (u === h &&
                            (n.x > a.x || (n.x === a.x && Wd(a, n))))) &&
                        ((a = n), (h = u))),
                      (n = n.next);
                  } while (n !== s);
                  return a;
                }
                function Wd(t, e) {
                  return Zd(t.prev, t, e.prev) < 0 && Zd(e.next, t, t.next) < 0;
                }
                function qd(t, e, n, r) {
                  let i = t;
                  do {
                    null === i.z && (i.z = $d(i.x, i.y, e, n, r)),
                      (i.prevZ = i.prev),
                      (i.nextZ = i.next),
                      (i = i.next);
                  } while (i !== t);
                  (i.prevZ.nextZ = null), (i.prevZ = null), Xd(i);
                }
                function Xd(t) {
                  let e,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c,
                    l = 1;
                  do {
                    (n = t), (t = null), (a = null), (o = 0);
                    while (n) {
                      for (o++, r = n, s = 0, e = 0; e < l; e++)
                        if ((s++, (r = r.nextZ), !r)) break;
                      c = l;
                      while (s > 0 || (c > 0 && r))
                        0 !== s && (0 === c || !r || n.z <= r.z)
                          ? ((i = n), (n = n.nextZ), s--)
                          : ((i = r), (r = r.nextZ), c--),
                          a ? (a.nextZ = i) : (t = i),
                          (i.prevZ = a),
                          (a = i);
                      n = r;
                    }
                    (a.nextZ = null), (l *= 2);
                  } while (o > 1);
                  return t;
                }
                function $d(t, e, n, r, i) {
                  return (
                    (t = 32767 * (t - n) * i),
                    (e = 32767 * (e - r) * i),
                    (t = 16711935 & (t | (t << 8))),
                    (t = 252645135 & (t | (t << 4))),
                    (t = 858993459 & (t | (t << 2))),
                    (t = 1431655765 & (t | (t << 1))),
                    (e = 16711935 & (e | (e << 8))),
                    (e = 252645135 & (e | (e << 4))),
                    (e = 858993459 & (e | (e << 2))),
                    (e = 1431655765 & (e | (e << 1))),
                    t | (e << 1)
                  );
                }
                function Yd(t) {
                  let e = t,
                    n = t;
                  do {
                    (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e),
                      (e = e.next);
                  } while (e !== t);
                  return n;
                }
                function Jd(t, e, n, r, i, a, o, s) {
                  return (
                    (i - o) * (e - s) - (t - o) * (a - s) >= 0 &&
                    (t - o) * (r - s) - (n - o) * (e - s) >= 0 &&
                    (n - o) * (a - s) - (i - o) * (r - s) >= 0
                  );
                }
                function Kd(t, e) {
                  return (
                    t.next.i !== e.i &&
                    t.prev.i !== e.i &&
                    !rf(t, e) &&
                    ((af(t, e) &&
                      af(e, t) &&
                      of(t, e) &&
                      (Zd(t.prev, t, e.prev) || Zd(t, e.prev, e))) ||
                      (Qd(t, e) &&
                        Zd(t.prev, t, t.next) > 0 &&
                        Zd(e.prev, e, e.next) > 0))
                  );
                }
                function Zd(t, e, n) {
                  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
                }
                function Qd(t, e) {
                  return t.x === e.x && t.y === e.y;
                }
                function tf(t, e, n, r) {
                  const i = nf(Zd(t, e, n)),
                    a = nf(Zd(t, e, r)),
                    o = nf(Zd(n, r, t)),
                    s = nf(Zd(n, r, e));
                  return (
                    (i !== a && o !== s) ||
                    !(0 !== i || !ef(t, n, e)) ||
                    !(0 !== a || !ef(t, r, e)) ||
                    !(0 !== o || !ef(n, t, r)) ||
                    !(0 !== s || !ef(n, e, r))
                  );
                }
                function ef(t, e, n) {
                  return (
                    e.x <= Math.max(t.x, n.x) &&
                    e.x >= Math.min(t.x, n.x) &&
                    e.y <= Math.max(t.y, n.y) &&
                    e.y >= Math.min(t.y, n.y)
                  );
                }
                function nf(t) {
                  return t > 0 ? 1 : t < 0 ? -1 : 0;
                }
                function rf(t, e) {
                  let n = t;
                  do {
                    if (
                      n.i !== t.i &&
                      n.next.i !== t.i &&
                      n.i !== e.i &&
                      n.next.i !== e.i &&
                      tf(n, n.next, t, e)
                    )
                      return !0;
                    n = n.next;
                  } while (n !== t);
                  return !1;
                }
                function af(t, e) {
                  return Zd(t.prev, t, t.next) < 0
                    ? Zd(t, e, t.next) >= 0 && Zd(t, t.prev, e) >= 0
                    : Zd(t, e, t.prev) < 0 || Zd(t, t.next, e) < 0;
                }
                function of(t, e) {
                  let n = t,
                    r = !1;
                  const i = (t.x + e.x) / 2,
                    a = (t.y + e.y) / 2;
                  do {
                    n.y > a !== n.next.y > a &&
                      n.next.y !== n.y &&
                      i <
                        ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) +
                          n.x &&
                      (r = !r),
                      (n = n.next);
                  } while (n !== t);
                  return r;
                }
                function sf(t, e) {
                  const n = new uf(t.i, t.x, t.y),
                    r = new uf(e.i, e.x, e.y),
                    i = t.next,
                    a = e.prev;
                  return (
                    (t.next = e),
                    (e.prev = t),
                    (n.next = i),
                    (i.prev = n),
                    (r.next = n),
                    (n.prev = r),
                    (a.next = r),
                    (r.prev = a),
                    r
                  );
                }
                function cf(t, e, n, r) {
                  const i = new uf(t, e, n);
                  return (
                    r
                      ? ((i.next = r.next),
                        (i.prev = r),
                        (r.next.prev = i),
                        (r.next = i))
                      : ((i.prev = i), (i.next = i)),
                    i
                  );
                }
                function lf(t) {
                  (t.next.prev = t.prev),
                    (t.prev.next = t.next),
                    t.prevZ && (t.prevZ.nextZ = t.nextZ),
                    t.nextZ && (t.nextZ.prevZ = t.prevZ);
                }
                function uf(t, e, n) {
                  (this.i = t),
                    (this.x = e),
                    (this.y = n),
                    (this.prev = null),
                    (this.next = null),
                    (this.z = null),
                    (this.prevZ = null),
                    (this.nextZ = null),
                    (this.steiner = !1);
                }
                function hf(t, e, n, r) {
                  let i = 0;
                  for (let a = e, o = n - r; a < n; a += r)
                    (i += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
                  return i;
                }
                class df {
                  static area(t) {
                    const e = t.length;
                    let n = 0;
                    for (let r = e - 1, i = 0; i < e; r = i++)
                      n += t[r].x * t[i].y - t[i].x * t[r].y;
                    return 0.5 * n;
                  }
                  static isClockWise(t) {
                    return df.area(t) < 0;
                  }
                  static triangulateShape(t, e) {
                    const n = [],
                      r = [],
                      i = [];
                    ff(t), pf(n, t);
                    let a = t.length;
                    e.forEach(ff);
                    for (let s = 0; s < e.length; s++)
                      r.push(a), (a += e[s].length), pf(n, e[s]);
                    const o = Od.triangulate(n, r);
                    for (let s = 0; s < o.length; s += 3)
                      i.push(o.slice(s, s + 3));
                    return i;
                  }
                }
                function ff(t) {
                  const e = t.length;
                  e > 2 && t[e - 1].equals(t[0]) && t.pop();
                }
                function pf(t, e) {
                  for (let n = 0; n < e.length; n++)
                    t.push(e[n].x), t.push(e[n].y);
                }
                class mf extends xi {
                  constructor(
                    t = new Id([
                      new gn(0.5, 0.5),
                      new gn(-0.5, 0.5),
                      new gn(-0.5, -0.5),
                      new gn(0.5, -0.5),
                    ]),
                    e = {}
                  ) {
                    super(),
                      (this.type = "ExtrudeGeometry"),
                      (this.parameters = { shapes: t, options: e }),
                      (t = Array.isArray(t) ? t : [t]);
                    const n = this,
                      r = [],
                      i = [];
                    for (let o = 0, s = t.length; o < s; o++) {
                      const e = t[o];
                      a(e);
                    }
                    function a(t) {
                      const a = [],
                        o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1;
                      let c = void 0 !== e.depth ? e.depth : 1,
                        l = void 0 === e.bevelEnabled || e.bevelEnabled,
                        u =
                          void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
                        h = void 0 !== e.bevelSize ? e.bevelSize : u - 0.1,
                        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                      const p = e.extrudePath,
                        m = void 0 !== e.UVGenerator ? e.UVGenerator : gf;
                      void 0 !== e.amount &&
                        (console.warn(
                          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                        ),
                        (c = e.amount));
                      let g,
                        v,
                        y,
                        b,
                        x,
                        _ = !1;
                      p &&
                        ((g = p.getSpacedPoints(s)),
                        (_ = !0),
                        (l = !1),
                        (v = p.computeFrenetFrames(s, !1)),
                        (y = new Gn()),
                        (b = new Gn()),
                        (x = new Gn())),
                        l || ((f = 0), (u = 0), (h = 0), (d = 0));
                      const w = t.extractPoints(o);
                      let S = w.shape;
                      const M = w.holes,
                        T = !df.isClockWise(S);
                      if (T) {
                        S = S.reverse();
                        for (let t = 0, e = M.length; t < e; t++) {
                          const e = M[t];
                          df.isClockWise(e) && (M[t] = e.reverse());
                        }
                      }
                      const E = df.triangulateShape(S, M),
                        A = S;
                      for (let e = 0, n = M.length; e < n; e++) {
                        const t = M[e];
                        S = S.concat(t);
                      }
                      function C(t, e, n) {
                        return (
                          e ||
                            console.error(
                              "THREE.ExtrudeGeometry: vec does not exist"
                            ),
                          e.clone().multiplyScalar(n).add(t)
                        );
                      }
                      const L = S.length,
                        R = E.length;
                      function P(t, e, n) {
                        let r, i, a;
                        const o = t.x - e.x,
                          s = t.y - e.y,
                          c = n.x - t.x,
                          l = n.y - t.y,
                          u = o * o + s * s,
                          h = o * l - s * c;
                        if (Math.abs(h) > Number.EPSILON) {
                          const h = Math.sqrt(u),
                            d = Math.sqrt(c * c + l * l),
                            f = e.x - s / h,
                            p = e.y + o / h,
                            m = n.x - l / d,
                            g = n.y + c / d,
                            v = ((m - f) * l - (g - p) * c) / (o * l - s * c);
                          (r = f + o * v - t.x), (i = p + s * v - t.y);
                          const y = r * r + i * i;
                          if (y <= 2) return new gn(r, i);
                          a = Math.sqrt(y / 2);
                        } else {
                          let t = !1;
                          o > Number.EPSILON
                            ? c > Number.EPSILON && (t = !0)
                            : o < -Number.EPSILON
                            ? c < -Number.EPSILON && (t = !0)
                            : Math.sign(s) === Math.sign(l) && (t = !0),
                            t
                              ? ((r = -s), (i = o), (a = Math.sqrt(u)))
                              : ((r = o), (i = s), (a = Math.sqrt(u / 2)));
                        }
                        return new gn(r / a, i / a);
                      }
                      const I = [];
                      for (
                        let e = 0, n = A.length, r = n - 1, i = e + 1;
                        e < n;
                        e++, r++, i++
                      )
                        r === n && (r = 0),
                          i === n && (i = 0),
                          (I[e] = P(A[e], A[r], A[i]));
                      const O = [];
                      let k,
                        N = I.concat();
                      for (let e = 0, n = M.length; e < n; e++) {
                        const t = M[e];
                        k = [];
                        for (
                          let e = 0, n = t.length, r = n - 1, i = e + 1;
                          e < n;
                          e++, r++, i++
                        )
                          r === n && (r = 0),
                            i === n && (i = 0),
                            (k[e] = P(t[e], t[r], t[i]));
                        O.push(k), (N = N.concat(k));
                      }
                      for (let e = 0; e < f; e++) {
                        const t = e / f,
                          n = u * Math.cos((t * Math.PI) / 2),
                          r = h * Math.sin((t * Math.PI) / 2) + d;
                        for (let e = 0, i = A.length; e < i; e++) {
                          const t = C(A[e], I[e], r);
                          B(t.x, t.y, -n);
                        }
                        for (let e = 0, i = M.length; e < i; e++) {
                          const t = M[e];
                          k = O[e];
                          for (let e = 0, i = t.length; e < i; e++) {
                            const i = C(t[e], k[e], r);
                            B(i.x, i.y, -n);
                          }
                        }
                      }
                      const D = h + d;
                      for (let e = 0; e < L; e++) {
                        const t = l ? C(S[e], N[e], D) : S[e];
                        _
                          ? (b.copy(v.normals[0]).multiplyScalar(t.x),
                            y.copy(v.binormals[0]).multiplyScalar(t.y),
                            x.copy(g[0]).add(b).add(y),
                            B(x.x, x.y, x.z))
                          : B(t.x, t.y, 0);
                      }
                      for (let e = 1; e <= s; e++)
                        for (let t = 0; t < L; t++) {
                          const n = l ? C(S[t], N[t], D) : S[t];
                          _
                            ? (b.copy(v.normals[e]).multiplyScalar(n.x),
                              y.copy(v.binormals[e]).multiplyScalar(n.y),
                              x.copy(g[e]).add(b).add(y),
                              B(x.x, x.y, x.z))
                            : B(n.x, n.y, (c / s) * e);
                        }
                      for (let e = f - 1; e >= 0; e--) {
                        const t = e / f,
                          n = u * Math.cos((t * Math.PI) / 2),
                          r = h * Math.sin((t * Math.PI) / 2) + d;
                        for (let e = 0, i = A.length; e < i; e++) {
                          const t = C(A[e], I[e], r);
                          B(t.x, t.y, c + n);
                        }
                        for (let e = 0, i = M.length; e < i; e++) {
                          const t = M[e];
                          k = O[e];
                          for (let e = 0, i = t.length; e < i; e++) {
                            const i = C(t[e], k[e], r);
                            _
                              ? B(i.x, i.y + g[s - 1].y, g[s - 1].x + n)
                              : B(i.x, i.y, c + n);
                          }
                        }
                      }
                      function z() {
                        const t = r.length / 3;
                        if (l) {
                          let t = 0,
                            e = L * t;
                          for (let n = 0; n < R; n++) {
                            const t = E[n];
                            j(t[2] + e, t[1] + e, t[0] + e);
                          }
                          (t = s + 2 * f), (e = L * t);
                          for (let n = 0; n < R; n++) {
                            const t = E[n];
                            j(t[0] + e, t[1] + e, t[2] + e);
                          }
                        } else {
                          for (let t = 0; t < R; t++) {
                            const e = E[t];
                            j(e[2], e[1], e[0]);
                          }
                          for (let t = 0; t < R; t++) {
                            const e = E[t];
                            j(e[0] + L * s, e[1] + L * s, e[2] + L * s);
                          }
                        }
                        n.addGroup(t, r.length / 3 - t, 0);
                      }
                      function F() {
                        const t = r.length / 3;
                        let e = 0;
                        U(A, e), (e += A.length);
                        for (let n = 0, r = M.length; n < r; n++) {
                          const t = M[n];
                          U(t, e), (e += t.length);
                        }
                        n.addGroup(t, r.length / 3 - t, 1);
                      }
                      function U(t, e) {
                        let n = t.length;
                        while (--n >= 0) {
                          const r = n;
                          let i = n - 1;
                          i < 0 && (i = t.length - 1);
                          for (let t = 0, n = s + 2 * f; t < n; t++) {
                            const n = L * t,
                              a = L * (t + 1),
                              o = e + r + n,
                              s = e + i + n,
                              c = e + i + a,
                              l = e + r + a;
                            H(o, s, c, l);
                          }
                        }
                      }
                      function B(t, e, n) {
                        a.push(t), a.push(e), a.push(n);
                      }
                      function j(t, e, i) {
                        V(t), V(e), V(i);
                        const a = r.length / 3,
                          o = m.generateTopUV(n, r, a - 3, a - 2, a - 1);
                        G(o[0]), G(o[1]), G(o[2]);
                      }
                      function H(t, e, i, a) {
                        V(t), V(e), V(a), V(e), V(i), V(a);
                        const o = r.length / 3,
                          s = m.generateSideWallUV(
                            n,
                            r,
                            o - 6,
                            o - 3,
                            o - 2,
                            o - 1
                          );
                        G(s[0]), G(s[1]), G(s[3]), G(s[1]), G(s[2]), G(s[3]);
                      }
                      function V(t) {
                        r.push(a[3 * t + 0]),
                          r.push(a[3 * t + 1]),
                          r.push(a[3 * t + 2]);
                      }
                      function G(t) {
                        i.push(t.x), i.push(t.y);
                      }
                      z(), F();
                    }
                    this.setAttribute("position", new di(r, 3)),
                      this.setAttribute("uv", new di(i, 2)),
                      this.computeVertexNormals();
                  }
                  toJSON() {
                    const t = super.toJSON(),
                      e = this.parameters.shapes,
                      n = this.parameters.options;
                    return vf(e, n, t);
                  }
                  static fromJSON(t, e) {
                    const n = [];
                    for (let i = 0, a = t.shapes.length; i < a; i++) {
                      const r = e[t.shapes[i]];
                      n.push(r);
                    }
                    const r = t.options.extrudePath;
                    return (
                      void 0 !== r &&
                        (t.options.extrudePath = new vd[r.type]().fromJSON(r)),
                      new mf(n, t.options)
                    );
                  }
                }
                const gf = {
                  generateTopUV: function (t, e, n, r, i) {
                    const a = e[3 * n],
                      o = e[3 * n + 1],
                      s = e[3 * r],
                      c = e[3 * r + 1],
                      l = e[3 * i],
                      u = e[3 * i + 1];
                    return [new gn(a, o), new gn(s, c), new gn(l, u)];
                  },
                  generateSideWallUV: function (t, e, n, r, i, a) {
                    const o = e[3 * n],
                      s = e[3 * n + 1],
                      c = e[3 * n + 2],
                      l = e[3 * r],
                      u = e[3 * r + 1],
                      h = e[3 * r + 2],
                      d = e[3 * i],
                      f = e[3 * i + 1],
                      p = e[3 * i + 2],
                      m = e[3 * a],
                      g = e[3 * a + 1],
                      v = e[3 * a + 2];
                    return Math.abs(s - u) < Math.abs(o - l)
                      ? [
                          new gn(o, 1 - c),
                          new gn(l, 1 - h),
                          new gn(d, 1 - p),
                          new gn(m, 1 - v),
                        ]
                      : [
                          new gn(s, 1 - c),
                          new gn(u, 1 - h),
                          new gn(f, 1 - p),
                          new gn(g, 1 - v),
                        ];
                  },
                };
                function vf(t, e, n) {
                  if (((n.shapes = []), Array.isArray(t)))
                    for (let r = 0, i = t.length; r < i; r++) {
                      const e = t[r];
                      n.shapes.push(e.uuid);
                    }
                  else n.shapes.push(t.uuid);
                  return (
                    (n.options = Object.assign({}, e)),
                    void 0 !== e.extrudePath &&
                      (n.options.extrudePath = e.extrudePath.toJSON()),
                    n
                  );
                }
                class yf extends Td {
                  constructor(t = 1, e = 0) {
                    const n = (1 + Math.sqrt(5)) / 2,
                      r = [
                        -1,
                        n,
                        0,
                        1,
                        n,
                        0,
                        -1,
                        -n,
                        0,
                        1,
                        -n,
                        0,
                        0,
                        -1,
                        n,
                        0,
                        1,
                        n,
                        0,
                        -1,
                        -n,
                        0,
                        1,
                        -n,
                        n,
                        0,
                        -1,
                        n,
                        0,
                        1,
                        -n,
                        0,
                        -1,
                        -n,
                        0,
                        1,
                      ],
                      i = [
                        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5,
                        9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3,
                        4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6,
                        2, 10, 8, 6, 7, 9, 8, 1,
                      ];
                    super(r, i, t, e),
                      (this.type = "IcosahedronGeometry"),
                      (this.parameters = { radius: t, detail: e });
                  }
                  static fromJSON(t) {
                    return new yf(t.radius, t.detail);
                  }
                }
                class bf extends Td {
                  constructor(t = 1, e = 0) {
                    const n = [
                        1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1,
                      ],
                      r = [
                        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1,
                        3, 4, 1, 4, 2,
                      ];
                    super(n, r, t, e),
                      (this.type = "OctahedronGeometry"),
                      (this.parameters = { radius: t, detail: e });
                  }
                  static fromJSON(t) {
                    return new bf(t.radius, t.detail);
                  }
                }
                class xf extends xi {
                  constructor(
                    t = 0.5,
                    e = 1,
                    n = 8,
                    r = 1,
                    i = 0,
                    a = 2 * Math.PI
                  ) {
                    super(),
                      (this.type = "RingGeometry"),
                      (this.parameters = {
                        innerRadius: t,
                        outerRadius: e,
                        thetaSegments: n,
                        phiSegments: r,
                        thetaStart: i,
                        thetaLength: a,
                      }),
                      (n = Math.max(3, n)),
                      (r = Math.max(1, r));
                    const o = [],
                      s = [],
                      c = [],
                      l = [];
                    let u = t;
                    const h = (e - t) / r,
                      d = new Gn(),
                      f = new gn();
                    for (let p = 0; p <= r; p++) {
                      for (let t = 0; t <= n; t++) {
                        const r = i + (t / n) * a;
                        (d.x = u * Math.cos(r)),
                          (d.y = u * Math.sin(r)),
                          s.push(d.x, d.y, d.z),
                          c.push(0, 0, 1),
                          (f.x = (d.x / e + 1) / 2),
                          (f.y = (d.y / e + 1) / 2),
                          l.push(f.x, f.y);
                      }
                      u += h;
                    }
                    for (let p = 0; p < r; p++) {
                      const t = p * (n + 1);
                      for (let e = 0; e < n; e++) {
                        const r = e + t,
                          i = r,
                          a = r + n + 1,
                          s = r + n + 2,
                          c = r + 1;
                        o.push(i, a, c), o.push(a, s, c);
                      }
                    }
                    this.setIndex(o),
                      this.setAttribute("position", new di(s, 3)),
                      this.setAttribute("normal", new di(c, 3)),
                      this.setAttribute("uv", new di(l, 2));
                  }
                  static fromJSON(t) {
                    return new xf(
                      t.innerRadius,
                      t.outerRadius,
                      t.thetaSegments,
                      t.phiSegments,
                      t.thetaStart,
                      t.thetaLength
                    );
                  }
                }
                class _f extends xi {
                  constructor(
                    t = new Id([
                      new gn(0, 0.5),
                      new gn(-0.5, -0.5),
                      new gn(0.5, -0.5),
                    ]),
                    e = 12
                  ) {
                    super(),
                      (this.type = "ShapeGeometry"),
                      (this.parameters = { shapes: t, curveSegments: e });
                    const n = [],
                      r = [],
                      i = [],
                      a = [];
                    let o = 0,
                      s = 0;
                    if (!1 === Array.isArray(t)) c(t);
                    else
                      for (let l = 0; l < t.length; l++)
                        c(t[l]), this.addGroup(o, s, l), (o += s), (s = 0);
                    function c(t) {
                      const o = r.length / 3,
                        c = t.extractPoints(e);
                      let l = c.shape;
                      const u = c.holes;
                      !1 === df.isClockWise(l) && (l = l.reverse());
                      for (let e = 0, n = u.length; e < n; e++) {
                        const t = u[e];
                        !0 === df.isClockWise(t) && (u[e] = t.reverse());
                      }
                      const h = df.triangulateShape(l, u);
                      for (let e = 0, n = u.length; e < n; e++) {
                        const t = u[e];
                        l = l.concat(t);
                      }
                      for (let e = 0, n = l.length; e < n; e++) {
                        const t = l[e];
                        r.push(t.x, t.y, 0), i.push(0, 0, 1), a.push(t.x, t.y);
                      }
                      for (let e = 0, r = h.length; e < r; e++) {
                        const t = h[e],
                          r = t[0] + o,
                          i = t[1] + o,
                          a = t[2] + o;
                        n.push(r, i, a), (s += 3);
                      }
                    }
                    this.setIndex(n),
                      this.setAttribute("position", new di(r, 3)),
                      this.setAttribute("normal", new di(i, 3)),
                      this.setAttribute("uv", new di(a, 2));
                  }
                  toJSON() {
                    const t = super.toJSON(),
                      e = this.parameters.shapes;
                    return wf(e, t);
                  }
                  static fromJSON(t, e) {
                    const n = [];
                    for (let r = 0, i = t.shapes.length; r < i; r++) {
                      const i = e[t.shapes[r]];
                      n.push(i);
                    }
                    return new _f(n, t.curveSegments);
                  }
                }
                function wf(t, e) {
                  if (((e.shapes = []), Array.isArray(t)))
                    for (let n = 0, r = t.length; n < r; n++) {
                      const r = t[n];
                      e.shapes.push(r.uuid);
                    }
                  else e.shapes.push(t.uuid);
                  return e;
                }
                class Sf extends xi {
                  constructor(
                    t = 1,
                    e = 32,
                    n = 16,
                    r = 0,
                    i = 2 * Math.PI,
                    a = 0,
                    o = Math.PI
                  ) {
                    super(),
                      (this.type = "SphereGeometry"),
                      (this.parameters = {
                        radius: t,
                        widthSegments: e,
                        heightSegments: n,
                        phiStart: r,
                        phiLength: i,
                        thetaStart: a,
                        thetaLength: o,
                      }),
                      (e = Math.max(3, Math.floor(e))),
                      (n = Math.max(2, Math.floor(n)));
                    const s = Math.min(a + o, Math.PI);
                    let c = 0;
                    const l = [],
                      u = new Gn(),
                      h = new Gn(),
                      d = [],
                      f = [],
                      p = [],
                      m = [];
                    for (let g = 0; g <= n; g++) {
                      const d = [],
                        v = g / n;
                      let y = 0;
                      0 == g && 0 == a
                        ? (y = 0.5 / e)
                        : g == n && s == Math.PI && (y = -0.5 / e);
                      for (let n = 0; n <= e; n++) {
                        const s = n / e;
                        (u.x = -t * Math.cos(r + s * i) * Math.sin(a + v * o)),
                          (u.y = t * Math.cos(a + v * o)),
                          (u.z = t * Math.sin(r + s * i) * Math.sin(a + v * o)),
                          f.push(u.x, u.y, u.z),
                          h.copy(u).normalize(),
                          p.push(h.x, h.y, h.z),
                          m.push(s + y, 1 - v),
                          d.push(c++);
                      }
                      l.push(d);
                    }
                    for (let g = 0; g < n; g++)
                      for (let t = 0; t < e; t++) {
                        const e = l[g][t + 1],
                          r = l[g][t],
                          i = l[g + 1][t],
                          o = l[g + 1][t + 1];
                        (0 !== g || a > 0) && d.push(e, r, o),
                          (g !== n - 1 || s < Math.PI) && d.push(r, i, o);
                      }
                    this.setIndex(d),
                      this.setAttribute("position", new di(f, 3)),
                      this.setAttribute("normal", new di(p, 3)),
                      this.setAttribute("uv", new di(m, 2));
                  }
                  static fromJSON(t) {
                    return new Sf(
                      t.radius,
                      t.widthSegments,
                      t.heightSegments,
                      t.phiStart,
                      t.phiLength,
                      t.thetaStart,
                      t.thetaLength
                    );
                  }
                }
                class Mf extends Td {
                  constructor(t = 1, e = 0) {
                    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                    super(n, r, t, e),
                      (this.type = "TetrahedronGeometry"),
                      (this.parameters = { radius: t, detail: e });
                  }
                  static fromJSON(t) {
                    return new Mf(t.radius, t.detail);
                  }
                }
                class Tf extends xi {
                  constructor(t = 1, e = 0.4, n = 8, r = 6, i = 2 * Math.PI) {
                    super(),
                      (this.type = "TorusGeometry"),
                      (this.parameters = {
                        radius: t,
                        tube: e,
                        radialSegments: n,
                        tubularSegments: r,
                        arc: i,
                      }),
                      (n = Math.floor(n)),
                      (r = Math.floor(r));
                    const a = [],
                      o = [],
                      s = [],
                      c = [],
                      l = new Gn(),
                      u = new Gn(),
                      h = new Gn();
                    for (let d = 0; d <= n; d++)
                      for (let a = 0; a <= r; a++) {
                        const f = (a / r) * i,
                          p = (d / n) * Math.PI * 2;
                        (u.x = (t + e * Math.cos(p)) * Math.cos(f)),
                          (u.y = (t + e * Math.cos(p)) * Math.sin(f)),
                          (u.z = e * Math.sin(p)),
                          o.push(u.x, u.y, u.z),
                          (l.x = t * Math.cos(f)),
                          (l.y = t * Math.sin(f)),
                          h.subVectors(u, l).normalize(),
                          s.push(h.x, h.y, h.z),
                          c.push(a / r),
                          c.push(d / n);
                      }
                    for (let d = 1; d <= n; d++)
                      for (let t = 1; t <= r; t++) {
                        const e = (r + 1) * d + t - 1,
                          n = (r + 1) * (d - 1) + t - 1,
                          i = (r + 1) * (d - 1) + t,
                          o = (r + 1) * d + t;
                        a.push(e, n, o), a.push(n, i, o);
                      }
                    this.setIndex(a),
                      this.setAttribute("position", new di(o, 3)),
                      this.setAttribute("normal", new di(s, 3)),
                      this.setAttribute("uv", new di(c, 2));
                  }
                  static fromJSON(t) {
                    return new Tf(
                      t.radius,
                      t.tube,
                      t.radialSegments,
                      t.tubularSegments,
                      t.arc
                    );
                  }
                }
                class Ef extends xi {
                  constructor(t = 1, e = 0.4, n = 64, r = 8, i = 2, a = 3) {
                    super(),
                      (this.type = "TorusKnotGeometry"),
                      (this.parameters = {
                        radius: t,
                        tube: e,
                        tubularSegments: n,
                        radialSegments: r,
                        p: i,
                        q: a,
                      }),
                      (n = Math.floor(n)),
                      (r = Math.floor(r));
                    const o = [],
                      s = [],
                      c = [],
                      l = [],
                      u = new Gn(),
                      h = new Gn(),
                      d = new Gn(),
                      f = new Gn(),
                      p = new Gn(),
                      m = new Gn(),
                      g = new Gn();
                    for (let y = 0; y <= n; ++y) {
                      const o = (y / n) * i * Math.PI * 2;
                      v(o, i, a, t, d),
                        v(o + 0.01, i, a, t, f),
                        m.subVectors(f, d),
                        g.addVectors(f, d),
                        p.crossVectors(m, g),
                        g.crossVectors(p, m),
                        p.normalize(),
                        g.normalize();
                      for (let t = 0; t <= r; ++t) {
                        const i = (t / r) * Math.PI * 2,
                          a = -e * Math.cos(i),
                          o = e * Math.sin(i);
                        (u.x = d.x + (a * g.x + o * p.x)),
                          (u.y = d.y + (a * g.y + o * p.y)),
                          (u.z = d.z + (a * g.z + o * p.z)),
                          s.push(u.x, u.y, u.z),
                          h.subVectors(u, d).normalize(),
                          c.push(h.x, h.y, h.z),
                          l.push(y / n),
                          l.push(t / r);
                      }
                    }
                    for (let y = 1; y <= n; y++)
                      for (let t = 1; t <= r; t++) {
                        const e = (r + 1) * (y - 1) + (t - 1),
                          n = (r + 1) * y + (t - 1),
                          i = (r + 1) * y + t,
                          a = (r + 1) * (y - 1) + t;
                        o.push(e, n, a), o.push(n, i, a);
                      }
                    function v(t, e, n, r, i) {
                      const a = Math.cos(t),
                        o = Math.sin(t),
                        s = (n / e) * t,
                        c = Math.cos(s);
                      (i.x = r * (2 + c) * 0.5 * a),
                        (i.y = r * (2 + c) * o * 0.5),
                        (i.z = r * Math.sin(s) * 0.5);
                    }
                    this.setIndex(o),
                      this.setAttribute("position", new di(s, 3)),
                      this.setAttribute("normal", new di(c, 3)),
                      this.setAttribute("uv", new di(l, 2));
                  }
                  static fromJSON(t) {
                    return new Ef(
                      t.radius,
                      t.tube,
                      t.tubularSegments,
                      t.radialSegments,
                      t.p,
                      t.q
                    );
                  }
                }
                class Af extends xi {
                  constructor(
                    t = new md(
                      new Gn(-1, -1, 0),
                      new Gn(-1, 1, 0),
                      new Gn(1, 1, 0)
                    ),
                    e = 64,
                    n = 1,
                    r = 8,
                    i = !1
                  ) {
                    super(),
                      (this.type = "TubeGeometry"),
                      (this.parameters = {
                        path: t,
                        tubularSegments: e,
                        radius: n,
                        radialSegments: r,
                        closed: i,
                      });
                    const a = t.computeFrenetFrames(e, i);
                    (this.tangents = a.tangents),
                      (this.normals = a.normals),
                      (this.binormals = a.binormals);
                    const o = new Gn(),
                      s = new Gn(),
                      c = new gn();
                    let l = new Gn();
                    const u = [],
                      h = [],
                      d = [],
                      f = [];
                    function p() {
                      for (let t = 0; t < e; t++) m(t);
                      m(!1 === i ? e : 0), v(), g();
                    }
                    function m(i) {
                      l = t.getPointAt(i / e, l);
                      const c = a.normals[i],
                        d = a.binormals[i];
                      for (let t = 0; t <= r; t++) {
                        const e = (t / r) * Math.PI * 2,
                          i = Math.sin(e),
                          a = -Math.cos(e);
                        (s.x = a * c.x + i * d.x),
                          (s.y = a * c.y + i * d.y),
                          (s.z = a * c.z + i * d.z),
                          s.normalize(),
                          h.push(s.x, s.y, s.z),
                          (o.x = l.x + n * s.x),
                          (o.y = l.y + n * s.y),
                          (o.z = l.z + n * s.z),
                          u.push(o.x, o.y, o.z);
                      }
                    }
                    function g() {
                      for (let t = 1; t <= e; t++)
                        for (let e = 1; e <= r; e++) {
                          const n = (r + 1) * (t - 1) + (e - 1),
                            i = (r + 1) * t + (e - 1),
                            a = (r + 1) * t + e,
                            o = (r + 1) * (t - 1) + e;
                          f.push(n, i, o), f.push(i, a, o);
                        }
                    }
                    function v() {
                      for (let t = 0; t <= e; t++)
                        for (let n = 0; n <= r; n++)
                          (c.x = t / e), (c.y = n / r), d.push(c.x, c.y);
                    }
                    p(),
                      this.setIndex(f),
                      this.setAttribute("position", new di(u, 3)),
                      this.setAttribute("normal", new di(h, 3)),
                      this.setAttribute("uv", new di(d, 2));
                  }
                  toJSON() {
                    const t = super.toJSON();
                    return (t.path = this.parameters.path.toJSON()), t;
                  }
                  static fromJSON(t) {
                    return new Af(
                      new vd[t.path.type]().fromJSON(t.path),
                      t.tubularSegments,
                      t.radius,
                      t.radialSegments,
                      t.closed
                    );
                  }
                }
                class Cf extends xi {
                  constructor(t = null) {
                    if (
                      (super(),
                      (this.type = "WireframeGeometry"),
                      (this.parameters = { geometry: t }),
                      null !== t)
                    ) {
                      const e = [],
                        n = new Set(),
                        r = new Gn(),
                        i = new Gn();
                      if (null !== t.index) {
                        const a = t.attributes.position,
                          o = t.index;
                        let s = t.groups;
                        0 === s.length &&
                          (s = [
                            { start: 0, count: o.count, materialIndex: 0 },
                          ]);
                        for (let t = 0, c = s.length; t < c; ++t) {
                          const c = s[t],
                            l = c.start,
                            u = c.count;
                          for (let t = l, s = l + u; t < s; t += 3)
                            for (let c = 0; c < 3; c++) {
                              const s = o.getX(t + c),
                                l = o.getX(t + ((c + 1) % 3));
                              r.fromBufferAttribute(a, s),
                                i.fromBufferAttribute(a, l),
                                !0 === Lf(r, i, n) &&
                                  (e.push(r.x, r.y, r.z),
                                  e.push(i.x, i.y, i.z));
                            }
                        }
                      } else {
                        const a = t.attributes.position;
                        for (let t = 0, o = a.count / 3; t < o; t++)
                          for (let s = 0; s < 3; s++) {
                            const o = 3 * t + s,
                              c = 3 * t + ((s + 1) % 3);
                            r.fromBufferAttribute(a, o),
                              i.fromBufferAttribute(a, c),
                              !0 === Lf(r, i, n) &&
                                (e.push(r.x, r.y, r.z), e.push(i.x, i.y, i.z));
                          }
                      }
                      this.setAttribute("position", new di(e, 3));
                    }
                  }
                }
                function Lf(t, e, n) {
                  const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                    i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                  return (
                    !0 !== n.has(r) &&
                    !0 !== n.has(i) &&
                    (n.add(r), n.add(i), !0)
                  );
                }
                var Rf = Object.freeze({
                  __proto__: null,
                  BoxGeometry: ji,
                  BoxBufferGeometry: ji,
                  CapsuleGeometry: _d,
                  CapsuleBufferGeometry: _d,
                  CircleGeometry: wd,
                  CircleBufferGeometry: wd,
                  ConeGeometry: Md,
                  ConeBufferGeometry: Md,
                  CylinderGeometry: Sd,
                  CylinderBufferGeometry: Sd,
                  DodecahedronGeometry: Ed,
                  DodecahedronBufferGeometry: Ed,
                  EdgesGeometry: Pd,
                  ExtrudeGeometry: mf,
                  ExtrudeBufferGeometry: mf,
                  IcosahedronGeometry: yf,
                  IcosahedronBufferGeometry: yf,
                  LatheGeometry: xd,
                  LatheBufferGeometry: xd,
                  OctahedronGeometry: bf,
                  OctahedronBufferGeometry: bf,
                  PlaneGeometry: ua,
                  PlaneBufferGeometry: ua,
                  PolyhedronGeometry: Td,
                  PolyhedronBufferGeometry: Td,
                  RingGeometry: xf,
                  RingBufferGeometry: xf,
                  ShapeGeometry: _f,
                  ShapeBufferGeometry: _f,
                  SphereGeometry: Sf,
                  SphereBufferGeometry: Sf,
                  TetrahedronGeometry: Mf,
                  TetrahedronBufferGeometry: Mf,
                  TorusGeometry: Tf,
                  TorusBufferGeometry: Tf,
                  TorusKnotGeometry: Ef,
                  TorusKnotBufferGeometry: Ef,
                  TubeGeometry: Af,
                  TubeBufferGeometry: Af,
                  WireframeGeometry: Cf,
                });
                class Pf extends ai {
                  constructor(t) {
                    super(),
                      (this.isShadowMaterial = !0),
                      (this.type = "ShadowMaterial"),
                      (this.color = new In(0)),
                      (this.transparent = !0),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class If extends Xi {
                  constructor(t) {
                    super(t),
                      (this.isRawShaderMaterial = !0),
                      (this.type = "RawShaderMaterial");
                  }
                }
                class Of extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshStandardMaterial = !0),
                      (this.defines = { STANDARD: "" }),
                      (this.type = "MeshStandardMaterial"),
                      (this.color = new In(16777215)),
                      (this.roughness = 1),
                      (this.metalness = 0),
                      (this.map = null),
                      (this.lightMap = null),
                      (this.lightMapIntensity = 1),
                      (this.aoMap = null),
                      (this.aoMapIntensity = 1),
                      (this.emissive = new In(0)),
                      (this.emissiveIntensity = 1),
                      (this.emissiveMap = null),
                      (this.bumpMap = null),
                      (this.bumpScale = 1),
                      (this.normalMap = null),
                      (this.normalMapType = Ie),
                      (this.normalScale = new gn(1, 1)),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.roughnessMap = null),
                      (this.metalnessMap = null),
                      (this.alphaMap = null),
                      (this.envMap = null),
                      (this.envMapIntensity = 1),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.wireframeLinecap = "round"),
                      (this.wireframeLinejoin = "round"),
                      (this.flatShading = !1),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.defines = { STANDARD: "" }),
                      this.color.copy(t.color),
                      (this.roughness = t.roughness),
                      (this.metalness = t.metalness),
                      (this.map = t.map),
                      (this.lightMap = t.lightMap),
                      (this.lightMapIntensity = t.lightMapIntensity),
                      (this.aoMap = t.aoMap),
                      (this.aoMapIntensity = t.aoMapIntensity),
                      this.emissive.copy(t.emissive),
                      (this.emissiveMap = t.emissiveMap),
                      (this.emissiveIntensity = t.emissiveIntensity),
                      (this.bumpMap = t.bumpMap),
                      (this.bumpScale = t.bumpScale),
                      (this.normalMap = t.normalMap),
                      (this.normalMapType = t.normalMapType),
                      this.normalScale.copy(t.normalScale),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.roughnessMap = t.roughnessMap),
                      (this.metalnessMap = t.metalnessMap),
                      (this.alphaMap = t.alphaMap),
                      (this.envMap = t.envMap),
                      (this.envMapIntensity = t.envMapIntensity),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.wireframeLinecap = t.wireframeLinecap),
                      (this.wireframeLinejoin = t.wireframeLinejoin),
                      (this.flatShading = t.flatShading),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class kf extends Of {
                  constructor(t) {
                    super(),
                      (this.isMeshPhysicalMaterial = !0),
                      (this.defines = { STANDARD: "", PHYSICAL: "" }),
                      (this.type = "MeshPhysicalMaterial"),
                      (this.clearcoatMap = null),
                      (this.clearcoatRoughness = 0),
                      (this.clearcoatRoughnessMap = null),
                      (this.clearcoatNormalScale = new gn(1, 1)),
                      (this.clearcoatNormalMap = null),
                      (this.ior = 1.5),
                      Object.defineProperty(this, "reflectivity", {
                        get: function () {
                          return Xe(
                            (2.5 * (this.ior - 1)) / (this.ior + 1),
                            0,
                            1
                          );
                        },
                        set: function (t) {
                          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                        },
                      }),
                      (this.iridescenceMap = null),
                      (this.iridescenceIOR = 1.3),
                      (this.iridescenceThicknessRange = [100, 400]),
                      (this.iridescenceThicknessMap = null),
                      (this.sheenColor = new In(0)),
                      (this.sheenColorMap = null),
                      (this.sheenRoughness = 1),
                      (this.sheenRoughnessMap = null),
                      (this.transmissionMap = null),
                      (this.thickness = 0),
                      (this.thicknessMap = null),
                      (this.attenuationDistance = 0),
                      (this.attenuationColor = new In(1, 1, 1)),
                      (this.specularIntensity = 1),
                      (this.specularIntensityMap = null),
                      (this.specularColor = new In(1, 1, 1)),
                      (this.specularColorMap = null),
                      (this._sheen = 0),
                      (this._clearcoat = 0),
                      (this._iridescence = 0),
                      (this._transmission = 0),
                      this.setValues(t);
                  }
                  get sheen() {
                    return this._sheen;
                  }
                  set sheen(t) {
                    this._sheen > 0 !== t > 0 && this.version++,
                      (this._sheen = t);
                  }
                  get clearcoat() {
                    return this._clearcoat;
                  }
                  set clearcoat(t) {
                    this._clearcoat > 0 !== t > 0 && this.version++,
                      (this._clearcoat = t);
                  }
                  get iridescence() {
                    return this._iridescence;
                  }
                  set iridescence(t) {
                    this._iridescence > 0 !== t > 0 && this.version++,
                      (this._iridescence = t);
                  }
                  get transmission() {
                    return this._transmission;
                  }
                  set transmission(t) {
                    this._transmission > 0 !== t > 0 && this.version++,
                      (this._transmission = t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.defines = { STANDARD: "", PHYSICAL: "" }),
                      (this.clearcoat = t.clearcoat),
                      (this.clearcoatMap = t.clearcoatMap),
                      (this.clearcoatRoughness = t.clearcoatRoughness),
                      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
                      (this.clearcoatNormalMap = t.clearcoatNormalMap),
                      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                      (this.ior = t.ior),
                      (this.iridescence = t.iridescence),
                      (this.iridescenceMap = t.iridescenceMap),
                      (this.iridescenceIOR = t.iridescenceIOR),
                      (this.iridescenceThicknessRange = [
                        ...t.iridescenceThicknessRange,
                      ]),
                      (this.iridescenceThicknessMap =
                        t.iridescenceThicknessMap),
                      (this.sheen = t.sheen),
                      this.sheenColor.copy(t.sheenColor),
                      (this.sheenColorMap = t.sheenColorMap),
                      (this.sheenRoughness = t.sheenRoughness),
                      (this.sheenRoughnessMap = t.sheenRoughnessMap),
                      (this.transmission = t.transmission),
                      (this.transmissionMap = t.transmissionMap),
                      (this.thickness = t.thickness),
                      (this.thicknessMap = t.thicknessMap),
                      (this.attenuationDistance = t.attenuationDistance),
                      this.attenuationColor.copy(t.attenuationColor),
                      (this.specularIntensity = t.specularIntensity),
                      (this.specularIntensityMap = t.specularIntensityMap),
                      this.specularColor.copy(t.specularColor),
                      (this.specularColorMap = t.specularColorMap),
                      this
                    );
                  }
                }
                class Nf extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshPhongMaterial = !0),
                      (this.type = "MeshPhongMaterial"),
                      (this.color = new In(16777215)),
                      (this.specular = new In(1118481)),
                      (this.shininess = 30),
                      (this.map = null),
                      (this.lightMap = null),
                      (this.lightMapIntensity = 1),
                      (this.aoMap = null),
                      (this.aoMapIntensity = 1),
                      (this.emissive = new In(0)),
                      (this.emissiveIntensity = 1),
                      (this.emissiveMap = null),
                      (this.bumpMap = null),
                      (this.bumpScale = 1),
                      (this.normalMap = null),
                      (this.normalMapType = Ie),
                      (this.normalScale = new gn(1, 1)),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.specularMap = null),
                      (this.alphaMap = null),
                      (this.envMap = null),
                      (this.combine = J),
                      (this.reflectivity = 1),
                      (this.refractionRatio = 0.98),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.wireframeLinecap = "round"),
                      (this.wireframeLinejoin = "round"),
                      (this.flatShading = !1),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      this.specular.copy(t.specular),
                      (this.shininess = t.shininess),
                      (this.map = t.map),
                      (this.lightMap = t.lightMap),
                      (this.lightMapIntensity = t.lightMapIntensity),
                      (this.aoMap = t.aoMap),
                      (this.aoMapIntensity = t.aoMapIntensity),
                      this.emissive.copy(t.emissive),
                      (this.emissiveMap = t.emissiveMap),
                      (this.emissiveIntensity = t.emissiveIntensity),
                      (this.bumpMap = t.bumpMap),
                      (this.bumpScale = t.bumpScale),
                      (this.normalMap = t.normalMap),
                      (this.normalMapType = t.normalMapType),
                      this.normalScale.copy(t.normalScale),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.specularMap = t.specularMap),
                      (this.alphaMap = t.alphaMap),
                      (this.envMap = t.envMap),
                      (this.combine = t.combine),
                      (this.reflectivity = t.reflectivity),
                      (this.refractionRatio = t.refractionRatio),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.wireframeLinecap = t.wireframeLinecap),
                      (this.wireframeLinejoin = t.wireframeLinejoin),
                      (this.flatShading = t.flatShading),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class Df extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshToonMaterial = !0),
                      (this.defines = { TOON: "" }),
                      (this.type = "MeshToonMaterial"),
                      (this.color = new In(16777215)),
                      (this.map = null),
                      (this.gradientMap = null),
                      (this.lightMap = null),
                      (this.lightMapIntensity = 1),
                      (this.aoMap = null),
                      (this.aoMapIntensity = 1),
                      (this.emissive = new In(0)),
                      (this.emissiveIntensity = 1),
                      (this.emissiveMap = null),
                      (this.bumpMap = null),
                      (this.bumpScale = 1),
                      (this.normalMap = null),
                      (this.normalMapType = Ie),
                      (this.normalScale = new gn(1, 1)),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.alphaMap = null),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.wireframeLinecap = "round"),
                      (this.wireframeLinejoin = "round"),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.map = t.map),
                      (this.gradientMap = t.gradientMap),
                      (this.lightMap = t.lightMap),
                      (this.lightMapIntensity = t.lightMapIntensity),
                      (this.aoMap = t.aoMap),
                      (this.aoMapIntensity = t.aoMapIntensity),
                      this.emissive.copy(t.emissive),
                      (this.emissiveMap = t.emissiveMap),
                      (this.emissiveIntensity = t.emissiveIntensity),
                      (this.bumpMap = t.bumpMap),
                      (this.bumpScale = t.bumpScale),
                      (this.normalMap = t.normalMap),
                      (this.normalMapType = t.normalMapType),
                      this.normalScale.copy(t.normalScale),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.alphaMap = t.alphaMap),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.wireframeLinecap = t.wireframeLinecap),
                      (this.wireframeLinejoin = t.wireframeLinejoin),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class zf extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshNormalMaterial = !0),
                      (this.type = "MeshNormalMaterial"),
                      (this.bumpMap = null),
                      (this.bumpScale = 1),
                      (this.normalMap = null),
                      (this.normalMapType = Ie),
                      (this.normalScale = new gn(1, 1)),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.flatShading = !1),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.bumpMap = t.bumpMap),
                      (this.bumpScale = t.bumpScale),
                      (this.normalMap = t.normalMap),
                      (this.normalMapType = t.normalMapType),
                      this.normalScale.copy(t.normalScale),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.flatShading = t.flatShading),
                      this
                    );
                  }
                }
                class Ff extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshLambertMaterial = !0),
                      (this.type = "MeshLambertMaterial"),
                      (this.color = new In(16777215)),
                      (this.map = null),
                      (this.lightMap = null),
                      (this.lightMapIntensity = 1),
                      (this.aoMap = null),
                      (this.aoMapIntensity = 1),
                      (this.emissive = new In(0)),
                      (this.emissiveIntensity = 1),
                      (this.emissiveMap = null),
                      (this.specularMap = null),
                      (this.alphaMap = null),
                      (this.envMap = null),
                      (this.combine = J),
                      (this.reflectivity = 1),
                      (this.refractionRatio = 0.98),
                      (this.wireframe = !1),
                      (this.wireframeLinewidth = 1),
                      (this.wireframeLinecap = "round"),
                      (this.wireframeLinejoin = "round"),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      this.color.copy(t.color),
                      (this.map = t.map),
                      (this.lightMap = t.lightMap),
                      (this.lightMapIntensity = t.lightMapIntensity),
                      (this.aoMap = t.aoMap),
                      (this.aoMapIntensity = t.aoMapIntensity),
                      this.emissive.copy(t.emissive),
                      (this.emissiveMap = t.emissiveMap),
                      (this.emissiveIntensity = t.emissiveIntensity),
                      (this.specularMap = t.specularMap),
                      (this.alphaMap = t.alphaMap),
                      (this.envMap = t.envMap),
                      (this.combine = t.combine),
                      (this.reflectivity = t.reflectivity),
                      (this.refractionRatio = t.refractionRatio),
                      (this.wireframe = t.wireframe),
                      (this.wireframeLinewidth = t.wireframeLinewidth),
                      (this.wireframeLinecap = t.wireframeLinecap),
                      (this.wireframeLinejoin = t.wireframeLinejoin),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class Uf extends ai {
                  constructor(t) {
                    super(),
                      (this.isMeshMatcapMaterial = !0),
                      (this.defines = { MATCAP: "" }),
                      (this.type = "MeshMatcapMaterial"),
                      (this.color = new In(16777215)),
                      (this.matcap = null),
                      (this.map = null),
                      (this.bumpMap = null),
                      (this.bumpScale = 1),
                      (this.normalMap = null),
                      (this.normalMapType = Ie),
                      (this.normalScale = new gn(1, 1)),
                      (this.displacementMap = null),
                      (this.displacementScale = 1),
                      (this.displacementBias = 0),
                      (this.alphaMap = null),
                      (this.flatShading = !1),
                      (this.fog = !0),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.defines = { MATCAP: "" }),
                      this.color.copy(t.color),
                      (this.matcap = t.matcap),
                      (this.map = t.map),
                      (this.bumpMap = t.bumpMap),
                      (this.bumpScale = t.bumpScale),
                      (this.normalMap = t.normalMap),
                      (this.normalMapType = t.normalMapType),
                      this.normalScale.copy(t.normalScale),
                      (this.displacementMap = t.displacementMap),
                      (this.displacementScale = t.displacementScale),
                      (this.displacementBias = t.displacementBias),
                      (this.alphaMap = t.alphaMap),
                      (this.flatShading = t.flatShading),
                      (this.fog = t.fog),
                      this
                    );
                  }
                }
                class Bf extends Eh {
                  constructor(t) {
                    super(),
                      (this.isLineDashedMaterial = !0),
                      (this.type = "LineDashedMaterial"),
                      (this.scale = 1),
                      (this.dashSize = 3),
                      (this.gapSize = 1),
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.scale = t.scale),
                      (this.dashSize = t.dashSize),
                      (this.gapSize = t.gapSize),
                      this
                    );
                  }
                }
                const jf = {
                  arraySlice: function (t, e, n) {
                    return jf.isTypedArray(t)
                      ? new t.constructor(
                          t.subarray(e, void 0 !== n ? n : t.length)
                        )
                      : t.slice(e, n);
                  },
                  convertArray: function (t, e, n) {
                    return !t || (!n && t.constructor === e)
                      ? t
                      : "number" === typeof e.BYTES_PER_ELEMENT
                      ? new e(t)
                      : Array.prototype.slice.call(t);
                  },
                  isTypedArray: function (t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView);
                  },
                  getKeyframeOrder: function (t) {
                    function e(e, n) {
                      return t[e] - t[n];
                    }
                    const n = t.length,
                      r = new Array(n);
                    for (let i = 0; i !== n; ++i) r[i] = i;
                    return r.sort(e), r;
                  },
                  sortedArray: function (t, e, n) {
                    const r = t.length,
                      i = new t.constructor(r);
                    for (let a = 0, o = 0; o !== r; ++a) {
                      const r = n[a] * e;
                      for (let n = 0; n !== e; ++n) i[o++] = t[r + n];
                    }
                    return i;
                  },
                  flattenJSON: function (t, e, n, r) {
                    let i = 1,
                      a = t[0];
                    while (void 0 !== a && void 0 === a[r]) a = t[i++];
                    if (void 0 === a) return;
                    let o = a[r];
                    if (void 0 !== o)
                      if (Array.isArray(o))
                        do {
                          (o = a[r]),
                            void 0 !== o &&
                              (e.push(a.time), n.push.apply(n, o)),
                            (a = t[i++]);
                        } while (void 0 !== a);
                      else if (void 0 !== o.toArray)
                        do {
                          (o = a[r]),
                            void 0 !== o &&
                              (e.push(a.time), o.toArray(n, n.length)),
                            (a = t[i++]);
                        } while (void 0 !== a);
                      else
                        do {
                          (o = a[r]),
                            void 0 !== o && (e.push(a.time), n.push(o)),
                            (a = t[i++]);
                        } while (void 0 !== a);
                  },
                  subclip: function (t, e, n, r, i = 30) {
                    const a = t.clone();
                    a.name = e;
                    const o = [];
                    for (let c = 0; c < a.tracks.length; ++c) {
                      const t = a.tracks[c],
                        e = t.getValueSize(),
                        s = [],
                        l = [];
                      for (let a = 0; a < t.times.length; ++a) {
                        const o = t.times[a] * i;
                        if (!(o < n || o >= r)) {
                          s.push(t.times[a]);
                          for (let n = 0; n < e; ++n)
                            l.push(t.values[a * e + n]);
                        }
                      }
                      0 !== s.length &&
                        ((t.times = jf.convertArray(s, t.times.constructor)),
                        (t.values = jf.convertArray(l, t.values.constructor)),
                        o.push(t));
                    }
                    a.tracks = o;
                    let s = 1 / 0;
                    for (let c = 0; c < a.tracks.length; ++c)
                      s > a.tracks[c].times[0] && (s = a.tracks[c].times[0]);
                    for (let c = 0; c < a.tracks.length; ++c)
                      a.tracks[c].shift(-1 * s);
                    return a.resetDuration(), a;
                  },
                  makeClipAdditive: function (t, e = 0, n = t, r = 30) {
                    r <= 0 && (r = 30);
                    const i = n.tracks.length,
                      a = e / r;
                    for (let o = 0; o < i; ++o) {
                      const e = n.tracks[o],
                        r = e.ValueTypeName;
                      if ("bool" === r || "string" === r) continue;
                      const i = t.tracks.find(function (t) {
                        return t.name === e.name && t.ValueTypeName === r;
                      });
                      if (void 0 === i) continue;
                      let s = 0;
                      const c = e.getValueSize();
                      e.createInterpolant
                        .isInterpolantFactoryMethodGLTFCubicSpline &&
                        (s = c / 3);
                      let l = 0;
                      const u = i.getValueSize();
                      i.createInterpolant
                        .isInterpolantFactoryMethodGLTFCubicSpline &&
                        (l = u / 3);
                      const h = e.times.length - 1;
                      let d;
                      if (a <= e.times[0]) {
                        const t = s,
                          n = c - s;
                        d = jf.arraySlice(e.values, t, n);
                      } else if (a >= e.times[h]) {
                        const t = h * c + s,
                          n = t + c - s;
                        d = jf.arraySlice(e.values, t, n);
                      } else {
                        const t = e.createInterpolant(),
                          n = s,
                          r = c - s;
                        t.evaluate(a),
                          (d = jf.arraySlice(t.resultBuffer, n, r));
                      }
                      if ("quaternion" === r) {
                        const t = new Vn().fromArray(d).normalize().conjugate();
                        t.toArray(d);
                      }
                      const f = i.times.length;
                      for (let t = 0; t < f; ++t) {
                        const e = t * u + l;
                        if ("quaternion" === r)
                          Vn.multiplyQuaternionsFlat(
                            i.values,
                            e,
                            d,
                            0,
                            i.values,
                            e
                          );
                        else {
                          const t = u - 2 * l;
                          for (let n = 0; n < t; ++n) i.values[e + n] -= d[n];
                        }
                      }
                    }
                    return (t.blendMode = Te), t;
                  },
                };
                class Hf {
                  constructor(t, e, n, r) {
                    (this.parameterPositions = t),
                      (this._cachedIndex = 0),
                      (this.resultBuffer =
                        void 0 !== r ? r : new e.constructor(n)),
                      (this.sampleValues = e),
                      (this.valueSize = n),
                      (this.settings = null),
                      (this.DefaultSettings_ = {});
                  }
                  evaluate(t) {
                    const e = this.parameterPositions;
                    let n = this._cachedIndex,
                      r = e[n],
                      i = e[n - 1];
                    t: {
                      e: {
                        let a;
                        n: {
                          r: if (!(t < r)) {
                            for (let a = n + 2; ; ) {
                              if (void 0 === r) {
                                if (t < i) break r;
                                return (
                                  (n = e.length),
                                  (this._cachedIndex = n),
                                  this.copySampleValue_(n - 1)
                                );
                              }
                              if (n === a) break;
                              if (((i = r), (r = e[++n]), t < r)) break e;
                            }
                            a = e.length;
                            break n;
                          }
                          if (t >= i) break t;
                          {
                            const o = e[1];
                            t < o && ((n = 2), (i = o));
                            for (let a = n - 2; ; ) {
                              if (void 0 === i)
                                return (
                                  (this._cachedIndex = 0),
                                  this.copySampleValue_(0)
                                );
                              if (n === a) break;
                              if (((r = i), (i = e[--n - 1]), t >= i)) break e;
                            }
                            (a = n), (n = 0);
                          }
                        }
                        while (n < a) {
                          const r = (n + a) >>> 1;
                          t < e[r] ? (a = r) : (n = r + 1);
                        }
                        if (((r = e[n]), (i = e[n - 1]), void 0 === i))
                          return (
                            (this._cachedIndex = 0), this.copySampleValue_(0)
                          );
                        if (void 0 === r)
                          return (
                            (n = e.length),
                            (this._cachedIndex = n),
                            this.copySampleValue_(n - 1)
                          );
                      }
                      (this._cachedIndex = n), this.intervalChanged_(n, i, r);
                    }
                    return this.interpolate_(n, i, t, r);
                  }
                  getSettings_() {
                    return this.settings || this.DefaultSettings_;
                  }
                  copySampleValue_(t) {
                    const e = this.resultBuffer,
                      n = this.sampleValues,
                      r = this.valueSize,
                      i = t * r;
                    for (let a = 0; a !== r; ++a) e[a] = n[i + a];
                    return e;
                  }
                  interpolate_() {
                    throw new Error("call to abstract method");
                  }
                  intervalChanged_() {}
                }
                class Vf extends Hf {
                  constructor(t, e, n, r) {
                    super(t, e, n, r),
                      (this._weightPrev = -0),
                      (this._offsetPrev = -0),
                      (this._weightNext = -0),
                      (this._offsetNext = -0),
                      (this.DefaultSettings_ = {
                        endingStart: _e,
                        endingEnd: _e,
                      });
                  }
                  intervalChanged_(t, e, n) {
                    const r = this.parameterPositions;
                    let i = t - 2,
                      a = t + 1,
                      o = r[i],
                      s = r[a];
                    if (void 0 === o)
                      switch (this.getSettings_().endingStart) {
                        case we:
                          (i = t), (o = 2 * e - n);
                          break;
                        case Se:
                          (i = r.length - 2), (o = e + r[i] - r[i + 1]);
                          break;
                        default:
                          (i = t), (o = n);
                      }
                    if (void 0 === s)
                      switch (this.getSettings_().endingEnd) {
                        case we:
                          (a = t), (s = 2 * n - e);
                          break;
                        case Se:
                          (a = 1), (s = n + r[1] - r[0]);
                          break;
                        default:
                          (a = t - 1), (s = e);
                      }
                    const c = 0.5 * (n - e),
                      l = this.valueSize;
                    (this._weightPrev = c / (e - o)),
                      (this._weightNext = c / (s - n)),
                      (this._offsetPrev = i * l),
                      (this._offsetNext = a * l);
                  }
                  interpolate_(t, e, n, r) {
                    const i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = t * o,
                      c = s - o,
                      l = this._offsetPrev,
                      u = this._offsetNext,
                      h = this._weightPrev,
                      d = this._weightNext,
                      f = (n - e) / (r - e),
                      p = f * f,
                      m = p * f,
                      g = -h * m + 2 * h * p - h * f,
                      v = (1 + h) * m + (-1.5 - 2 * h) * p + (-0.5 + h) * f + 1,
                      y = (-1 - d) * m + (1.5 + d) * p + 0.5 * f,
                      b = d * m - d * p;
                    for (let x = 0; x !== o; ++x)
                      i[x] =
                        g * a[l + x] +
                        v * a[c + x] +
                        y * a[s + x] +
                        b * a[u + x];
                    return i;
                  }
                }
                class Gf extends Hf {
                  constructor(t, e, n, r) {
                    super(t, e, n, r);
                  }
                  interpolate_(t, e, n, r) {
                    const i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = t * o,
                      c = s - o,
                      l = (n - e) / (r - e),
                      u = 1 - l;
                    for (let h = 0; h !== o; ++h)
                      i[h] = a[c + h] * u + a[s + h] * l;
                    return i;
                  }
                }
                class Wf extends Hf {
                  constructor(t, e, n, r) {
                    super(t, e, n, r);
                  }
                  interpolate_(t) {
                    return this.copySampleValue_(t - 1);
                  }
                }
                class qf {
                  constructor(t, e, n, r) {
                    if (void 0 === t)
                      throw new Error(
                        "THREE.KeyframeTrack: track name is undefined"
                      );
                    if (void 0 === e || 0 === e.length)
                      throw new Error(
                        "THREE.KeyframeTrack: no keyframes in track named " + t
                      );
                    (this.name = t),
                      (this.times = jf.convertArray(e, this.TimeBufferType)),
                      (this.values = jf.convertArray(n, this.ValueBufferType)),
                      this.setInterpolation(r || this.DefaultInterpolation);
                  }
                  static toJSON(t) {
                    const e = t.constructor;
                    let n;
                    if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                    else {
                      n = {
                        name: t.name,
                        times: jf.convertArray(t.times, Array),
                        values: jf.convertArray(t.values, Array),
                      };
                      const e = t.getInterpolation();
                      e !== t.DefaultInterpolation && (n.interpolation = e);
                    }
                    return (n.type = t.ValueTypeName), n;
                  }
                  InterpolantFactoryMethodDiscrete(t) {
                    return new Wf(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t
                    );
                  }
                  InterpolantFactoryMethodLinear(t) {
                    return new Gf(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t
                    );
                  }
                  InterpolantFactoryMethodSmooth(t) {
                    return new Vf(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t
                    );
                  }
                  setInterpolation(t) {
                    let e;
                    switch (t) {
                      case ye:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                      case be:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                      case xe:
                        e = this.InterpolantFactoryMethodSmooth;
                        break;
                    }
                    if (void 0 === e) {
                      const e =
                        "unsupported interpolation for " +
                        this.ValueTypeName +
                        " keyframe track named " +
                        this.name;
                      if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation);
                      }
                      return console.warn("THREE.KeyframeTrack:", e), this;
                    }
                    return (this.createInterpolant = e), this;
                  }
                  getInterpolation() {
                    switch (this.createInterpolant) {
                      case this.InterpolantFactoryMethodDiscrete:
                        return ye;
                      case this.InterpolantFactoryMethodLinear:
                        return be;
                      case this.InterpolantFactoryMethodSmooth:
                        return xe;
                    }
                  }
                  getValueSize() {
                    return this.values.length / this.times.length;
                  }
                  shift(t) {
                    if (0 !== t) {
                      const e = this.times;
                      for (let n = 0, r = e.length; n !== r; ++n) e[n] += t;
                    }
                    return this;
                  }
                  scale(t) {
                    if (1 !== t) {
                      const e = this.times;
                      for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t;
                    }
                    return this;
                  }
                  trim(t, e) {
                    const n = this.times,
                      r = n.length;
                    let i = 0,
                      a = r - 1;
                    while (i !== r && n[i] < t) ++i;
                    while (-1 !== a && n[a] > e) --a;
                    if ((++a, 0 !== i || a !== r)) {
                      i >= a && ((a = Math.max(a, 1)), (i = a - 1));
                      const t = this.getValueSize();
                      (this.times = jf.arraySlice(n, i, a)),
                        (this.values = jf.arraySlice(
                          this.values,
                          i * t,
                          a * t
                        ));
                    }
                    return this;
                  }
                  validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) !== 0 &&
                      (console.error(
                        "THREE.KeyframeTrack: Invalid value size in track.",
                        this
                      ),
                      (t = !1));
                    const n = this.times,
                      r = this.values,
                      i = n.length;
                    0 === i &&
                      (console.error(
                        "THREE.KeyframeTrack: Track is empty.",
                        this
                      ),
                      (t = !1));
                    let a = null;
                    for (let o = 0; o !== i; o++) {
                      const e = n[o];
                      if ("number" === typeof e && isNaN(e)) {
                        console.error(
                          "THREE.KeyframeTrack: Time is not a valid number.",
                          this,
                          o,
                          e
                        ),
                          (t = !1);
                        break;
                      }
                      if (null !== a && a > e) {
                        console.error(
                          "THREE.KeyframeTrack: Out of order keys.",
                          this,
                          o,
                          e,
                          a
                        ),
                          (t = !1);
                        break;
                      }
                      a = e;
                    }
                    if (void 0 !== r && jf.isTypedArray(r))
                      for (let o = 0, s = r.length; o !== s; ++o) {
                        const e = r[o];
                        if (isNaN(e)) {
                          console.error(
                            "THREE.KeyframeTrack: Value is not a valid number.",
                            this,
                            o,
                            e
                          ),
                            (t = !1);
                          break;
                        }
                      }
                    return t;
                  }
                  optimize() {
                    const t = jf.arraySlice(this.times),
                      e = jf.arraySlice(this.values),
                      n = this.getValueSize(),
                      r = this.getInterpolation() === xe,
                      i = t.length - 1;
                    let a = 1;
                    for (let o = 1; o < i; ++o) {
                      let i = !1;
                      const s = t[o],
                        c = t[o + 1];
                      if (s !== c && (1 !== o || s !== t[0]))
                        if (r) i = !0;
                        else {
                          const t = o * n,
                            r = t - n,
                            a = t + n;
                          for (let o = 0; o !== n; ++o) {
                            const n = e[t + o];
                            if (n !== e[r + o] || n !== e[a + o]) {
                              i = !0;
                              break;
                            }
                          }
                        }
                      if (i) {
                        if (o !== a) {
                          t[a] = t[o];
                          const r = o * n,
                            i = a * n;
                          for (let t = 0; t !== n; ++t) e[i + t] = e[r + t];
                        }
                        ++a;
                      }
                    }
                    if (i > 0) {
                      t[a] = t[i];
                      for (let t = i * n, r = a * n, o = 0; o !== n; ++o)
                        e[r + o] = e[t + o];
                      ++a;
                    }
                    return (
                      a !== t.length
                        ? ((this.times = jf.arraySlice(t, 0, a)),
                          (this.values = jf.arraySlice(e, 0, a * n)))
                        : ((this.times = t), (this.values = e)),
                      this
                    );
                  }
                  clone() {
                    const t = jf.arraySlice(this.times, 0),
                      e = jf.arraySlice(this.values, 0),
                      n = this.constructor,
                      r = new n(this.name, t, e);
                    return (r.createInterpolant = this.createInterpolant), r;
                  }
                }
                (qf.prototype.TimeBufferType = Float32Array),
                  (qf.prototype.ValueBufferType = Float32Array),
                  (qf.prototype.DefaultInterpolation = be);
                class Xf extends qf {}
                (Xf.prototype.ValueTypeName = "bool"),
                  (Xf.prototype.ValueBufferType = Array),
                  (Xf.prototype.DefaultInterpolation = ye),
                  (Xf.prototype.InterpolantFactoryMethodLinear = void 0),
                  (Xf.prototype.InterpolantFactoryMethodSmooth = void 0);
                class $f extends qf {}
                $f.prototype.ValueTypeName = "color";
                class Yf extends qf {}
                Yf.prototype.ValueTypeName = "number";
                class Jf extends Hf {
                  constructor(t, e, n, r) {
                    super(t, e, n, r);
                  }
                  interpolate_(t, e, n, r) {
                    const i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = (n - e) / (r - e);
                    let c = t * o;
                    for (let l = c + o; c !== l; c += 4)
                      Vn.slerpFlat(i, 0, a, c - o, a, c, s);
                    return i;
                  }
                }
                class Kf extends qf {
                  InterpolantFactoryMethodLinear(t) {
                    return new Jf(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t
                    );
                  }
                }
                (Kf.prototype.ValueTypeName = "quaternion"),
                  (Kf.prototype.DefaultInterpolation = be),
                  (Kf.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Zf extends qf {}
                (Zf.prototype.ValueTypeName = "string"),
                  (Zf.prototype.ValueBufferType = Array),
                  (Zf.prototype.DefaultInterpolation = ye),
                  (Zf.prototype.InterpolantFactoryMethodLinear = void 0),
                  (Zf.prototype.InterpolantFactoryMethodSmooth = void 0);
                class Qf extends qf {}
                Qf.prototype.ValueTypeName = "vector";
                class tp {
                  constructor(t, e = -1, n, r = Me) {
                    (this.name = t),
                      (this.tracks = n),
                      (this.duration = e),
                      (this.blendMode = r),
                      (this.uuid = qe()),
                      this.duration < 0 && this.resetDuration();
                  }
                  static parse(t) {
                    const e = [],
                      n = t.tracks,
                      r = 1 / (t.fps || 1);
                    for (let a = 0, o = n.length; a !== o; ++a)
                      e.push(np(n[a]).scale(r));
                    const i = new this(t.name, t.duration, e, t.blendMode);
                    return (i.uuid = t.uuid), i;
                  }
                  static toJSON(t) {
                    const e = [],
                      n = t.tracks,
                      r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid,
                        blendMode: t.blendMode,
                      };
                    for (let i = 0, a = n.length; i !== a; ++i)
                      e.push(qf.toJSON(n[i]));
                    return r;
                  }
                  static CreateFromMorphTargetSequence(t, e, n, r) {
                    const i = e.length,
                      a = [];
                    for (let o = 0; o < i; o++) {
                      let t = [],
                        s = [];
                      t.push((o + i - 1) % i, o, (o + 1) % i), s.push(0, 1, 0);
                      const c = jf.getKeyframeOrder(t);
                      (t = jf.sortedArray(t, 1, c)),
                        (s = jf.sortedArray(s, 1, c)),
                        r || 0 !== t[0] || (t.push(i), s.push(s[0])),
                        a.push(
                          new Yf(
                            ".morphTargetInfluences[" + e[o].name + "]",
                            t,
                            s
                          ).scale(1 / n)
                        );
                    }
                    return new this(t, -1, a);
                  }
                  static findByName(t, e) {
                    let n = t;
                    if (!Array.isArray(t)) {
                      const e = t;
                      n = (e.geometry && e.geometry.animations) || e.animations;
                    }
                    for (let r = 0; r < n.length; r++)
                      if (n[r].name === e) return n[r];
                    return null;
                  }
                  static CreateClipsFromMorphTargetSequences(t, e, n) {
                    const r = {},
                      i = /^([\w-]*?)([\d]+)$/;
                    for (let o = 0, s = t.length; o < s; o++) {
                      const e = t[o],
                        n = e.name.match(i);
                      if (n && n.length > 1) {
                        const t = n[1];
                        let i = r[t];
                        i || (r[t] = i = []), i.push(e);
                      }
                    }
                    const a = [];
                    for (const o in r)
                      a.push(this.CreateFromMorphTargetSequence(o, r[o], e, n));
                    return a;
                  }
                  static parseAnimation(t, e) {
                    if (!t)
                      return (
                        console.error(
                          "THREE.AnimationClip: No animation in JSONLoader data."
                        ),
                        null
                      );
                    const n = function (t, e, n, r, i) {
                        if (0 !== n.length) {
                          const a = [],
                            o = [];
                          jf.flattenJSON(n, a, o, r),
                            0 !== a.length && i.push(new t(e, a, o));
                        }
                      },
                      r = [],
                      i = t.name || "default",
                      a = t.fps || 30,
                      o = t.blendMode;
                    let s = t.length || -1;
                    const c = t.hierarchy || [];
                    for (let u = 0; u < c.length; u++) {
                      const t = c[u].keys;
                      if (t && 0 !== t.length)
                        if (t[0].morphTargets) {
                          const e = {};
                          let n;
                          for (n = 0; n < t.length; n++)
                            if (t[n].morphTargets)
                              for (let r = 0; r < t[n].morphTargets.length; r++)
                                e[t[n].morphTargets[r]] = -1;
                          for (const i in e) {
                            const e = [],
                              a = [];
                            for (
                              let r = 0;
                              r !== t[n].morphTargets.length;
                              ++r
                            ) {
                              const r = t[n];
                              e.push(r.time),
                                a.push(r.morphTarget === i ? 1 : 0);
                            }
                            r.push(
                              new Yf(".morphTargetInfluence[" + i + "]", e, a)
                            );
                          }
                          s = e.length * a;
                        } else {
                          const i = ".bones[" + e[u].name + "]";
                          n(Qf, i + ".position", t, "pos", r),
                            n(Kf, i + ".quaternion", t, "rot", r),
                            n(Qf, i + ".scale", t, "scl", r);
                        }
                    }
                    if (0 === r.length) return null;
                    const l = new this(i, s, r, o);
                    return l;
                  }
                  resetDuration() {
                    const t = this.tracks;
                    let e = 0;
                    for (let n = 0, r = t.length; n !== r; ++n) {
                      const t = this.tracks[n];
                      e = Math.max(e, t.times[t.times.length - 1]);
                    }
                    return (this.duration = e), this;
                  }
                  trim() {
                    for (let t = 0; t < this.tracks.length; t++)
                      this.tracks[t].trim(0, this.duration);
                    return this;
                  }
                  validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++)
                      t = t && this.tracks[e].validate();
                    return t;
                  }
                  optimize() {
                    for (let t = 0; t < this.tracks.length; t++)
                      this.tracks[t].optimize();
                    return this;
                  }
                  clone() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++)
                      t.push(this.tracks[e].clone());
                    return new this.constructor(
                      this.name,
                      this.duration,
                      t,
                      this.blendMode
                    );
                  }
                  toJSON() {
                    return this.constructor.toJSON(this);
                  }
                }
                function ep(t) {
                  switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                      return Yf;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                      return Qf;
                    case "color":
                      return $f;
                    case "quaternion":
                      return Kf;
                    case "bool":
                    case "boolean":
                      return Xf;
                    case "string":
                      return Zf;
                  }
                  throw new Error(
                    "THREE.KeyframeTrack: Unsupported typeName: " + t
                  );
                }
                function np(t) {
                  if (void 0 === t.type)
                    throw new Error(
                      "THREE.KeyframeTrack: track type undefined, can not parse"
                    );
                  const e = ep(t.type);
                  if (void 0 === t.times) {
                    const e = [],
                      n = [];
                    jf.flattenJSON(t.keys, e, n, "value"),
                      (t.times = e),
                      (t.values = n);
                  }
                  return void 0 !== e.parse
                    ? e.parse(t)
                    : new e(t.name, t.times, t.values, t.interpolation);
                }
                const rp = {
                  enabled: !1,
                  files: {},
                  add: function (t, e) {
                    !1 !== this.enabled && (this.files[t] = e);
                  },
                  get: function (t) {
                    if (!1 !== this.enabled) return this.files[t];
                  },
                  remove: function (t) {
                    delete this.files[t];
                  },
                  clear: function () {
                    this.files = {};
                  },
                };
                class ip {
                  constructor(t, e, n) {
                    const r = this;
                    let i,
                      a = !1,
                      o = 0,
                      s = 0;
                    const c = [];
                    (this.onStart = void 0),
                      (this.onLoad = t),
                      (this.onProgress = e),
                      (this.onError = n),
                      (this.itemStart = function (t) {
                        s++,
                          !1 === a &&
                            void 0 !== r.onStart &&
                            r.onStart(t, o, s),
                          (a = !0);
                      }),
                      (this.itemEnd = function (t) {
                        o++,
                          void 0 !== r.onProgress && r.onProgress(t, o, s),
                          o === s &&
                            ((a = !1), void 0 !== r.onLoad && r.onLoad());
                      }),
                      (this.itemError = function (t) {
                        void 0 !== r.onError && r.onError(t);
                      }),
                      (this.resolveURL = function (t) {
                        return i ? i(t) : t;
                      }),
                      (this.setURLModifier = function (t) {
                        return (i = t), this;
                      }),
                      (this.addHandler = function (t, e) {
                        return c.push(t, e), this;
                      }),
                      (this.removeHandler = function (t) {
                        const e = c.indexOf(t);
                        return -1 !== e && c.splice(e, 2), this;
                      }),
                      (this.getHandler = function (t) {
                        for (let e = 0, n = c.length; e < n; e += 2) {
                          const n = c[e],
                            r = c[e + 1];
                          if ((n.global && (n.lastIndex = 0), n.test(t)))
                            return r;
                        }
                        return null;
                      });
                  }
                }
                const ap = new ip();
                class op {
                  constructor(t) {
                    (this.manager = void 0 !== t ? t : ap),
                      (this.crossOrigin = "anonymous"),
                      (this.withCredentials = !1),
                      (this.path = ""),
                      (this.resourcePath = ""),
                      (this.requestHeader = {});
                  }
                  load() {}
                  loadAsync(t, e) {
                    const n = this;
                    return new Promise(function (r, i) {
                      n.load(t, r, e, i);
                    });
                  }
                  parse() {}
                  setCrossOrigin(t) {
                    return (this.crossOrigin = t), this;
                  }
                  setWithCredentials(t) {
                    return (this.withCredentials = t), this;
                  }
                  setPath(t) {
                    return (this.path = t), this;
                  }
                  setResourcePath(t) {
                    return (this.resourcePath = t), this;
                  }
                  setRequestHeader(t) {
                    return (this.requestHeader = t), this;
                  }
                }
                const sp = {};
                class cp extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    void 0 === t && (t = ""),
                      void 0 !== this.path && (t = this.path + t),
                      (t = this.manager.resolveURL(t));
                    const i = rp.get(t);
                    if (void 0 !== i)
                      return (
                        this.manager.itemStart(t),
                        setTimeout(() => {
                          e && e(i), this.manager.itemEnd(t);
                        }, 0),
                        i
                      );
                    if (void 0 !== sp[t])
                      return void sp[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r,
                      });
                    (sp[t] = []),
                      sp[t].push({ onLoad: e, onProgress: n, onError: r });
                    const a = new Request(t, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials
                          ? "include"
                          : "same-origin",
                      }),
                      o = this.mimeType,
                      s = this.responseType;
                    fetch(a)
                      .then((e) => {
                        if (200 === e.status || 0 === e.status) {
                          if (
                            (0 === e.status &&
                              console.warn(
                                "THREE.FileLoader: HTTP Status 0 received."
                              ),
                            "undefined" === typeof ReadableStream ||
                              void 0 === e.body ||
                              void 0 === e.body.getReader)
                          )
                            return e;
                          const n = sp[t],
                            r = e.body.getReader(),
                            i = e.headers.get("Content-Length"),
                            a = i ? parseInt(i) : 0,
                            o = 0 !== a;
                          let s = 0;
                          const c = new ReadableStream({
                            start(t) {
                              function e() {
                                r.read().then(({ done: r, value: i }) => {
                                  if (r) t.close();
                                  else {
                                    s += i.byteLength;
                                    const r = new ProgressEvent("progress", {
                                      lengthComputable: o,
                                      loaded: s,
                                      total: a,
                                    });
                                    for (let t = 0, e = n.length; t < e; t++) {
                                      const e = n[t];
                                      e.onProgress && e.onProgress(r);
                                    }
                                    t.enqueue(i), e();
                                  }
                                });
                              }
                              e();
                            },
                          });
                          return new Response(c);
                        }
                        throw Error(
                          `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
                        );
                      })
                      .then((t) => {
                        switch (s) {
                          case "arraybuffer":
                            return t.arrayBuffer();
                          case "blob":
                            return t.blob();
                          case "document":
                            return t.text().then((t) => {
                              const e = new DOMParser();
                              return e.parseFromString(t, o);
                            });
                          case "json":
                            return t.json();
                          default:
                            if (void 0 === o) return t.text();
                            {
                              const e = /charset="?([^;"\s]*)"?/i,
                                n = e.exec(o),
                                r = n && n[1] ? n[1].toLowerCase() : void 0,
                                i = new TextDecoder(r);
                              return t.arrayBuffer().then((t) => i.decode(t));
                            }
                        }
                      })
                      .then((e) => {
                        rp.add(t, e);
                        const n = sp[t];
                        delete sp[t];
                        for (let t = 0, r = n.length; t < r; t++) {
                          const r = n[t];
                          r.onLoad && r.onLoad(e);
                        }
                      })
                      .catch((e) => {
                        const n = sp[t];
                        if (void 0 === n) throw (this.manager.itemError(t), e);
                        delete sp[t];
                        for (let t = 0, r = n.length; t < r; t++) {
                          const r = n[t];
                          r.onError && r.onError(e);
                        }
                        this.manager.itemError(t);
                      })
                      .finally(() => {
                        this.manager.itemEnd(t);
                      }),
                      this.manager.itemStart(t);
                  }
                  setResponseType(t) {
                    return (this.responseType = t), this;
                  }
                  setMimeType(t) {
                    return (this.mimeType = t), this;
                  }
                }
                class lp extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = [],
                      o = new Gh(),
                      s = new cp(this.manager);
                    s.setPath(this.path),
                      s.setResponseType("arraybuffer"),
                      s.setRequestHeader(this.requestHeader),
                      s.setWithCredentials(i.withCredentials);
                    let c = 0;
                    function l(l) {
                      s.load(
                        t[l],
                        function (t) {
                          const n = i.parse(t, !0);
                          (a[l] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps,
                          }),
                            (c += 1),
                            6 === c &&
                              (1 === n.mipmapCount && (o.minFilter = vt),
                              (o.image = a),
                              (o.format = n.format),
                              (o.needsUpdate = !0),
                              e && e(o));
                        },
                        n,
                        r
                      );
                    }
                    if (Array.isArray(t))
                      for (let u = 0, h = t.length; u < h; ++u) l(u);
                    else
                      s.load(
                        t,
                        function (t) {
                          const n = i.parse(t, !0);
                          if (n.isCubemap) {
                            const t = n.mipmaps.length / n.mipmapCount;
                            for (let e = 0; e < t; e++) {
                              a[e] = { mipmaps: [] };
                              for (let t = 0; t < n.mipmapCount; t++)
                                a[e].mipmaps.push(
                                  n.mipmaps[e * n.mipmapCount + t]
                                ),
                                  (a[e].format = n.format),
                                  (a[e].width = n.width),
                                  (a[e].height = n.height);
                            }
                            o.image = a;
                          } else
                            (o.image.width = n.width),
                              (o.image.height = n.height),
                              (o.mipmaps = n.mipmaps);
                          1 === n.mipmapCount && (o.minFilter = vt),
                            (o.format = n.format),
                            (o.needsUpdate = !0),
                            e && e(o);
                        },
                        n,
                        r
                      );
                    return o;
                  }
                }
                class up extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    void 0 !== this.path && (t = this.path + t),
                      (t = this.manager.resolveURL(t));
                    const i = this,
                      a = rp.get(t);
                    if (void 0 !== a)
                      return (
                        i.manager.itemStart(t),
                        setTimeout(function () {
                          e && e(a), i.manager.itemEnd(t);
                        }, 0),
                        a
                      );
                    const o = _n("img");
                    function s() {
                      l(), rp.add(t, this), e && e(this), i.manager.itemEnd(t);
                    }
                    function c(e) {
                      l(),
                        r && r(e),
                        i.manager.itemError(t),
                        i.manager.itemEnd(t);
                    }
                    function l() {
                      o.removeEventListener("load", s, !1),
                        o.removeEventListener("error", c, !1);
                    }
                    return (
                      o.addEventListener("load", s, !1),
                      o.addEventListener("error", c, !1),
                      "data:" !== t.slice(0, 5) &&
                        void 0 !== this.crossOrigin &&
                        (o.crossOrigin = this.crossOrigin),
                      i.manager.itemStart(t),
                      (o.src = t),
                      o
                    );
                  }
                }
                class hp extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new gh(),
                      o = new cp(this.manager);
                    return (
                      o.setResponseType("arraybuffer"),
                      o.setRequestHeader(this.requestHeader),
                      o.setPath(this.path),
                      o.setWithCredentials(i.withCredentials),
                      o.load(
                        t,
                        function (t) {
                          const n = i.parse(t);
                          n &&
                            (void 0 !== n.image
                              ? (a.image = n.image)
                              : void 0 !== n.data &&
                                ((a.image.width = n.width),
                                (a.image.height = n.height),
                                (a.image.data = n.data)),
                            (a.wrapS = void 0 !== n.wrapS ? n.wrapS : dt),
                            (a.wrapT = void 0 !== n.wrapT ? n.wrapT : dt),
                            (a.magFilter =
                              void 0 !== n.magFilter ? n.magFilter : vt),
                            (a.minFilter =
                              void 0 !== n.minFilter ? n.minFilter : vt),
                            (a.anisotropy =
                              void 0 !== n.anisotropy ? n.anisotropy : 1),
                            void 0 !== n.encoding && (a.encoding = n.encoding),
                            void 0 !== n.flipY && (a.flipY = n.flipY),
                            void 0 !== n.format && (a.format = n.format),
                            void 0 !== n.type && (a.type = n.type),
                            void 0 !== n.mipmaps &&
                              ((a.mipmaps = n.mipmaps), (a.minFilter = bt)),
                            1 === n.mipmapCount && (a.minFilter = vt),
                            void 0 !== n.generateMipmaps &&
                              (a.generateMipmaps = n.generateMipmaps),
                            (a.needsUpdate = !0),
                            e && e(a, n));
                        },
                        n,
                        r
                      ),
                      a
                    );
                  }
                }
                class dp extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = new Fn(),
                      a = new up(this.manager);
                    return (
                      a.setCrossOrigin(this.crossOrigin),
                      a.setPath(this.path),
                      a.load(
                        t,
                        function (t) {
                          (i.image = t),
                            (i.needsUpdate = !0),
                            void 0 !== e && e(i);
                        },
                        n,
                        r
                      ),
                      i
                    );
                  }
                }
                class fp extends qr {
                  constructor(t, e = 1) {
                    super(),
                      (this.isLight = !0),
                      (this.type = "Light"),
                      (this.color = new In(t)),
                      (this.intensity = e);
                  }
                  dispose() {}
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      this.color.copy(t.color),
                      (this.intensity = t.intensity),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                      (e.object.color = this.color.getHex()),
                      (e.object.intensity = this.intensity),
                      void 0 !== this.groundColor &&
                        (e.object.groundColor = this.groundColor.getHex()),
                      void 0 !== this.distance &&
                        (e.object.distance = this.distance),
                      void 0 !== this.angle && (e.object.angle = this.angle),
                      void 0 !== this.decay && (e.object.decay = this.decay),
                      void 0 !== this.penumbra &&
                        (e.object.penumbra = this.penumbra),
                      void 0 !== this.shadow &&
                        (e.object.shadow = this.shadow.toJSON()),
                      e
                    );
                  }
                }
                class pp extends fp {
                  constructor(t, e, n) {
                    super(t, n),
                      (this.isHemisphereLight = !0),
                      (this.type = "HemisphereLight"),
                      this.position.copy(qr.DefaultUp),
                      this.updateMatrix(),
                      (this.groundColor = new In(e));
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      this.groundColor.copy(t.groundColor),
                      this
                    );
                  }
                }
                const mp = new _r(),
                  gp = new Gn(),
                  vp = new Gn();
                class yp {
                  constructor(t) {
                    (this.camera = t),
                      (this.bias = 0),
                      (this.normalBias = 0),
                      (this.radius = 1),
                      (this.blurSamples = 8),
                      (this.mapSize = new gn(512, 512)),
                      (this.map = null),
                      (this.mapPass = null),
                      (this.matrix = new _r()),
                      (this.autoUpdate = !0),
                      (this.needsUpdate = !1),
                      (this._frustum = new sa()),
                      (this._frameExtents = new gn(1, 1)),
                      (this._viewportCount = 1),
                      (this._viewports = [new Un(0, 0, 1, 1)]);
                  }
                  getViewportCount() {
                    return this._viewportCount;
                  }
                  getFrustum() {
                    return this._frustum;
                  }
                  updateMatrices(t) {
                    const e = this.camera,
                      n = this.matrix;
                    gp.setFromMatrixPosition(t.matrixWorld),
                      e.position.copy(gp),
                      vp.setFromMatrixPosition(t.target.matrixWorld),
                      e.lookAt(vp),
                      e.updateMatrixWorld(),
                      mp.multiplyMatrices(
                        e.projectionMatrix,
                        e.matrixWorldInverse
                      ),
                      this._frustum.setFromProjectionMatrix(mp),
                      n.set(
                        0.5,
                        0,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0,
                        0.5,
                        0.5,
                        0,
                        0,
                        0,
                        1
                      ),
                      n.multiply(e.projectionMatrix),
                      n.multiply(e.matrixWorldInverse);
                  }
                  getViewport(t) {
                    return this._viewports[t];
                  }
                  getFrameExtents() {
                    return this._frameExtents;
                  }
                  dispose() {
                    this.map && this.map.dispose(),
                      this.mapPass && this.mapPass.dispose();
                  }
                  copy(t) {
                    return (
                      (this.camera = t.camera.clone()),
                      (this.bias = t.bias),
                      (this.radius = t.radius),
                      this.mapSize.copy(t.mapSize),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  toJSON() {
                    const t = {};
                    return (
                      0 !== this.bias && (t.bias = this.bias),
                      0 !== this.normalBias && (t.normalBias = this.normalBias),
                      1 !== this.radius && (t.radius = this.radius),
                      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                        (t.mapSize = this.mapSize.toArray()),
                      (t.camera = this.camera.toJSON(!1).object),
                      delete t.camera.matrix,
                      t
                    );
                  }
                }
                class bp extends yp {
                  constructor() {
                    super(new Yi(50, 1, 0.5, 500)),
                      (this.isSpotLightShadow = !0),
                      (this.focus = 1);
                  }
                  updateMatrices(t) {
                    const e = this.camera,
                      n = 2 * We * t.angle * this.focus,
                      r = this.mapSize.width / this.mapSize.height,
                      i = t.distance || e.far;
                    (n === e.fov && r === e.aspect && i === e.far) ||
                      ((e.fov = n),
                      (e.aspect = r),
                      (e.far = i),
                      e.updateProjectionMatrix()),
                      super.updateMatrices(t);
                  }
                  copy(t) {
                    return super.copy(t), (this.focus = t.focus), this;
                  }
                }
                class xp extends fp {
                  constructor(t, e, n = 0, r = Math.PI / 3, i = 0, a = 1) {
                    super(t, e),
                      (this.isSpotLight = !0),
                      (this.type = "SpotLight"),
                      this.position.copy(qr.DefaultUp),
                      this.updateMatrix(),
                      (this.target = new qr()),
                      (this.distance = n),
                      (this.angle = r),
                      (this.penumbra = i),
                      (this.decay = a),
                      (this.shadow = new bp());
                  }
                  get power() {
                    return this.intensity * Math.PI;
                  }
                  set power(t) {
                    this.intensity = t / Math.PI;
                  }
                  dispose() {
                    this.shadow.dispose();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.distance = t.distance),
                      (this.angle = t.angle),
                      (this.penumbra = t.penumbra),
                      (this.decay = t.decay),
                      (this.target = t.target.clone()),
                      (this.shadow = t.shadow.clone()),
                      this
                    );
                  }
                }
                const _p = new _r(),
                  wp = new Gn(),
                  Sp = new Gn();
                class Mp extends yp {
                  constructor() {
                    super(new Yi(90, 1, 0.5, 500)),
                      (this.isPointLightShadow = !0),
                      (this._frameExtents = new gn(4, 2)),
                      (this._viewportCount = 6),
                      (this._viewports = [
                        new Un(2, 1, 1, 1),
                        new Un(0, 1, 1, 1),
                        new Un(3, 1, 1, 1),
                        new Un(1, 1, 1, 1),
                        new Un(3, 0, 1, 1),
                        new Un(1, 0, 1, 1),
                      ]),
                      (this._cubeDirections = [
                        new Gn(1, 0, 0),
                        new Gn(-1, 0, 0),
                        new Gn(0, 0, 1),
                        new Gn(0, 0, -1),
                        new Gn(0, 1, 0),
                        new Gn(0, -1, 0),
                      ]),
                      (this._cubeUps = [
                        new Gn(0, 1, 0),
                        new Gn(0, 1, 0),
                        new Gn(0, 1, 0),
                        new Gn(0, 1, 0),
                        new Gn(0, 0, 1),
                        new Gn(0, 0, -1),
                      ]);
                  }
                  updateMatrices(t, e = 0) {
                    const n = this.camera,
                      r = this.matrix,
                      i = t.distance || n.far;
                    i !== n.far && ((n.far = i), n.updateProjectionMatrix()),
                      wp.setFromMatrixPosition(t.matrixWorld),
                      n.position.copy(wp),
                      Sp.copy(n.position),
                      Sp.add(this._cubeDirections[e]),
                      n.up.copy(this._cubeUps[e]),
                      n.lookAt(Sp),
                      n.updateMatrixWorld(),
                      r.makeTranslation(-wp.x, -wp.y, -wp.z),
                      _p.multiplyMatrices(
                        n.projectionMatrix,
                        n.matrixWorldInverse
                      ),
                      this._frustum.setFromProjectionMatrix(_p);
                  }
                }
                class Tp extends fp {
                  constructor(t, e, n = 0, r = 1) {
                    super(t, e),
                      (this.isPointLight = !0),
                      (this.type = "PointLight"),
                      (this.distance = n),
                      (this.decay = r),
                      (this.shadow = new Mp());
                  }
                  get power() {
                    return 4 * this.intensity * Math.PI;
                  }
                  set power(t) {
                    this.intensity = t / (4 * Math.PI);
                  }
                  dispose() {
                    this.shadow.dispose();
                  }
                  copy(t, e) {
                    return (
                      super.copy(t, e),
                      (this.distance = t.distance),
                      (this.decay = t.decay),
                      (this.shadow = t.shadow.clone()),
                      this
                    );
                  }
                }
                class Ep extends yp {
                  constructor() {
                    super(new Js(-5, 5, 5, -5, 0.5, 500)),
                      (this.isDirectionalLightShadow = !0);
                  }
                }
                class Ap extends fp {
                  constructor(t, e) {
                    super(t, e),
                      (this.isDirectionalLight = !0),
                      (this.type = "DirectionalLight"),
                      this.position.copy(qr.DefaultUp),
                      this.updateMatrix(),
                      (this.target = new qr()),
                      (this.shadow = new Ep());
                  }
                  dispose() {
                    this.shadow.dispose();
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.target = t.target.clone()),
                      (this.shadow = t.shadow.clone()),
                      this
                    );
                  }
                }
                class Cp extends fp {
                  constructor(t, e) {
                    super(t, e),
                      (this.isAmbientLight = !0),
                      (this.type = "AmbientLight");
                  }
                }
                class Lp extends fp {
                  constructor(t, e, n = 10, r = 10) {
                    super(t, e),
                      (this.isRectAreaLight = !0),
                      (this.type = "RectAreaLight"),
                      (this.width = n),
                      (this.height = r);
                  }
                  get power() {
                    return this.intensity * this.width * this.height * Math.PI;
                  }
                  set power(t) {
                    this.intensity = t / (this.width * this.height * Math.PI);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.width = t.width),
                      (this.height = t.height),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (
                      (e.object.width = this.width),
                      (e.object.height = this.height),
                      e
                    );
                  }
                }
                class Rp {
                  constructor() {
                    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
                    for (let t = 0; t < 9; t++)
                      this.coefficients.push(new Gn());
                  }
                  set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this;
                  }
                  zero() {
                    for (let t = 0; t < 9; t++)
                      this.coefficients[t].set(0, 0, 0);
                    return this;
                  }
                  getAt(t, e) {
                    const n = t.x,
                      r = t.y,
                      i = t.z,
                      a = this.coefficients;
                    return (
                      e.copy(a[0]).multiplyScalar(0.282095),
                      e.addScaledVector(a[1], 0.488603 * r),
                      e.addScaledVector(a[2], 0.488603 * i),
                      e.addScaledVector(a[3], 0.488603 * n),
                      e.addScaledVector(a[4], n * r * 1.092548),
                      e.addScaledVector(a[5], r * i * 1.092548),
                      e.addScaledVector(a[6], 0.315392 * (3 * i * i - 1)),
                      e.addScaledVector(a[7], n * i * 1.092548),
                      e.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
                      e
                    );
                  }
                  getIrradianceAt(t, e) {
                    const n = t.x,
                      r = t.y,
                      i = t.z,
                      a = this.coefficients;
                    return (
                      e.copy(a[0]).multiplyScalar(0.886227),
                      e.addScaledVector(a[1], 1.023328 * r),
                      e.addScaledVector(a[2], 1.023328 * i),
                      e.addScaledVector(a[3], 1.023328 * n),
                      e.addScaledVector(a[4], 0.858086 * n * r),
                      e.addScaledVector(a[5], 0.858086 * r * i),
                      e.addScaledVector(a[6], 0.743125 * i * i - 0.247708),
                      e.addScaledVector(a[7], 0.858086 * n * i),
                      e.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
                      e
                    );
                  }
                  add(t) {
                    for (let e = 0; e < 9; e++)
                      this.coefficients[e].add(t.coefficients[e]);
                    return this;
                  }
                  addScaledSH(t, e) {
                    for (let n = 0; n < 9; n++)
                      this.coefficients[n].addScaledVector(
                        t.coefficients[n],
                        e
                      );
                    return this;
                  }
                  scale(t) {
                    for (let e = 0; e < 9; e++)
                      this.coefficients[e].multiplyScalar(t);
                    return this;
                  }
                  lerp(t, e) {
                    for (let n = 0; n < 9; n++)
                      this.coefficients[n].lerp(t.coefficients[n], e);
                    return this;
                  }
                  equals(t) {
                    for (let e = 0; e < 9; e++)
                      if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                    return !0;
                  }
                  copy(t) {
                    return this.set(t.coefficients);
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  fromArray(t, e = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
                    return this;
                  }
                  toArray(t = [], e = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
                    return t;
                  }
                  static getBasisAt(t, e) {
                    const n = t.x,
                      r = t.y,
                      i = t.z;
                    (e[0] = 0.282095),
                      (e[1] = 0.488603 * r),
                      (e[2] = 0.488603 * i),
                      (e[3] = 0.488603 * n),
                      (e[4] = 1.092548 * n * r),
                      (e[5] = 1.092548 * r * i),
                      (e[6] = 0.315392 * (3 * i * i - 1)),
                      (e[7] = 1.092548 * n * i),
                      (e[8] = 0.546274 * (n * n - r * r));
                  }
                }
                class Pp extends fp {
                  constructor(t = new Rp(), e = 1) {
                    super(void 0, e), (this.isLightProbe = !0), (this.sh = t);
                  }
                  copy(t) {
                    return super.copy(t), this.sh.copy(t.sh), this;
                  }
                  fromJSON(t) {
                    return (
                      (this.intensity = t.intensity),
                      this.sh.fromArray(t.sh),
                      this
                    );
                  }
                  toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.sh = this.sh.toArray()), e;
                  }
                }
                class Ip extends op {
                  constructor(t) {
                    super(t), (this.textures = {});
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new cp(i.manager);
                    a.setPath(i.path),
                      a.setRequestHeader(i.requestHeader),
                      a.setWithCredentials(i.withCredentials),
                      a.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(JSON.parse(n)));
                          } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  parse(t) {
                    const e = this.textures;
                    function n(t) {
                      return (
                        void 0 === e[t] &&
                          console.warn(
                            "THREE.MaterialLoader: Undefined texture",
                            t
                          ),
                        e[t]
                      );
                    }
                    const r = Ip.createMaterialFromType(t.type);
                    if (
                      (void 0 !== t.uuid && (r.uuid = t.uuid),
                      void 0 !== t.name && (r.name = t.name),
                      void 0 !== t.color &&
                        void 0 !== r.color &&
                        r.color.setHex(t.color),
                      void 0 !== t.roughness && (r.roughness = t.roughness),
                      void 0 !== t.metalness && (r.metalness = t.metalness),
                      void 0 !== t.sheen && (r.sheen = t.sheen),
                      void 0 !== t.sheenColor &&
                        (r.sheenColor = new In().setHex(t.sheenColor)),
                      void 0 !== t.sheenRoughness &&
                        (r.sheenRoughness = t.sheenRoughness),
                      void 0 !== t.emissive &&
                        void 0 !== r.emissive &&
                        r.emissive.setHex(t.emissive),
                      void 0 !== t.specular &&
                        void 0 !== r.specular &&
                        r.specular.setHex(t.specular),
                      void 0 !== t.specularIntensity &&
                        (r.specularIntensity = t.specularIntensity),
                      void 0 !== t.specularColor &&
                        void 0 !== r.specularColor &&
                        r.specularColor.setHex(t.specularColor),
                      void 0 !== t.shininess && (r.shininess = t.shininess),
                      void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat),
                      void 0 !== t.clearcoatRoughness &&
                        (r.clearcoatRoughness = t.clearcoatRoughness),
                      void 0 !== t.iridescence &&
                        (r.iridescence = t.iridescence),
                      void 0 !== t.iridescenceIOR &&
                        (r.iridescenceIOR = t.iridescenceIOR),
                      void 0 !== t.iridescenceThicknessRange &&
                        (r.iridescenceThicknessRange =
                          t.iridescenceThicknessRange),
                      void 0 !== t.transmission &&
                        (r.transmission = t.transmission),
                      void 0 !== t.thickness && (r.thickness = t.thickness),
                      void 0 !== t.attenuationDistance &&
                        (r.attenuationDistance = t.attenuationDistance),
                      void 0 !== t.attenuationColor &&
                        void 0 !== r.attenuationColor &&
                        r.attenuationColor.setHex(t.attenuationColor),
                      void 0 !== t.fog && (r.fog = t.fog),
                      void 0 !== t.flatShading &&
                        (r.flatShading = t.flatShading),
                      void 0 !== t.blending && (r.blending = t.blending),
                      void 0 !== t.combine && (r.combine = t.combine),
                      void 0 !== t.side && (r.side = t.side),
                      void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide),
                      void 0 !== t.opacity && (r.opacity = t.opacity),
                      void 0 !== t.transparent &&
                        (r.transparent = t.transparent),
                      void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
                      void 0 !== t.depthTest && (r.depthTest = t.depthTest),
                      void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
                      void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
                      void 0 !== t.stencilWrite &&
                        (r.stencilWrite = t.stencilWrite),
                      void 0 !== t.stencilWriteMask &&
                        (r.stencilWriteMask = t.stencilWriteMask),
                      void 0 !== t.stencilFunc &&
                        (r.stencilFunc = t.stencilFunc),
                      void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef),
                      void 0 !== t.stencilFuncMask &&
                        (r.stencilFuncMask = t.stencilFuncMask),
                      void 0 !== t.stencilFail &&
                        (r.stencilFail = t.stencilFail),
                      void 0 !== t.stencilZFail &&
                        (r.stencilZFail = t.stencilZFail),
                      void 0 !== t.stencilZPass &&
                        (r.stencilZPass = t.stencilZPass),
                      void 0 !== t.wireframe && (r.wireframe = t.wireframe),
                      void 0 !== t.wireframeLinewidth &&
                        (r.wireframeLinewidth = t.wireframeLinewidth),
                      void 0 !== t.wireframeLinecap &&
                        (r.wireframeLinecap = t.wireframeLinecap),
                      void 0 !== t.wireframeLinejoin &&
                        (r.wireframeLinejoin = t.wireframeLinejoin),
                      void 0 !== t.rotation && (r.rotation = t.rotation),
                      1 !== t.linewidth && (r.linewidth = t.linewidth),
                      void 0 !== t.dashSize && (r.dashSize = t.dashSize),
                      void 0 !== t.gapSize && (r.gapSize = t.gapSize),
                      void 0 !== t.scale && (r.scale = t.scale),
                      void 0 !== t.polygonOffset &&
                        (r.polygonOffset = t.polygonOffset),
                      void 0 !== t.polygonOffsetFactor &&
                        (r.polygonOffsetFactor = t.polygonOffsetFactor),
                      void 0 !== t.polygonOffsetUnits &&
                        (r.polygonOffsetUnits = t.polygonOffsetUnits),
                      void 0 !== t.dithering && (r.dithering = t.dithering),
                      void 0 !== t.alphaToCoverage &&
                        (r.alphaToCoverage = t.alphaToCoverage),
                      void 0 !== t.premultipliedAlpha &&
                        (r.premultipliedAlpha = t.premultipliedAlpha),
                      void 0 !== t.visible && (r.visible = t.visible),
                      void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped),
                      void 0 !== t.userData && (r.userData = t.userData),
                      void 0 !== t.vertexColors &&
                        ("number" === typeof t.vertexColors
                          ? (r.vertexColors = t.vertexColors > 0)
                          : (r.vertexColors = t.vertexColors)),
                      void 0 !== t.uniforms)
                    )
                      for (const i in t.uniforms) {
                        const e = t.uniforms[i];
                        switch (((r.uniforms[i] = {}), e.type)) {
                          case "t":
                            r.uniforms[i].value = n(e.value);
                            break;
                          case "c":
                            r.uniforms[i].value = new In().setHex(e.value);
                            break;
                          case "v2":
                            r.uniforms[i].value = new gn().fromArray(e.value);
                            break;
                          case "v3":
                            r.uniforms[i].value = new Gn().fromArray(e.value);
                            break;
                          case "v4":
                            r.uniforms[i].value = new Un().fromArray(e.value);
                            break;
                          case "m3":
                            r.uniforms[i].value = new vn().fromArray(e.value);
                            break;
                          case "m4":
                            r.uniforms[i].value = new _r().fromArray(e.value);
                            break;
                          default:
                            r.uniforms[i].value = e.value;
                        }
                      }
                    if (
                      (void 0 !== t.defines && (r.defines = t.defines),
                      void 0 !== t.vertexShader &&
                        (r.vertexShader = t.vertexShader),
                      void 0 !== t.fragmentShader &&
                        (r.fragmentShader = t.fragmentShader),
                      void 0 !== t.extensions)
                    )
                      for (const i in t.extensions)
                        r.extensions[i] = t.extensions[i];
                    if (
                      (void 0 !== t.shading &&
                        (r.flatShading = 1 === t.shading),
                      void 0 !== t.size && (r.size = t.size),
                      void 0 !== t.sizeAttenuation &&
                        (r.sizeAttenuation = t.sizeAttenuation),
                      void 0 !== t.map && (r.map = n(t.map)),
                      void 0 !== t.matcap && (r.matcap = n(t.matcap)),
                      void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)),
                      void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)),
                      void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
                      void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)),
                      void 0 !== t.normalMapType &&
                        (r.normalMapType = t.normalMapType),
                      void 0 !== t.normalScale)
                    ) {
                      let e = t.normalScale;
                      !1 === Array.isArray(e) && (e = [e, e]),
                        (r.normalScale = new gn().fromArray(e));
                    }
                    return (
                      void 0 !== t.displacementMap &&
                        (r.displacementMap = n(t.displacementMap)),
                      void 0 !== t.displacementScale &&
                        (r.displacementScale = t.displacementScale),
                      void 0 !== t.displacementBias &&
                        (r.displacementBias = t.displacementBias),
                      void 0 !== t.roughnessMap &&
                        (r.roughnessMap = n(t.roughnessMap)),
                      void 0 !== t.metalnessMap &&
                        (r.metalnessMap = n(t.metalnessMap)),
                      void 0 !== t.emissiveMap &&
                        (r.emissiveMap = n(t.emissiveMap)),
                      void 0 !== t.emissiveIntensity &&
                        (r.emissiveIntensity = t.emissiveIntensity),
                      void 0 !== t.specularMap &&
                        (r.specularMap = n(t.specularMap)),
                      void 0 !== t.specularIntensityMap &&
                        (r.specularIntensityMap = n(t.specularIntensityMap)),
                      void 0 !== t.specularColorMap &&
                        (r.specularColorMap = n(t.specularColorMap)),
                      void 0 !== t.envMap && (r.envMap = n(t.envMap)),
                      void 0 !== t.envMapIntensity &&
                        (r.envMapIntensity = t.envMapIntensity),
                      void 0 !== t.reflectivity &&
                        (r.reflectivity = t.reflectivity),
                      void 0 !== t.refractionRatio &&
                        (r.refractionRatio = t.refractionRatio),
                      void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)),
                      void 0 !== t.lightMapIntensity &&
                        (r.lightMapIntensity = t.lightMapIntensity),
                      void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)),
                      void 0 !== t.aoMapIntensity &&
                        (r.aoMapIntensity = t.aoMapIntensity),
                      void 0 !== t.gradientMap &&
                        (r.gradientMap = n(t.gradientMap)),
                      void 0 !== t.clearcoatMap &&
                        (r.clearcoatMap = n(t.clearcoatMap)),
                      void 0 !== t.clearcoatRoughnessMap &&
                        (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
                      void 0 !== t.clearcoatNormalMap &&
                        (r.clearcoatNormalMap = n(t.clearcoatNormalMap)),
                      void 0 !== t.clearcoatNormalScale &&
                        (r.clearcoatNormalScale = new gn().fromArray(
                          t.clearcoatNormalScale
                        )),
                      void 0 !== t.iridescenceMap &&
                        (r.iridescenceMap = n(t.iridescenceMap)),
                      void 0 !== t.iridescenceThicknessMap &&
                        (r.iridescenceThicknessMap = n(
                          t.iridescenceThicknessMap
                        )),
                      void 0 !== t.transmissionMap &&
                        (r.transmissionMap = n(t.transmissionMap)),
                      void 0 !== t.thicknessMap &&
                        (r.thicknessMap = n(t.thicknessMap)),
                      void 0 !== t.sheenColorMap &&
                        (r.sheenColorMap = n(t.sheenColorMap)),
                      void 0 !== t.sheenRoughnessMap &&
                        (r.sheenRoughnessMap = n(t.sheenRoughnessMap)),
                      r
                    );
                  }
                  setTextures(t) {
                    return (this.textures = t), this;
                  }
                  static createMaterialFromType(t) {
                    const e = {
                      ShadowMaterial: Pf,
                      SpriteMaterial: Gu,
                      RawShaderMaterial: If,
                      ShaderMaterial: Xi,
                      PointsMaterial: zh,
                      MeshPhysicalMaterial: kf,
                      MeshStandardMaterial: Of,
                      MeshPhongMaterial: Nf,
                      MeshToonMaterial: Df,
                      MeshNormalMaterial: zf,
                      MeshLambertMaterial: Ff,
                      MeshDepthMaterial: xu,
                      MeshDistanceMaterial: _u,
                      MeshBasicMaterial: oi,
                      MeshMatcapMaterial: Uf,
                      LineDashedMaterial: Bf,
                      LineBasicMaterial: Eh,
                      Material: ai,
                    };
                    return new e[t]();
                  }
                }
                class Op {
                  static decodeText(t) {
                    if ("undefined" !== typeof TextDecoder)
                      return new TextDecoder().decode(t);
                    let e = "";
                    for (let n = 0, r = t.length; n < r; n++)
                      e += String.fromCharCode(t[n]);
                    try {
                      return decodeURIComponent(escape(e));
                    } catch (n) {
                      return e;
                    }
                  }
                  static extractUrlBase(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.slice(0, e + 1);
                  }
                  static resolveURL(t, e) {
                    return "string" !== typeof t || "" === t
                      ? ""
                      : (/^https?:\/\//i.test(e) &&
                          /^\//.test(t) &&
                          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(t) ||
                        /^data:.*,.*$/i.test(t) ||
                        /^blob:.*$/i.test(t)
                          ? t
                          : e + t);
                  }
                }
                class kp extends xi {
                  constructor() {
                    super(),
                      (this.isInstancedBufferGeometry = !0),
                      (this.type = "InstancedBufferGeometry"),
                      (this.instanceCount = 1 / 0);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.instanceCount = t.instanceCount),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                  toJSON() {
                    const t = super.toJSON(this);
                    return (
                      (t.instanceCount = this.instanceCount),
                      (t.isInstancedBufferGeometry = !0),
                      t
                    );
                  }
                }
                class Np extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new cp(i.manager);
                    a.setPath(i.path),
                      a.setRequestHeader(i.requestHeader),
                      a.setWithCredentials(i.withCredentials),
                      a.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(JSON.parse(n)));
                          } catch (a) {
                            r ? r(a) : console.error(a), i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  parse(t) {
                    const e = {},
                      n = {};
                    function r(t, n) {
                      if (void 0 !== e[n]) return e[n];
                      const r = t.interleavedBuffers,
                        a = r[n],
                        o = i(t, a.buffer),
                        s = xn(a.type, o),
                        c = new ju(s, a.stride);
                      return (c.uuid = a.uuid), (e[n] = c), c;
                    }
                    function i(t, e) {
                      if (void 0 !== n[e]) return n[e];
                      const r = t.arrayBuffers,
                        i = r[e],
                        a = new Uint32Array(i).buffer;
                      return (n[e] = a), a;
                    }
                    const a = t.isInstancedBufferGeometry ? new kp() : new xi(),
                      o = t.data.index;
                    if (void 0 !== o) {
                      const t = xn(o.type, o.array);
                      a.setIndex(new li(t, 1));
                    }
                    const s = t.data.attributes;
                    for (const d in s) {
                      const e = s[d];
                      let n;
                      if (e.isInterleavedBufferAttribute) {
                        const i = r(t.data, e.data);
                        n = new Vu(i, e.itemSize, e.offset, e.normalized);
                      } else {
                        const t = xn(e.type, e.array),
                          r = e.isInstancedBufferAttribute ? xh : li;
                        n = new r(t, e.itemSize, e.normalized);
                      }
                      void 0 !== e.name && (n.name = e.name),
                        void 0 !== e.usage && n.setUsage(e.usage),
                        void 0 !== e.updateRange &&
                          ((n.updateRange.offset = e.updateRange.offset),
                          (n.updateRange.count = e.updateRange.count)),
                        a.setAttribute(d, n);
                    }
                    const c = t.data.morphAttributes;
                    if (c)
                      for (const d in c) {
                        const e = c[d],
                          n = [];
                        for (let i = 0, a = e.length; i < a; i++) {
                          const a = e[i];
                          let o;
                          if (a.isInterleavedBufferAttribute) {
                            const e = r(t.data, a.data);
                            o = new Vu(e, a.itemSize, a.offset, a.normalized);
                          } else {
                            const t = xn(a.type, a.array);
                            o = new li(t, a.itemSize, a.normalized);
                          }
                          void 0 !== a.name && (o.name = a.name), n.push(o);
                        }
                        a.morphAttributes[d] = n;
                      }
                    const l = t.data.morphTargetsRelative;
                    l && (a.morphTargetsRelative = !0);
                    const u =
                      t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== u)
                      for (let d = 0, f = u.length; d !== f; ++d) {
                        const t = u[d];
                        a.addGroup(t.start, t.count, t.materialIndex);
                      }
                    const h = t.data.boundingSphere;
                    if (void 0 !== h) {
                      const t = new Gn();
                      void 0 !== h.center && t.fromArray(h.center),
                        (a.boundingSphere = new dr(t, h.radius));
                    }
                    return (
                      t.name && (a.name = t.name),
                      t.userData && (a.userData = t.userData),
                      a
                    );
                  }
                }
                class Dp extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = "" === this.path ? Op.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    const o = new cp(this.manager);
                    o.setPath(this.path),
                      o.setRequestHeader(this.requestHeader),
                      o.setWithCredentials(this.withCredentials),
                      o.load(
                        t,
                        function (n) {
                          let a = null;
                          try {
                            a = JSON.parse(n);
                          } catch (s) {
                            return (
                              void 0 !== r && r(s),
                              void console.error(
                                "THREE:ObjectLoader: Can't parse " + t + ".",
                                s.message
                              )
                            );
                          }
                          const o = a.metadata;
                          void 0 !== o &&
                          void 0 !== o.type &&
                          "geometry" !== o.type.toLowerCase()
                            ? i.parse(a, e)
                            : console.error(
                                "THREE.ObjectLoader: Can't load " + t
                              );
                        },
                        n,
                        r
                      );
                  }
                  async loadAsync(t, e) {
                    const n = this,
                      r = "" === this.path ? Op.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || r;
                    const i = new cp(this.manager);
                    i.setPath(this.path),
                      i.setRequestHeader(this.requestHeader),
                      i.setWithCredentials(this.withCredentials);
                    const a = await i.loadAsync(t, e),
                      o = JSON.parse(a),
                      s = o.metadata;
                    if (
                      void 0 === s ||
                      void 0 === s.type ||
                      "geometry" === s.type.toLowerCase()
                    )
                      throw new Error("THREE.ObjectLoader: Can't load " + t);
                    return await n.parseAsync(o);
                  }
                  parse(t, e) {
                    const n = this.parseAnimations(t.animations),
                      r = this.parseShapes(t.shapes),
                      i = this.parseGeometries(t.geometries, r),
                      a = this.parseImages(t.images, function () {
                        void 0 !== e && e(c);
                      }),
                      o = this.parseTextures(t.textures, a),
                      s = this.parseMaterials(t.materials, o),
                      c = this.parseObject(t.object, i, s, o, n),
                      l = this.parseSkeletons(t.skeletons, c);
                    if ((this.bindSkeletons(c, l), void 0 !== e)) {
                      let t = !1;
                      for (const e in a)
                        if (a[e].data instanceof HTMLImageElement) {
                          t = !0;
                          break;
                        }
                      !1 === t && e(c);
                    }
                    return c;
                  }
                  async parseAsync(t) {
                    const e = this.parseAnimations(t.animations),
                      n = this.parseShapes(t.shapes),
                      r = this.parseGeometries(t.geometries, n),
                      i = await this.parseImagesAsync(t.images),
                      a = this.parseTextures(t.textures, i),
                      o = this.parseMaterials(t.materials, a),
                      s = this.parseObject(t.object, r, o, a, e),
                      c = this.parseSkeletons(t.skeletons, s);
                    return this.bindSkeletons(s, c), s;
                  }
                  parseShapes(t) {
                    const e = {};
                    if (void 0 !== t)
                      for (let n = 0, r = t.length; n < r; n++) {
                        const r = new Id().fromJSON(t[n]);
                        e[r.uuid] = r;
                      }
                    return e;
                  }
                  parseSkeletons(t, e) {
                    const n = {},
                      r = {};
                    if (
                      (e.traverse(function (t) {
                        t.isBone && (r[t.uuid] = t);
                      }),
                      void 0 !== t)
                    )
                      for (let i = 0, a = t.length; i < a; i++) {
                        const e = new bh().fromJSON(t[i], r);
                        n[e.uuid] = e;
                      }
                    return n;
                  }
                  parseGeometries(t, e) {
                    const n = {};
                    if (void 0 !== t) {
                      const r = new Np();
                      for (let i = 0, a = t.length; i < a; i++) {
                        let a;
                        const o = t[i];
                        switch (o.type) {
                          case "BufferGeometry":
                          case "InstancedBufferGeometry":
                            a = r.parse(o);
                            break;
                          case "Geometry":
                            console.error(
                              "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                            );
                            break;
                          default:
                            o.type in Rf
                              ? (a = Rf[o.type].fromJSON(o, e))
                              : console.warn(
                                  `THREE.ObjectLoader: Unsupported geometry type "${o.type}"`
                                );
                        }
                        (a.uuid = o.uuid),
                          void 0 !== o.name && (a.name = o.name),
                          !0 === a.isBufferGeometry &&
                            void 0 !== o.userData &&
                            (a.userData = o.userData),
                          (n[o.uuid] = a);
                      }
                    }
                    return n;
                  }
                  parseMaterials(t, e) {
                    const n = {},
                      r = {};
                    if (void 0 !== t) {
                      const i = new Ip();
                      i.setTextures(e);
                      for (let e = 0, a = t.length; e < a; e++) {
                        const a = t[e];
                        if ("MultiMaterial" === a.type) {
                          const t = [];
                          for (let e = 0; e < a.materials.length; e++) {
                            const r = a.materials[e];
                            void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)),
                              t.push(n[r.uuid]);
                          }
                          r[a.uuid] = t;
                        } else
                          void 0 === n[a.uuid] && (n[a.uuid] = i.parse(a)),
                            (r[a.uuid] = n[a.uuid]);
                      }
                    }
                    return r;
                  }
                  parseAnimations(t) {
                    const e = {};
                    if (void 0 !== t)
                      for (let n = 0; n < t.length; n++) {
                        const r = t[n],
                          i = tp.parse(r);
                        e[i.uuid] = i;
                      }
                    return e;
                  }
                  parseImages(t, e) {
                    const n = this,
                      r = {};
                    let i;
                    function a(t) {
                      return (
                        n.manager.itemStart(t),
                        i.load(
                          t,
                          function () {
                            n.manager.itemEnd(t);
                          },
                          void 0,
                          function () {
                            n.manager.itemError(t), n.manager.itemEnd(t);
                          }
                        )
                      );
                    }
                    function o(t) {
                      if ("string" === typeof t) {
                        const e = t,
                          r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)
                            ? e
                            : n.resourcePath + e;
                        return a(r);
                      }
                      return t.data
                        ? {
                            data: xn(t.type, t.data),
                            width: t.width,
                            height: t.height,
                          }
                        : null;
                    }
                    if (void 0 !== t && t.length > 0) {
                      const n = new ip(e);
                      (i = new up(n)), i.setCrossOrigin(this.crossOrigin);
                      for (let e = 0, i = t.length; e < i; e++) {
                        const n = t[e],
                          i = n.url;
                        if (Array.isArray(i)) {
                          const t = [];
                          for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e],
                              r = o(n);
                            null !== r &&
                              (r instanceof HTMLImageElement
                                ? t.push(r)
                                : t.push(new gh(r.data, r.width, r.height)));
                          }
                          r[n.uuid] = new Nn(t);
                        } else {
                          const t = o(n.url);
                          r[n.uuid] = new Nn(t);
                        }
                      }
                    }
                    return r;
                  }
                  async parseImagesAsync(t) {
                    const e = this,
                      n = {};
                    let r;
                    async function i(t) {
                      if ("string" === typeof t) {
                        const n = t,
                          i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)
                            ? n
                            : e.resourcePath + n;
                        return await r.loadAsync(i);
                      }
                      return t.data
                        ? {
                            data: xn(t.type, t.data),
                            width: t.width,
                            height: t.height,
                          }
                        : null;
                    }
                    if (void 0 !== t && t.length > 0) {
                      (r = new up(this.manager)),
                        r.setCrossOrigin(this.crossOrigin);
                      for (let e = 0, r = t.length; e < r; e++) {
                        const r = t[e],
                          a = r.url;
                        if (Array.isArray(a)) {
                          const t = [];
                          for (let e = 0, n = a.length; e < n; e++) {
                            const n = a[e],
                              r = await i(n);
                            null !== r &&
                              (r instanceof HTMLImageElement
                                ? t.push(r)
                                : t.push(new gh(r.data, r.width, r.height)));
                          }
                          n[r.uuid] = new Nn(t);
                        } else {
                          const t = await i(r.url);
                          n[r.uuid] = new Nn(t);
                        }
                      }
                    }
                    return n;
                  }
                  parseTextures(t, e) {
                    function n(t, e) {
                      return "number" === typeof t
                        ? t
                        : (console.warn(
                            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                            t
                          ),
                          e[t]);
                    }
                    const r = {};
                    if (void 0 !== t)
                      for (let i = 0, a = t.length; i < a; i++) {
                        const a = t[i];
                        void 0 === a.image &&
                          console.warn(
                            'THREE.ObjectLoader: No "image" specified for',
                            a.uuid
                          ),
                          void 0 === e[a.image] &&
                            console.warn(
                              "THREE.ObjectLoader: Undefined image",
                              a.image
                            );
                        const o = e[a.image],
                          s = o.data;
                        let c;
                        Array.isArray(s)
                          ? ((c = new Qi()),
                            6 === s.length && (c.needsUpdate = !0))
                          : ((c = s && s.data ? new gh() : new Fn()),
                            s && (c.needsUpdate = !0)),
                          (c.source = o),
                          (c.uuid = a.uuid),
                          void 0 !== a.name && (c.name = a.name),
                          void 0 !== a.mapping &&
                            (c.mapping = n(a.mapping, zp)),
                          void 0 !== a.offset && c.offset.fromArray(a.offset),
                          void 0 !== a.repeat && c.repeat.fromArray(a.repeat),
                          void 0 !== a.center && c.center.fromArray(a.center),
                          void 0 !== a.rotation && (c.rotation = a.rotation),
                          void 0 !== a.wrap &&
                            ((c.wrapS = n(a.wrap[0], Fp)),
                            (c.wrapT = n(a.wrap[1], Fp))),
                          void 0 !== a.format && (c.format = a.format),
                          void 0 !== a.type && (c.type = a.type),
                          void 0 !== a.encoding && (c.encoding = a.encoding),
                          void 0 !== a.minFilter &&
                            (c.minFilter = n(a.minFilter, Up)),
                          void 0 !== a.magFilter &&
                            (c.magFilter = n(a.magFilter, Up)),
                          void 0 !== a.anisotropy &&
                            (c.anisotropy = a.anisotropy),
                          void 0 !== a.flipY && (c.flipY = a.flipY),
                          void 0 !== a.premultiplyAlpha &&
                            (c.premultiplyAlpha = a.premultiplyAlpha),
                          void 0 !== a.unpackAlignment &&
                            (c.unpackAlignment = a.unpackAlignment),
                          void 0 !== a.userData && (c.userData = a.userData),
                          (r[a.uuid] = c);
                      }
                    return r;
                  }
                  parseObject(t, e, n, r, i) {
                    let a, o, s;
                    function c(t) {
                      return (
                        void 0 === e[t] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined geometry",
                            t
                          ),
                        e[t]
                      );
                    }
                    function l(t) {
                      if (void 0 !== t) {
                        if (Array.isArray(t)) {
                          const e = [];
                          for (let r = 0, i = t.length; r < i; r++) {
                            const i = t[r];
                            void 0 === n[i] &&
                              console.warn(
                                "THREE.ObjectLoader: Undefined material",
                                i
                              ),
                              e.push(n[i]);
                          }
                          return e;
                        }
                        return (
                          void 0 === n[t] &&
                            console.warn(
                              "THREE.ObjectLoader: Undefined material",
                              t
                            ),
                          n[t]
                        );
                      }
                    }
                    function u(t) {
                      return (
                        void 0 === r[t] &&
                          console.warn(
                            "THREE.ObjectLoader: Undefined texture",
                            t
                          ),
                        r[t]
                      );
                    }
                    switch (t.type) {
                      case "Scene":
                        (a = new Bu()),
                          void 0 !== t.background &&
                            (Number.isInteger(t.background)
                              ? (a.background = new In(t.background))
                              : (a.background = u(t.background))),
                          void 0 !== t.environment &&
                            (a.environment = u(t.environment)),
                          void 0 !== t.fog &&
                            ("Fog" === t.fog.type
                              ? (a.fog = new Uu(
                                  t.fog.color,
                                  t.fog.near,
                                  t.fog.far
                                ))
                              : "FogExp2" === t.fog.type &&
                                (a.fog = new Fu(t.fog.color, t.fog.density)));
                        break;
                      case "PerspectiveCamera":
                        (a = new Yi(t.fov, t.aspect, t.near, t.far)),
                          void 0 !== t.focus && (a.focus = t.focus),
                          void 0 !== t.zoom && (a.zoom = t.zoom),
                          void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge),
                          void 0 !== t.filmOffset &&
                            (a.filmOffset = t.filmOffset),
                          void 0 !== t.view &&
                            (a.view = Object.assign({}, t.view));
                        break;
                      case "OrthographicCamera":
                        (a = new Js(
                          t.left,
                          t.right,
                          t.top,
                          t.bottom,
                          t.near,
                          t.far
                        )),
                          void 0 !== t.zoom && (a.zoom = t.zoom),
                          void 0 !== t.view &&
                            (a.view = Object.assign({}, t.view));
                        break;
                      case "AmbientLight":
                        a = new Cp(t.color, t.intensity);
                        break;
                      case "DirectionalLight":
                        a = new Ap(t.color, t.intensity);
                        break;
                      case "PointLight":
                        a = new Tp(t.color, t.intensity, t.distance, t.decay);
                        break;
                      case "RectAreaLight":
                        a = new Lp(t.color, t.intensity, t.width, t.height);
                        break;
                      case "SpotLight":
                        a = new xp(
                          t.color,
                          t.intensity,
                          t.distance,
                          t.angle,
                          t.penumbra,
                          t.decay
                        );
                        break;
                      case "HemisphereLight":
                        a = new pp(t.color, t.groundColor, t.intensity);
                        break;
                      case "LightProbe":
                        a = new Pp().fromJSON(t);
                        break;
                      case "SkinnedMesh":
                        (o = c(t.geometry)),
                          (s = l(t.material)),
                          (a = new ph(o, s)),
                          void 0 !== t.bindMode && (a.bindMode = t.bindMode),
                          void 0 !== t.bindMatrix &&
                            a.bindMatrix.fromArray(t.bindMatrix),
                          void 0 !== t.skeleton && (a.skeleton = t.skeleton);
                        break;
                      case "Mesh":
                        (o = c(t.geometry)),
                          (s = l(t.material)),
                          (a = new Fi(o, s));
                        break;
                      case "InstancedMesh":
                        (o = c(t.geometry)), (s = l(t.material));
                        const e = t.count,
                          n = t.instanceMatrix,
                          r = t.instanceColor;
                        (a = new Th(o, s, e)),
                          (a.instanceMatrix = new xh(
                            new Float32Array(n.array),
                            16
                          )),
                          void 0 !== r &&
                            (a.instanceColor = new xh(
                              new Float32Array(r.array),
                              r.itemSize
                            ));
                        break;
                      case "LOD":
                        a = new ch();
                        break;
                      case "Line":
                        a = new Ih(c(t.geometry), l(t.material));
                        break;
                      case "LineLoop":
                        a = new Dh(c(t.geometry), l(t.material));
                        break;
                      case "LineSegments":
                        a = new Nh(c(t.geometry), l(t.material));
                        break;
                      case "PointCloud":
                      case "Points":
                        a = new Hh(c(t.geometry), l(t.material));
                        break;
                      case "Sprite":
                        a = new ih(l(t.material));
                        break;
                      case "Group":
                        a = new Lu();
                        break;
                      case "Bone":
                        a = new mh();
                        break;
                      default:
                        a = new qr();
                    }
                    if (
                      ((a.uuid = t.uuid),
                      void 0 !== t.name && (a.name = t.name),
                      void 0 !== t.matrix
                        ? (a.matrix.fromArray(t.matrix),
                          void 0 !== t.matrixAutoUpdate &&
                            (a.matrixAutoUpdate = t.matrixAutoUpdate),
                          a.matrixAutoUpdate &&
                            a.matrix.decompose(
                              a.position,
                              a.quaternion,
                              a.scale
                            ))
                        : (void 0 !== t.position &&
                            a.position.fromArray(t.position),
                          void 0 !== t.rotation &&
                            a.rotation.fromArray(t.rotation),
                          void 0 !== t.quaternion &&
                            a.quaternion.fromArray(t.quaternion),
                          void 0 !== t.scale && a.scale.fromArray(t.scale)),
                      void 0 !== t.castShadow && (a.castShadow = t.castShadow),
                      void 0 !== t.receiveShadow &&
                        (a.receiveShadow = t.receiveShadow),
                      t.shadow &&
                        (void 0 !== t.shadow.bias &&
                          (a.shadow.bias = t.shadow.bias),
                        void 0 !== t.shadow.normalBias &&
                          (a.shadow.normalBias = t.shadow.normalBias),
                        void 0 !== t.shadow.radius &&
                          (a.shadow.radius = t.shadow.radius),
                        void 0 !== t.shadow.mapSize &&
                          a.shadow.mapSize.fromArray(t.shadow.mapSize),
                        void 0 !== t.shadow.camera &&
                          (a.shadow.camera = this.parseObject(
                            t.shadow.camera
                          ))),
                      void 0 !== t.visible && (a.visible = t.visible),
                      void 0 !== t.frustumCulled &&
                        (a.frustumCulled = t.frustumCulled),
                      void 0 !== t.renderOrder &&
                        (a.renderOrder = t.renderOrder),
                      void 0 !== t.userData && (a.userData = t.userData),
                      void 0 !== t.layers && (a.layers.mask = t.layers),
                      void 0 !== t.children)
                    ) {
                      const o = t.children;
                      for (let t = 0; t < o.length; t++)
                        a.add(this.parseObject(o[t], e, n, r, i));
                    }
                    if (void 0 !== t.animations) {
                      const e = t.animations;
                      for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        a.animations.push(i[n]);
                      }
                    }
                    if ("LOD" === t.type) {
                      void 0 !== t.autoUpdate && (a.autoUpdate = t.autoUpdate);
                      const e = t.levels;
                      for (let t = 0; t < e.length; t++) {
                        const n = e[t],
                          r = a.getObjectByProperty("uuid", n.object);
                        void 0 !== r && a.addLevel(r, n.distance);
                      }
                    }
                    return a;
                  }
                  bindSkeletons(t, e) {
                    0 !== Object.keys(e).length &&
                      t.traverse(function (t) {
                        if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                          const n = e[t.skeleton];
                          void 0 === n
                            ? console.warn(
                                "THREE.ObjectLoader: No skeleton found with UUID:",
                                t.skeleton
                              )
                            : t.bind(n, t.bindMatrix);
                        }
                      });
                  }
                  setTexturePath(t) {
                    return (
                      console.warn(
                        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
                      ),
                      this.setResourcePath(t)
                    );
                  }
                }
                const zp = {
                    UVMapping: at,
                    CubeReflectionMapping: ot,
                    CubeRefractionMapping: st,
                    EquirectangularReflectionMapping: ct,
                    EquirectangularRefractionMapping: lt,
                    CubeUVReflectionMapping: ut,
                  },
                  Fp = {
                    RepeatWrapping: ht,
                    ClampToEdgeWrapping: dt,
                    MirroredRepeatWrapping: ft,
                  },
                  Up = {
                    NearestFilter: pt,
                    NearestMipmapNearestFilter: mt,
                    NearestMipmapLinearFilter: gt,
                    LinearFilter: vt,
                    LinearMipmapNearestFilter: yt,
                    LinearMipmapLinearFilter: bt,
                  };
                class Bp extends op {
                  constructor(t) {
                    super(t),
                      (this.isImageBitmapLoader = !0),
                      "undefined" === typeof createImageBitmap &&
                        console.warn(
                          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                        ),
                      "undefined" === typeof fetch &&
                        console.warn(
                          "THREE.ImageBitmapLoader: fetch() not supported."
                        ),
                      (this.options = { premultiplyAlpha: "none" });
                  }
                  setOptions(t) {
                    return (this.options = t), this;
                  }
                  load(t, e, n, r) {
                    void 0 === t && (t = ""),
                      void 0 !== this.path && (t = this.path + t),
                      (t = this.manager.resolveURL(t));
                    const i = this,
                      a = rp.get(t);
                    if (void 0 !== a)
                      return (
                        i.manager.itemStart(t),
                        setTimeout(function () {
                          e && e(a), i.manager.itemEnd(t);
                        }, 0),
                        a
                      );
                    const o = {};
                    (o.credentials =
                      "anonymous" === this.crossOrigin
                        ? "same-origin"
                        : "include"),
                      (o.headers = this.requestHeader),
                      fetch(t, o)
                        .then(function (t) {
                          return t.blob();
                        })
                        .then(function (t) {
                          return createImageBitmap(
                            t,
                            Object.assign(i.options, {
                              colorSpaceConversion: "none",
                            })
                          );
                        })
                        .then(function (n) {
                          rp.add(t, n), e && e(n), i.manager.itemEnd(t);
                        })
                        .catch(function (e) {
                          r && r(e),
                            i.manager.itemError(t),
                            i.manager.itemEnd(t);
                        }),
                      i.manager.itemStart(t);
                  }
                }
                class jp {
                  constructor(t = !0) {
                    (this.autoStart = t),
                      (this.startTime = 0),
                      (this.oldTime = 0),
                      (this.elapsedTime = 0),
                      (this.running = !1);
                  }
                  start() {
                    (this.startTime = Hp()),
                      (this.oldTime = this.startTime),
                      (this.elapsedTime = 0),
                      (this.running = !0);
                  }
                  stop() {
                    this.getElapsedTime(),
                      (this.running = !1),
                      (this.autoStart = !1);
                  }
                  getElapsedTime() {
                    return this.getDelta(), this.elapsedTime;
                  }
                  getDelta() {
                    let t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                      const e = Hp();
                      (t = (e - this.oldTime) / 1e3),
                        (this.oldTime = e),
                        (this.elapsedTime += t);
                    }
                    return t;
                  }
                }
                function Hp() {
                  return (
                    "undefined" === typeof performance ? Date : performance
                  ).now();
                }
                class Vp {
                  constructor(t, e, n) {
                    let r, i, a;
                    switch (((this.binding = t), (this.valueSize = n), e)) {
                      case "quaternion":
                        (r = this._slerp),
                          (i = this._slerpAdditive),
                          (a = this._setAdditiveIdentityQuaternion),
                          (this.buffer = new Float64Array(6 * n)),
                          (this._workIndex = 5);
                        break;
                      case "string":
                      case "bool":
                        (r = this._select),
                          (i = this._select),
                          (a = this._setAdditiveIdentityOther),
                          (this.buffer = new Array(5 * n));
                        break;
                      default:
                        (r = this._lerp),
                          (i = this._lerpAdditive),
                          (a = this._setAdditiveIdentityNumeric),
                          (this.buffer = new Float64Array(5 * n));
                    }
                    (this._mixBufferRegion = r),
                      (this._mixBufferRegionAdditive = i),
                      (this._setIdentity = a),
                      (this._origIndex = 3),
                      (this._addIndex = 4),
                      (this.cumulativeWeight = 0),
                      (this.cumulativeWeightAdditive = 0),
                      (this.useCount = 0),
                      (this.referenceCount = 0);
                  }
                  accumulate(t, e) {
                    const n = this.buffer,
                      r = this.valueSize,
                      i = t * r + r;
                    let a = this.cumulativeWeight;
                    if (0 === a) {
                      for (let t = 0; t !== r; ++t) n[i + t] = n[t];
                      a = e;
                    } else {
                      a += e;
                      const t = e / a;
                      this._mixBufferRegion(n, i, 0, t, r);
                    }
                    this.cumulativeWeight = a;
                  }
                  accumulateAdditive(t) {
                    const e = this.buffer,
                      n = this.valueSize,
                      r = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(),
                      this._mixBufferRegionAdditive(e, r, 0, t, n),
                      (this.cumulativeWeightAdditive += t);
                  }
                  apply(t) {
                    const e = this.valueSize,
                      n = this.buffer,
                      r = t * e + e,
                      i = this.cumulativeWeight,
                      a = this.cumulativeWeightAdditive,
                      o = this.binding;
                    if (
                      ((this.cumulativeWeight = 0),
                      (this.cumulativeWeightAdditive = 0),
                      i < 1)
                    ) {
                      const t = e * this._origIndex;
                      this._mixBufferRegion(n, r, t, 1 - i, e);
                    }
                    a > 0 &&
                      this._mixBufferRegionAdditive(
                        n,
                        r,
                        this._addIndex * e,
                        1,
                        e
                      );
                    for (let s = e, c = e + e; s !== c; ++s)
                      if (n[s] !== n[s + e]) {
                        o.setValue(n, r);
                        break;
                      }
                  }
                  saveOriginalState() {
                    const t = this.binding,
                      e = this.buffer,
                      n = this.valueSize,
                      r = n * this._origIndex;
                    t.getValue(e, r);
                    for (let i = n, a = r; i !== a; ++i) e[i] = e[r + (i % n)];
                    this._setIdentity(),
                      (this.cumulativeWeight = 0),
                      (this.cumulativeWeightAdditive = 0);
                  }
                  restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t);
                  }
                  _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                      e = t + this.valueSize;
                    for (let n = t; n < e; n++) this.buffer[n] = 0;
                  }
                  _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(),
                      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
                  }
                  _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                      e = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++)
                      this.buffer[e + n] = this.buffer[t + n];
                  }
                  _select(t, e, n, r, i) {
                    if (r >= 0.5)
                      for (let a = 0; a !== i; ++a) t[e + a] = t[n + a];
                  }
                  _slerp(t, e, n, r) {
                    Vn.slerpFlat(t, e, t, e, t, n, r);
                  }
                  _slerpAdditive(t, e, n, r, i) {
                    const a = this._workIndex * i;
                    Vn.multiplyQuaternionsFlat(t, a, t, e, t, n),
                      Vn.slerpFlat(t, e, t, e, t, a, r);
                  }
                  _lerp(t, e, n, r, i) {
                    const a = 1 - r;
                    for (let o = 0; o !== i; ++o) {
                      const i = e + o;
                      t[i] = t[i] * a + t[n + o] * r;
                    }
                  }
                  _lerpAdditive(t, e, n, r, i) {
                    for (let a = 0; a !== i; ++a) {
                      const i = e + a;
                      t[i] = t[i] + t[n + a] * r;
                    }
                  }
                }
                const Gp = "\\[\\]\\.:\\/",
                  Wp = new RegExp("[" + Gp + "]", "g"),
                  qp = "[^" + Gp + "]",
                  Xp = "[^" + Gp.replace("\\.", "") + "]",
                  $p = /((?:WC+[\/:])*)/.source.replace("WC", qp),
                  Yp = /(WCOD+)?/.source.replace("WCOD", Xp),
                  Jp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", qp),
                  Kp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", qp),
                  Zp = new RegExp("^" + $p + Yp + Jp + Kp + "$"),
                  Qp = ["material", "materials", "bones"];
                class tm {
                  constructor(t, e, n) {
                    const r = n || em.parseTrackName(e);
                    (this._targetGroup = t),
                      (this._bindings = t.subscribe_(e, r));
                  }
                  getValue(t, e) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                      r = this._bindings[n];
                    void 0 !== r && r.getValue(t, e);
                  }
                  setValue(t, e) {
                    const n = this._bindings;
                    for (
                      let r = this._targetGroup.nCachedObjects_, i = n.length;
                      r !== i;
                      ++r
                    )
                      n[r].setValue(t, e);
                  }
                  bind() {
                    const t = this._bindings;
                    for (
                      let e = this._targetGroup.nCachedObjects_, n = t.length;
                      e !== n;
                      ++e
                    )
                      t[e].bind();
                  }
                  unbind() {
                    const t = this._bindings;
                    for (
                      let e = this._targetGroup.nCachedObjects_, n = t.length;
                      e !== n;
                      ++e
                    )
                      t[e].unbind();
                  }
                }
                class em {
                  constructor(t, e, n) {
                    (this.path = e),
                      (this.parsedPath = n || em.parseTrackName(e)),
                      (this.node =
                        em.findNode(t, this.parsedPath.nodeName) || t),
                      (this.rootNode = t),
                      (this.getValue = this._getValue_unbound),
                      (this.setValue = this._setValue_unbound);
                  }
                  static create(t, e, n) {
                    return t && t.isAnimationObjectGroup
                      ? new em.Composite(t, e, n)
                      : new em(t, e, n);
                  }
                  static sanitizeNodeName(t) {
                    return t.replace(/\s/g, "_").replace(Wp, "");
                  }
                  static parseTrackName(t) {
                    const e = Zp.exec(t);
                    if (null === e)
                      throw new Error(
                        "PropertyBinding: Cannot parse trackName: " + t
                      );
                    const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6],
                      },
                      r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                      const t = n.nodeName.substring(r + 1);
                      -1 !== Qp.indexOf(t) &&
                        ((n.nodeName = n.nodeName.substring(0, r)),
                        (n.objectName = t));
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                      throw new Error(
                        "PropertyBinding: can not parse propertyName from trackName: " +
                          t
                      );
                    return n;
                  }
                  static findNode(t, e) {
                    if (
                      void 0 === e ||
                      "" === e ||
                      "." === e ||
                      -1 === e ||
                      e === t.name ||
                      e === t.uuid
                    )
                      return t;
                    if (t.skeleton) {
                      const n = t.skeleton.getBoneByName(e);
                      if (void 0 !== n) return n;
                    }
                    if (t.children) {
                      const n = function (t) {
                          for (let r = 0; r < t.length; r++) {
                            const i = t[r];
                            if (i.name === e || i.uuid === e) return i;
                            const a = n(i.children);
                            if (a) return a;
                          }
                          return null;
                        },
                        r = n(t.children);
                      if (r) return r;
                    }
                    return null;
                  }
                  _getValue_unavailable() {}
                  _setValue_unavailable() {}
                  _getValue_direct(t, e) {
                    t[e] = this.targetObject[this.propertyName];
                  }
                  _getValue_array(t, e) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r];
                  }
                  _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex];
                  }
                  _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e);
                  }
                  _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e];
                  }
                  _setValue_direct_setNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]),
                      (this.targetObject.needsUpdate = !0);
                  }
                  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]),
                      (this.targetObject.matrixWorldNeedsUpdate = !0);
                  }
                  _setValue_array(t, e) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                  }
                  _setValue_array_setNeedsUpdate(t, e) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                    this.targetObject.needsUpdate = !0;
                  }
                  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0;
                  }
                  _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e];
                  }
                  _setValue_arrayElement_setNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]),
                      (this.targetObject.needsUpdate = !0);
                  }
                  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]),
                      (this.targetObject.matrixWorldNeedsUpdate = !0);
                  }
                  _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e);
                  }
                  _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e),
                      (this.targetObject.needsUpdate = !0);
                  }
                  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e),
                      (this.targetObject.matrixWorldNeedsUpdate = !0);
                  }
                  _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e);
                  }
                  _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e);
                  }
                  bind() {
                    let t = this.node;
                    const e = this.parsedPath,
                      n = e.objectName,
                      r = e.propertyName;
                    let i = e.propertyIndex;
                    if (
                      (t ||
                        ((t =
                          em.findNode(this.rootNode, e.nodeName) ||
                          this.rootNode),
                        (this.node = t)),
                      (this.getValue = this._getValue_unavailable),
                      (this.setValue = this._setValue_unavailable),
                      !t)
                    )
                      return void console.error(
                        "THREE.PropertyBinding: Trying to update node for track: " +
                          this.path +
                          " but it wasn't found."
                      );
                    if (n) {
                      let r = e.objectIndex;
                      switch (n) {
                        case "materials":
                          if (!t.material)
                            return void console.error(
                              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                              this
                            );
                          if (!t.material.materials)
                            return void console.error(
                              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                              this
                            );
                          t = t.material.materials;
                          break;
                        case "bones":
                          if (!t.skeleton)
                            return void console.error(
                              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                              this
                            );
                          t = t.skeleton.bones;
                          for (let e = 0; e < t.length; e++)
                            if (t[e].name === r) {
                              r = e;
                              break;
                            }
                          break;
                        default:
                          if (void 0 === t[n])
                            return void console.error(
                              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                              this
                            );
                          t = t[n];
                      }
                      if (void 0 !== r) {
                        if (void 0 === t[r])
                          return void console.error(
                            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                            this,
                            t
                          );
                        t = t[r];
                      }
                    }
                    const a = t[r];
                    if (void 0 === a) {
                      const n = e.nodeName;
                      return void console.error(
                        "THREE.PropertyBinding: Trying to update property for track: " +
                          n +
                          "." +
                          r +
                          " but it wasn't found.",
                        t
                      );
                    }
                    let o = this.Versioning.None;
                    (this.targetObject = t),
                      void 0 !== t.needsUpdate
                        ? (o = this.Versioning.NeedsUpdate)
                        : void 0 !== t.matrixWorldNeedsUpdate &&
                          (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let s = this.BindingType.Direct;
                    if (void 0 !== i) {
                      if ("morphTargetInfluences" === r) {
                        if (!t.geometry)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                            this
                          );
                        if (!t.geometry.morphAttributes)
                          return void console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                            this
                          );
                        void 0 !== t.morphTargetDictionary[i] &&
                          (i = t.morphTargetDictionary[i]);
                      }
                      (s = this.BindingType.ArrayElement),
                        (this.resolvedProperty = a),
                        (this.propertyIndex = i);
                    } else
                      void 0 !== a.fromArray && void 0 !== a.toArray
                        ? ((s = this.BindingType.HasFromToArray),
                          (this.resolvedProperty = a))
                        : Array.isArray(a)
                        ? ((s = this.BindingType.EntireArray),
                          (this.resolvedProperty = a))
                        : (this.propertyName = r);
                    (this.getValue = this.GetterByBindingType[s]),
                      (this.setValue =
                        this.SetterByBindingTypeAndVersioning[s][o]);
                  }
                  unbind() {
                    (this.node = null),
                      (this.getValue = this._getValue_unbound),
                      (this.setValue = this._setValue_unbound);
                  }
                }
                (em.Composite = tm),
                  (em.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3,
                  }),
                  (em.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2,
                  }),
                  (em.prototype.GetterByBindingType = [
                    em.prototype._getValue_direct,
                    em.prototype._getValue_array,
                    em.prototype._getValue_arrayElement,
                    em.prototype._getValue_toArray,
                  ]),
                  (em.prototype.SetterByBindingTypeAndVersioning = [
                    [
                      em.prototype._setValue_direct,
                      em.prototype._setValue_direct_setNeedsUpdate,
                      em.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
                    ],
                    [
                      em.prototype._setValue_array,
                      em.prototype._setValue_array_setNeedsUpdate,
                      em.prototype._setValue_array_setMatrixWorldNeedsUpdate,
                    ],
                    [
                      em.prototype._setValue_arrayElement,
                      em.prototype._setValue_arrayElement_setNeedsUpdate,
                      em.prototype
                        ._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                    ],
                    [
                      em.prototype._setValue_fromArray,
                      em.prototype._setValue_fromArray_setNeedsUpdate,
                      em.prototype
                        ._setValue_fromArray_setMatrixWorldNeedsUpdate,
                    ],
                  ]);
                class nm {
                  constructor(t, e, n = null, r = e.blendMode) {
                    (this._mixer = t),
                      (this._clip = e),
                      (this._localRoot = n),
                      (this.blendMode = r);
                    const i = e.tracks,
                      a = i.length,
                      o = new Array(a),
                      s = { endingStart: _e, endingEnd: _e };
                    for (let c = 0; c !== a; ++c) {
                      const t = i[c].createInterpolant(null);
                      (o[c] = t), (t.settings = s);
                    }
                    (this._interpolantSettings = s),
                      (this._interpolants = o),
                      (this._propertyBindings = new Array(a)),
                      (this._cacheIndex = null),
                      (this._byClipCacheIndex = null),
                      (this._timeScaleInterpolant = null),
                      (this._weightInterpolant = null),
                      (this.loop = ge),
                      (this._loopCount = -1),
                      (this._startTime = null),
                      (this.time = 0),
                      (this.timeScale = 1),
                      (this._effectiveTimeScale = 1),
                      (this.weight = 1),
                      (this._effectiveWeight = 1),
                      (this.repetitions = 1 / 0),
                      (this.paused = !1),
                      (this.enabled = !0),
                      (this.clampWhenFinished = !1),
                      (this.zeroSlopeAtStart = !0),
                      (this.zeroSlopeAtEnd = !0);
                  }
                  play() {
                    return this._mixer._activateAction(this), this;
                  }
                  stop() {
                    return this._mixer._deactivateAction(this), this.reset();
                  }
                  reset() {
                    return (
                      (this.paused = !1),
                      (this.enabled = !0),
                      (this.time = 0),
                      (this._loopCount = -1),
                      (this._startTime = null),
                      this.stopFading().stopWarping()
                    );
                  }
                  isRunning() {
                    return (
                      this.enabled &&
                      !this.paused &&
                      0 !== this.timeScale &&
                      null === this._startTime &&
                      this._mixer._isActiveAction(this)
                    );
                  }
                  isScheduled() {
                    return this._mixer._isActiveAction(this);
                  }
                  startAt(t) {
                    return (this._startTime = t), this;
                  }
                  setLoop(t, e) {
                    return (this.loop = t), (this.repetitions = e), this;
                  }
                  setEffectiveWeight(t) {
                    return (
                      (this.weight = t),
                      (this._effectiveWeight = this.enabled ? t : 0),
                      this.stopFading()
                    );
                  }
                  getEffectiveWeight() {
                    return this._effectiveWeight;
                  }
                  fadeIn(t) {
                    return this._scheduleFading(t, 0, 1);
                  }
                  fadeOut(t) {
                    return this._scheduleFading(t, 1, 0);
                  }
                  crossFadeFrom(t, e, n) {
                    if ((t.fadeOut(e), this.fadeIn(e), n)) {
                      const n = this._clip.duration,
                        r = t._clip.duration,
                        i = r / n,
                        a = n / r;
                      t.warp(1, i, e), this.warp(a, 1, e);
                    }
                    return this;
                  }
                  crossFadeTo(t, e, n) {
                    return t.crossFadeFrom(this, e, n);
                  }
                  stopFading() {
                    const t = this._weightInterpolant;
                    return (
                      null !== t &&
                        ((this._weightInterpolant = null),
                        this._mixer._takeBackControlInterpolant(t)),
                      this
                    );
                  }
                  setEffectiveTimeScale(t) {
                    return (
                      (this.timeScale = t),
                      (this._effectiveTimeScale = this.paused ? 0 : t),
                      this.stopWarping()
                    );
                  }
                  getEffectiveTimeScale() {
                    return this._effectiveTimeScale;
                  }
                  setDuration(t) {
                    return (
                      (this.timeScale = this._clip.duration / t),
                      this.stopWarping()
                    );
                  }
                  syncWith(t) {
                    return (
                      (this.time = t.time),
                      (this.timeScale = t.timeScale),
                      this.stopWarping()
                    );
                  }
                  halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t);
                  }
                  warp(t, e, n) {
                    const r = this._mixer,
                      i = r.time,
                      a = this.timeScale;
                    let o = this._timeScaleInterpolant;
                    null === o &&
                      ((o = r._lendControlInterpolant()),
                      (this._timeScaleInterpolant = o));
                    const s = o.parameterPositions,
                      c = o.sampleValues;
                    return (
                      (s[0] = i),
                      (s[1] = i + n),
                      (c[0] = t / a),
                      (c[1] = e / a),
                      this
                    );
                  }
                  stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return (
                      null !== t &&
                        ((this._timeScaleInterpolant = null),
                        this._mixer._takeBackControlInterpolant(t)),
                      this
                    );
                  }
                  getMixer() {
                    return this._mixer;
                  }
                  getClip() {
                    return this._clip;
                  }
                  getRoot() {
                    return this._localRoot || this._mixer._root;
                  }
                  _update(t, e, n, r) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const i = this._startTime;
                    if (null !== i) {
                      const r = (t - i) * n;
                      if (r < 0 || 0 === n) return;
                      (this._startTime = null), (e = n * r);
                    }
                    e *= this._updateTimeScale(t);
                    const a = this._updateTime(e),
                      o = this._updateWeight(t);
                    if (o > 0) {
                      const t = this._interpolants,
                        e = this._propertyBindings;
                      switch (this.blendMode) {
                        case Te:
                          for (let n = 0, r = t.length; n !== r; ++n)
                            t[n].evaluate(a), e[n].accumulateAdditive(o);
                          break;
                        case Me:
                        default:
                          for (let n = 0, i = t.length; n !== i; ++n)
                            t[n].evaluate(a), e[n].accumulate(r, o);
                      }
                    }
                  }
                  _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                      e = this.weight;
                      const n = this._weightInterpolant;
                      if (null !== n) {
                        const r = n.evaluate(t)[0];
                        (e *= r),
                          t > n.parameterPositions[1] &&
                            (this.stopFading(), 0 === r && (this.enabled = !1));
                      }
                    }
                    return (this._effectiveWeight = e), e;
                  }
                  _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                      e = this.timeScale;
                      const n = this._timeScaleInterpolant;
                      if (null !== n) {
                        const r = n.evaluate(t)[0];
                        (e *= r),
                          t > n.parameterPositions[1] &&
                            (this.stopWarping(),
                            0 === e
                              ? (this.paused = !0)
                              : (this.timeScale = e));
                      }
                    }
                    return (this._effectiveTimeScale = e), e;
                  }
                  _updateTime(t) {
                    const e = this._clip.duration,
                      n = this.loop;
                    let r = this.time + t,
                      i = this._loopCount;
                    const a = n === ve;
                    if (0 === t)
                      return -1 === i ? r : a && 1 === (1 & i) ? e - r : r;
                    if (n === me) {
                      -1 === i &&
                        ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                      t: {
                        if (r >= e) r = e;
                        else {
                          if (!(r < 0)) {
                            this.time = r;
                            break t;
                          }
                          r = 0;
                        }
                        this.clampWhenFinished
                          ? (this.paused = !0)
                          : (this.enabled = !1),
                          (this.time = r),
                          this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1,
                          });
                      }
                    } else {
                      if (
                        (-1 === i &&
                          (t >= 0
                            ? ((i = 0),
                              this._setEndings(!0, 0 === this.repetitions, a))
                            : this._setEndings(0 === this.repetitions, !0, a)),
                        r >= e || r < 0)
                      ) {
                        const n = Math.floor(r / e);
                        (r -= e * n), (i += Math.abs(n));
                        const o = this.repetitions - i;
                        if (o <= 0)
                          this.clampWhenFinished
                            ? (this.paused = !0)
                            : (this.enabled = !1),
                            (r = t > 0 ? e : 0),
                            (this.time = r),
                            this._mixer.dispatchEvent({
                              type: "finished",
                              action: this,
                              direction: t > 0 ? 1 : -1,
                            });
                        else {
                          if (1 === o) {
                            const e = t < 0;
                            this._setEndings(e, !e, a);
                          } else this._setEndings(!1, !1, a);
                          (this._loopCount = i),
                            (this.time = r),
                            this._mixer.dispatchEvent({
                              type: "loop",
                              action: this,
                              loopDelta: n,
                            });
                        }
                      } else this.time = r;
                      if (a && 1 === (1 & i)) return e - r;
                    }
                    return r;
                  }
                  _setEndings(t, e, n) {
                    const r = this._interpolantSettings;
                    n
                      ? ((r.endingStart = we), (r.endingEnd = we))
                      : ((r.endingStart = t
                          ? this.zeroSlopeAtStart
                            ? we
                            : _e
                          : Se),
                        (r.endingEnd = e
                          ? this.zeroSlopeAtEnd
                            ? we
                            : _e
                          : Se));
                  }
                  _scheduleFading(t, e, n) {
                    const r = this._mixer,
                      i = r.time;
                    let a = this._weightInterpolant;
                    null === a &&
                      ((a = r._lendControlInterpolant()),
                      (this._weightInterpolant = a));
                    const o = a.parameterPositions,
                      s = a.sampleValues;
                    return (
                      (o[0] = i), (s[0] = e), (o[1] = i + t), (s[1] = n), this
                    );
                  }
                }
                const rm = new Float32Array(1);
                class im extends je {
                  constructor(t) {
                    super(),
                      (this._root = t),
                      this._initMemoryManager(),
                      (this._accuIndex = 0),
                      (this.time = 0),
                      (this.timeScale = 1);
                  }
                  _bindAction(t, e) {
                    const n = t._localRoot || this._root,
                      r = t._clip.tracks,
                      i = r.length,
                      a = t._propertyBindings,
                      o = t._interpolants,
                      s = n.uuid,
                      c = this._bindingsByRootAndName;
                    let l = c[s];
                    void 0 === l && ((l = {}), (c[s] = l));
                    for (let u = 0; u !== i; ++u) {
                      const t = r[u],
                        i = t.name;
                      let c = l[i];
                      if (void 0 !== c) ++c.referenceCount, (a[u] = c);
                      else {
                        if (((c = a[u]), void 0 !== c)) {
                          null === c._cacheIndex &&
                            (++c.referenceCount,
                            this._addInactiveBinding(c, s, i));
                          continue;
                        }
                        const r =
                          e && e._propertyBindings[u].binding.parsedPath;
                        (c = new Vp(
                          em.create(n, i, r),
                          t.ValueTypeName,
                          t.getValueSize()
                        )),
                          ++c.referenceCount,
                          this._addInactiveBinding(c, s, i),
                          (a[u] = c);
                      }
                      o[u].resultBuffer = c.buffer;
                    }
                  }
                  _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                      if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid,
                          n = t._clip.uuid,
                          r = this._actionsByClip[n];
                        this._bindAction(t, r && r.knownActions[0]),
                          this._addInactiveAction(t, n, e);
                      }
                      const e = t._propertyBindings;
                      for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 === n.useCount++ &&
                          (this._lendBinding(n), n.saveOriginalState());
                      }
                      this._lendAction(t);
                    }
                  }
                  _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                      const e = t._propertyBindings;
                      for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 === --n.useCount &&
                          (n.restoreOriginalState(), this._takeBackBinding(n));
                      }
                      this._takeBackAction(t);
                    }
                  }
                  _initMemoryManager() {
                    (this._actions = []),
                      (this._nActiveActions = 0),
                      (this._actionsByClip = {}),
                      (this._bindings = []),
                      (this._nActiveBindings = 0),
                      (this._bindingsByRootAndName = {}),
                      (this._controlInterpolants = []),
                      (this._nActiveControlInterpolants = 0);
                    const t = this;
                    this.stats = {
                      actions: {
                        get total() {
                          return t._actions.length;
                        },
                        get inUse() {
                          return t._nActiveActions;
                        },
                      },
                      bindings: {
                        get total() {
                          return t._bindings.length;
                        },
                        get inUse() {
                          return t._nActiveBindings;
                        },
                      },
                      controlInterpolants: {
                        get total() {
                          return t._controlInterpolants.length;
                        },
                        get inUse() {
                          return t._nActiveControlInterpolants;
                        },
                      },
                    };
                  }
                  _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions;
                  }
                  _addInactiveAction(t, e, n) {
                    const r = this._actions,
                      i = this._actionsByClip;
                    let a = i[e];
                    if (void 0 === a)
                      (a = { knownActions: [t], actionByRoot: {} }),
                        (t._byClipCacheIndex = 0),
                        (i[e] = a);
                    else {
                      const e = a.knownActions;
                      (t._byClipCacheIndex = e.length), e.push(t);
                    }
                    (t._cacheIndex = r.length),
                      r.push(t),
                      (a.actionByRoot[n] = t);
                  }
                  _removeInactiveAction(t) {
                    const e = this._actions,
                      n = e[e.length - 1],
                      r = t._cacheIndex;
                    (n._cacheIndex = r),
                      (e[r] = n),
                      e.pop(),
                      (t._cacheIndex = null);
                    const i = t._clip.uuid,
                      a = this._actionsByClip,
                      o = a[i],
                      s = o.knownActions,
                      c = s[s.length - 1],
                      l = t._byClipCacheIndex;
                    (c._byClipCacheIndex = l),
                      (s[l] = c),
                      s.pop(),
                      (t._byClipCacheIndex = null);
                    const u = o.actionByRoot,
                      h = (t._localRoot || this._root).uuid;
                    delete u[h],
                      0 === s.length && delete a[i],
                      this._removeInactiveBindingsForAction(t);
                  }
                  _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                      const t = e[n];
                      0 === --t.referenceCount &&
                        this._removeInactiveBinding(t);
                    }
                  }
                  _lendAction(t) {
                    const e = this._actions,
                      n = t._cacheIndex,
                      r = this._nActiveActions++,
                      i = e[r];
                    (t._cacheIndex = r),
                      (e[r] = t),
                      (i._cacheIndex = n),
                      (e[n] = i);
                  }
                  _takeBackAction(t) {
                    const e = this._actions,
                      n = t._cacheIndex,
                      r = --this._nActiveActions,
                      i = e[r];
                    (t._cacheIndex = r),
                      (e[r] = t),
                      (i._cacheIndex = n),
                      (e[n] = i);
                  }
                  _addInactiveBinding(t, e, n) {
                    const r = this._bindingsByRootAndName,
                      i = this._bindings;
                    let a = r[e];
                    void 0 === a && ((a = {}), (r[e] = a)),
                      (a[n] = t),
                      (t._cacheIndex = i.length),
                      i.push(t);
                  }
                  _removeInactiveBinding(t) {
                    const e = this._bindings,
                      n = t.binding,
                      r = n.rootNode.uuid,
                      i = n.path,
                      a = this._bindingsByRootAndName,
                      o = a[r],
                      s = e[e.length - 1],
                      c = t._cacheIndex;
                    (s._cacheIndex = c),
                      (e[c] = s),
                      e.pop(),
                      delete o[i],
                      0 === Object.keys(o).length && delete a[r];
                  }
                  _lendBinding(t) {
                    const e = this._bindings,
                      n = t._cacheIndex,
                      r = this._nActiveBindings++,
                      i = e[r];
                    (t._cacheIndex = r),
                      (e[r] = t),
                      (i._cacheIndex = n),
                      (e[n] = i);
                  }
                  _takeBackBinding(t) {
                    const e = this._bindings,
                      n = t._cacheIndex,
                      r = --this._nActiveBindings,
                      i = e[r];
                    (t._cacheIndex = r),
                      (e[r] = t),
                      (i._cacheIndex = n),
                      (e[n] = i);
                  }
                  _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                      e = this._nActiveControlInterpolants++;
                    let n = t[e];
                    return (
                      void 0 === n &&
                        ((n = new Gf(
                          new Float32Array(2),
                          new Float32Array(2),
                          1,
                          rm
                        )),
                        (n.__cacheIndex = e),
                        (t[e] = n)),
                      n
                    );
                  }
                  _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                      n = t.__cacheIndex,
                      r = --this._nActiveControlInterpolants,
                      i = e[r];
                    (t.__cacheIndex = r),
                      (e[r] = t),
                      (i.__cacheIndex = n),
                      (e[n] = i);
                  }
                  clipAction(t, e, n) {
                    const r = e || this._root,
                      i = r.uuid;
                    let a = "string" === typeof t ? tp.findByName(r, t) : t;
                    const o = null !== a ? a.uuid : t,
                      s = this._actionsByClip[o];
                    let c = null;
                    if (
                      (void 0 === n && (n = null !== a ? a.blendMode : Me),
                      void 0 !== s)
                    ) {
                      const t = s.actionByRoot[i];
                      if (void 0 !== t && t.blendMode === n) return t;
                      (c = s.knownActions[0]), null === a && (a = c._clip);
                    }
                    if (null === a) return null;
                    const l = new nm(this, a, e, n);
                    return (
                      this._bindAction(l, c),
                      this._addInactiveAction(l, o, i),
                      l
                    );
                  }
                  existingAction(t, e) {
                    const n = e || this._root,
                      r = n.uuid,
                      i = "string" === typeof t ? tp.findByName(n, t) : t,
                      a = i ? i.uuid : t,
                      o = this._actionsByClip[a];
                    return (void 0 !== o && o.actionByRoot[r]) || null;
                  }
                  stopAllAction() {
                    const t = this._actions,
                      e = this._nActiveActions;
                    for (let n = e - 1; n >= 0; --n) t[n].stop();
                    return this;
                  }
                  update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                      n = this._nActiveActions,
                      r = (this.time += t),
                      i = Math.sign(t),
                      a = (this._accuIndex ^= 1);
                    for (let c = 0; c !== n; ++c) {
                      const n = e[c];
                      n._update(r, t, i, a);
                    }
                    const o = this._bindings,
                      s = this._nActiveBindings;
                    for (let c = 0; c !== s; ++c) o[c].apply(a);
                    return this;
                  }
                  setTime(t) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++)
                      this._actions[e].time = 0;
                    return this.update(t);
                  }
                  getRoot() {
                    return this._root;
                  }
                  uncacheClip(t) {
                    const e = this._actions,
                      n = t.uuid,
                      r = this._actionsByClip,
                      i = r[n];
                    if (void 0 !== i) {
                      const t = i.knownActions;
                      for (let n = 0, r = t.length; n !== r; ++n) {
                        const r = t[n];
                        this._deactivateAction(r);
                        const i = r._cacheIndex,
                          a = e[e.length - 1];
                        (r._cacheIndex = null),
                          (r._byClipCacheIndex = null),
                          (a._cacheIndex = i),
                          (e[i] = a),
                          e.pop(),
                          this._removeInactiveBindingsForAction(r);
                      }
                      delete r[n];
                    }
                  }
                  uncacheRoot(t) {
                    const e = t.uuid,
                      n = this._actionsByClip;
                    for (const a in n) {
                      const t = n[a].actionByRoot,
                        r = t[e];
                      void 0 !== r &&
                        (this._deactivateAction(r),
                        this._removeInactiveAction(r));
                    }
                    const r = this._bindingsByRootAndName,
                      i = r[e];
                    if (void 0 !== i)
                      for (const a in i) {
                        const t = i[a];
                        t.restoreOriginalState(),
                          this._removeInactiveBinding(t);
                      }
                  }
                  uncacheAction(t, e) {
                    const n = this.existingAction(t, e);
                    null !== n &&
                      (this._deactivateAction(n),
                      this._removeInactiveAction(n));
                  }
                }
                class am {
                  constructor(t, e, n = 0, r = 1 / 0) {
                    (this.ray = new xr(t, e)),
                      (this.near = n),
                      (this.far = r),
                      (this.camera = null),
                      (this.layers = new Ir()),
                      (this.params = {
                        Mesh: {},
                        Line: { threshold: 1 },
                        LOD: {},
                        Points: { threshold: 1 },
                        Sprite: {},
                      });
                  }
                  set(t, e) {
                    this.ray.set(t, e);
                  }
                  setFromCamera(t, e) {
                    e.isPerspectiveCamera
                      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction
                          .set(t.x, t.y, 0.5)
                          .unproject(e)
                          .sub(this.ray.origin)
                          .normalize(),
                        (this.camera = e))
                      : e.isOrthographicCamera
                      ? (this.ray.origin
                          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                          .unproject(e),
                        this.ray.direction
                          .set(0, 0, -1)
                          .transformDirection(e.matrixWorld),
                        (this.camera = e))
                      : console.error(
                          "THREE.Raycaster: Unsupported camera type: " + e.type
                        );
                  }
                  intersectObject(t, e = !0, n = []) {
                    return sm(t, this, n, e), n.sort(om), n;
                  }
                  intersectObjects(t, e = !0, n = []) {
                    for (let r = 0, i = t.length; r < i; r++)
                      sm(t[r], this, n, e);
                    return n.sort(om), n;
                  }
                }
                function om(t, e) {
                  return t.distance - e.distance;
                }
                function sm(t, e, n, r) {
                  if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === r)) {
                    const r = t.children;
                    for (let t = 0, i = r.length; t < i; t++)
                      sm(r[t], e, n, !0);
                  }
                }
                class cm {
                  constructor(t = 1, e = 0, n = 0) {
                    return (
                      (this.radius = t), (this.phi = e), (this.theta = n), this
                    );
                  }
                  set(t, e, n) {
                    return (
                      (this.radius = t), (this.phi = e), (this.theta = n), this
                    );
                  }
                  copy(t) {
                    return (
                      (this.radius = t.radius),
                      (this.phi = t.phi),
                      (this.theta = t.theta),
                      this
                    );
                  }
                  makeSafe() {
                    const t = 1e-6;
                    return (
                      (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))),
                      this
                    );
                  }
                  setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z);
                  }
                  setFromCartesianCoords(t, e, n) {
                    return (
                      (this.radius = Math.sqrt(t * t + e * e + n * n)),
                      0 === this.radius
                        ? ((this.theta = 0), (this.phi = 0))
                        : ((this.theta = Math.atan2(t, n)),
                          (this.phi = Math.acos(Xe(e / this.radius, -1, 1)))),
                      this
                    );
                  }
                  clone() {
                    return new this.constructor().copy(this);
                  }
                }
                const {
                  floatView: lm,
                  uint32View: um,
                  baseTable: hm,
                  shiftTable: dm,
                  mantissaTable: fm,
                  exponentTable: pm,
                  offsetTable: mm,
                } = gm();
                function gm() {
                  const t = new ArrayBuffer(4),
                    e = new Float32Array(t),
                    n = new Uint32Array(t),
                    r = new Uint32Array(512),
                    i = new Uint32Array(512);
                  for (let c = 0; c < 256; ++c) {
                    const t = c - 127;
                    t < -27
                      ? ((r[c] = 0),
                        (r[256 | c] = 32768),
                        (i[c] = 24),
                        (i[256 | c] = 24))
                      : t < -14
                      ? ((r[c] = 1024 >> (-t - 14)),
                        (r[256 | c] = (1024 >> (-t - 14)) | 32768),
                        (i[c] = -t - 1),
                        (i[256 | c] = -t - 1))
                      : t <= 15
                      ? ((r[c] = (t + 15) << 10),
                        (r[256 | c] = ((t + 15) << 10) | 32768),
                        (i[c] = 13),
                        (i[256 | c] = 13))
                      : t < 128
                      ? ((r[c] = 31744),
                        (r[256 | c] = 64512),
                        (i[c] = 24),
                        (i[256 | c] = 24))
                      : ((r[c] = 31744),
                        (r[256 | c] = 64512),
                        (i[c] = 13),
                        (i[256 | c] = 13));
                  }
                  const a = new Uint32Array(2048),
                    o = new Uint32Array(64),
                    s = new Uint32Array(64);
                  for (let c = 1; c < 1024; ++c) {
                    let t = c << 13,
                      e = 0;
                    while (0 === (8388608 & t)) (t <<= 1), (e -= 8388608);
                    (t &= -8388609), (e += 947912704), (a[c] = t | e);
                  }
                  for (let c = 1024; c < 2048; ++c)
                    a[c] = 939524096 + ((c - 1024) << 13);
                  for (let c = 1; c < 31; ++c) o[c] = c << 23;
                  (o[31] = 1199570944), (o[32] = 2147483648);
                  for (let c = 33; c < 63; ++c)
                    o[c] = 2147483648 + ((c - 32) << 23);
                  o[63] = 3347054592;
                  for (let c = 1; c < 64; ++c) 32 !== c && (s[c] = 1024);
                  return {
                    floatView: e,
                    uint32View: n,
                    baseTable: r,
                    shiftTable: i,
                    mantissaTable: a,
                    exponentTable: o,
                    offsetTable: s,
                  };
                }
                "undefined" !== typeof __THREE_DEVTOOLS__ &&
                  __THREE_DEVTOOLS__.dispatchEvent(
                    new CustomEvent("register", { detail: { revision: s } })
                  ),
                  "undefined" !== typeof window &&
                    (window.__THREE__
                      ? console.warn(
                          "WARNING: Multiple instances of Three.js being imported."
                        )
                      : (window.__THREE__ = s));
                const vm = { type: "change" },
                  ym = { type: "start" },
                  bm = { type: "end" };
                class xm extends je {
                  constructor(t, e) {
                    super(),
                      void 0 === e &&
                        console.warn(
                          'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
                        ),
                      e === document &&
                        console.error(
                          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
                        ),
                      (this.object = t),
                      (this.domElement = e),
                      (this.domElement.style.touchAction = "none"),
                      (this.enabled = !0),
                      (this.target = new Gn()),
                      (this.minDistance = 0),
                      (this.maxDistance = 1 / 0),
                      (this.minZoom = 0),
                      (this.maxZoom = 1 / 0),
                      (this.minPolarAngle = 0),
                      (this.maxPolarAngle = Math.PI),
                      (this.minAzimuthAngle = -1 / 0),
                      (this.maxAzimuthAngle = 1 / 0),
                      (this.enableDamping = !1),
                      (this.dampingFactor = 0.05),
                      (this.enableZoom = !0),
                      (this.zoomSpeed = 1),
                      (this.enableRotate = !0),
                      (this.rotateSpeed = 1),
                      (this.enablePan = !0),
                      (this.panSpeed = 1),
                      (this.screenSpacePanning = !0),
                      (this.keyPanSpeed = 7),
                      (this.autoRotate = !1),
                      (this.autoRotateSpeed = 2),
                      (this.keys = {
                        LEFT: "ArrowLeft",
                        UP: "ArrowUp",
                        RIGHT: "ArrowRight",
                        BOTTOM: "ArrowDown",
                      }),
                      (this.mouseButtons = {
                        LEFT: c.ROTATE,
                        MIDDLE: c.DOLLY,
                        RIGHT: c.PAN,
                      }),
                      (this.touches = { ONE: l.ROTATE, TWO: l.DOLLY_PAN }),
                      (this.target0 = this.target.clone()),
                      (this.position0 = this.object.position.clone()),
                      (this.zoom0 = this.object.zoom),
                      (this._domElementKeyEvents = null),
                      (this.getPolarAngle = function () {
                        return o.phi;
                      }),
                      (this.getAzimuthalAngle = function () {
                        return o.theta;
                      }),
                      (this.getDistance = function () {
                        return this.object.position.distanceTo(this.target);
                      }),
                      (this.listenToKeyEvents = function (t) {
                        t.addEventListener("keydown", it),
                          (this._domElementKeyEvents = t);
                      }),
                      (this.saveState = function () {
                        n.target0.copy(n.target),
                          n.position0.copy(n.object.position),
                          (n.zoom0 = n.object.zoom);
                      }),
                      (this.reset = function () {
                        n.target.copy(n.target0),
                          n.object.position.copy(n.position0),
                          (n.object.zoom = n.zoom0),
                          n.object.updateProjectionMatrix(),
                          n.dispatchEvent(vm),
                          n.update(),
                          (i = r.NONE);
                      }),
                      (this.update = (function () {
                        const e = new Gn(),
                          c = new Vn().setFromUnitVectors(
                            t.up,
                            new Gn(0, 1, 0)
                          ),
                          l = c.clone().invert(),
                          f = new Gn(),
                          p = new Vn(),
                          m = 2 * Math.PI;
                        return function () {
                          const t = n.object.position;
                          e.copy(t).sub(n.target),
                            e.applyQuaternion(c),
                            o.setFromVector3(e),
                            n.autoRotate && i === r.NONE && E(M()),
                            n.enableDamping
                              ? ((o.theta += s.theta * n.dampingFactor),
                                (o.phi += s.phi * n.dampingFactor))
                              : ((o.theta += s.theta), (o.phi += s.phi));
                          let g = n.minAzimuthAngle,
                            v = n.maxAzimuthAngle;
                          return (
                            isFinite(g) &&
                              isFinite(v) &&
                              (g < -Math.PI
                                ? (g += m)
                                : g > Math.PI && (g -= m),
                              v < -Math.PI ? (v += m) : v > Math.PI && (v -= m),
                              (o.theta =
                                g <= v
                                  ? Math.max(g, Math.min(v, o.theta))
                                  : o.theta > (g + v) / 2
                                  ? Math.max(g, o.theta)
                                  : Math.min(v, o.theta))),
                            (o.phi = Math.max(
                              n.minPolarAngle,
                              Math.min(n.maxPolarAngle, o.phi)
                            )),
                            o.makeSafe(),
                            (o.radius *= u),
                            (o.radius = Math.max(
                              n.minDistance,
                              Math.min(n.maxDistance, o.radius)
                            )),
                            !0 === n.enableDamping
                              ? n.target.addScaledVector(h, n.dampingFactor)
                              : n.target.add(h),
                            e.setFromSpherical(o),
                            e.applyQuaternion(l),
                            t.copy(n.target).add(e),
                            n.object.lookAt(n.target),
                            !0 === n.enableDamping
                              ? ((s.theta *= 1 - n.dampingFactor),
                                (s.phi *= 1 - n.dampingFactor),
                                h.multiplyScalar(1 - n.dampingFactor))
                              : (s.set(0, 0, 0), h.set(0, 0, 0)),
                            (u = 1),
                            !!(
                              d ||
                              f.distanceToSquared(n.object.position) > a ||
                              8 * (1 - p.dot(n.object.quaternion)) > a
                            ) &&
                              (n.dispatchEvent(vm),
                              f.copy(n.object.position),
                              p.copy(n.object.quaternion),
                              (d = !1),
                              !0)
                          );
                        };
                      })()),
                      (this.dispose = function () {
                        n.domElement.removeEventListener("contextmenu", st),
                          n.domElement.removeEventListener("pointerdown", K),
                          n.domElement.removeEventListener("pointercancel", tt),
                          n.domElement.removeEventListener("wheel", rt),
                          n.domElement.removeEventListener("pointermove", Z),
                          n.domElement.removeEventListener("pointerup", Q),
                          null !== n._domElementKeyEvents &&
                            n._domElementKeyEvents.removeEventListener(
                              "keydown",
                              it
                            );
                      });
                    const n = this,
                      r = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6,
                      };
                    let i = r.NONE;
                    const a = 1e-6,
                      o = new cm(),
                      s = new cm();
                    let u = 1;
                    const h = new Gn();
                    let d = !1;
                    const f = new gn(),
                      p = new gn(),
                      m = new gn(),
                      g = new gn(),
                      v = new gn(),
                      y = new gn(),
                      b = new gn(),
                      x = new gn(),
                      _ = new gn(),
                      w = [],
                      S = {};
                    function M() {
                      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
                    }
                    function T() {
                      return Math.pow(0.95, n.zoomSpeed);
                    }
                    function E(t) {
                      s.theta -= t;
                    }
                    function A(t) {
                      s.phi -= t;
                    }
                    const C = (function () {
                        const t = new Gn();
                        return function (e, n) {
                          t.setFromMatrixColumn(n, 0),
                            t.multiplyScalar(-e),
                            h.add(t);
                        };
                      })(),
                      L = (function () {
                        const t = new Gn();
                        return function (e, r) {
                          !0 === n.screenSpacePanning
                            ? t.setFromMatrixColumn(r, 1)
                            : (t.setFromMatrixColumn(r, 0),
                              t.crossVectors(n.object.up, t)),
                            t.multiplyScalar(e),
                            h.add(t);
                        };
                      })(),
                      R = (function () {
                        const t = new Gn();
                        return function (e, r) {
                          const i = n.domElement;
                          if (n.object.isPerspectiveCamera) {
                            const a = n.object.position;
                            t.copy(a).sub(n.target);
                            let o = t.length();
                            (o *= Math.tan(
                              ((n.object.fov / 2) * Math.PI) / 180
                            )),
                              C((2 * e * o) / i.clientHeight, n.object.matrix),
                              L((2 * r * o) / i.clientHeight, n.object.matrix);
                          } else
                            n.object.isOrthographicCamera
                              ? (C(
                                  (e * (n.object.right - n.object.left)) /
                                    n.object.zoom /
                                    i.clientWidth,
                                  n.object.matrix
                                ),
                                L(
                                  (r * (n.object.top - n.object.bottom)) /
                                    n.object.zoom /
                                    i.clientHeight,
                                  n.object.matrix
                                ))
                              : (console.warn(
                                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                                ),
                                (n.enablePan = !1));
                        };
                      })();
                    function P(t) {
                      n.object.isPerspectiveCamera
                        ? (u /= t)
                        : n.object.isOrthographicCamera
                        ? ((n.object.zoom = Math.max(
                            n.minZoom,
                            Math.min(n.maxZoom, n.object.zoom * t)
                          )),
                          n.object.updateProjectionMatrix(),
                          (d = !0))
                        : (console.warn(
                            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                          ),
                          (n.enableZoom = !1));
                    }
                    function I(t) {
                      n.object.isPerspectiveCamera
                        ? (u *= t)
                        : n.object.isOrthographicCamera
                        ? ((n.object.zoom = Math.max(
                            n.minZoom,
                            Math.min(n.maxZoom, n.object.zoom / t)
                          )),
                          n.object.updateProjectionMatrix(),
                          (d = !0))
                        : (console.warn(
                            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                          ),
                          (n.enableZoom = !1));
                    }
                    function O(t) {
                      f.set(t.clientX, t.clientY);
                    }
                    function k(t) {
                      b.set(t.clientX, t.clientY);
                    }
                    function N(t) {
                      g.set(t.clientX, t.clientY);
                    }
                    function D(t) {
                      p.set(t.clientX, t.clientY),
                        m.subVectors(p, f).multiplyScalar(n.rotateSpeed);
                      const e = n.domElement;
                      E((2 * Math.PI * m.x) / e.clientHeight),
                        A((2 * Math.PI * m.y) / e.clientHeight),
                        f.copy(p),
                        n.update();
                    }
                    function z(t) {
                      x.set(t.clientX, t.clientY),
                        _.subVectors(x, b),
                        _.y > 0 ? P(T()) : _.y < 0 && I(T()),
                        b.copy(x),
                        n.update();
                    }
                    function F(t) {
                      v.set(t.clientX, t.clientY),
                        y.subVectors(v, g).multiplyScalar(n.panSpeed),
                        R(y.x, y.y),
                        g.copy(v),
                        n.update();
                    }
                    function U(t) {
                      t.deltaY < 0 ? I(T()) : t.deltaY > 0 && P(T()),
                        n.update();
                    }
                    function B(t) {
                      let e = !1;
                      switch (t.code) {
                        case n.keys.UP:
                          R(0, n.keyPanSpeed), (e = !0);
                          break;
                        case n.keys.BOTTOM:
                          R(0, -n.keyPanSpeed), (e = !0);
                          break;
                        case n.keys.LEFT:
                          R(n.keyPanSpeed, 0), (e = !0);
                          break;
                        case n.keys.RIGHT:
                          R(-n.keyPanSpeed, 0), (e = !0);
                          break;
                      }
                      e && (t.preventDefault(), n.update());
                    }
                    function j() {
                      if (1 === w.length) f.set(w[0].pageX, w[0].pageY);
                      else {
                        const t = 0.5 * (w[0].pageX + w[1].pageX),
                          e = 0.5 * (w[0].pageY + w[1].pageY);
                        f.set(t, e);
                      }
                    }
                    function H() {
                      if (1 === w.length) g.set(w[0].pageX, w[0].pageY);
                      else {
                        const t = 0.5 * (w[0].pageX + w[1].pageX),
                          e = 0.5 * (w[0].pageY + w[1].pageY);
                        g.set(t, e);
                      }
                    }
                    function V() {
                      const t = w[0].pageX - w[1].pageX,
                        e = w[0].pageY - w[1].pageY,
                        n = Math.sqrt(t * t + e * e);
                      b.set(0, n);
                    }
                    function G() {
                      n.enableZoom && V(), n.enablePan && H();
                    }
                    function W() {
                      n.enableZoom && V(), n.enableRotate && j();
                    }
                    function q(t) {
                      if (1 == w.length) p.set(t.pageX, t.pageY);
                      else {
                        const e = ht(t),
                          n = 0.5 * (t.pageX + e.x),
                          r = 0.5 * (t.pageY + e.y);
                        p.set(n, r);
                      }
                      m.subVectors(p, f).multiplyScalar(n.rotateSpeed);
                      const e = n.domElement;
                      E((2 * Math.PI * m.x) / e.clientHeight),
                        A((2 * Math.PI * m.y) / e.clientHeight),
                        f.copy(p);
                    }
                    function X(t) {
                      if (1 === w.length) v.set(t.pageX, t.pageY);
                      else {
                        const e = ht(t),
                          n = 0.5 * (t.pageX + e.x),
                          r = 0.5 * (t.pageY + e.y);
                        v.set(n, r);
                      }
                      y.subVectors(v, g).multiplyScalar(n.panSpeed),
                        R(y.x, y.y),
                        g.copy(v);
                    }
                    function $(t) {
                      const e = ht(t),
                        r = t.pageX - e.x,
                        i = t.pageY - e.y,
                        a = Math.sqrt(r * r + i * i);
                      x.set(0, a),
                        _.set(0, Math.pow(x.y / b.y, n.zoomSpeed)),
                        P(_.y),
                        b.copy(x);
                    }
                    function Y(t) {
                      n.enableZoom && $(t), n.enablePan && X(t);
                    }
                    function J(t) {
                      n.enableZoom && $(t), n.enableRotate && q(t);
                    }
                    function K(t) {
                      !1 !== n.enabled &&
                        (0 === w.length &&
                          (n.domElement.setPointerCapture(t.pointerId),
                          n.domElement.addEventListener("pointermove", Z),
                          n.domElement.addEventListener("pointerup", Q)),
                        ct(t),
                        "touch" === t.pointerType ? at(t) : et(t));
                    }
                    function Z(t) {
                      !1 !== n.enabled &&
                        ("touch" === t.pointerType ? ot(t) : nt(t));
                    }
                    function Q(t) {
                      lt(t),
                        0 === w.length &&
                          (n.domElement.releasePointerCapture(t.pointerId),
                          n.domElement.removeEventListener("pointermove", Z),
                          n.domElement.removeEventListener("pointerup", Q)),
                        n.dispatchEvent(bm),
                        (i = r.NONE);
                    }
                    function tt(t) {
                      lt(t);
                    }
                    function et(t) {
                      let e;
                      switch (t.button) {
                        case 0:
                          e = n.mouseButtons.LEFT;
                          break;
                        case 1:
                          e = n.mouseButtons.MIDDLE;
                          break;
                        case 2:
                          e = n.mouseButtons.RIGHT;
                          break;
                        default:
                          e = -1;
                      }
                      switch (e) {
                        case c.DOLLY:
                          if (!1 === n.enableZoom) return;
                          k(t), (i = r.DOLLY);
                          break;
                        case c.ROTATE:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan) return;
                            N(t), (i = r.PAN);
                          } else {
                            if (!1 === n.enableRotate) return;
                            O(t), (i = r.ROTATE);
                          }
                          break;
                        case c.PAN:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate) return;
                            O(t), (i = r.ROTATE);
                          } else {
                            if (!1 === n.enablePan) return;
                            N(t), (i = r.PAN);
                          }
                          break;
                        default:
                          i = r.NONE;
                      }
                      i !== r.NONE && n.dispatchEvent(ym);
                    }
                    function nt(t) {
                      if (!1 !== n.enabled)
                        switch (i) {
                          case r.ROTATE:
                            if (!1 === n.enableRotate) return;
                            D(t);
                            break;
                          case r.DOLLY:
                            if (!1 === n.enableZoom) return;
                            z(t);
                            break;
                          case r.PAN:
                            if (!1 === n.enablePan) return;
                            F(t);
                            break;
                        }
                    }
                    function rt(t) {
                      !1 !== n.enabled &&
                        !1 !== n.enableZoom &&
                        i === r.NONE &&
                        (t.preventDefault(),
                        n.dispatchEvent(ym),
                        U(t),
                        n.dispatchEvent(bm));
                    }
                    function it(t) {
                      !1 !== n.enabled && !1 !== n.enablePan && B(t);
                    }
                    function at(t) {
                      switch ((ut(t), w.length)) {
                        case 1:
                          switch (n.touches.ONE) {
                            case l.ROTATE:
                              if (!1 === n.enableRotate) return;
                              j(), (i = r.TOUCH_ROTATE);
                              break;
                            case l.PAN:
                              if (!1 === n.enablePan) return;
                              H(), (i = r.TOUCH_PAN);
                              break;
                            default:
                              i = r.NONE;
                          }
                          break;
                        case 2:
                          switch (n.touches.TWO) {
                            case l.DOLLY_PAN:
                              if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                              G(), (i = r.TOUCH_DOLLY_PAN);
                              break;
                            case l.DOLLY_ROTATE:
                              if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                              W(), (i = r.TOUCH_DOLLY_ROTATE);
                              break;
                            default:
                              i = r.NONE;
                          }
                          break;
                        default:
                          i = r.NONE;
                      }
                      i !== r.NONE && n.dispatchEvent(ym);
                    }
                    function ot(t) {
                      switch ((ut(t), i)) {
                        case r.TOUCH_ROTATE:
                          if (!1 === n.enableRotate) return;
                          q(t), n.update();
                          break;
                        case r.TOUCH_PAN:
                          if (!1 === n.enablePan) return;
                          X(t), n.update();
                          break;
                        case r.TOUCH_DOLLY_PAN:
                          if (!1 === n.enableZoom && !1 === n.enablePan) return;
                          Y(t), n.update();
                          break;
                        case r.TOUCH_DOLLY_ROTATE:
                          if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                          J(t), n.update();
                          break;
                        default:
                          i = r.NONE;
                      }
                    }
                    function st(t) {
                      !1 !== n.enabled && t.preventDefault();
                    }
                    function ct(t) {
                      w.push(t);
                    }
                    function lt(t) {
                      delete S[t.pointerId];
                      for (let e = 0; e < w.length; e++)
                        if (w[e].pointerId == t.pointerId)
                          return void w.splice(e, 1);
                    }
                    function ut(t) {
                      let e = S[t.pointerId];
                      void 0 === e && ((e = new gn()), (S[t.pointerId] = e)),
                        e.set(t.pageX, t.pageY);
                    }
                    function ht(t) {
                      const e = t.pointerId === w[0].pointerId ? w[1] : w[0];
                      return S[e.pointerId];
                    }
                    n.domElement.addEventListener("contextmenu", st),
                      n.domElement.addEventListener("pointerdown", K),
                      n.domElement.addEventListener("pointercancel", tt),
                      n.domElement.addEventListener("wheel", rt, {
                        passive: !1,
                      }),
                      this.update();
                  }
                }
                var _m = function () {
                  var t = 0,
                    e = document.createElement("div");
                  function n(t) {
                    return e.appendChild(t.dom), t;
                  }
                  function r(n) {
                    for (var r = 0; r < e.children.length; r++)
                      e.children[r].style.display = r === n ? "block" : "none";
                    t = n;
                  }
                  (e.style.cssText =
                    "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
                    e.addEventListener(
                      "click",
                      function (n) {
                        n.preventDefault(), r(++t % e.children.length);
                      },
                      !1
                    );
                  var i = (performance || Date).now(),
                    a = i,
                    o = 0,
                    s = n(new _m.Panel("FPS", "#0ff", "#002")),
                    c = n(new _m.Panel("MS", "#0f0", "#020"));
                  if (self.performance && self.performance.memory)
                    var l = n(new _m.Panel("MB", "#f08", "#201"));
                  return (
                    r(0),
                    {
                      REVISION: 16,
                      dom: e,
                      addPanel: n,
                      showPanel: r,
                      begin: function () {
                        i = (performance || Date).now();
                      },
                      end: function () {
                        o++;
                        var t = (performance || Date).now();
                        if (
                          (c.update(t - i, 200),
                          t >= a + 1e3 &&
                            (s.update((1e3 * o) / (t - a), 100),
                            (a = t),
                            (o = 0),
                            l))
                        ) {
                          var e = performance.memory;
                          l.update(
                            e.usedJSHeapSize / 1048576,
                            e.jsHeapSizeLimit / 1048576
                          );
                        }
                        return t;
                      },
                      update: function () {
                        i = this.end();
                      },
                      domElement: e,
                      setMode: r,
                    }
                  );
                };
                _m.Panel = function (t, e, n) {
                  var r = 1 / 0,
                    i = 0,
                    a = Math.round,
                    o = a(window.devicePixelRatio || 1),
                    s = 80 * o,
                    c = 48 * o,
                    l = 3 * o,
                    u = 2 * o,
                    h = 3 * o,
                    d = 15 * o,
                    f = 74 * o,
                    p = 30 * o,
                    m = document.createElement("canvas");
                  (m.width = s),
                    (m.height = c),
                    (m.style.cssText = "width:80px;height:48px");
                  var g = m.getContext("2d");
                  return (
                    (g.font =
                      "bold " + 9 * o + "px Helvetica,Arial,sans-serif"),
                    (g.textBaseline = "top"),
                    (g.fillStyle = n),
                    g.fillRect(0, 0, s, c),
                    (g.fillStyle = e),
                    g.fillText(t, l, u),
                    g.fillRect(h, d, f, p),
                    (g.fillStyle = n),
                    (g.globalAlpha = 0.9),
                    g.fillRect(h, d, f, p),
                    {
                      dom: m,
                      update: function (c, v) {
                        (r = Math.min(r, c)),
                          (i = Math.max(i, c)),
                          (g.fillStyle = n),
                          (g.globalAlpha = 1),
                          g.fillRect(0, 0, s, d),
                          (g.fillStyle = e),
                          g.fillText(
                            a(c) + " " + t + " (" + a(r) + "-" + a(i) + ")",
                            l,
                            u
                          ),
                          g.drawImage(m, h + o, d, f - o, p, h, d, f - o, p),
                          g.fillRect(h + f - o, d, o, p),
                          (g.fillStyle = n),
                          (g.globalAlpha = 0.9),
                          g.fillRect(h + f - o, d, o, a((1 - c / v) * p));
                      },
                    }
                  );
                };
                var wm = _m,
                  Sm = {},
                  Mm = function (t) {
                    return URL.createObjectURL(
                      new Blob([t], { type: "text/javascript" })
                    );
                  },
                  Tm = function (t) {
                    return new Worker(t);
                  };
                try {
                  URL.revokeObjectURL(Mm(""));
                } catch (dx) {
                  (Mm = function (t) {
                    return (
                      "data:application/javascript;charset=UTF-8," +
                      encodeURI(t)
                    );
                  }),
                    (Tm = function (t) {
                      return new Worker(t, { type: "module" });
                    });
                }
                var Em = function (t, e, n, r, i) {
                    var a = Tm(Sm[e] || (Sm[e] = Mm(t)));
                    return (
                      (a.onerror = function (t) {
                        return i(t.error, null);
                      }),
                      (a.onmessage = function (t) {
                        return i(null, t.data);
                      }),
                      a.postMessage(n, r),
                      a
                    );
                  },
                  Am = Uint8Array,
                  Cm = Uint16Array,
                  Lm = Uint32Array,
                  Rm = new Am([
                    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
                    4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
                  ]),
                  Pm = new Am([
                    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
                    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
                  ]),
                  Im = new Am([
                    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14,
                    1, 15,
                  ]),
                  Om = function (t, e) {
                    for (var n = new Cm(31), r = 0; r < 31; ++r)
                      n[r] = e += 1 << t[r - 1];
                    var i = new Lm(n[30]);
                    for (r = 1; r < 30; ++r)
                      for (var a = n[r]; a < n[r + 1]; ++a)
                        i[a] = ((a - n[r]) << 5) | r;
                    return [n, i];
                  },
                  km = Om(Rm, 2),
                  Nm = km[0],
                  Dm = km[1];
                (Nm[28] = 258), (Dm[258] = 28);
                for (
                  var zm = Om(Pm, 0),
                    Fm = zm[0],
                    Um = zm[1],
                    Bm = new Cm(32768),
                    jm = 0;
                  jm < 32768;
                  ++jm
                ) {
                  var Hm = ((43690 & jm) >>> 1) | ((21845 & jm) << 1);
                  (Hm = ((52428 & Hm) >>> 2) | ((13107 & Hm) << 2)),
                    (Hm = ((61680 & Hm) >>> 4) | ((3855 & Hm) << 4)),
                    (Bm[jm] = (((65280 & Hm) >>> 8) | ((255 & Hm) << 8)) >>> 1);
                }
                var Vm = function (t, e, n) {
                    for (var r = t.length, i = 0, a = new Cm(e); i < r; ++i)
                      ++a[t[i] - 1];
                    var o,
                      s = new Cm(e);
                    for (i = 0; i < e; ++i) s[i] = (s[i - 1] + a[i - 1]) << 1;
                    if (n) {
                      o = new Cm(1 << e);
                      var c = 15 - e;
                      for (i = 0; i < r; ++i)
                        if (t[i])
                          for (
                            var l = (i << 4) | t[i],
                              u = e - t[i],
                              h = s[t[i] - 1]++ << u,
                              d = h | ((1 << u) - 1);
                            h <= d;
                            ++h
                          )
                            o[Bm[h] >>> c] = l;
                    } else
                      for (o = new Cm(r), i = 0; i < r; ++i)
                        t[i] && (o[i] = Bm[s[t[i] - 1]++] >>> (15 - t[i]));
                    return o;
                  },
                  Gm = new Am(288);
                for (jm = 0; jm < 144; ++jm) Gm[jm] = 8;
                for (jm = 144; jm < 256; ++jm) Gm[jm] = 9;
                for (jm = 256; jm < 280; ++jm) Gm[jm] = 7;
                for (jm = 280; jm < 288; ++jm) Gm[jm] = 8;
                var Wm = new Am(32);
                for (jm = 0; jm < 32; ++jm) Wm[jm] = 5;
                var qm = Vm(Gm, 9, 0),
                  Xm = Vm(Gm, 9, 1),
                  $m = Vm(Wm, 5, 0),
                  Ym = Vm(Wm, 5, 1),
                  Jm = function (t) {
                    for (var e = t[0], n = 1; n < t.length; ++n)
                      t[n] > e && (e = t[n]);
                    return e;
                  },
                  Km = function (t, e, n) {
                    var r = (e / 8) | 0;
                    return ((t[r] | (t[r + 1] << 8)) >> (7 & e)) & n;
                  },
                  Zm = function (t, e) {
                    var n = (e / 8) | 0;
                    return (
                      (t[n] | (t[n + 1] << 8) | (t[n + 2] << 16)) >> (7 & e)
                    );
                  },
                  Qm = function (t) {
                    return ((t / 8) | 0) + (7 & t && 1);
                  },
                  tg = function (t, e, n) {
                    (null == e || e < 0) && (e = 0),
                      (null == n || n > t.length) && (n = t.length);
                    var r = new (
                      t instanceof Cm ? Cm : t instanceof Lm ? Lm : Am
                    )(n - e);
                    return r.set(t.subarray(e, n)), r;
                  },
                  eg = function (t, e, n) {
                    var r = t.length;
                    if (!r || (n && !n.l && r < 5)) return e || new Am(0);
                    var i = !e || n,
                      a = !n || n.i;
                    n || (n = {}), e || (e = new Am(3 * r));
                    var o = function (t) {
                        var n = e.length;
                        if (t > n) {
                          var r = new Am(Math.max(2 * n, t));
                          r.set(e), (e = r);
                        }
                      },
                      s = n.f || 0,
                      c = n.p || 0,
                      l = n.b || 0,
                      u = n.l,
                      h = n.d,
                      d = n.m,
                      f = n.n,
                      p = 8 * r;
                    do {
                      if (!u) {
                        n.f = s = Km(t, c, 1);
                        var m = Km(t, c + 1, 3);
                        if (((c += 3), !m)) {
                          var g = Qm(c) + 4,
                            v = t[g - 4] | (t[g - 3] << 8),
                            y = g + v;
                          if (y > r) {
                            if (a) throw "unexpected EOF";
                            break;
                          }
                          i && o(l + v),
                            e.set(t.subarray(g, y), l),
                            (n.b = l += v),
                            (n.p = c = 8 * y);
                          continue;
                        }
                        if (1 == m) (u = Xm), (h = Ym), (d = 9), (f = 5);
                        else {
                          if (2 != m) throw "invalid block type";
                          var b = Km(t, c, 31) + 257,
                            x = Km(t, c + 10, 15) + 4,
                            _ = b + Km(t, c + 5, 31) + 1;
                          c += 14;
                          for (
                            var w = new Am(_), S = new Am(19), M = 0;
                            M < x;
                            ++M
                          )
                            S[Im[M]] = Km(t, c + 3 * M, 7);
                          c += 3 * x;
                          var T = Jm(S),
                            E = (1 << T) - 1,
                            A = Vm(S, T, 1);
                          for (M = 0; M < _; ) {
                            var C = A[Km(t, c, E)];
                            if (((c += 15 & C), (g = C >>> 4), g < 16))
                              w[M++] = g;
                            else {
                              var L = 0,
                                R = 0;
                              16 == g
                                ? ((R = 3 + Km(t, c, 3)),
                                  (c += 2),
                                  (L = w[M - 1]))
                                : 17 == g
                                ? ((R = 3 + Km(t, c, 7)), (c += 3))
                                : 18 == g &&
                                  ((R = 11 + Km(t, c, 127)), (c += 7));
                              while (R--) w[M++] = L;
                            }
                          }
                          var P = w.subarray(0, b),
                            I = w.subarray(b);
                          (d = Jm(P)),
                            (f = Jm(I)),
                            (u = Vm(P, d, 1)),
                            (h = Vm(I, f, 1));
                        }
                        if (c > p) {
                          if (a) throw "unexpected EOF";
                          break;
                        }
                      }
                      i && o(l + 131072);
                      for (
                        var O = (1 << d) - 1, k = (1 << f) - 1, N = c;
                        ;
                        N = c
                      ) {
                        L = u[Zm(t, c) & O];
                        var D = L >>> 4;
                        if (((c += 15 & L), c > p)) {
                          if (a) throw "unexpected EOF";
                          break;
                        }
                        if (!L) throw "invalid length/literal";
                        if (D < 256) e[l++] = D;
                        else {
                          if (256 == D) {
                            (N = c), (u = null);
                            break;
                          }
                          var z = D - 254;
                          if (D > 264) {
                            M = D - 257;
                            var F = Rm[M];
                            (z = Km(t, c, (1 << F) - 1) + Nm[M]), (c += F);
                          }
                          var U = h[Zm(t, c) & k],
                            B = U >>> 4;
                          if (!U) throw "invalid distance";
                          if (
                            ((c += 15 & U),
                            (I = Fm[B]),
                            B > 3 &&
                              ((F = Pm[B]),
                              (I += Zm(t, c) & ((1 << F) - 1)),
                              (c += F)),
                            c > p)
                          ) {
                            if (a) throw "unexpected EOF";
                            break;
                          }
                          i && o(l + 131072);
                          for (var j = l + z; l < j; l += 4)
                            (e[l] = e[l - I]),
                              (e[l + 1] = e[l + 1 - I]),
                              (e[l + 2] = e[l + 2 - I]),
                              (e[l + 3] = e[l + 3 - I]);
                          l = j;
                        }
                      }
                      (n.l = u),
                        (n.p = N),
                        (n.b = l),
                        u && ((s = 1), (n.m = d), (n.d = h), (n.n = f));
                    } while (!s);
                    return l == e.length ? e : tg(e, 0, l);
                  },
                  ng = function (t, e, n) {
                    n <<= 7 & e;
                    var r = (e / 8) | 0;
                    (t[r] |= n), (t[r + 1] |= n >>> 8);
                  },
                  rg = function (t, e, n) {
                    n <<= 7 & e;
                    var r = (e / 8) | 0;
                    (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
                  },
                  ig = function (t, e) {
                    for (var n = [], r = 0; r < t.length; ++r)
                      t[r] && n.push({ s: r, f: t[r] });
                    var i = n.length,
                      a = n.slice();
                    if (!i) return [hg, 0];
                    if (1 == i) {
                      var o = new Am(n[0].s + 1);
                      return (o[n[0].s] = 1), [o, 1];
                    }
                    n.sort(function (t, e) {
                      return t.f - e.f;
                    }),
                      n.push({ s: -1, f: 25001 });
                    var s = n[0],
                      c = n[1],
                      l = 0,
                      u = 1,
                      h = 2;
                    n[0] = { s: -1, f: s.f + c.f, l: s, r: c };
                    while (u != i - 1)
                      (s = n[n[l].f < n[h].f ? l++ : h++]),
                        (c = n[l != u && n[l].f < n[h].f ? l++ : h++]),
                        (n[u++] = { s: -1, f: s.f + c.f, l: s, r: c });
                    var d = a[0].s;
                    for (r = 1; r < i; ++r) a[r].s > d && (d = a[r].s);
                    var f = new Cm(d + 1),
                      p = ag(n[u - 1], f, 0);
                    if (p > e) {
                      r = 0;
                      var m = 0,
                        g = p - e,
                        v = 1 << g;
                      for (
                        a.sort(function (t, e) {
                          return f[e.s] - f[t.s] || t.f - e.f;
                        });
                        r < i;
                        ++r
                      ) {
                        var y = a[r].s;
                        if (!(f[y] > e)) break;
                        (m += v - (1 << (p - f[y]))), (f[y] = e);
                      }
                      m >>>= g;
                      while (m > 0) {
                        var b = a[r].s;
                        f[b] < e ? (m -= 1 << (e - f[b]++ - 1)) : ++r;
                      }
                      for (; r >= 0 && m; --r) {
                        var x = a[r].s;
                        f[x] == e && (--f[x], ++m);
                      }
                      p = e;
                    }
                    return [new Am(f), p];
                  },
                  ag = function (t, e, n) {
                    return -1 == t.s
                      ? Math.max(ag(t.l, e, n + 1), ag(t.r, e, n + 1))
                      : (e[t.s] = n);
                  },
                  og = function (t) {
                    var e = t.length;
                    while (e && !t[--e]);
                    for (
                      var n = new Cm(++e),
                        r = 0,
                        i = t[0],
                        a = 1,
                        o = function (t) {
                          n[r++] = t;
                        },
                        s = 1;
                      s <= e;
                      ++s
                    )
                      if (t[s] == i && s != e) ++a;
                      else {
                        if (!i && a > 2) {
                          for (; a > 138; a -= 138) o(32754);
                          a > 2 &&
                            (o(
                              a > 10
                                ? ((a - 11) << 5) | 28690
                                : ((a - 3) << 5) | 12305
                            ),
                            (a = 0));
                        } else if (a > 3) {
                          for (o(i), --a; a > 6; a -= 6) o(8304);
                          a > 2 && (o(((a - 3) << 5) | 8208), (a = 0));
                        }
                        while (a--) o(i);
                        (a = 1), (i = t[s]);
                      }
                    return [n.subarray(0, r), e];
                  },
                  sg = function (t, e) {
                    for (var n = 0, r = 0; r < e.length; ++r) n += t[r] * e[r];
                    return n;
                  },
                  cg = function (t, e, n) {
                    var r = n.length,
                      i = Qm(e + 2);
                    (t[i] = 255 & r),
                      (t[i + 1] = r >>> 8),
                      (t[i + 2] = 255 ^ t[i]),
                      (t[i + 3] = 255 ^ t[i + 1]);
                    for (var a = 0; a < r; ++a) t[i + a + 4] = n[a];
                    return 8 * (i + 4 + r);
                  },
                  lg = function (t, e, n, r, i, a, o, s, c, l, u) {
                    ng(e, u++, n), ++i[256];
                    for (
                      var h = ig(i, 15),
                        d = h[0],
                        f = h[1],
                        p = ig(a, 15),
                        m = p[0],
                        g = p[1],
                        v = og(d),
                        y = v[0],
                        b = v[1],
                        x = og(m),
                        _ = x[0],
                        w = x[1],
                        S = new Cm(19),
                        M = 0;
                      M < y.length;
                      ++M
                    )
                      S[31 & y[M]]++;
                    for (M = 0; M < _.length; ++M) S[31 & _[M]]++;
                    for (
                      var T = ig(S, 7), E = T[0], A = T[1], C = 19;
                      C > 4 && !E[Im[C - 1]];
                      --C
                    );
                    var L,
                      R,
                      P,
                      I,
                      O = (l + 5) << 3,
                      k = sg(i, Gm) + sg(a, Wm) + o,
                      N =
                        sg(i, d) +
                        sg(a, m) +
                        o +
                        14 +
                        3 * C +
                        sg(S, E) +
                        (2 * S[16] + 3 * S[17] + 7 * S[18]);
                    if (O <= k && O <= N) return cg(e, u, t.subarray(c, c + l));
                    if ((ng(e, u, 1 + (N < k)), (u += 2), N < k)) {
                      (L = Vm(d, f, 0)), (R = d), (P = Vm(m, g, 0)), (I = m);
                      var D = Vm(E, A, 0);
                      for (
                        ng(e, u, b - 257),
                          ng(e, u + 5, w - 1),
                          ng(e, u + 10, C - 4),
                          u += 14,
                          M = 0;
                        M < C;
                        ++M
                      )
                        ng(e, u + 3 * M, E[Im[M]]);
                      u += 3 * C;
                      for (var z = [y, _], F = 0; F < 2; ++F) {
                        var U = z[F];
                        for (M = 0; M < U.length; ++M) {
                          var B = 31 & U[M];
                          ng(e, u, D[B]),
                            (u += E[B]),
                            B > 15 &&
                              (ng(e, u, (U[M] >>> 5) & 127),
                              (u += U[M] >>> 12));
                        }
                      }
                    } else (L = qm), (R = Gm), (P = $m), (I = Wm);
                    for (M = 0; M < s; ++M)
                      if (r[M] > 255) {
                        (B = (r[M] >>> 18) & 31),
                          rg(e, u, L[B + 257]),
                          (u += R[B + 257]),
                          B > 7 && (ng(e, u, (r[M] >>> 23) & 31), (u += Rm[B]));
                        var j = 31 & r[M];
                        rg(e, u, P[j]),
                          (u += I[j]),
                          j > 3 &&
                            (rg(e, u, (r[M] >>> 5) & 8191), (u += Pm[j]));
                      } else rg(e, u, L[r[M]]), (u += R[r[M]]);
                    return rg(e, u, L[256]), u + R[256];
                  },
                  ug = new Lm([
                    65540, 131080, 131088, 131104, 262176, 1048704, 1048832,
                    2114560, 2117632,
                  ]),
                  hg = new Am(0),
                  dg = function (t, e, n, r, i, a) {
                    var o = t.length,
                      s = new Am(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
                      c = s.subarray(r, s.length - i),
                      l = 0;
                    if (!e || o < 8)
                      for (var u = 0; u <= o; u += 65535) {
                        var h = u + 65535;
                        h < o
                          ? (l = cg(c, l, t.subarray(u, h)))
                          : ((c[u] = a), (l = cg(c, l, t.subarray(u, o))));
                      }
                    else {
                      for (
                        var d = ug[e - 1],
                          f = d >>> 13,
                          p = 8191 & d,
                          m = (1 << n) - 1,
                          g = new Cm(32768),
                          v = new Cm(m + 1),
                          y = Math.ceil(n / 3),
                          b = 2 * y,
                          x = function (e) {
                            return (
                              (t[e] ^ (t[e + 1] << y) ^ (t[e + 2] << b)) & m
                            );
                          },
                          _ = new Lm(25e3),
                          w = new Cm(288),
                          S = new Cm(32),
                          M = 0,
                          T = 0,
                          E = ((u = 0), 0),
                          A = 0,
                          C = 0;
                        u < o;
                        ++u
                      ) {
                        var L = x(u),
                          R = 32767 & u,
                          P = v[L];
                        if (((g[R] = P), (v[L] = R), A <= u)) {
                          var I = o - u;
                          if ((M > 7e3 || E > 24576) && I > 423) {
                            (l = lg(t, c, 0, _, w, S, T, E, C, u - C, l)),
                              (E = M = T = 0),
                              (C = u);
                            for (var O = 0; O < 286; ++O) w[O] = 0;
                            for (O = 0; O < 30; ++O) S[O] = 0;
                          }
                          var k = 2,
                            N = 0,
                            D = p,
                            z = (R - P) & 32767;
                          if (I > 2 && L == x(u - z)) {
                            var F = Math.min(f, I) - 1,
                              U = Math.min(32767, u),
                              B = Math.min(258, I);
                            while (z <= U && --D && R != P) {
                              if (t[u + k] == t[u + k - z]) {
                                for (
                                  var j = 0;
                                  j < B && t[u + j] == t[u + j - z];
                                  ++j
                                );
                                if (j > k) {
                                  if (((k = j), (N = z), j > F)) break;
                                  var H = Math.min(z, j - 2),
                                    V = 0;
                                  for (O = 0; O < H; ++O) {
                                    var G = (u - z + O + 32768) & 32767,
                                      W = g[G],
                                      q = (G - W + 32768) & 32767;
                                    q > V && ((V = q), (P = G));
                                  }
                                }
                              }
                              (R = P),
                                (P = g[R]),
                                (z += (R - P + 32768) & 32767);
                            }
                          }
                          if (N) {
                            _[E++] = 268435456 | (Dm[k] << 18) | Um[N];
                            var X = 31 & Dm[k],
                              $ = 31 & Um[N];
                            (T += Rm[X] + Pm[$]),
                              ++w[257 + X],
                              ++S[$],
                              (A = u + k),
                              ++M;
                          } else (_[E++] = t[u]), ++w[t[u]];
                        }
                      }
                      (l = lg(t, c, a, _, w, S, T, E, C, u - C, l)),
                        !a && 7 & l && (l = cg(c, l + 1, hg));
                    }
                    return tg(s, 0, r + Qm(l) + i);
                  },
                  fg = (function () {
                    for (var t = new Lm(256), e = 0; e < 256; ++e) {
                      var n = e,
                        r = 9;
                      while (--r) n = (1 & n && 3988292384) ^ (n >>> 1);
                      t[e] = n;
                    }
                    return t;
                  })(),
                  pg = function () {
                    var t = -1;
                    return {
                      p: function (e) {
                        for (var n = t, r = 0; r < e.length; ++r)
                          n = fg[(255 & n) ^ e[r]] ^ (n >>> 8);
                        t = n;
                      },
                      d: function () {
                        return ~t;
                      },
                    };
                  },
                  mg = function () {
                    var t = 1,
                      e = 0;
                    return {
                      p: function (n) {
                        for (var r = t, i = e, a = n.length, o = 0; o != a; ) {
                          for (var s = Math.min(o + 2655, a); o < s; ++o)
                            i += r += n[o];
                          (r = (65535 & r) + 15 * (r >> 16)),
                            (i = (65535 & i) + 15 * (i >> 16));
                        }
                        (t = r), (e = i);
                      },
                      d: function () {
                        return (
                          (t %= 65521),
                          (e %= 65521),
                          ((255 & t) << 24) |
                            ((t >>> 8) << 16) |
                            ((255 & e) << 8) |
                            (e >>> 8)
                        );
                      },
                    };
                  },
                  gg = function (t, e, n, r, i) {
                    return dg(
                      t,
                      null == e.level ? 6 : e.level,
                      null == e.mem
                        ? Math.ceil(
                            1.5 * Math.max(8, Math.min(13, Math.log(t.length)))
                          )
                        : 12 + e.mem,
                      n,
                      r,
                      !i
                    );
                  },
                  vg = function (t, e) {
                    var n = {};
                    for (var r in t) n[r] = t[r];
                    for (var r in e) n[r] = e[r];
                    return n;
                  },
                  yg = function (t, e, n) {
                    for (
                      var r = t(),
                        i = t.toString(),
                        a = i
                          .slice(i.indexOf("[") + 1, i.lastIndexOf("]"))
                          .replace(/ /g, "")
                          .split(","),
                        o = 0;
                      o < r.length;
                      ++o
                    ) {
                      var s = r[o],
                        c = a[o];
                      if ("function" == typeof s) {
                        e += ";" + c + "=";
                        var l = s.toString();
                        if (s.prototype)
                          if (-1 != l.indexOf("[native code]")) {
                            var u = l.indexOf(" ", 8) + 1;
                            e += l.slice(u, l.indexOf("(", u));
                          } else
                            for (var h in ((e += l), s.prototype))
                              e +=
                                ";" +
                                c +
                                ".prototype." +
                                h +
                                "=" +
                                s.prototype[h].toString();
                        else e += l;
                      } else n[c] = s;
                    }
                    return [e, n];
                  },
                  bg = [],
                  xg = function (t) {
                    var e = [];
                    for (var n in t)
                      (t[n] instanceof Am ||
                        t[n] instanceof Cm ||
                        t[n] instanceof Lm) &&
                        e.push((t[n] = new t[n].constructor(t[n])).buffer);
                    return e;
                  },
                  _g = function (t, e, n, r) {
                    var i;
                    if (!bg[n]) {
                      for (
                        var a = "", o = {}, s = t.length - 1, c = 0;
                        c < s;
                        ++c
                      )
                        (i = yg(t[c], a, o)), (a = i[0]), (o = i[1]);
                      bg[n] = yg(t[s], a, o);
                    }
                    var l = vg({}, bg[n][1]);
                    return Em(
                      bg[n][0] +
                        ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" +
                        e.toString() +
                        "}",
                      n,
                      l,
                      xg(l),
                      r
                    );
                  },
                  wg = function () {
                    return [
                      Am,
                      Cm,
                      Lm,
                      Rm,
                      Pm,
                      Im,
                      Nm,
                      Fm,
                      Xm,
                      Ym,
                      Bm,
                      Vm,
                      Jm,
                      Km,
                      Zm,
                      Qm,
                      tg,
                      eg,
                      Kg,
                      Cg,
                      Lg,
                    ];
                  },
                  Sg = function () {
                    return [
                      Am,
                      Cm,
                      Lm,
                      Rm,
                      Pm,
                      Im,
                      Dm,
                      Um,
                      qm,
                      Gm,
                      $m,
                      Wm,
                      Bm,
                      ug,
                      hg,
                      Vm,
                      ng,
                      rg,
                      ig,
                      ag,
                      og,
                      sg,
                      cg,
                      lg,
                      Qm,
                      tg,
                      dg,
                      gg,
                      Xg,
                      Cg,
                    ];
                  },
                  Mg = function () {
                    return [zg, Bg, Dg, pg, fg];
                  },
                  Tg = function () {
                    return [Fg, Ug];
                  },
                  Eg = function () {
                    return [jg, Dg, mg];
                  },
                  Ag = function () {
                    return [Hg];
                  },
                  Cg = function (t) {
                    return postMessage(t, [t.buffer]);
                  },
                  Lg = function (t) {
                    return t && t.size && new Am(t.size);
                  },
                  Rg = function (t, e, n, r, i, a) {
                    var o = _g(n, r, i, function (t, e) {
                      o.terminate(), a(t, e);
                    });
                    return (
                      o.postMessage([t, e], e.consume ? [t.buffer] : []),
                      function () {
                        o.terminate();
                      }
                    );
                  },
                  Pg = function (t) {
                    return (
                      (t.ondata = function (t, e) {
                        return postMessage([t, e], [t.buffer]);
                      }),
                      function (e) {
                        return t.push(e.data[0], e.data[1]);
                      }
                    );
                  },
                  Ig = function (t, e, n, r, i) {
                    var a,
                      o = _g(t, r, i, function (t, n) {
                        t
                          ? (o.terminate(), e.ondata.call(e, t))
                          : (n[1] && o.terminate(),
                            e.ondata.call(e, t, n[0], n[1]));
                      });
                    o.postMessage(n),
                      (e.push = function (t, n) {
                        if (a) throw "stream finished";
                        if (!e.ondata) throw "no stream handler";
                        o.postMessage([t, (a = n)], [t.buffer]);
                      }),
                      (e.terminate = function () {
                        o.terminate();
                      });
                  },
                  Og = function (t, e) {
                    return t[e] | (t[e + 1] << 8);
                  },
                  kg = function (t, e) {
                    return (
                      (t[e] |
                        (t[e + 1] << 8) |
                        (t[e + 2] << 16) |
                        (t[e + 3] << 24)) >>>
                      0
                    );
                  },
                  Ng = function (t, e) {
                    return kg(t, e) + 4294967296 * kg(t, e + 4);
                  },
                  Dg = function (t, e, n) {
                    for (; n; ++e) (t[e] = n), (n >>>= 8);
                  },
                  zg = function (t, e) {
                    var n = e.filename;
                    if (
                      ((t[0] = 31),
                      (t[1] = 139),
                      (t[2] = 8),
                      (t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0),
                      (t[9] = 3),
                      0 != e.mtime &&
                        Dg(
                          t,
                          4,
                          Math.floor(new Date(e.mtime || Date.now()) / 1e3)
                        ),
                      n)
                    ) {
                      t[3] = 8;
                      for (var r = 0; r <= n.length; ++r)
                        t[r + 10] = n.charCodeAt(r);
                    }
                  },
                  Fg = function (t) {
                    if (31 != t[0] || 139 != t[1] || 8 != t[2])
                      throw "invalid gzip data";
                    var e = t[3],
                      n = 10;
                    4 & e && (n += t[10] | (2 + (t[11] << 8)));
                    for (
                      var r = ((e >> 3) & 1) + ((e >> 4) & 1);
                      r > 0;
                      r -= !t[n++]
                    );
                    return n + (2 & e);
                  },
                  Ug = function (t) {
                    var e = t.length;
                    return (
                      (t[e - 4] |
                        (t[e - 3] << 8) |
                        (t[e - 2] << 16) |
                        (t[e - 1] << 24)) >>>
                      0
                    );
                  },
                  Bg = function (t) {
                    return 10 + ((t.filename && t.filename.length + 1) || 0);
                  },
                  jg = function (t, e) {
                    var n = e.level,
                      r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
                    (t[0] = 120), (t[1] = (r << 6) | (r ? 32 - 2 * r : 1));
                  },
                  Hg = function (t) {
                    if (
                      8 != (15 & t[0]) ||
                      t[0] >>> 4 > 7 ||
                      ((t[0] << 8) | t[1]) % 31
                    )
                      throw "invalid zlib data";
                    if (32 & t[1])
                      throw "invalid zlib data: preset dictionaries not supported";
                  };
                function Vg(t, e) {
                  return (
                    e || "function" != typeof t || ((e = t), (t = {})),
                    (this.ondata = e),
                    t
                  );
                }
                var Gg = (function () {
                    function t(t, e) {
                      e || "function" != typeof t || ((e = t), (t = {})),
                        (this.ondata = e),
                        (this.o = t || {});
                    }
                    return (
                      (t.prototype.p = function (t, e) {
                        this.ondata(gg(t, this.o, 0, 0, !e), e);
                      }),
                      (t.prototype.push = function (t, e) {
                        if (this.d) throw "stream finished";
                        if (!this.ondata) throw "no stream handler";
                        (this.d = e), this.p(t, e || !1);
                      }),
                      t
                    );
                  })(),
                  Wg = (function () {
                    function t(t, e) {
                      Ig(
                        [
                          Sg,
                          function () {
                            return [Pg, Gg];
                          },
                        ],
                        this,
                        Vg.call(this, t, e),
                        function (t) {
                          var e = new Gg(t.data);
                          onmessage = Pg(e);
                        },
                        6
                      );
                    }
                    return t;
                  })();
                function qg(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [Sg],
                    function (t) {
                      return Cg(Xg(t.data[0], t.data[1]));
                    },
                    0,
                    n
                  );
                }
                function Xg(t, e) {
                  return gg(t, e || {}, 0, 0);
                }
                var $g = (function () {
                    function t(t) {
                      (this.s = {}), (this.p = new Am(0)), (this.ondata = t);
                    }
                    return (
                      (t.prototype.e = function (t) {
                        if (this.d) throw "stream finished";
                        if (!this.ondata) throw "no stream handler";
                        var e = this.p.length,
                          n = new Am(e + t.length);
                        n.set(this.p), n.set(t, e), (this.p = n);
                      }),
                      (t.prototype.c = function (t) {
                        this.d = this.s.i = t || !1;
                        var e = this.s.b,
                          n = eg(this.p, this.o, this.s);
                        this.ondata(tg(n, e, this.s.b), this.d),
                          (this.o = tg(n, this.s.b - 32768)),
                          (this.s.b = this.o.length),
                          (this.p = tg(this.p, (this.s.p / 8) | 0)),
                          (this.s.p &= 7);
                      }),
                      (t.prototype.push = function (t, e) {
                        this.e(t), this.c(e);
                      }),
                      t
                    );
                  })(),
                  Yg = (function () {
                    function t(t) {
                      (this.ondata = t),
                        Ig(
                          [
                            wg,
                            function () {
                              return [Pg, $g];
                            },
                          ],
                          this,
                          0,
                          function () {
                            var t = new $g();
                            onmessage = Pg(t);
                          },
                          7
                        );
                    }
                    return t;
                  })();
                function Jg(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [wg],
                    function (t) {
                      return Cg(Kg(t.data[0], Lg(t.data[1])));
                    },
                    1,
                    n
                  );
                }
                function Kg(t, e) {
                  return eg(t, e);
                }
                var Zg = (function () {
                    function t(t, e) {
                      (this.c = pg()),
                        (this.l = 0),
                        (this.v = 1),
                        Gg.call(this, t, e);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        Gg.prototype.push.call(this, t, e);
                      }),
                      (t.prototype.p = function (t, e) {
                        this.c.p(t), (this.l += t.length);
                        var n = gg(t, this.o, this.v && Bg(this.o), e && 8, !e);
                        this.v && (zg(n, this.o), (this.v = 0)),
                          e &&
                            (Dg(n, n.length - 8, this.c.d()),
                            Dg(n, n.length - 4, this.l)),
                          this.ondata(n, e);
                      }),
                      t
                    );
                  })(),
                  Qg = (function () {
                    function t(t, e) {
                      Ig(
                        [
                          Sg,
                          Mg,
                          function () {
                            return [Pg, Gg, Zg];
                          },
                        ],
                        this,
                        Vg.call(this, t, e),
                        function (t) {
                          var e = new Zg(t.data);
                          onmessage = Pg(e);
                        },
                        8
                      );
                    }
                    return t;
                  })();
                function tv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [
                      Sg,
                      Mg,
                      function () {
                        return [ev];
                      },
                    ],
                    function (t) {
                      return Cg(ev(t.data[0], t.data[1]));
                    },
                    2,
                    n
                  );
                }
                function ev(t, e) {
                  e || (e = {});
                  var n = pg(),
                    r = t.length;
                  n.p(t);
                  var i = gg(t, e, Bg(e), 8),
                    a = i.length;
                  return zg(i, e), Dg(i, a - 8, n.d()), Dg(i, a - 4, r), i;
                }
                var nv = (function () {
                    function t(t) {
                      (this.v = 1), $g.call(this, t);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        if (($g.prototype.e.call(this, t), this.v)) {
                          var n = this.p.length > 3 ? Fg(this.p) : 4;
                          if (n >= this.p.length && !e) return;
                          (this.p = this.p.subarray(n)), (this.v = 0);
                        }
                        if (e) {
                          if (this.p.length < 8) throw "invalid gzip stream";
                          this.p = this.p.subarray(0, -8);
                        }
                        $g.prototype.c.call(this, e);
                      }),
                      t
                    );
                  })(),
                  rv = (function () {
                    function t(t) {
                      (this.ondata = t),
                        Ig(
                          [
                            wg,
                            Tg,
                            function () {
                              return [Pg, $g, nv];
                            },
                          ],
                          this,
                          0,
                          function () {
                            var t = new nv();
                            onmessage = Pg(t);
                          },
                          9
                        );
                    }
                    return t;
                  })();
                function iv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [
                      wg,
                      Tg,
                      function () {
                        return [av];
                      },
                    ],
                    function (t) {
                      return Cg(av(t.data[0]));
                    },
                    3,
                    n
                  );
                }
                function av(t, e) {
                  return eg(t.subarray(Fg(t), -8), e || new Am(Ug(t)));
                }
                var ov = (function () {
                    function t(t, e) {
                      (this.c = mg()), (this.v = 1), Gg.call(this, t, e);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        Gg.prototype.push.call(this, t, e);
                      }),
                      (t.prototype.p = function (t, e) {
                        this.c.p(t);
                        var n = gg(t, this.o, this.v && 2, e && 4, !e);
                        this.v && (jg(n, this.o), (this.v = 0)),
                          e && Dg(n, n.length - 4, this.c.d()),
                          this.ondata(n, e);
                      }),
                      t
                    );
                  })(),
                  sv = (function () {
                    function t(t, e) {
                      Ig(
                        [
                          Sg,
                          Eg,
                          function () {
                            return [Pg, Gg, ov];
                          },
                        ],
                        this,
                        Vg.call(this, t, e),
                        function (t) {
                          var e = new ov(t.data);
                          onmessage = Pg(e);
                        },
                        10
                      );
                    }
                    return t;
                  })();
                function cv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [
                      Sg,
                      Eg,
                      function () {
                        return [lv];
                      },
                    ],
                    function (t) {
                      return Cg(lv(t.data[0], t.data[1]));
                    },
                    4,
                    n
                  );
                }
                function lv(t, e) {
                  e || (e = {});
                  var n = mg();
                  n.p(t);
                  var r = gg(t, e, 2, 4);
                  return jg(r, e), Dg(r, r.length - 4, n.d()), r;
                }
                var uv = (function () {
                    function t(t) {
                      (this.v = 1), $g.call(this, t);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        if (($g.prototype.e.call(this, t), this.v)) {
                          if (this.p.length < 2 && !e) return;
                          (this.p = this.p.subarray(2)), (this.v = 0);
                        }
                        if (e) {
                          if (this.p.length < 4) throw "invalid zlib stream";
                          this.p = this.p.subarray(0, -4);
                        }
                        $g.prototype.c.call(this, e);
                      }),
                      t
                    );
                  })(),
                  hv = (function () {
                    function t(t) {
                      (this.ondata = t),
                        Ig(
                          [
                            wg,
                            Ag,
                            function () {
                              return [Pg, $g, uv];
                            },
                          ],
                          this,
                          0,
                          function () {
                            var t = new uv();
                            onmessage = Pg(t);
                          },
                          11
                        );
                    }
                    return t;
                  })();
                function dv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return Rg(
                    t,
                    e,
                    [
                      wg,
                      Ag,
                      function () {
                        return [fv];
                      },
                    ],
                    function (t) {
                      return Cg(fv(t.data[0], Lg(t.data[1])));
                    },
                    5,
                    n
                  );
                }
                function fv(t, e) {
                  return eg((Hg(t), t.subarray(2, -4)), e);
                }
                var pv = (function () {
                    function t(t) {
                      (this.G = nv),
                        (this.I = $g),
                        (this.Z = uv),
                        (this.ondata = t);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        if (!this.ondata) throw "no stream handler";
                        if (this.s) this.s.push(t, e);
                        else {
                          if (this.p && this.p.length) {
                            var n = new Am(this.p.length + t.length);
                            n.set(this.p), n.set(t, this.p.length);
                          } else this.p = t;
                          if (this.p.length > 2) {
                            var r = this,
                              i = function () {
                                r.ondata.apply(r, arguments);
                              };
                            (this.s =
                              31 == this.p[0] &&
                              139 == this.p[1] &&
                              8 == this.p[2]
                                ? new this.G(i)
                                : 8 != (15 & this.p[0]) ||
                                  this.p[0] >> 4 > 7 ||
                                  ((this.p[0] << 8) | this.p[1]) % 31
                                ? new this.I(i)
                                : new this.Z(i)),
                              this.s.push(this.p, e),
                              (this.p = null);
                          }
                        }
                      }),
                      t
                    );
                  })(),
                  mv = (function () {
                    function t(t) {
                      (this.G = rv),
                        (this.I = Yg),
                        (this.Z = hv),
                        (this.ondata = t);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        pv.prototype.push.call(this, t, e);
                      }),
                      t
                    );
                  })();
                function gv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  return 31 == t[0] && 139 == t[1] && 8 == t[2]
                    ? iv(t, e, n)
                    : 8 != (15 & t[0]) ||
                      t[0] >> 4 > 7 ||
                      ((t[0] << 8) | t[1]) % 31
                    ? Jg(t, e, n)
                    : dv(t, e, n);
                }
                function vv(t, e) {
                  return 31 == t[0] && 139 == t[1] && 8 == t[2]
                    ? av(t, e)
                    : 8 != (15 & t[0]) ||
                      t[0] >> 4 > 7 ||
                      ((t[0] << 8) | t[1]) % 31
                    ? Kg(t, e)
                    : fv(t, e);
                }
                var yv = function (t, e, n, r) {
                    for (var i in t) {
                      var a = t[i],
                        o = e + i;
                      a instanceof Am
                        ? (n[o] = [a, r])
                        : Array.isArray(a)
                        ? (n[o] = [a[0], vg(r, a[1])])
                        : yv(a, o + "/", n, r);
                    }
                  },
                  bv = "undefined" != typeof TextEncoder && new TextEncoder(),
                  xv = "undefined" != typeof TextDecoder && new TextDecoder(),
                  _v = 0;
                try {
                  xv.decode(hg, { stream: !0 }), (_v = 1);
                } catch (dx) {}
                var wv = function (t) {
                    for (var e = "", n = 0; ; ) {
                      var r = t[n++],
                        i = (r > 127) + (r > 223) + (r > 239);
                      if (n + i > t.length) return [e, tg(t, n - 1)];
                      i
                        ? 3 == i
                          ? ((r =
                              (((15 & r) << 18) |
                                ((63 & t[n++]) << 12) |
                                ((63 & t[n++]) << 6) |
                                (63 & t[n++])) -
                              65536),
                            (e += String.fromCharCode(
                              55296 | (r >> 10),
                              56320 | (1023 & r)
                            )))
                          : (e +=
                              1 & i
                                ? String.fromCharCode(
                                    ((31 & r) << 6) | (63 & t[n++])
                                  )
                                : String.fromCharCode(
                                    ((15 & r) << 12) |
                                      ((63 & t[n++]) << 6) |
                                      (63 & t[n++])
                                  ))
                        : (e += String.fromCharCode(r));
                    }
                  },
                  Sv = (function () {
                    function t(t) {
                      (this.ondata = t),
                        _v ? (this.t = new TextDecoder()) : (this.p = hg);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        if (!this.ondata) throw "no callback";
                        if (((e = !!e), this.t)) {
                          if (
                            (this.ondata(this.t.decode(t, { stream: !0 }), e),
                            e)
                          ) {
                            if (this.t.decode().length)
                              throw "invalid utf-8 data";
                            this.t = null;
                          }
                        } else {
                          if (!this.p) throw "stream finished";
                          var n = new Am(this.p.length + t.length);
                          n.set(this.p), n.set(t, this.p.length);
                          var r = wv(n),
                            i = r[0],
                            a = r[1];
                          if (e) {
                            if (a.length) throw "invalid utf-8 data";
                            this.p = null;
                          } else this.p = a;
                          this.ondata(i, e);
                        }
                      }),
                      t
                    );
                  })(),
                  Mv = (function () {
                    function t(t) {
                      this.ondata = t;
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        if (!this.ondata) throw "no callback";
                        if (this.d) throw "stream finished";
                        this.ondata(Tv(t), (this.d = e || !1));
                      }),
                      t
                    );
                  })();
                function Tv(t, e) {
                  if (e) {
                    for (var n = new Am(t.length), r = 0; r < t.length; ++r)
                      n[r] = t.charCodeAt(r);
                    return n;
                  }
                  if (bv) return bv.encode(t);
                  var i = t.length,
                    a = new Am(t.length + (t.length >> 1)),
                    o = 0,
                    s = function (t) {
                      a[o++] = t;
                    };
                  for (r = 0; r < i; ++r) {
                    if (o + 5 > a.length) {
                      var c = new Am(o + 8 + ((i - r) << 1));
                      c.set(a), (a = c);
                    }
                    var l = t.charCodeAt(r);
                    l < 128 || e
                      ? s(l)
                      : l < 2048
                      ? (s(192 | (l >> 6)), s(128 | (63 & l)))
                      : l > 55295 && l < 57344
                      ? ((l =
                          (65536 + (1047552 & l)) | (1023 & t.charCodeAt(++r))),
                        s(240 | (l >> 18)),
                        s(128 | ((l >> 12) & 63)),
                        s(128 | ((l >> 6) & 63)),
                        s(128 | (63 & l)))
                      : (s(224 | (l >> 12)),
                        s(128 | ((l >> 6) & 63)),
                        s(128 | (63 & l)));
                  }
                  return tg(a, 0, o);
                }
                function Ev(t, e) {
                  if (e) {
                    for (var n = "", r = 0; r < t.length; r += 16384)
                      n += String.fromCharCode.apply(
                        null,
                        t.subarray(r, r + 16384)
                      );
                    return n;
                  }
                  if (xv) return xv.decode(t);
                  var i = wv(t),
                    a = i[0],
                    o = i[1];
                  if (o.length) throw "invalid utf-8 data";
                  return a;
                }
                var Av = function (t) {
                    return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0;
                  },
                  Cv = function (t, e) {
                    return e + 30 + Og(t, e + 26) + Og(t, e + 28);
                  },
                  Lv = function (t, e, n) {
                    var r = Og(t, e + 28),
                      i = Ev(
                        t.subarray(e + 46, e + 46 + r),
                        !(2048 & Og(t, e + 8))
                      ),
                      a = e + 46 + r,
                      o = kg(t, e + 20),
                      s =
                        n && 4294967295 == o
                          ? Rv(t, a)
                          : [o, kg(t, e + 24), kg(t, e + 42)],
                      c = s[0],
                      l = s[1],
                      u = s[2];
                    return [
                      Og(t, e + 10),
                      c,
                      l,
                      i,
                      a + Og(t, e + 30) + Og(t, e + 32),
                      u,
                    ];
                  },
                  Rv = function (t, e) {
                    for (; 1 != Og(t, e); e += 4 + Og(t, e + 2));
                    return [Ng(t, e + 12), Ng(t, e + 4), Ng(t, e + 20)];
                  },
                  Pv = function (t) {
                    var e = 0;
                    if (t)
                      for (var n in t) {
                        var r = t[n].length;
                        if (r > 65535) throw "extra field too long";
                        e += r + 4;
                      }
                    return e;
                  },
                  Iv = function (t, e, n, r, i, a, o, s) {
                    var c = r.length,
                      l = n.extra,
                      u = s && s.length,
                      h = Pv(l);
                    Dg(t, e, null != o ? 33639248 : 67324752),
                      (e += 4),
                      null != o && ((t[e++] = 20), (t[e++] = n.os)),
                      (t[e] = 20),
                      (e += 2),
                      (t[e++] = (n.flag << 1) | (null == a && 8)),
                      (t[e++] = i && 8),
                      (t[e++] = 255 & n.compression),
                      (t[e++] = n.compression >> 8);
                    var d = new Date(null == n.mtime ? Date.now() : n.mtime),
                      f = d.getFullYear() - 1980;
                    if (f < 0 || f > 119) throw "date not in range 1980-2099";
                    if (
                      (Dg(
                        t,
                        e,
                        (f << 25) |
                          ((d.getMonth() + 1) << 21) |
                          (d.getDate() << 16) |
                          (d.getHours() << 11) |
                          (d.getMinutes() << 5) |
                          (d.getSeconds() >>> 1)
                      ),
                      (e += 4),
                      null != a &&
                        (Dg(t, e, n.crc),
                        Dg(t, e + 4, a),
                        Dg(t, e + 8, n.size)),
                      Dg(t, e + 12, c),
                      Dg(t, e + 14, h),
                      (e += 16),
                      null != o &&
                        (Dg(t, e, u),
                        Dg(t, e + 6, n.attrs),
                        Dg(t, e + 10, o),
                        (e += 14)),
                      t.set(r, e),
                      (e += c),
                      h)
                    )
                      for (var p in l) {
                        var m = l[p],
                          g = m.length;
                        Dg(t, e, +p),
                          Dg(t, e + 2, g),
                          t.set(m, e + 4),
                          (e += 4 + g);
                      }
                    return u && (t.set(s, e), (e += u)), e;
                  },
                  Ov = function (t, e, n, r, i) {
                    Dg(t, e, 101010256),
                      Dg(t, e + 8, n),
                      Dg(t, e + 10, n),
                      Dg(t, e + 12, r),
                      Dg(t, e + 16, i);
                  },
                  kv = (function () {
                    function t(t) {
                      (this.filename = t),
                        (this.c = pg()),
                        (this.size = 0),
                        (this.compression = 0);
                    }
                    return (
                      (t.prototype.process = function (t, e) {
                        this.ondata(null, t, e);
                      }),
                      (t.prototype.push = function (t, e) {
                        if (!this.ondata)
                          throw "no callback - add to ZIP archive before pushing";
                        this.c.p(t),
                          (this.size += t.length),
                          e && (this.crc = this.c.d()),
                          this.process(t, e || !1);
                      }),
                      t
                    );
                  })(),
                  Nv = (function () {
                    function t(t, e) {
                      var n = this;
                      e || (e = {}),
                        kv.call(this, t),
                        (this.d = new Gg(e, function (t, e) {
                          n.ondata(null, t, e);
                        })),
                        (this.compression = 8),
                        (this.flag = Av(e.level));
                    }
                    return (
                      (t.prototype.process = function (t, e) {
                        try {
                          this.d.push(t, e);
                        } catch (dx) {
                          this.ondata(dx, null, e);
                        }
                      }),
                      (t.prototype.push = function (t, e) {
                        kv.prototype.push.call(this, t, e);
                      }),
                      t
                    );
                  })(),
                  Dv = (function () {
                    function t(t, e) {
                      var n = this;
                      e || (e = {}),
                        kv.call(this, t),
                        (this.d = new Wg(e, function (t, e, r) {
                          n.ondata(t, e, r);
                        })),
                        (this.compression = 8),
                        (this.flag = Av(e.level)),
                        (this.terminate = this.d.terminate);
                    }
                    return (
                      (t.prototype.process = function (t, e) {
                        this.d.push(t, e);
                      }),
                      (t.prototype.push = function (t, e) {
                        kv.prototype.push.call(this, t, e);
                      }),
                      t
                    );
                  })(),
                  zv = (function () {
                    function t(t) {
                      (this.ondata = t), (this.u = []), (this.d = 1);
                    }
                    return (
                      (t.prototype.add = function (t) {
                        var e = this;
                        if (2 & this.d) throw "stream finished";
                        var n = Tv(t.filename),
                          r = n.length,
                          i = t.comment,
                          a = i && Tv(i),
                          o =
                            r != t.filename.length ||
                            (a && i.length != a.length),
                          s = r + Pv(t.extra) + 30;
                        if (r > 65535) throw "filename too long";
                        var c = new Am(s);
                        Iv(c, 0, t, n, o);
                        var l = [c],
                          u = function () {
                            for (var t = 0, n = l; t < n.length; t++) {
                              var r = n[t];
                              e.ondata(null, r, !1);
                            }
                            l = [];
                          },
                          h = this.d;
                        this.d = 0;
                        var d = this.u.length,
                          f = vg(t, {
                            f: n,
                            u: o,
                            o: a,
                            t: function () {
                              t.terminate && t.terminate();
                            },
                            r: function () {
                              if ((u(), h)) {
                                var t = e.u[d + 1];
                                t ? t.r() : (e.d = 1);
                              }
                              h = 1;
                            },
                          }),
                          p = 0;
                        (t.ondata = function (n, r, i) {
                          if (n) e.ondata(n, r, i), e.terminate();
                          else if (((p += r.length), l.push(r), i)) {
                            var a = new Am(16);
                            Dg(a, 0, 134695760),
                              Dg(a, 4, t.crc),
                              Dg(a, 8, p),
                              Dg(a, 12, t.size),
                              l.push(a),
                              (f.c = p),
                              (f.b = s + p + 16),
                              (f.crc = t.crc),
                              (f.size = t.size),
                              h && f.r(),
                              (h = 1);
                          } else h && u();
                        }),
                          this.u.push(f);
                      }),
                      (t.prototype.end = function () {
                        var t = this;
                        if (2 & this.d) {
                          if (1 & this.d) throw "stream finishing";
                          throw "stream finished";
                        }
                        this.d
                          ? this.e()
                          : this.u.push({
                              r: function () {
                                1 & t.d && (t.u.splice(-1, 1), t.e());
                              },
                              t: function () {},
                            }),
                          (this.d = 3);
                      }),
                      (t.prototype.e = function () {
                        for (
                          var t = 0, e = 0, n = 0, r = 0, i = this.u;
                          r < i.length;
                          r++
                        ) {
                          var a = i[r];
                          n +=
                            46 +
                            a.f.length +
                            Pv(a.extra) +
                            (a.o ? a.o.length : 0);
                        }
                        for (
                          var o = new Am(n + 22), s = 0, c = this.u;
                          s < c.length;
                          s++
                        )
                          (a = c[s]),
                            Iv(o, t, a, a.f, a.u, a.c, e, a.o),
                            (t +=
                              46 +
                              a.f.length +
                              Pv(a.extra) +
                              (a.o ? a.o.length : 0)),
                            (e += a.b);
                        Ov(o, t, this.u.length, n, e),
                          this.ondata(null, o, !0),
                          (this.d = 2);
                      }),
                      (t.prototype.terminate = function () {
                        for (var t = 0, e = this.u; t < e.length; t++) {
                          var n = e[t];
                          n.t();
                        }
                        this.d = 2;
                      }),
                      t
                    );
                  })();
                function Fv(t, e, n) {
                  if ((n || ((n = e), (e = {})), "function" != typeof n))
                    throw "no callback";
                  var r = {};
                  yv(t, "", r, e);
                  var i = Object.keys(r),
                    a = i.length,
                    o = 0,
                    s = 0,
                    c = a,
                    l = new Array(a),
                    u = [],
                    h = function () {
                      for (var t = 0; t < u.length; ++t) u[t]();
                    },
                    d = function () {
                      var t = new Am(s + 22),
                        e = o,
                        r = s - o;
                      s = 0;
                      for (var i = 0; i < c; ++i) {
                        var a = l[i];
                        try {
                          var u = a.c.length;
                          Iv(t, s, a, a.f, a.u, u);
                          var h = 30 + a.f.length + Pv(a.extra),
                            d = s + h;
                          t.set(a.c, d),
                            Iv(t, o, a, a.f, a.u, u, s, a.m),
                            (o += 16 + h + (a.m ? a.m.length : 0)),
                            (s = d + u);
                        } catch (dx) {
                          return n(dx, null);
                        }
                      }
                      Ov(t, o, l.length, r, e), n(null, t);
                    };
                  a || d();
                  for (
                    var f = function (t) {
                        var e = i[t],
                          c = r[e],
                          f = c[0],
                          p = c[1],
                          m = pg(),
                          g = f.length;
                        m.p(f);
                        var v = Tv(e),
                          y = v.length,
                          b = p.comment,
                          x = b && Tv(b),
                          _ = x && x.length,
                          w = Pv(p.extra),
                          S = 0 == p.level ? 0 : 8,
                          M = function (r, i) {
                            if (r) h(), n(r, null);
                            else {
                              var c = i.length;
                              (l[t] = vg(p, {
                                size: g,
                                crc: m.d(),
                                c: i,
                                f: v,
                                m: x,
                                u: y != e.length || (x && b.length != _),
                                compression: S,
                              })),
                                (o += 30 + y + w + c),
                                (s += 76 + 2 * (y + w) + (_ || 0) + c),
                                --a || d();
                            }
                          };
                        if ((y > 65535 && M("filename too long", null), S))
                          if (g < 16e4)
                            try {
                              M(null, Xg(f, p));
                            } catch (dx) {
                              M(dx, null);
                            }
                          else u.push(qg(f, p, M));
                        else M(null, f);
                      },
                      p = 0;
                    p < c;
                    ++p
                  )
                    f(p);
                  return h;
                }
                function Uv(t, e) {
                  e || (e = {});
                  var n = {},
                    r = [];
                  yv(t, "", n, e);
                  var i = 0,
                    a = 0;
                  for (var o in n) {
                    var s = n[o],
                      c = s[0],
                      l = s[1],
                      u = 0 == l.level ? 0 : 8,
                      h = Tv(o),
                      d = h.length,
                      f = l.comment,
                      p = f && Tv(f),
                      m = p && p.length,
                      g = Pv(l.extra);
                    if (d > 65535) throw "filename too long";
                    var v = u ? Xg(c, l) : c,
                      y = v.length,
                      b = pg();
                    b.p(c),
                      r.push(
                        vg(l, {
                          size: c.length,
                          crc: b.d(),
                          c: v,
                          f: h,
                          m: p,
                          u: d != o.length || (p && f.length != m),
                          o: i,
                          compression: u,
                        })
                      ),
                      (i += 30 + d + g + y),
                      (a += 76 + 2 * (d + g) + (m || 0) + y);
                  }
                  for (
                    var x = new Am(a + 22), _ = i, w = a - i, S = 0;
                    S < r.length;
                    ++S
                  ) {
                    (h = r[S]), Iv(x, h.o, h, h.f, h.u, h.c.length);
                    var M = 30 + h.f.length + Pv(h.extra);
                    x.set(h.c, h.o + M),
                      Iv(x, i, h, h.f, h.u, h.c.length, h.o, h.m),
                      (i += 16 + M + (h.m ? h.m.length : 0));
                  }
                  return Ov(x, i, r.length, w, _), x;
                }
                var Bv = (function () {
                    function t() {}
                    return (
                      (t.prototype.push = function (t, e) {
                        this.ondata(null, t, e);
                      }),
                      (t.compression = 0),
                      t
                    );
                  })(),
                  jv = (function () {
                    function t() {
                      var t = this;
                      this.i = new $g(function (e, n) {
                        t.ondata(null, e, n);
                      });
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        try {
                          this.i.push(t, e);
                        } catch (dx) {
                          this.ondata(dx, t, e);
                        }
                      }),
                      (t.compression = 8),
                      t
                    );
                  })(),
                  Hv = (function () {
                    function t(t, e) {
                      var n = this;
                      e < 32e4
                        ? (this.i = new $g(function (t, e) {
                            n.ondata(null, t, e);
                          }))
                        : ((this.i = new Yg(function (t, e, r) {
                            n.ondata(t, e, r);
                          })),
                          (this.terminate = this.i.terminate));
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        this.i.terminate && (t = tg(t, 0)), this.i.push(t, e);
                      }),
                      (t.compression = 8),
                      t
                    );
                  })(),
                  Vv = (function () {
                    function t(t) {
                      (this.onfile = t),
                        (this.k = []),
                        (this.o = { 0: Bv }),
                        (this.p = hg);
                    }
                    return (
                      (t.prototype.push = function (t, e) {
                        var n = this;
                        if (!this.onfile) throw "no callback";
                        if (!this.p) throw "stream finished";
                        if (this.c > 0) {
                          var r = Math.min(this.c, t.length),
                            i = t.subarray(0, r);
                          if (
                            ((this.c -= r),
                            this.d
                              ? this.d.push(i, !this.c)
                              : this.k[0].push(i),
                            (t = t.subarray(r)),
                            t.length)
                          )
                            return this.push(t, e);
                        } else {
                          var a = 0,
                            o = 0,
                            s = void 0,
                            c = void 0;
                          this.p.length
                            ? t.length
                              ? ((c = new Am(this.p.length + t.length)),
                                c.set(this.p),
                                c.set(t, this.p.length))
                              : (c = this.p)
                            : (c = t);
                          for (
                            var l = c.length,
                              u = this.c,
                              h = u && this.d,
                              d = function () {
                                var t,
                                  e = kg(c, o);
                                if (67324752 == e) {
                                  (a = 1), (s = o), (f.d = null), (f.c = 0);
                                  var r = Og(c, o + 6),
                                    i = Og(c, o + 8),
                                    h = 2048 & r,
                                    d = 8 & r,
                                    p = Og(c, o + 26),
                                    m = Og(c, o + 28);
                                  if (l > o + 30 + p + m) {
                                    var g = [];
                                    f.k.unshift(g), (a = 2);
                                    var v,
                                      y = kg(c, o + 18),
                                      b = kg(c, o + 22),
                                      x = Ev(
                                        c.subarray(o + 30, (o += 30 + p)),
                                        !h
                                      );
                                    4294967295 == y
                                      ? ((t = d ? [-2] : Rv(c, o)),
                                        (y = t[0]),
                                        (b = t[1]))
                                      : d && (y = -1),
                                      (o += m),
                                      (f.c = y);
                                    var _ = {
                                      name: x,
                                      compression: i,
                                      start: function () {
                                        if (!_.ondata) throw "no callback";
                                        if (y) {
                                          var t = n.o[i];
                                          if (!t)
                                            throw (
                                              "unknown compression type " + i
                                            );
                                          (v =
                                            y < 0 ? new t(x) : new t(x, y, b)),
                                            (v.ondata = function (t, e, n) {
                                              _.ondata(t, e, n);
                                            });
                                          for (
                                            var e = 0, r = g;
                                            e < r.length;
                                            e++
                                          ) {
                                            var a = r[e];
                                            v.push(a, !1);
                                          }
                                          n.k[0] == g && n.c
                                            ? (n.d = v)
                                            : v.push(hg, !0);
                                        } else _.ondata(null, hg, !0);
                                      },
                                      terminate: function () {
                                        v && v.terminate && v.terminate();
                                      },
                                    };
                                    y >= 0 &&
                                      ((_.size = y), (_.originalSize = b)),
                                      f.onfile(_);
                                  }
                                  return "break";
                                }
                                if (u) {
                                  if (134695760 == e)
                                    return (
                                      (s = o += 12 + (-2 == u && 8)),
                                      (a = 3),
                                      (f.c = 0),
                                      "break"
                                    );
                                  if (33639248 == e)
                                    return (
                                      (s = o -= 4), (a = 3), (f.c = 0), "break"
                                    );
                                }
                              },
                              f = this;
                            o < l - 4;
                            ++o
                          ) {
                            var p = d();
                            if ("break" === p) break;
                          }
                          if (((this.p = hg), u < 0)) {
                            var m = a
                              ? c.subarray(
                                  0,
                                  s -
                                    12 -
                                    (-2 == u && 8) -
                                    (134695760 == kg(c, s - 16) && 4)
                                )
                              : c.subarray(0, o);
                            h ? h.push(m, !!a) : this.k[+(2 == a)].push(m);
                          }
                          if (2 & a) return this.push(c.subarray(o), e);
                          this.p = c.subarray(o);
                        }
                        if (e) {
                          if (this.c) throw "invalid zip file";
                          this.p = null;
                        }
                      }),
                      (t.prototype.register = function (t) {
                        this.o[t.compression] = t;
                      }),
                      t
                    );
                  })();
                function Gv(t, e) {
                  if ("function" != typeof e) throw "no callback";
                  for (
                    var n = [],
                      r = function () {
                        for (var t = 0; t < n.length; ++t) n[t]();
                      },
                      i = {},
                      a = t.length - 22;
                    101010256 != kg(t, a);
                    --a
                  )
                    if (!a || t.length - a > 65558)
                      return void e("invalid zip file", null);
                  var o = Og(t, a + 8);
                  o || e(null, {});
                  var s = o,
                    c = kg(t, a + 16),
                    l = 4294967295 == c;
                  if (l) {
                    if (((a = kg(t, a - 12)), 101075792 != kg(t, a)))
                      return void e("invalid zip file", null);
                    (s = o = kg(t, a + 32)), (c = kg(t, a + 48));
                  }
                  for (
                    var u = function (s) {
                        var u = Lv(t, c, l),
                          h = u[0],
                          d = u[1],
                          f = u[2],
                          p = u[3],
                          m = u[4],
                          g = u[5],
                          v = Cv(t, g);
                        c = m;
                        var y = function (t, n) {
                          t
                            ? (r(), e(t, null))
                            : ((i[p] = n), --o || e(null, i));
                        };
                        if (h)
                          if (8 == h) {
                            var b = t.subarray(v, v + d);
                            if (d < 32e4)
                              try {
                                y(null, Kg(b, new Am(f)));
                              } catch (a) {
                                y(a, null);
                              }
                            else n.push(Jg(b, { size: f }, y));
                          } else y("unknown compression type " + h, null);
                        else y(null, tg(t, v, v + d));
                      },
                      h = 0;
                    h < s;
                    ++h
                  )
                    u(h);
                  return r;
                }
                function Wv(t) {
                  for (
                    var e = {}, n = t.length - 22;
                    101010256 != kg(t, n);
                    --n
                  )
                    if (!n || t.length - n > 65558) throw "invalid zip file";
                  var r = Og(t, n + 8);
                  if (!r) return {};
                  var i = kg(t, n + 16),
                    a = 4294967295 == i;
                  if (a) {
                    if (((n = kg(t, n - 12)), 101075792 != kg(t, n)))
                      throw "invalid zip file";
                    (r = kg(t, n + 32)), (i = kg(t, n + 48));
                  }
                  for (var o = 0; o < r; ++o) {
                    var s = Lv(t, i, a),
                      c = s[0],
                      l = s[1],
                      u = s[2],
                      h = s[3],
                      d = s[4],
                      f = s[5],
                      p = Cv(t, f);
                    if (((i = d), c)) {
                      if (8 != c) throw "unknown compression type " + c;
                      e[h] = Kg(t.subarray(p, p + l), new Am(u));
                    } else e[h] = tg(t, p, p + l);
                  }
                  return e;
                }
                function qv(t, e, n) {
                  const r = n.length - t - 1;
                  if (e >= n[r]) return r - 1;
                  if (e <= n[t]) return t;
                  let i = t,
                    a = r,
                    o = Math.floor((i + a) / 2);
                  while (e < n[o] || e >= n[o + 1])
                    e < n[o] ? (a = o) : (i = o), (o = Math.floor((i + a) / 2));
                  return o;
                }
                function Xv(t, e, n, r) {
                  const i = [],
                    a = [],
                    o = [];
                  i[0] = 1;
                  for (let s = 1; s <= n; ++s) {
                    (a[s] = e - r[t + 1 - s]), (o[s] = r[t + s] - e);
                    let n = 0;
                    for (let t = 0; t < s; ++t) {
                      const e = o[t + 1],
                        r = a[s - t],
                        c = i[t] / (e + r);
                      (i[t] = n + e * c), (n = r * c);
                    }
                    i[s] = n;
                  }
                  return i;
                }
                function $v(t, e, n, r) {
                  const i = qv(t, r, e),
                    a = Xv(i, r, t, e),
                    o = new Un(0, 0, 0, 0);
                  for (let s = 0; s <= t; ++s) {
                    const e = n[i - t + s],
                      r = a[s],
                      c = e.w * r;
                    (o.x += e.x * c),
                      (o.y += e.y * c),
                      (o.z += e.z * c),
                      (o.w += e.w * r);
                  }
                  return o;
                }
                function Yv(t, e, n, r, i) {
                  const a = [];
                  for (let h = 0; h <= n; ++h) a[h] = 0;
                  const o = [];
                  for (let h = 0; h <= r; ++h) o[h] = a.slice(0);
                  const s = [];
                  for (let h = 0; h <= n; ++h) s[h] = a.slice(0);
                  s[0][0] = 1;
                  const c = a.slice(0),
                    l = a.slice(0);
                  for (let h = 1; h <= n; ++h) {
                    (c[h] = e - i[t + 1 - h]), (l[h] = i[t + h] - e);
                    let n = 0;
                    for (let t = 0; t < h; ++t) {
                      const e = l[t + 1],
                        r = c[h - t];
                      s[h][t] = e + r;
                      const i = s[t][h - 1] / s[h][t];
                      (s[t][h] = n + e * i), (n = r * i);
                    }
                    s[h][h] = n;
                  }
                  for (let h = 0; h <= n; ++h) o[0][h] = s[h][n];
                  for (let h = 0; h <= n; ++h) {
                    let t = 0,
                      e = 1;
                    const i = [];
                    for (let r = 0; r <= n; ++r) i[r] = a.slice(0);
                    i[0][0] = 1;
                    for (let a = 1; a <= r; ++a) {
                      let r = 0;
                      const c = h - a,
                        l = n - a;
                      h >= a &&
                        ((i[e][0] = i[t][0] / s[l + 1][c]),
                        (r = i[e][0] * s[c][l]));
                      const u = c >= -1 ? 1 : -c,
                        d = h - 1 <= l ? a - 1 : n - h;
                      for (let n = u; n <= d; ++n)
                        (i[e][n] = (i[t][n] - i[t][n - 1]) / s[l + 1][c + n]),
                          (r += i[e][n] * s[c + n][l]);
                      h <= l &&
                        ((i[e][a] = -i[t][a - 1] / s[l + 1][h]),
                        (r += i[e][a] * s[h][l])),
                        (o[a][h] = r);
                      const f = t;
                      (t = e), (e = f);
                    }
                  }
                  let u = n;
                  for (let h = 1; h <= r; ++h) {
                    for (let t = 0; t <= n; ++t) o[h][t] *= u;
                    u *= n - h;
                  }
                  return o;
                }
                function Jv(t, e, n, r, i) {
                  const a = i < t ? i : t,
                    o = [],
                    s = qv(t, r, e),
                    c = Yv(s, r, t, a, e),
                    l = [];
                  for (let u = 0; u < n.length; ++u) {
                    const t = n[u].clone(),
                      e = t.w;
                    (t.x *= e), (t.y *= e), (t.z *= e), (l[u] = t);
                  }
                  for (let u = 0; u <= a; ++u) {
                    const e = l[s - t].clone().multiplyScalar(c[u][0]);
                    for (let n = 1; n <= t; ++n)
                      e.add(l[s - t + n].clone().multiplyScalar(c[u][n]));
                    o[u] = e;
                  }
                  for (let u = a + 1; u <= i + 1; ++u) o[u] = new Un(0, 0, 0);
                  return o;
                }
                function Kv(t, e) {
                  let n = 1;
                  for (let i = 2; i <= t; ++i) n *= i;
                  let r = 1;
                  for (let i = 2; i <= e; ++i) r *= i;
                  for (let i = 2; i <= t - e; ++i) r *= i;
                  return n / r;
                }
                function Zv(t) {
                  const e = t.length,
                    n = [],
                    r = [];
                  for (let a = 0; a < e; ++a) {
                    const e = t[a];
                    (n[a] = new Gn(e.x, e.y, e.z)), (r[a] = e.w);
                  }
                  const i = [];
                  for (let a = 0; a < e; ++a) {
                    const t = n[a].clone();
                    for (let e = 1; e <= a; ++e)
                      t.sub(i[a - e].clone().multiplyScalar(Kv(a, e) * r[e]));
                    i[a] = t.divideScalar(r[0]);
                  }
                  return i;
                }
                function Qv(t, e, n, r, i) {
                  const a = Jv(t, e, n, r, i);
                  return Zv(a);
                }
                class ty extends Wh {
                  constructor(t, e, n, r, i) {
                    super(),
                      (this.degree = t),
                      (this.knots = e),
                      (this.controlPoints = []),
                      (this.startKnot = r || 0),
                      (this.endKnot = i || this.knots.length - 1);
                    for (let a = 0; a < n.length; ++a) {
                      const t = n[a];
                      this.controlPoints[a] = new Un(t.x, t.y, t.z, t.w);
                    }
                  }
                  getPoint(t, e = new Gn()) {
                    const n = e,
                      r =
                        this.knots[this.startKnot] +
                        t *
                          (this.knots[this.endKnot] -
                            this.knots[this.startKnot]),
                      i = $v(this.degree, this.knots, this.controlPoints, r);
                    return (
                      1 !== i.w && i.divideScalar(i.w), n.set(i.x, i.y, i.z)
                    );
                  }
                  getTangent(t, e = new Gn()) {
                    const n = e,
                      r =
                        this.knots[0] +
                        t * (this.knots[this.knots.length - 1] - this.knots[0]),
                      i = Qv(this.degree, this.knots, this.controlPoints, r, 1);
                    return n.copy(i[1]).normalize(), n;
                  }
                }
                let ey, ny, ry;
                class iy extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = "" === i.path ? Op.extractUrlBase(t) : i.path,
                      o = new cp(this.manager);
                    o.setPath(i.path),
                      o.setResponseType("arraybuffer"),
                      o.setRequestHeader(i.requestHeader),
                      o.setWithCredentials(i.withCredentials),
                      o.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n, a));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  parse(t, e) {
                    if (dy(t)) ey = new ly().parse(t);
                    else {
                      const e = Sy(t);
                      if (!fy(e))
                        throw new Error("THREE.FBXLoader: Unknown format.");
                      if (py(e) < 7e3)
                        throw new Error(
                          "THREE.FBXLoader: FBX version not supported, FileVersion: " +
                            py(e)
                        );
                      ey = new cy().parse(e);
                    }
                    const n = new dp(this.manager)
                      .setPath(this.resourcePath || e)
                      .setCrossOrigin(this.crossOrigin);
                    return new ay(n, this.manager).parse(ey);
                  }
                }
                class ay {
                  constructor(t, e) {
                    (this.textureLoader = t), (this.manager = e);
                  }
                  parse() {
                    ny = this.parseConnections();
                    const t = this.parseImages(),
                      e = this.parseTextures(t),
                      n = this.parseMaterials(e),
                      r = this.parseDeformers(),
                      i = new oy().parse(r);
                    return this.parseScene(r, i, n), ry;
                  }
                  parseConnections() {
                    const t = new Map();
                    if ("Connections" in ey) {
                      const e = ey.Connections.connections;
                      e.forEach(function (e) {
                        const n = e[0],
                          r = e[1],
                          i = e[2];
                        t.has(n) || t.set(n, { parents: [], children: [] });
                        const a = { ID: r, relationship: i };
                        t.get(n).parents.push(a),
                          t.has(r) || t.set(r, { parents: [], children: [] });
                        const o = { ID: n, relationship: i };
                        t.get(r).children.push(o);
                      });
                    }
                    return t;
                  }
                  parseImages() {
                    const t = {},
                      e = {};
                    if ("Video" in ey.Objects) {
                      const n = ey.Objects.Video;
                      for (const r in n) {
                        const i = n[r],
                          a = parseInt(r);
                        if (
                          ((t[a] = i.RelativeFilename || i.Filename),
                          "Content" in i)
                        ) {
                          const t =
                              i.Content instanceof ArrayBuffer &&
                              i.Content.byteLength > 0,
                            a =
                              "string" === typeof i.Content && "" !== i.Content;
                          if (t || a) {
                            const t = this.parseImage(n[r]);
                            e[i.RelativeFilename || i.Filename] = t;
                          }
                        }
                      }
                    }
                    for (const n in t) {
                      const r = t[n];
                      void 0 !== e[r]
                        ? (t[n] = e[r])
                        : (t[n] = t[n].split("\\").pop());
                    }
                    return t;
                  }
                  parseImage(t) {
                    const e = t.Content,
                      n = t.RelativeFilename || t.Filename,
                      r = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
                    let i;
                    switch (r) {
                      case "bmp":
                        i = "image/bmp";
                        break;
                      case "jpg":
                      case "jpeg":
                        i = "image/jpeg";
                        break;
                      case "png":
                        i = "image/png";
                        break;
                      case "tif":
                        i = "image/tiff";
                        break;
                      case "tga":
                        null === this.manager.getHandler(".tga") &&
                          console.warn(
                            "FBXLoader: TGA loader not found, skipping ",
                            n
                          ),
                          (i = "image/tga");
                        break;
                      default:
                        return void console.warn(
                          'FBXLoader: Image type "' + r + '" is not supported.'
                        );
                    }
                    if ("string" === typeof e)
                      return "data:" + i + ";base64," + e;
                    {
                      const t = new Uint8Array(e);
                      return window.URL.createObjectURL(
                        new Blob([t], { type: i })
                      );
                    }
                  }
                  parseTextures(t) {
                    const e = new Map();
                    if ("Texture" in ey.Objects) {
                      const n = ey.Objects.Texture;
                      for (const r in n) {
                        const i = this.parseTexture(n[r], t);
                        e.set(parseInt(r), i);
                      }
                    }
                    return e;
                  }
                  parseTexture(t, e) {
                    const n = this.loadTexture(t, e);
                    (n.ID = t.id), (n.name = t.attrName);
                    const r = t.WrapModeU,
                      i = t.WrapModeV,
                      a = void 0 !== r ? r.value : 0,
                      o = void 0 !== i ? i.value : 0;
                    if (
                      ((n.wrapS = 0 === a ? ht : dt),
                      (n.wrapT = 0 === o ? ht : dt),
                      "Scaling" in t)
                    ) {
                      const e = t.Scaling.value;
                      (n.repeat.x = e[0]), (n.repeat.y = e[1]);
                    }
                    if ("Translation" in t) {
                      const e = t.Translation.value;
                      (n.offset.x = e[0]), (n.offset.y = e[1]);
                    }
                    return n;
                  }
                  loadTexture(t, e) {
                    let n;
                    const r = this.textureLoader.path,
                      i = ny.get(t.id).children;
                    let a;
                    void 0 !== i &&
                      i.length > 0 &&
                      void 0 !== e[i[0].ID] &&
                      ((n = e[i[0].ID]),
                      (0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:")) ||
                        this.textureLoader.setPath(void 0));
                    const o = t.FileName.slice(-3).toLowerCase();
                    if ("tga" === o) {
                      const e = this.manager.getHandler(".tga");
                      null === e
                        ? (console.warn(
                            "FBXLoader: TGA loader not found, creating placeholder texture for",
                            t.RelativeFilename
                          ),
                          (a = new Fn()))
                        : (e.setPath(this.textureLoader.path), (a = e.load(n)));
                    } else
                      "psd" === o
                        ? (console.warn(
                            "FBXLoader: PSD textures are not supported, creating placeholder texture for",
                            t.RelativeFilename
                          ),
                          (a = new Fn()))
                        : (a = this.textureLoader.load(n));
                    return this.textureLoader.setPath(r), a;
                  }
                  parseMaterials(t) {
                    const e = new Map();
                    if ("Material" in ey.Objects) {
                      const n = ey.Objects.Material;
                      for (const r in n) {
                        const i = this.parseMaterial(n[r], t);
                        null !== i && e.set(parseInt(r), i);
                      }
                    }
                    return e;
                  }
                  parseMaterial(t, e) {
                    const n = t.id,
                      r = t.attrName;
                    let i = t.ShadingModel;
                    if (("object" === typeof i && (i = i.value), !ny.has(n)))
                      return null;
                    const a = this.parseParameters(t, e, n);
                    let o;
                    switch (i.toLowerCase()) {
                      case "phong":
                        o = new Nf();
                        break;
                      case "lambert":
                        o = new Ff();
                        break;
                      default:
                        console.warn(
                          'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
                          i
                        ),
                          (o = new Nf());
                        break;
                    }
                    return o.setValues(a), (o.name = r), o;
                  }
                  parseParameters(t, e, n) {
                    const r = {};
                    t.BumpFactor && (r.bumpScale = t.BumpFactor.value),
                      t.Diffuse
                        ? (r.color = new In().fromArray(t.Diffuse.value))
                        : !t.DiffuseColor ||
                          ("Color" !== t.DiffuseColor.type &&
                            "ColorRGB" !== t.DiffuseColor.type) ||
                          (r.color = new In().fromArray(t.DiffuseColor.value)),
                      t.DisplacementFactor &&
                        (r.displacementScale = t.DisplacementFactor.value),
                      t.Emissive
                        ? (r.emissive = new In().fromArray(t.Emissive.value))
                        : !t.EmissiveColor ||
                          ("Color" !== t.EmissiveColor.type &&
                            "ColorRGB" !== t.EmissiveColor.type) ||
                          (r.emissive = new In().fromArray(
                            t.EmissiveColor.value
                          )),
                      t.EmissiveFactor &&
                        (r.emissiveIntensity = parseFloat(
                          t.EmissiveFactor.value
                        )),
                      t.Opacity && (r.opacity = parseFloat(t.Opacity.value)),
                      r.opacity < 1 && (r.transparent = !0),
                      t.ReflectionFactor &&
                        (r.reflectivity = t.ReflectionFactor.value),
                      t.Shininess && (r.shininess = t.Shininess.value),
                      t.Specular
                        ? (r.specular = new In().fromArray(t.Specular.value))
                        : t.SpecularColor &&
                          "Color" === t.SpecularColor.type &&
                          (r.specular = new In().fromArray(
                            t.SpecularColor.value
                          ));
                    const i = this;
                    return (
                      ny.get(n).children.forEach(function (t) {
                        const n = t.relationship;
                        switch (n) {
                          case "Bump":
                            r.bumpMap = i.getTexture(e, t.ID);
                            break;
                          case "Maya|TEX_ao_map":
                            r.aoMap = i.getTexture(e, t.ID);
                            break;
                          case "DiffuseColor":
                          case "Maya|TEX_color_map":
                            (r.map = i.getTexture(e, t.ID)),
                              void 0 !== r.map && (r.map.encoding = Le);
                            break;
                          case "DisplacementColor":
                            r.displacementMap = i.getTexture(e, t.ID);
                            break;
                          case "EmissiveColor":
                            (r.emissiveMap = i.getTexture(e, t.ID)),
                              void 0 !== r.emissiveMap &&
                                (r.emissiveMap.encoding = Le);
                            break;
                          case "NormalMap":
                          case "Maya|TEX_normal_map":
                            r.normalMap = i.getTexture(e, t.ID);
                            break;
                          case "ReflectionColor":
                            (r.envMap = i.getTexture(e, t.ID)),
                              void 0 !== r.envMap &&
                                ((r.envMap.mapping = ct),
                                (r.envMap.encoding = Le));
                            break;
                          case "SpecularColor":
                            (r.specularMap = i.getTexture(e, t.ID)),
                              void 0 !== r.specularMap &&
                                (r.specularMap.encoding = Le);
                            break;
                          case "TransparentColor":
                          case "TransparencyFactor":
                            (r.alphaMap = i.getTexture(e, t.ID)),
                              (r.transparent = !0);
                            break;
                          case "AmbientColor":
                          case "ShininessExponent":
                          case "SpecularFactor":
                          case "VectorDisplacementColor":
                          default:
                            console.warn(
                              "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
                              n
                            );
                            break;
                        }
                      }),
                      r
                    );
                  }
                  getTexture(t, e) {
                    return (
                      "LayeredTexture" in ey.Objects &&
                        e in ey.Objects.LayeredTexture &&
                        (console.warn(
                          "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
                        ),
                        (e = ny.get(e).children[0].ID)),
                      t.get(e)
                    );
                  }
                  parseDeformers() {
                    const t = {},
                      e = {};
                    if ("Deformer" in ey.Objects) {
                      const n = ey.Objects.Deformer;
                      for (const r in n) {
                        const i = n[r],
                          a = ny.get(parseInt(r));
                        if ("Skin" === i.attrType) {
                          const e = this.parseSkeleton(a, n);
                          (e.ID = r),
                            a.parents.length > 1 &&
                              console.warn(
                                "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
                              ),
                            (e.geometryID = a.parents[0].ID),
                            (t[r] = e);
                        } else if ("BlendShape" === i.attrType) {
                          const t = { id: r };
                          (t.rawTargets = this.parseMorphTargets(a, n)),
                            (t.id = r),
                            a.parents.length > 1 &&
                              console.warn(
                                "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
                              ),
                            (e[r] = t);
                        }
                      }
                    }
                    return { skeletons: t, morphTargets: e };
                  }
                  parseSkeleton(t, e) {
                    const n = [];
                    return (
                      t.children.forEach(function (t) {
                        const r = e[t.ID];
                        if ("Cluster" !== r.attrType) return;
                        const i = {
                          ID: t.ID,
                          indices: [],
                          weights: [],
                          transformLink: new _r().fromArray(r.TransformLink.a),
                        };
                        "Indexes" in r &&
                          ((i.indices = r.Indexes.a),
                          (i.weights = r.Weights.a)),
                          n.push(i);
                      }),
                      { rawBones: n, bones: [] }
                    );
                  }
                  parseMorphTargets(t, e) {
                    const n = [];
                    for (let r = 0; r < t.children.length; r++) {
                      const i = t.children[r],
                        a = e[i.ID],
                        o = {
                          name: a.attrName,
                          initialWeight: a.DeformPercent,
                          id: a.id,
                          fullWeights: a.FullWeights.a,
                        };
                      if ("BlendShapeChannel" !== a.attrType) return;
                      (o.geoID = ny
                        .get(parseInt(i.ID))
                        .children.filter(function (t) {
                          return void 0 === t.relationship;
                        })[0].ID),
                        n.push(o);
                    }
                    return n;
                  }
                  parseScene(t, e, n) {
                    ry = new Lu();
                    const r = this.parseModels(t.skeletons, e, n),
                      i = ey.Objects.Model,
                      a = this;
                    r.forEach(function (t) {
                      const e = i[t.ID];
                      a.setLookAtProperties(t, e);
                      const n = ny.get(t.ID).parents;
                      n.forEach(function (e) {
                        const n = r.get(e.ID);
                        void 0 !== n && n.add(t);
                      }),
                        null === t.parent && ry.add(t);
                    }),
                      this.bindSkeleton(t.skeletons, e, r),
                      this.createAmbientLight(),
                      ry.traverse(function (t) {
                        if (t.userData.transformData) {
                          t.parent &&
                            ((t.userData.transformData.parentMatrix =
                              t.parent.matrix),
                            (t.userData.transformData.parentMatrixWorld =
                              t.parent.matrixWorld));
                          const e = xy(t.userData.transformData);
                          t.applyMatrix4(e), t.updateWorldMatrix();
                        }
                      });
                    const o = new sy().parse();
                    1 === ry.children.length &&
                      ry.children[0].isGroup &&
                      ((ry.children[0].animations = o), (ry = ry.children[0])),
                      (ry.animations = o);
                  }
                  parseModels(t, e, n) {
                    const r = new Map(),
                      i = ey.Objects.Model;
                    for (const a in i) {
                      const o = parseInt(a),
                        s = i[a],
                        c = ny.get(o);
                      let l = this.buildSkeleton(c, t, o, s.attrName);
                      if (!l) {
                        switch (s.attrType) {
                          case "Camera":
                            l = this.createCamera(c);
                            break;
                          case "Light":
                            l = this.createLight(c);
                            break;
                          case "Mesh":
                            l = this.createMesh(c, e, n);
                            break;
                          case "NurbsCurve":
                            l = this.createCurve(c, e);
                            break;
                          case "LimbNode":
                          case "Root":
                            l = new mh();
                            break;
                          case "Null":
                          default:
                            l = new Lu();
                            break;
                        }
                        (l.name = s.attrName
                          ? em.sanitizeNodeName(s.attrName)
                          : ""),
                          (l.ID = o);
                      }
                      this.getTransformData(l, s), r.set(o, l);
                    }
                    return r;
                  }
                  buildSkeleton(t, e, n, r) {
                    let i = null;
                    return (
                      t.parents.forEach(function (t) {
                        for (const a in e) {
                          const o = e[a];
                          o.rawBones.forEach(function (e, a) {
                            if (e.ID === t.ID) {
                              const t = i;
                              (i = new mh()),
                                i.matrixWorld.copy(e.transformLink),
                                (i.name = r ? em.sanitizeNodeName(r) : ""),
                                (i.ID = n),
                                (o.bones[a] = i),
                                null !== t && i.add(t);
                            }
                          });
                        }
                      }),
                      i
                    );
                  }
                  createCamera(t) {
                    let e, n;
                    if (
                      (t.children.forEach(function (t) {
                        const e = ey.Objects.NodeAttribute[t.ID];
                        void 0 !== e && (n = e);
                      }),
                      void 0 === n)
                    )
                      e = new qr();
                    else {
                      let t = 0;
                      void 0 !== n.CameraProjectionType &&
                        1 === n.CameraProjectionType.value &&
                        (t = 1);
                      let r = 1;
                      void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
                      let i = 1e3;
                      void 0 !== n.FarPlane && (i = n.FarPlane.value / 1e3);
                      let a = window.innerWidth,
                        o = window.innerHeight;
                      void 0 !== n.AspectWidth &&
                        void 0 !== n.AspectHeight &&
                        ((a = n.AspectWidth.value), (o = n.AspectHeight.value));
                      const s = a / o;
                      let c = 45;
                      void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
                      const l = n.FocalLength ? n.FocalLength.value : null;
                      switch (t) {
                        case 0:
                          (e = new Yi(c, s, r, i)),
                            null !== l && e.setFocalLength(l);
                          break;
                        case 1:
                          e = new Js(-a / 2, a / 2, o / 2, -o / 2, r, i);
                          break;
                        default:
                          console.warn(
                            "THREE.FBXLoader: Unknown camera type " + t + "."
                          ),
                            (e = new qr());
                          break;
                      }
                    }
                    return e;
                  }
                  createLight(t) {
                    let e, n;
                    if (
                      (t.children.forEach(function (t) {
                        const e = ey.Objects.NodeAttribute[t.ID];
                        void 0 !== e && (n = e);
                      }),
                      void 0 === n)
                    )
                      e = new qr();
                    else {
                      let t;
                      t = void 0 === n.LightType ? 0 : n.LightType.value;
                      let r = 16777215;
                      void 0 !== n.Color &&
                        (r = new In().fromArray(n.Color.value));
                      let i =
                        void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
                      void 0 !== n.CastLightOnObject &&
                        0 === n.CastLightOnObject.value &&
                        (i = 0);
                      let a = 0;
                      void 0 !== n.FarAttenuationEnd &&
                        (a =
                          void 0 !== n.EnableFarAttenuation &&
                          0 === n.EnableFarAttenuation.value
                            ? 0
                            : n.FarAttenuationEnd.value);
                      const o = 1;
                      switch (t) {
                        case 0:
                          e = new Tp(r, i, a, o);
                          break;
                        case 1:
                          e = new Ap(r, i);
                          break;
                        case 2:
                          let t = Math.PI / 3;
                          void 0 !== n.InnerAngle &&
                            (t = mn.degToRad(n.InnerAngle.value));
                          let s = 0;
                          void 0 !== n.OuterAngle &&
                            ((s = mn.degToRad(n.OuterAngle.value)),
                            (s = Math.max(s, 1))),
                            (e = new xp(r, i, a, t, s, o));
                          break;
                        default:
                          console.warn(
                            "THREE.FBXLoader: Unknown light type " +
                              n.LightType.value +
                              ", defaulting to a PointLight."
                          ),
                            (e = new Tp(r, i));
                          break;
                      }
                      void 0 !== n.CastShadows &&
                        1 === n.CastShadows.value &&
                        (e.castShadow = !0);
                    }
                    return e;
                  }
                  createMesh(t, e, n) {
                    let r,
                      i = null,
                      a = null;
                    const o = [];
                    return (
                      t.children.forEach(function (t) {
                        e.has(t.ID) && (i = e.get(t.ID)),
                          n.has(t.ID) && o.push(n.get(t.ID));
                      }),
                      o.length > 1
                        ? (a = o)
                        : o.length > 0
                        ? (a = o[0])
                        : ((a = new Nf({ color: 13421772 })), o.push(a)),
                      "color" in i.attributes &&
                        o.forEach(function (t) {
                          t.vertexColors = !0;
                        }),
                      i.FBX_Deformer
                        ? ((r = new ph(i, a)), r.normalizeSkinWeights())
                        : (r = new Fi(i, a)),
                      r
                    );
                  }
                  createCurve(t, e) {
                    const n = t.children.reduce(function (t, n) {
                        return e.has(n.ID) && (t = e.get(n.ID)), t;
                      }, null),
                      r = new Eh({ color: 3342591, linewidth: 1 });
                    return new Ih(n, r);
                  }
                  getTransformData(t, e) {
                    const n = {};
                    "InheritType" in e &&
                      (n.inheritType = parseInt(e.InheritType.value)),
                      (n.eulerOrder =
                        "RotationOrder" in e
                          ? _y(e.RotationOrder.value)
                          : "ZYX"),
                      "Lcl_Translation" in e &&
                        (n.translation = e.Lcl_Translation.value),
                      "PreRotation" in e &&
                        (n.preRotation = e.PreRotation.value),
                      "Lcl_Rotation" in e &&
                        (n.rotation = e.Lcl_Rotation.value),
                      "PostRotation" in e &&
                        (n.postRotation = e.PostRotation.value),
                      "Lcl_Scaling" in e && (n.scale = e.Lcl_Scaling.value),
                      "ScalingOffset" in e &&
                        (n.scalingOffset = e.ScalingOffset.value),
                      "ScalingPivot" in e &&
                        (n.scalingPivot = e.ScalingPivot.value),
                      "RotationOffset" in e &&
                        (n.rotationOffset = e.RotationOffset.value),
                      "RotationPivot" in e &&
                        (n.rotationPivot = e.RotationPivot.value),
                      (t.userData.transformData = n);
                  }
                  setLookAtProperties(t, e) {
                    if ("LookAtProperty" in e) {
                      const e = ny.get(t.ID).children;
                      e.forEach(function (e) {
                        if ("LookAtProperty" === e.relationship) {
                          const n = ey.Objects.Model[e.ID];
                          if ("Lcl_Translation" in n) {
                            const e = n.Lcl_Translation.value;
                            void 0 !== t.target
                              ? (t.target.position.fromArray(e),
                                ry.add(t.target))
                              : t.lookAt(new Gn().fromArray(e));
                          }
                        }
                      });
                    }
                  }
                  bindSkeleton(t, e, n) {
                    const r = this.parsePoseNodes();
                    for (const i in t) {
                      const a = t[i],
                        o = ny.get(parseInt(a.ID)).parents;
                      o.forEach(function (t) {
                        if (e.has(t.ID)) {
                          const e = t.ID,
                            i = ny.get(e);
                          i.parents.forEach(function (t) {
                            if (n.has(t.ID)) {
                              const e = n.get(t.ID);
                              e.bind(new bh(a.bones), r[t.ID]);
                            }
                          });
                        }
                      });
                    }
                  }
                  parsePoseNodes() {
                    const t = {};
                    if ("Pose" in ey.Objects) {
                      const e = ey.Objects.Pose;
                      for (const n in e)
                        if (
                          "BindPose" === e[n].attrType &&
                          e[n].NbPoseNodes > 0
                        ) {
                          const r = e[n].PoseNode;
                          Array.isArray(r)
                            ? r.forEach(function (e) {
                                t[e.Node] = new _r().fromArray(e.Matrix.a);
                              })
                            : (t[r.Node] = new _r().fromArray(r.Matrix.a));
                        }
                    }
                    return t;
                  }
                  createAmbientLight() {
                    if (
                      "GlobalSettings" in ey &&
                      "AmbientColor" in ey.GlobalSettings
                    ) {
                      const t = ey.GlobalSettings.AmbientColor.value,
                        e = t[0],
                        n = t[1],
                        r = t[2];
                      if (0 !== e || 0 !== n || 0 !== r) {
                        const t = new In(e, n, r);
                        ry.add(new Cp(t, 1));
                      }
                    }
                  }
                }
                class oy {
                  parse(t) {
                    const e = new Map();
                    if ("Geometry" in ey.Objects) {
                      const n = ey.Objects.Geometry;
                      for (const r in n) {
                        const i = ny.get(parseInt(r)),
                          a = this.parseGeometry(i, n[r], t);
                        e.set(parseInt(r), a);
                      }
                    }
                    return e;
                  }
                  parseGeometry(t, e, n) {
                    switch (e.attrType) {
                      case "Mesh":
                        return this.parseMeshGeometry(t, e, n);
                      case "NurbsCurve":
                        return this.parseNurbsGeometry(e);
                    }
                  }
                  parseMeshGeometry(t, e, n) {
                    const r = n.skeletons,
                      i = [],
                      a = t.parents.map(function (t) {
                        return ey.Objects.Model[t.ID];
                      });
                    if (0 === a.length) return;
                    const o = t.children.reduce(function (t, e) {
                      return void 0 !== r[e.ID] && (t = r[e.ID]), t;
                    }, null);
                    t.children.forEach(function (t) {
                      void 0 !== n.morphTargets[t.ID] &&
                        i.push(n.morphTargets[t.ID]);
                    });
                    const s = a[0],
                      c = {};
                    "RotationOrder" in s &&
                      (c.eulerOrder = _y(s.RotationOrder.value)),
                      "InheritType" in s &&
                        (c.inheritType = parseInt(s.InheritType.value)),
                      "GeometricTranslation" in s &&
                        (c.translation = s.GeometricTranslation.value),
                      "GeometricRotation" in s &&
                        (c.rotation = s.GeometricRotation.value),
                      "GeometricScaling" in s &&
                        (c.scale = s.GeometricScaling.value);
                    const l = xy(c);
                    return this.genGeometry(e, o, i, l);
                  }
                  genGeometry(t, e, n, r) {
                    const i = new xi();
                    t.attrName && (i.name = t.attrName);
                    const a = this.parseGeoNode(t, e),
                      o = this.genBuffers(a),
                      s = new di(o.vertex, 3);
                    if (
                      (s.applyMatrix4(r),
                      i.setAttribute("position", s),
                      o.colors.length > 0 &&
                        i.setAttribute("color", new di(o.colors, 3)),
                      e &&
                        (i.setAttribute(
                          "skinIndex",
                          new ui(o.weightsIndices, 4)
                        ),
                        i.setAttribute(
                          "skinWeight",
                          new di(o.vertexWeights, 4)
                        ),
                        (i.FBX_Deformer = e)),
                      o.normal.length > 0)
                    ) {
                      const t = new vn().getNormalMatrix(r),
                        e = new di(o.normal, 3);
                      e.applyNormalMatrix(t), i.setAttribute("normal", e);
                    }
                    if (
                      (o.uvs.forEach(function (t, e) {
                        let n = "uv" + (e + 1).toString();
                        0 === e && (n = "uv"),
                          i.setAttribute(n, new di(o.uvs[e], 2));
                      }),
                      a.material && "AllSame" !== a.material.mappingType)
                    ) {
                      let t = o.materialIndex[0],
                        e = 0;
                      if (
                        (o.materialIndex.forEach(function (n, r) {
                          n !== t &&
                            (i.addGroup(e, r - e, t), (t = n), (e = r));
                        }),
                        i.groups.length > 0)
                      ) {
                        const e = i.groups[i.groups.length - 1],
                          n = e.start + e.count;
                        n !== o.materialIndex.length &&
                          i.addGroup(n, o.materialIndex.length - n, t);
                      }
                      0 === i.groups.length &&
                        i.addGroup(
                          0,
                          o.materialIndex.length,
                          o.materialIndex[0]
                        );
                    }
                    return this.addMorphTargets(i, t, n, r), i;
                  }
                  parseGeoNode(t, e) {
                    const n = {};
                    if (
                      ((n.vertexPositions =
                        void 0 !== t.Vertices ? t.Vertices.a : []),
                      (n.vertexIndices =
                        void 0 !== t.PolygonVertexIndex
                          ? t.PolygonVertexIndex.a
                          : []),
                      t.LayerElementColor &&
                        (n.color = this.parseVertexColors(
                          t.LayerElementColor[0]
                        )),
                      t.LayerElementMaterial &&
                        (n.material = this.parseMaterialIndices(
                          t.LayerElementMaterial[0]
                        )),
                      t.LayerElementNormal &&
                        (n.normal = this.parseNormals(t.LayerElementNormal[0])),
                      t.LayerElementUV)
                    ) {
                      n.uv = [];
                      let e = 0;
                      while (t.LayerElementUV[e])
                        t.LayerElementUV[e].UV &&
                          n.uv.push(this.parseUVs(t.LayerElementUV[e])),
                          e++;
                    }
                    return (
                      (n.weightTable = {}),
                      null !== e &&
                        ((n.skeleton = e),
                        e.rawBones.forEach(function (t, e) {
                          t.indices.forEach(function (r, i) {
                            void 0 === n.weightTable[r] &&
                              (n.weightTable[r] = []),
                              n.weightTable[r].push({
                                id: e,
                                weight: t.weights[i],
                              });
                          });
                        })),
                      n
                    );
                  }
                  genBuffers(t) {
                    const e = {
                      vertex: [],
                      normal: [],
                      colors: [],
                      uvs: [],
                      materialIndex: [],
                      vertexWeights: [],
                      weightsIndices: [],
                    };
                    let n = 0,
                      r = 0,
                      i = !1,
                      a = [],
                      o = [],
                      s = [],
                      c = [],
                      l = [],
                      u = [];
                    const h = this;
                    return (
                      t.vertexIndices.forEach(function (d, f) {
                        let p,
                          m = !1;
                        d < 0 && ((d ^= -1), (m = !0));
                        let g = [],
                          v = [];
                        if ((a.push(3 * d, 3 * d + 1, 3 * d + 2), t.color)) {
                          const e = vy(f, n, d, t.color);
                          s.push(e[0], e[1], e[2]);
                        }
                        if (t.skeleton) {
                          if (
                            (void 0 !== t.weightTable[d] &&
                              t.weightTable[d].forEach(function (t) {
                                v.push(t.weight), g.push(t.id);
                              }),
                            v.length > 4)
                          ) {
                            i ||
                              (console.warn(
                                "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
                              ),
                              (i = !0));
                            const t = [0, 0, 0, 0],
                              e = [0, 0, 0, 0];
                            v.forEach(function (n, r) {
                              let i = n,
                                a = g[r];
                              e.forEach(function (e, n, r) {
                                if (i > e) {
                                  (r[n] = i), (i = e);
                                  const o = t[n];
                                  (t[n] = a), (a = o);
                                }
                              });
                            }),
                              (g = t),
                              (v = e);
                          }
                          while (v.length < 4) v.push(0), g.push(0);
                          for (let t = 0; t < 4; ++t)
                            l.push(v[t]), u.push(g[t]);
                        }
                        if (t.normal) {
                          const e = vy(f, n, d, t.normal);
                          o.push(e[0], e[1], e[2]);
                        }
                        t.material &&
                          "AllSame" !== t.material.mappingType &&
                          (p = vy(f, n, d, t.material)[0]),
                          t.uv &&
                            t.uv.forEach(function (t, e) {
                              const r = vy(f, n, d, t);
                              void 0 === c[e] && (c[e] = []),
                                c[e].push(r[0]),
                                c[e].push(r[1]);
                            }),
                          r++,
                          m &&
                            (h.genFace(e, t, a, p, o, s, c, l, u, r),
                            n++,
                            (r = 0),
                            (a = []),
                            (o = []),
                            (s = []),
                            (c = []),
                            (l = []),
                            (u = []));
                      }),
                      e
                    );
                  }
                  genFace(t, e, n, r, i, a, o, s, c, l) {
                    for (let u = 2; u < l; u++)
                      t.vertex.push(e.vertexPositions[n[0]]),
                        t.vertex.push(e.vertexPositions[n[1]]),
                        t.vertex.push(e.vertexPositions[n[2]]),
                        t.vertex.push(e.vertexPositions[n[3 * (u - 1)]]),
                        t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 1]]),
                        t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 2]]),
                        t.vertex.push(e.vertexPositions[n[3 * u]]),
                        t.vertex.push(e.vertexPositions[n[3 * u + 1]]),
                        t.vertex.push(e.vertexPositions[n[3 * u + 2]]),
                        e.skeleton &&
                          (t.vertexWeights.push(s[0]),
                          t.vertexWeights.push(s[1]),
                          t.vertexWeights.push(s[2]),
                          t.vertexWeights.push(s[3]),
                          t.vertexWeights.push(s[4 * (u - 1)]),
                          t.vertexWeights.push(s[4 * (u - 1) + 1]),
                          t.vertexWeights.push(s[4 * (u - 1) + 2]),
                          t.vertexWeights.push(s[4 * (u - 1) + 3]),
                          t.vertexWeights.push(s[4 * u]),
                          t.vertexWeights.push(s[4 * u + 1]),
                          t.vertexWeights.push(s[4 * u + 2]),
                          t.vertexWeights.push(s[4 * u + 3]),
                          t.weightsIndices.push(c[0]),
                          t.weightsIndices.push(c[1]),
                          t.weightsIndices.push(c[2]),
                          t.weightsIndices.push(c[3]),
                          t.weightsIndices.push(c[4 * (u - 1)]),
                          t.weightsIndices.push(c[4 * (u - 1) + 1]),
                          t.weightsIndices.push(c[4 * (u - 1) + 2]),
                          t.weightsIndices.push(c[4 * (u - 1) + 3]),
                          t.weightsIndices.push(c[4 * u]),
                          t.weightsIndices.push(c[4 * u + 1]),
                          t.weightsIndices.push(c[4 * u + 2]),
                          t.weightsIndices.push(c[4 * u + 3])),
                        e.color &&
                          (t.colors.push(a[0]),
                          t.colors.push(a[1]),
                          t.colors.push(a[2]),
                          t.colors.push(a[3 * (u - 1)]),
                          t.colors.push(a[3 * (u - 1) + 1]),
                          t.colors.push(a[3 * (u - 1) + 2]),
                          t.colors.push(a[3 * u]),
                          t.colors.push(a[3 * u + 1]),
                          t.colors.push(a[3 * u + 2])),
                        e.material &&
                          "AllSame" !== e.material.mappingType &&
                          (t.materialIndex.push(r),
                          t.materialIndex.push(r),
                          t.materialIndex.push(r)),
                        e.normal &&
                          (t.normal.push(i[0]),
                          t.normal.push(i[1]),
                          t.normal.push(i[2]),
                          t.normal.push(i[3 * (u - 1)]),
                          t.normal.push(i[3 * (u - 1) + 1]),
                          t.normal.push(i[3 * (u - 1) + 2]),
                          t.normal.push(i[3 * u]),
                          t.normal.push(i[3 * u + 1]),
                          t.normal.push(i[3 * u + 2])),
                        e.uv &&
                          e.uv.forEach(function (e, n) {
                            void 0 === t.uvs[n] && (t.uvs[n] = []),
                              t.uvs[n].push(o[n][0]),
                              t.uvs[n].push(o[n][1]),
                              t.uvs[n].push(o[n][2 * (u - 1)]),
                              t.uvs[n].push(o[n][2 * (u - 1) + 1]),
                              t.uvs[n].push(o[n][2 * u]),
                              t.uvs[n].push(o[n][2 * u + 1]);
                          });
                  }
                  addMorphTargets(t, e, n, r) {
                    if (0 === n.length) return;
                    (t.morphTargetsRelative = !0),
                      (t.morphAttributes.position = []);
                    const i = this;
                    n.forEach(function (n) {
                      n.rawTargets.forEach(function (n) {
                        const a = ey.Objects.Geometry[n.geoID];
                        void 0 !== a && i.genMorphGeometry(t, e, a, r, n.name);
                      });
                    });
                  }
                  genMorphGeometry(t, e, n, r, i) {
                    const a =
                        void 0 !== e.PolygonVertexIndex
                          ? e.PolygonVertexIndex.a
                          : [],
                      o = void 0 !== n.Vertices ? n.Vertices.a : [],
                      s = void 0 !== n.Indexes ? n.Indexes.a : [],
                      c = 3 * t.attributes.position.count,
                      l = new Float32Array(c);
                    for (let f = 0; f < s.length; f++) {
                      const t = 3 * s[f];
                      (l[t] = o[3 * f]),
                        (l[t + 1] = o[3 * f + 1]),
                        (l[t + 2] = o[3 * f + 2]);
                    }
                    const u = { vertexIndices: a, vertexPositions: l },
                      h = this.genBuffers(u),
                      d = new di(h.vertex, 3);
                    (d.name = i || n.attrName),
                      d.applyMatrix4(r),
                      t.morphAttributes.position.push(d);
                  }
                  parseNormals(t) {
                    const e = t.MappingInformationType,
                      n = t.ReferenceInformationType,
                      r = t.Normals.a;
                    let i = [];
                    return (
                      "IndexToDirect" === n &&
                        ("NormalIndex" in t
                          ? (i = t.NormalIndex.a)
                          : "NormalsIndex" in t && (i = t.NormalsIndex.a)),
                      {
                        dataSize: 3,
                        buffer: r,
                        indices: i,
                        mappingType: e,
                        referenceType: n,
                      }
                    );
                  }
                  parseUVs(t) {
                    const e = t.MappingInformationType,
                      n = t.ReferenceInformationType,
                      r = t.UV.a;
                    let i = [];
                    return (
                      "IndexToDirect" === n && (i = t.UVIndex.a),
                      {
                        dataSize: 2,
                        buffer: r,
                        indices: i,
                        mappingType: e,
                        referenceType: n,
                      }
                    );
                  }
                  parseVertexColors(t) {
                    const e = t.MappingInformationType,
                      n = t.ReferenceInformationType,
                      r = t.Colors.a;
                    let i = [];
                    return (
                      "IndexToDirect" === n && (i = t.ColorIndex.a),
                      {
                        dataSize: 4,
                        buffer: r,
                        indices: i,
                        mappingType: e,
                        referenceType: n,
                      }
                    );
                  }
                  parseMaterialIndices(t) {
                    const e = t.MappingInformationType,
                      n = t.ReferenceInformationType;
                    if ("NoMappingInformation" === e)
                      return {
                        dataSize: 1,
                        buffer: [0],
                        indices: [0],
                        mappingType: "AllSame",
                        referenceType: n,
                      };
                    const r = t.Materials.a,
                      i = [];
                    for (let a = 0; a < r.length; ++a) i.push(a);
                    return {
                      dataSize: 1,
                      buffer: r,
                      indices: i,
                      mappingType: e,
                      referenceType: n,
                    };
                  }
                  parseNurbsGeometry(t) {
                    if (void 0 === ty)
                      return (
                        console.error(
                          "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
                        ),
                        new xi()
                      );
                    const e = parseInt(t.Order);
                    if (isNaN(e))
                      return (
                        console.error(
                          "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
                          t.Order,
                          t.id
                        ),
                        new xi()
                      );
                    const n = e - 1,
                      r = t.KnotVector.a,
                      i = [],
                      a = t.Points.a;
                    for (let u = 0, h = a.length; u < h; u += 4)
                      i.push(new Un().fromArray(a, u));
                    let o, s;
                    if ("Closed" === t.Form) i.push(i[0]);
                    else if ("Periodic" === t.Form) {
                      (o = n), (s = r.length - 1 - o);
                      for (let t = 0; t < n; ++t) i.push(i[t]);
                    }
                    const c = new ty(n, r, i, o, s),
                      l = c.getPoints(12 * i.length);
                    return new xi().setFromPoints(l);
                  }
                }
                class sy {
                  parse() {
                    const t = [],
                      e = this.parseClips();
                    if (void 0 !== e)
                      for (const n in e) {
                        const r = e[n],
                          i = this.addClip(r);
                        t.push(i);
                      }
                    return t;
                  }
                  parseClips() {
                    if (void 0 === ey.Objects.AnimationCurve) return;
                    const t = this.parseAnimationCurveNodes();
                    this.parseAnimationCurves(t);
                    const e = this.parseAnimationLayers(t),
                      n = this.parseAnimStacks(e);
                    return n;
                  }
                  parseAnimationCurveNodes() {
                    const t = ey.Objects.AnimationCurveNode,
                      e = new Map();
                    for (const n in t) {
                      const r = t[n];
                      if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
                        const t = { id: r.id, attr: r.attrName, curves: {} };
                        e.set(t.id, t);
                      }
                    }
                    return e;
                  }
                  parseAnimationCurves(t) {
                    const e = ey.Objects.AnimationCurve;
                    for (const n in e) {
                      const r = {
                          id: e[n].id,
                          times: e[n].KeyTime.a.map(my),
                          values: e[n].KeyValueFloat.a,
                        },
                        i = ny.get(r.id);
                      if (void 0 !== i) {
                        const e = i.parents[0].ID,
                          n = i.parents[0].relationship;
                        n.match(/X/)
                          ? (t.get(e).curves["x"] = r)
                          : n.match(/Y/)
                          ? (t.get(e).curves["y"] = r)
                          : n.match(/Z/)
                          ? (t.get(e).curves["z"] = r)
                          : n.match(/d|DeformPercent/) &&
                            t.has(e) &&
                            (t.get(e).curves["morph"] = r);
                      }
                    }
                  }
                  parseAnimationLayers(t) {
                    const e = ey.Objects.AnimationLayer,
                      n = new Map();
                    for (const r in e) {
                      const e = [],
                        i = ny.get(parseInt(r));
                      if (void 0 !== i) {
                        const a = i.children;
                        a.forEach(function (n, r) {
                          if (t.has(n.ID)) {
                            const i = t.get(n.ID);
                            if (
                              void 0 !== i.curves.x ||
                              void 0 !== i.curves.y ||
                              void 0 !== i.curves.z
                            ) {
                              if (void 0 === e[r]) {
                                const t = ny
                                  .get(n.ID)
                                  .parents.filter(function (t) {
                                    return void 0 !== t.relationship;
                                  })[0].ID;
                                if (void 0 !== t) {
                                  const i = ey.Objects.Model[t.toString()];
                                  if (void 0 === i)
                                    return void console.warn(
                                      "THREE.FBXLoader: Encountered a unused curve.",
                                      n
                                    );
                                  const a = {
                                    modelName: i.attrName
                                      ? em.sanitizeNodeName(i.attrName)
                                      : "",
                                    ID: i.id,
                                    initialPosition: [0, 0, 0],
                                    initialRotation: [0, 0, 0],
                                    initialScale: [1, 1, 1],
                                  };
                                  ry.traverse(function (t) {
                                    t.ID === i.id &&
                                      ((a.transform = t.matrix),
                                      t.userData.transformData &&
                                        (a.eulerOrder =
                                          t.userData.transformData.eulerOrder));
                                  }),
                                    a.transform || (a.transform = new _r()),
                                    "PreRotation" in i &&
                                      (a.preRotation = i.PreRotation.value),
                                    "PostRotation" in i &&
                                      (a.postRotation = i.PostRotation.value),
                                    (e[r] = a);
                                }
                              }
                              e[r] && (e[r][i.attr] = i);
                            } else if (void 0 !== i.curves.morph) {
                              if (void 0 === e[r]) {
                                const t = ny
                                    .get(n.ID)
                                    .parents.filter(function (t) {
                                      return void 0 !== t.relationship;
                                    })[0].ID,
                                  i = ny.get(t).parents[0].ID,
                                  a = ny.get(i).parents[0].ID,
                                  o = ny.get(a).parents[0].ID,
                                  s = ey.Objects.Model[o],
                                  c = {
                                    modelName: s.attrName
                                      ? em.sanitizeNodeName(s.attrName)
                                      : "",
                                    morphName: ey.Objects.Deformer[t].attrName,
                                  };
                                e[r] = c;
                              }
                              e[r][i.attr] = i;
                            }
                          }
                        }),
                          n.set(parseInt(r), e);
                      }
                    }
                    return n;
                  }
                  parseAnimStacks(t) {
                    const e = ey.Objects.AnimationStack,
                      n = {};
                    for (const r in e) {
                      const i = ny.get(parseInt(r)).children;
                      i.length > 1 &&
                        console.warn(
                          "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
                        );
                      const a = t.get(i[0].ID);
                      n[r] = { name: e[r].attrName, layer: a };
                    }
                    return n;
                  }
                  addClip(t) {
                    let e = [];
                    const n = this;
                    return (
                      t.layer.forEach(function (t) {
                        e = e.concat(n.generateTracks(t));
                      }),
                      new tp(t.name, -1, e)
                    );
                  }
                  generateTracks(t) {
                    const e = [];
                    let n = new Gn(),
                      r = new Vn(),
                      i = new Gn();
                    if (
                      (t.transform && t.transform.decompose(n, r, i),
                      (n = n.toArray()),
                      (r = new Pr()
                        .setFromQuaternion(r, t.eulerOrder)
                        .toArray()),
                      (i = i.toArray()),
                      void 0 !== t.T && Object.keys(t.T.curves).length > 0)
                    ) {
                      const r = this.generateVectorTrack(
                        t.modelName,
                        t.T.curves,
                        n,
                        "position"
                      );
                      void 0 !== r && e.push(r);
                    }
                    if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) {
                      const n = this.generateRotationTrack(
                        t.modelName,
                        t.R.curves,
                        r,
                        t.preRotation,
                        t.postRotation,
                        t.eulerOrder
                      );
                      void 0 !== n && e.push(n);
                    }
                    if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) {
                      const n = this.generateVectorTrack(
                        t.modelName,
                        t.S.curves,
                        i,
                        "scale"
                      );
                      void 0 !== n && e.push(n);
                    }
                    if (void 0 !== t.DeformPercent) {
                      const n = this.generateMorphTrack(t);
                      void 0 !== n && e.push(n);
                    }
                    return e;
                  }
                  generateVectorTrack(t, e, n, r) {
                    const i = this.getTimesForAllAxes(e),
                      a = this.getKeyframeTrackValues(i, e, n);
                    return new Qf(t + "." + r, i, a);
                  }
                  generateRotationTrack(t, e, n, r, i, a) {
                    void 0 !== e.x &&
                      (this.interpolateRotations(e.x),
                      (e.x.values = e.x.values.map(mn.degToRad))),
                      void 0 !== e.y &&
                        (this.interpolateRotations(e.y),
                        (e.y.values = e.y.values.map(mn.degToRad))),
                      void 0 !== e.z &&
                        (this.interpolateRotations(e.z),
                        (e.z.values = e.z.values.map(mn.degToRad)));
                    const o = this.getTimesForAllAxes(e),
                      s = this.getKeyframeTrackValues(o, e, n);
                    void 0 !== r &&
                      ((r = r.map(mn.degToRad)),
                      r.push(a),
                      (r = new Pr().fromArray(r)),
                      (r = new Vn().setFromEuler(r))),
                      void 0 !== i &&
                        ((i = i.map(mn.degToRad)),
                        i.push(a),
                        (i = new Pr().fromArray(i)),
                        (i = new Vn().setFromEuler(i).invert()));
                    const c = new Vn(),
                      l = new Pr(),
                      u = [];
                    for (let h = 0; h < s.length; h += 3)
                      l.set(s[h], s[h + 1], s[h + 2], a),
                        c.setFromEuler(l),
                        void 0 !== r && c.premultiply(r),
                        void 0 !== i && c.multiply(i),
                        c.toArray(u, (h / 3) * 4);
                    return new Kf(t + ".quaternion", o, u);
                  }
                  generateMorphTrack(t) {
                    const e = t.DeformPercent.curves.morph,
                      n = e.values.map(function (t) {
                        return t / 100;
                      }),
                      r = ry.getObjectByName(t.modelName).morphTargetDictionary[
                        t.morphName
                      ];
                    return new Yf(
                      t.modelName + ".morphTargetInfluences[" + r + "]",
                      e.times,
                      n
                    );
                  }
                  getTimesForAllAxes(t) {
                    let e = [];
                    if (
                      (void 0 !== t.x && (e = e.concat(t.x.times)),
                      void 0 !== t.y && (e = e.concat(t.y.times)),
                      void 0 !== t.z && (e = e.concat(t.z.times)),
                      (e = e.sort(function (t, e) {
                        return t - e;
                      })),
                      e.length > 1)
                    ) {
                      let t = 1,
                        n = e[0];
                      for (let r = 1; r < e.length; r++) {
                        const i = e[r];
                        i !== n && ((e[t] = i), (n = i), t++);
                      }
                      e = e.slice(0, t);
                    }
                    return e;
                  }
                  getKeyframeTrackValues(t, e, n) {
                    const r = n,
                      i = [];
                    let a = -1,
                      o = -1,
                      s = -1;
                    return (
                      t.forEach(function (t) {
                        if (
                          (e.x && (a = e.x.times.indexOf(t)),
                          e.y && (o = e.y.times.indexOf(t)),
                          e.z && (s = e.z.times.indexOf(t)),
                          -1 !== a)
                        ) {
                          const t = e.x.values[a];
                          i.push(t), (r[0] = t);
                        } else i.push(r[0]);
                        if (-1 !== o) {
                          const t = e.y.values[o];
                          i.push(t), (r[1] = t);
                        } else i.push(r[1]);
                        if (-1 !== s) {
                          const t = e.z.values[s];
                          i.push(t), (r[2] = t);
                        } else i.push(r[2]);
                      }),
                      i
                    );
                  }
                  interpolateRotations(t) {
                    for (let e = 1; e < t.values.length; e++) {
                      const n = t.values[e - 1],
                        r = t.values[e] - n,
                        i = Math.abs(r);
                      if (i >= 180) {
                        const a = i / 180,
                          o = r / a;
                        let s = n + o;
                        const c = t.times[e - 1],
                          l = t.times[e] - c,
                          u = l / a;
                        let h = c + u;
                        const d = [],
                          f = [];
                        while (h < t.times[e])
                          d.push(h), (h += u), f.push(s), (s += o);
                        (t.times = Ey(t.times, e, d)),
                          (t.values = Ey(t.values, e, f));
                      }
                    }
                  }
                }
                class cy {
                  getPrevNode() {
                    return this.nodeStack[this.currentIndent - 2];
                  }
                  getCurrentNode() {
                    return this.nodeStack[this.currentIndent - 1];
                  }
                  getCurrentProp() {
                    return this.currentProp;
                  }
                  pushStack(t) {
                    this.nodeStack.push(t), (this.currentIndent += 1);
                  }
                  popStack() {
                    this.nodeStack.pop(), (this.currentIndent -= 1);
                  }
                  setCurrentProp(t, e) {
                    (this.currentProp = t), (this.currentPropName = e);
                  }
                  parse(t) {
                    (this.currentIndent = 0),
                      (this.allNodes = new hy()),
                      (this.nodeStack = []),
                      (this.currentProp = []),
                      (this.currentPropName = "");
                    const e = this,
                      n = t.split(/[\r\n]+/);
                    return (
                      n.forEach(function (t, r) {
                        const i = t.match(/^[\s\t]*;/),
                          a = t.match(/^[\s\t]*$/);
                        if (i || a) return;
                        const o = t.match(
                            "^\\t{" + e.currentIndent + "}(\\w+):(.*){",
                            ""
                          ),
                          s = t.match(
                            "^\\t{" +
                              e.currentIndent +
                              "}(\\w+):[\\s\\t\\r\\n](.*)"
                          ),
                          c = t.match("^\\t{" + (e.currentIndent - 1) + "}}");
                        o
                          ? e.parseNodeBegin(t, o)
                          : s
                          ? e.parseNodeProperty(t, s, n[++r])
                          : c
                          ? e.popStack()
                          : t.match(/^[^\s\t}]/) &&
                            e.parseNodePropertyContinued(t);
                      }),
                      this.allNodes
                    );
                  }
                  parseNodeBegin(t, e) {
                    const n = e[1].trim().replace(/^"/, "").replace(/"$/, ""),
                      r = e[2].split(",").map(function (t) {
                        return t.trim().replace(/^"/, "").replace(/"$/, "");
                      }),
                      i = { name: n },
                      a = this.parseNodeAttr(r),
                      o = this.getCurrentNode();
                    0 === this.currentIndent
                      ? this.allNodes.add(n, i)
                      : n in o
                      ? ("PoseNode" === n
                          ? o.PoseNode.push(i)
                          : void 0 !== o[n].id &&
                            ((o[n] = {}), (o[n][o[n].id] = o[n])),
                        "" !== a.id && (o[n][a.id] = i))
                      : "number" === typeof a.id
                      ? ((o[n] = {}), (o[n][a.id] = i))
                      : "Properties70" !== n &&
                        (o[n] = "PoseNode" === n ? [i] : i),
                      "number" === typeof a.id && (i.id = a.id),
                      "" !== a.name && (i.attrName = a.name),
                      "" !== a.type && (i.attrType = a.type),
                      this.pushStack(i);
                  }
                  parseNodeAttr(t) {
                    let e = t[0];
                    "" !== t[0] &&
                      ((e = parseInt(t[0])), isNaN(e) && (e = t[0]));
                    let n = "",
                      r = "";
                    return (
                      t.length > 1 &&
                        ((n = t[1].replace(/^(\w+)::/, "")), (r = t[2])),
                      { id: e, name: n, type: r }
                    );
                  }
                  parseNodeProperty(t, e, n) {
                    let r = e[1].replace(/^"/, "").replace(/"$/, "").trim(),
                      i = e[2].replace(/^"/, "").replace(/"$/, "").trim();
                    "Content" === r &&
                      "," === i &&
                      (i = n.replace(/"/g, "").replace(/,$/, "").trim());
                    const a = this.getCurrentNode(),
                      o = a.name;
                    if ("Properties70" !== o) {
                      if ("C" === r) {
                        const t = i.split(",").slice(1),
                          e = parseInt(t[0]),
                          n = parseInt(t[1]);
                        let o = i.split(",").slice(3);
                        (o = o.map(function (t) {
                          return t.trim().replace(/^"/, "");
                        })),
                          (r = "connections"),
                          (i = [e, n]),
                          My(i, o),
                          void 0 === a[r] && (a[r] = []);
                      }
                      "Node" === r && (a.id = i),
                        r in a && Array.isArray(a[r])
                          ? a[r].push(i)
                          : "a" !== r
                          ? (a[r] = i)
                          : (a.a = i),
                        this.setCurrentProp(a, r),
                        "a" === r && "," !== i.slice(-1) && (a.a = wy(i));
                    } else this.parseNodeSpecialProperty(t, r, i);
                  }
                  parseNodePropertyContinued(t) {
                    const e = this.getCurrentNode();
                    (e.a += t), "," !== t.slice(-1) && (e.a = wy(e.a));
                  }
                  parseNodeSpecialProperty(t, e, n) {
                    const r = n.split('",').map(function (t) {
                        return t.trim().replace(/^\"/, "").replace(/\s/, "_");
                      }),
                      i = r[0],
                      a = r[1],
                      o = r[2],
                      s = r[3];
                    let c = r[4];
                    switch (a) {
                      case "int":
                      case "enum":
                      case "bool":
                      case "ULongLong":
                      case "double":
                      case "Number":
                      case "FieldOfView":
                        c = parseFloat(c);
                        break;
                      case "Color":
                      case "ColorRGB":
                      case "Vector3D":
                      case "Lcl_Translation":
                      case "Lcl_Rotation":
                      case "Lcl_Scaling":
                        c = wy(c);
                        break;
                    }
                    (this.getPrevNode()[i] = {
                      type: a,
                      type2: o,
                      flag: s,
                      value: c,
                    }),
                      this.setCurrentProp(this.getPrevNode(), i);
                  }
                }
                class ly {
                  parse(t) {
                    const e = new uy(t);
                    e.skip(23);
                    const n = e.getUint32();
                    if (n < 6400)
                      throw new Error(
                        "THREE.FBXLoader: FBX version not supported, FileVersion: " +
                          n
                      );
                    const r = new hy();
                    while (!this.endOfContent(e)) {
                      const t = this.parseNode(e, n);
                      null !== t && r.add(t.name, t);
                    }
                    return r;
                  }
                  endOfContent(t) {
                    return t.size() % 16 === 0
                      ? ((t.getOffset() + 160 + 16) & -16) >= t.size()
                      : t.getOffset() + 160 + 16 >= t.size();
                  }
                  parseNode(t, e) {
                    const n = {},
                      r = e >= 7500 ? t.getUint64() : t.getUint32(),
                      i = e >= 7500 ? t.getUint64() : t.getUint32();
                    e >= 7500 ? t.getUint64() : t.getUint32();
                    const a = t.getUint8(),
                      o = t.getString(a);
                    if (0 === r) return null;
                    const s = [];
                    for (let h = 0; h < i; h++) s.push(this.parseProperty(t));
                    const c = s.length > 0 ? s[0] : "",
                      l = s.length > 1 ? s[1] : "",
                      u = s.length > 2 ? s[2] : "";
                    n.singleProperty = 1 === i && t.getOffset() === r;
                    while (r > t.getOffset()) {
                      const r = this.parseNode(t, e);
                      null !== r && this.parseSubNode(o, n, r);
                    }
                    return (
                      (n.propertyList = s),
                      "number" === typeof c && (n.id = c),
                      "" !== l && (n.attrName = l),
                      "" !== u && (n.attrType = u),
                      "" !== o && (n.name = o),
                      n
                    );
                  }
                  parseSubNode(t, e, n) {
                    if (!0 === n.singleProperty) {
                      const t = n.propertyList[0];
                      Array.isArray(t)
                        ? ((e[n.name] = n), (n.a = t))
                        : (e[n.name] = t);
                    } else if ("Connections" === t && "C" === n.name) {
                      const t = [];
                      n.propertyList.forEach(function (e, n) {
                        0 !== n && t.push(e);
                      }),
                        void 0 === e.connections && (e.connections = []),
                        e.connections.push(t);
                    } else if ("Properties70" === n.name) {
                      const t = Object.keys(n);
                      t.forEach(function (t) {
                        e[t] = n[t];
                      });
                    } else if ("Properties70" === t && "P" === n.name) {
                      let t = n.propertyList[0],
                        r = n.propertyList[1];
                      const i = n.propertyList[2],
                        a = n.propertyList[3];
                      let o;
                      0 === t.indexOf("Lcl ") &&
                        (t = t.replace("Lcl ", "Lcl_")),
                        0 === r.indexOf("Lcl ") &&
                          (r = r.replace("Lcl ", "Lcl_")),
                        (o =
                          "Color" === r ||
                          "ColorRGB" === r ||
                          "Vector" === r ||
                          "Vector3D" === r ||
                          0 === r.indexOf("Lcl_")
                            ? [
                                n.propertyList[4],
                                n.propertyList[5],
                                n.propertyList[6],
                              ]
                            : n.propertyList[4]),
                        (e[t] = { type: r, type2: i, flag: a, value: o });
                    } else
                      void 0 === e[n.name]
                        ? "number" === typeof n.id
                          ? ((e[n.name] = {}), (e[n.name][n.id] = n))
                          : (e[n.name] = n)
                        : "PoseNode" === n.name
                        ? (Array.isArray(e[n.name]) ||
                            (e[n.name] = [e[n.name]]),
                          e[n.name].push(n))
                        : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n);
                  }
                  parseProperty(e) {
                    const n = e.getString(1);
                    let r;
                    switch (n) {
                      case "C":
                        return e.getBoolean();
                      case "D":
                        return e.getFloat64();
                      case "F":
                        return e.getFloat32();
                      case "I":
                        return e.getInt32();
                      case "L":
                        return e.getInt64();
                      case "R":
                        return (r = e.getUint32()), e.getArrayBuffer(r);
                      case "S":
                        return (r = e.getUint32()), e.getString(r);
                      case "Y":
                        return e.getInt16();
                      case "b":
                      case "c":
                      case "d":
                      case "f":
                      case "i":
                      case "l":
                        const i = e.getUint32(),
                          a = e.getUint32(),
                          o = e.getUint32();
                        if (0 === a)
                          switch (n) {
                            case "b":
                            case "c":
                              return e.getBooleanArray(i);
                            case "d":
                              return e.getFloat64Array(i);
                            case "f":
                              return e.getFloat32Array(i);
                            case "i":
                              return e.getInt32Array(i);
                            case "l":
                              return e.getInt64Array(i);
                          }
                        "undefined" === typeof t &&
                          console.error(
                            "THREE.FBXLoader: External library fflate.min.js required."
                          );
                        const s = fv(new Uint8Array(e.getArrayBuffer(o))),
                          c = new uy(s.buffer);
                        switch (n) {
                          case "b":
                          case "c":
                            return c.getBooleanArray(i);
                          case "d":
                            return c.getFloat64Array(i);
                          case "f":
                            return c.getFloat32Array(i);
                          case "i":
                            return c.getInt32Array(i);
                          case "l":
                            return c.getInt64Array(i);
                        }
                        break;
                      default:
                        throw new Error(
                          "THREE.FBXLoader: Unknown property type " + n
                        );
                    }
                  }
                }
                class uy {
                  constructor(t, e) {
                    (this.dv = new DataView(t)),
                      (this.offset = 0),
                      (this.littleEndian = void 0 === e || e);
                  }
                  getOffset() {
                    return this.offset;
                  }
                  size() {
                    return this.dv.buffer.byteLength;
                  }
                  skip(t) {
                    this.offset += t;
                  }
                  getBoolean() {
                    return 1 === (1 & this.getUint8());
                  }
                  getBooleanArray(t) {
                    const e = [];
                    for (let n = 0; n < t; n++) e.push(this.getBoolean());
                    return e;
                  }
                  getUint8() {
                    const t = this.dv.getUint8(this.offset);
                    return (this.offset += 1), t;
                  }
                  getInt16() {
                    const t = this.dv.getInt16(this.offset, this.littleEndian);
                    return (this.offset += 2), t;
                  }
                  getInt32() {
                    const t = this.dv.getInt32(this.offset, this.littleEndian);
                    return (this.offset += 4), t;
                  }
                  getInt32Array(t) {
                    const e = [];
                    for (let n = 0; n < t; n++) e.push(this.getInt32());
                    return e;
                  }
                  getUint32() {
                    const t = this.dv.getUint32(this.offset, this.littleEndian);
                    return (this.offset += 4), t;
                  }
                  getInt64() {
                    let t, e;
                    return (
                      this.littleEndian
                        ? ((t = this.getUint32()), (e = this.getUint32()))
                        : ((e = this.getUint32()), (t = this.getUint32())),
                      2147483648 & e
                        ? ((e = 4294967295 & ~e),
                          (t = 4294967295 & ~t),
                          4294967295 === t && (e = (e + 1) & 4294967295),
                          (t = (t + 1) & 4294967295),
                          -(4294967296 * e + t))
                        : 4294967296 * e + t
                    );
                  }
                  getInt64Array(t) {
                    const e = [];
                    for (let n = 0; n < t; n++) e.push(this.getInt64());
                    return e;
                  }
                  getUint64() {
                    let t, e;
                    return (
                      this.littleEndian
                        ? ((t = this.getUint32()), (e = this.getUint32()))
                        : ((e = this.getUint32()), (t = this.getUint32())),
                      4294967296 * e + t
                    );
                  }
                  getFloat32() {
                    const t = this.dv.getFloat32(
                      this.offset,
                      this.littleEndian
                    );
                    return (this.offset += 4), t;
                  }
                  getFloat32Array(t) {
                    const e = [];
                    for (let n = 0; n < t; n++) e.push(this.getFloat32());
                    return e;
                  }
                  getFloat64() {
                    const t = this.dv.getFloat64(
                      this.offset,
                      this.littleEndian
                    );
                    return (this.offset += 8), t;
                  }
                  getFloat64Array(t) {
                    const e = [];
                    for (let n = 0; n < t; n++) e.push(this.getFloat64());
                    return e;
                  }
                  getArrayBuffer(t) {
                    const e = this.dv.buffer.slice(
                      this.offset,
                      this.offset + t
                    );
                    return (this.offset += t), e;
                  }
                  getString(t) {
                    let e = [];
                    for (let r = 0; r < t; r++) e[r] = this.getUint8();
                    const n = e.indexOf(0);
                    return (
                      n >= 0 && (e = e.slice(0, n)),
                      Op.decodeText(new Uint8Array(e))
                    );
                  }
                }
                class hy {
                  add(t, e) {
                    this[t] = e;
                  }
                }
                function dy(t) {
                  const e = "Kaydara FBX Binary  \0";
                  return t.byteLength >= e.length && e === Sy(t, 0, e.length);
                }
                function fy(t) {
                  const e = [
                    "K",
                    "a",
                    "y",
                    "d",
                    "a",
                    "r",
                    "a",
                    "\\",
                    "F",
                    "B",
                    "X",
                    "\\",
                    "B",
                    "i",
                    "n",
                    "a",
                    "r",
                    "y",
                    "\\",
                    "\\",
                  ];
                  let n = 0;
                  function r(e) {
                    const r = t[e - 1];
                    return (t = t.slice(n + e)), n++, r;
                  }
                  for (let i = 0; i < e.length; ++i) {
                    const t = r(1);
                    if (t === e[i]) return !1;
                  }
                  return !0;
                }
                function py(t) {
                  const e = /FBXVersion: (\d+)/,
                    n = t.match(e);
                  if (n) {
                    const t = parseInt(n[1]);
                    return t;
                  }
                  throw new Error(
                    "THREE.FBXLoader: Cannot find the version number for the file given."
                  );
                }
                function my(t) {
                  return t / 46186158e3;
                }
                const gy = [];
                function vy(t, e, n, r) {
                  let i;
                  switch (r.mappingType) {
                    case "ByPolygonVertex":
                      i = t;
                      break;
                    case "ByPolygon":
                      i = e;
                      break;
                    case "ByVertice":
                      i = n;
                      break;
                    case "AllSame":
                      i = r.indices[0];
                      break;
                    default:
                      console.warn(
                        "THREE.FBXLoader: unknown attribute mapping type " +
                          r.mappingType
                      );
                  }
                  "IndexToDirect" === r.referenceType && (i = r.indices[i]);
                  const a = i * r.dataSize,
                    o = a + r.dataSize;
                  return Ty(gy, r.buffer, a, o);
                }
                const yy = new Pr(),
                  by = new Gn();
                function xy(t) {
                  const e = new _r(),
                    n = new _r(),
                    r = new _r(),
                    i = new _r(),
                    a = new _r(),
                    o = new _r(),
                    s = new _r(),
                    c = new _r(),
                    l = new _r(),
                    u = new _r(),
                    h = new _r(),
                    d = new _r(),
                    f = t.inheritType ? t.inheritType : 0;
                  if (
                    (t.translation &&
                      e.setPosition(by.fromArray(t.translation)),
                    t.preRotation)
                  ) {
                    const e = t.preRotation.map(mn.degToRad);
                    e.push(t.eulerOrder),
                      n.makeRotationFromEuler(yy.fromArray(e));
                  }
                  if (t.rotation) {
                    const e = t.rotation.map(mn.degToRad);
                    e.push(t.eulerOrder),
                      r.makeRotationFromEuler(yy.fromArray(e));
                  }
                  if (t.postRotation) {
                    const e = t.postRotation.map(mn.degToRad);
                    e.push(t.eulerOrder),
                      i.makeRotationFromEuler(yy.fromArray(e)),
                      i.invert();
                  }
                  t.scale && a.scale(by.fromArray(t.scale)),
                    t.scalingOffset &&
                      s.setPosition(by.fromArray(t.scalingOffset)),
                    t.scalingPivot &&
                      o.setPosition(by.fromArray(t.scalingPivot)),
                    t.rotationOffset &&
                      c.setPosition(by.fromArray(t.rotationOffset)),
                    t.rotationPivot &&
                      l.setPosition(by.fromArray(t.rotationPivot)),
                    t.parentMatrixWorld &&
                      (h.copy(t.parentMatrix), u.copy(t.parentMatrixWorld));
                  const p = n.clone().multiply(r).multiply(i),
                    m = new _r();
                  m.extractRotation(u);
                  const g = new _r();
                  g.copyPosition(u);
                  const v = g.clone().invert().multiply(u),
                    y = m.clone().invert().multiply(v),
                    b = a,
                    x = new _r();
                  if (0 === f) x.copy(m).multiply(p).multiply(y).multiply(b);
                  else if (1 === f)
                    x.copy(m).multiply(y).multiply(p).multiply(b);
                  else {
                    const t = new _r().scale(new Gn().setFromMatrixScale(h)),
                      e = t.clone().invert(),
                      n = y.clone().multiply(e);
                    x.copy(m).multiply(p).multiply(n).multiply(b);
                  }
                  const _ = l.clone().invert(),
                    w = o.clone().invert();
                  let S = e
                    .clone()
                    .multiply(c)
                    .multiply(l)
                    .multiply(n)
                    .multiply(r)
                    .multiply(i)
                    .multiply(_)
                    .multiply(s)
                    .multiply(o)
                    .multiply(a)
                    .multiply(w);
                  const M = new _r().copyPosition(S),
                    T = u.clone().multiply(M);
                  return (
                    d.copyPosition(T),
                    (S = d.clone().multiply(x)),
                    S.premultiply(u.invert()),
                    S
                  );
                }
                function _y(t) {
                  t = t || 0;
                  const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
                  return 6 === t
                    ? (console.warn(
                        "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
                      ),
                      e[0])
                    : e[t];
                }
                function wy(t) {
                  const e = t.split(",").map(function (t) {
                    return parseFloat(t);
                  });
                  return e;
                }
                function Sy(t, e, n) {
                  return (
                    void 0 === e && (e = 0),
                    void 0 === n && (n = t.byteLength),
                    Op.decodeText(new Uint8Array(t, e, n))
                  );
                }
                function My(t, e) {
                  for (let n = 0, r = t.length, i = e.length; n < i; n++, r++)
                    t[r] = e[n];
                }
                function Ty(t, e, n, r) {
                  for (let i = n, a = 0; i < r; i++, a++) t[a] = e[i];
                  return t;
                }
                function Ey(t, e, n) {
                  return t.slice(0, e).concat(n).concat(t.slice(e));
                }
                n(2087);
                class Ay extends hp {
                  constructor(t) {
                    super(t);
                  }
                  parse(t) {
                    function e(t) {
                      switch (t.image_type) {
                        case h:
                        case p:
                          (t.colormap_length > 256 ||
                            24 !== t.colormap_size ||
                            1 !== t.colormap_type) &&
                            console.error(
                              "THREE.TGALoader: Invalid type colormap data for indexed type."
                            );
                          break;
                        case d:
                        case f:
                        case m:
                        case g:
                          t.colormap_type &&
                            console.error(
                              "THREE.TGALoader: Invalid type colormap data for colormap type."
                            );
                          break;
                        case u:
                          console.error("THREE.TGALoader: No data.");
                        default:
                          console.error(
                            'THREE.TGALoader: Invalid type "%s".',
                            t.image_type
                          );
                      }
                      (t.width <= 0 || t.height <= 0) &&
                        console.error("THREE.TGALoader: Invalid image size."),
                        8 !== t.pixel_size &&
                          16 !== t.pixel_size &&
                          24 !== t.pixel_size &&
                          32 !== t.pixel_size &&
                          console.error(
                            'THREE.TGALoader: Invalid pixel size "%s".',
                            t.pixel_size
                          );
                    }
                    function n(t, e, n, r, i) {
                      let a, o;
                      const s = n.pixel_size >> 3,
                        c = n.width * n.height * s;
                      if (
                        (e &&
                          (o = i.subarray(
                            r,
                            (r += n.colormap_length * (n.colormap_size >> 3))
                          )),
                        t)
                      ) {
                        let t, e, n;
                        a = new Uint8Array(c);
                        let o = 0;
                        const l = new Uint8Array(s);
                        while (o < c)
                          if (((t = i[r++]), (e = 1 + (127 & t)), 128 & t)) {
                            for (n = 0; n < s; ++n) l[n] = i[r++];
                            for (n = 0; n < e; ++n) a.set(l, o + n * s);
                            o += s * e;
                          } else {
                            for (e *= s, n = 0; n < e; ++n) a[o + n] = i[r++];
                            o += e;
                          }
                      } else
                        a = i.subarray(r, (r += e ? n.width * n.height : c));
                      return { pixel_data: a, palettes: o };
                    }
                    function r(t, e, n, r, i, a, o, s, c) {
                      const l = c;
                      let u,
                        h,
                        d,
                        f = 0;
                      const p = T.width;
                      for (d = e; d !== r; d += n)
                        for (h = i; h !== o; h += a, f++)
                          (u = s[f]),
                            (t[4 * (h + p * d) + 3] = 255),
                            (t[4 * (h + p * d) + 2] = l[3 * u + 0]),
                            (t[4 * (h + p * d) + 1] = l[3 * u + 1]),
                            (t[4 * (h + p * d) + 0] = l[3 * u + 2]);
                      return t;
                    }
                    function i(t, e, n, r, i, a, o, s) {
                      let c,
                        l,
                        u,
                        h = 0;
                      const d = T.width;
                      for (u = e; u !== r; u += n)
                        for (l = i; l !== o; l += a, h += 2)
                          (c = s[h + 0] + (s[h + 1] << 8)),
                            (t[4 * (l + d * u) + 0] = (31744 & c) >> 7),
                            (t[4 * (l + d * u) + 1] = (992 & c) >> 2),
                            (t[4 * (l + d * u) + 2] = (31 & c) << 3),
                            (t[4 * (l + d * u) + 3] = 32768 & c ? 0 : 255);
                      return t;
                    }
                    function a(t, e, n, r, i, a, o, s) {
                      let c,
                        l,
                        u = 0;
                      const h = T.width;
                      for (l = e; l !== r; l += n)
                        for (c = i; c !== o; c += a, u += 3)
                          (t[4 * (c + h * l) + 3] = 255),
                            (t[4 * (c + h * l) + 2] = s[u + 0]),
                            (t[4 * (c + h * l) + 1] = s[u + 1]),
                            (t[4 * (c + h * l) + 0] = s[u + 2]);
                      return t;
                    }
                    function o(t, e, n, r, i, a, o, s) {
                      let c,
                        l,
                        u = 0;
                      const h = T.width;
                      for (l = e; l !== r; l += n)
                        for (c = i; c !== o; c += a, u += 4)
                          (t[4 * (c + h * l) + 2] = s[u + 0]),
                            (t[4 * (c + h * l) + 1] = s[u + 1]),
                            (t[4 * (c + h * l) + 0] = s[u + 2]),
                            (t[4 * (c + h * l) + 3] = s[u + 3]);
                      return t;
                    }
                    function s(t, e, n, r, i, a, o, s) {
                      let c,
                        l,
                        u,
                        h = 0;
                      const d = T.width;
                      for (u = e; u !== r; u += n)
                        for (l = i; l !== o; l += a, h++)
                          (c = s[h]),
                            (t[4 * (l + d * u) + 0] = c),
                            (t[4 * (l + d * u) + 1] = c),
                            (t[4 * (l + d * u) + 2] = c),
                            (t[4 * (l + d * u) + 3] = 255);
                      return t;
                    }
                    function c(t, e, n, r, i, a, o, s) {
                      let c,
                        l,
                        u = 0;
                      const h = T.width;
                      for (l = e; l !== r; l += n)
                        for (c = i; c !== o; c += a, u += 2)
                          (t[4 * (c + h * l) + 0] = s[u + 0]),
                            (t[4 * (c + h * l) + 1] = s[u + 0]),
                            (t[4 * (c + h * l) + 2] = s[u + 0]),
                            (t[4 * (c + h * l) + 3] = s[u + 1]);
                      return t;
                    }
                    function l(t, e, n, l, u) {
                      let h, d, f, p, m, g;
                      switch ((T.flags & v) >> y) {
                        default:
                        case _:
                          (h = 0), (f = 1), (m = e), (d = 0), (p = 1), (g = n);
                          break;
                        case b:
                          (h = 0),
                            (f = 1),
                            (m = e),
                            (d = n - 1),
                            (p = -1),
                            (g = -1);
                          break;
                        case w:
                          (h = e - 1),
                            (f = -1),
                            (m = -1),
                            (d = 0),
                            (p = 1),
                            (g = n);
                          break;
                        case x:
                          (h = e - 1),
                            (f = -1),
                            (m = -1),
                            (d = n - 1),
                            (p = -1),
                            (g = -1);
                          break;
                      }
                      if (C)
                        switch (T.pixel_size) {
                          case 8:
                            s(t, d, p, g, h, f, m, l);
                            break;
                          case 16:
                            c(t, d, p, g, h, f, m, l);
                            break;
                          default:
                            console.error(
                              "THREE.TGALoader: Format not supported."
                            );
                            break;
                        }
                      else
                        switch (T.pixel_size) {
                          case 8:
                            r(t, d, p, g, h, f, m, l, u);
                            break;
                          case 16:
                            i(t, d, p, g, h, f, m, l);
                            break;
                          case 24:
                            a(t, d, p, g, h, f, m, l);
                            break;
                          case 32:
                            o(t, d, p, g, h, f, m, l);
                            break;
                          default:
                            console.error(
                              "THREE.TGALoader: Format not supported."
                            );
                            break;
                        }
                      return t;
                    }
                    const u = 0,
                      h = 1,
                      d = 2,
                      f = 3,
                      p = 9,
                      m = 10,
                      g = 11,
                      v = 48,
                      y = 4,
                      b = 0,
                      x = 1,
                      _ = 2,
                      w = 3;
                    t.length < 19 &&
                      console.error(
                        "THREE.TGALoader: Not enough data to contain header."
                      );
                    let S = 0;
                    const M = new Uint8Array(t),
                      T = {
                        id_length: M[S++],
                        colormap_type: M[S++],
                        image_type: M[S++],
                        colormap_index: M[S++] | (M[S++] << 8),
                        colormap_length: M[S++] | (M[S++] << 8),
                        colormap_size: M[S++],
                        origin: [
                          M[S++] | (M[S++] << 8),
                          M[S++] | (M[S++] << 8),
                        ],
                        width: M[S++] | (M[S++] << 8),
                        height: M[S++] | (M[S++] << 8),
                        pixel_size: M[S++],
                        flags: M[S++],
                      };
                    e(T),
                      T.id_length + S > t.length &&
                        console.error("THREE.TGALoader: No data."),
                      (S += T.id_length);
                    let E = !1,
                      A = !1,
                      C = !1;
                    switch (T.image_type) {
                      case p:
                        (E = !0), (A = !0);
                        break;
                      case h:
                        A = !0;
                        break;
                      case m:
                        E = !0;
                        break;
                      case d:
                        break;
                      case g:
                        (E = !0), (C = !0);
                        break;
                      case f:
                        C = !0;
                        break;
                    }
                    const L = new Uint8Array(T.width * T.height * 4),
                      R = n(E, A, T, S, M);
                    return (
                      l(L, T.width, T.height, R.pixel_data, R.palettes),
                      {
                        data: L,
                        width: T.width,
                        height: T.height,
                        flipY: !0,
                        generateMipmaps: !0,
                        minFilter: bt,
                      }
                    );
                  }
                }
                class Cy extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = "" === i.path ? Op.extractUrlBase(t) : i.path,
                      o = new cp(i.manager);
                    o.setPath(i.path),
                      o.setRequestHeader(i.requestHeader),
                      o.setWithCredentials(i.withCredentials),
                      o.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n, a));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  parse(t, e) {
                    function n(t, e) {
                      const n = [],
                        r = t.childNodes;
                      for (let i = 0, a = r.length; i < a; i++) {
                        const t = r[i];
                        t.nodeName === e && n.push(t);
                      }
                      return n;
                    }
                    function r(t) {
                      if (0 === t.length) return [];
                      const e = t.trim().split(/\s+/),
                        n = new Array(e.length);
                      for (let r = 0, i = e.length; r < i; r++) n[r] = e[r];
                      return n;
                    }
                    function i(t) {
                      if (0 === t.length) return [];
                      const e = t.trim().split(/\s+/),
                        n = new Array(e.length);
                      for (let r = 0, i = e.length; r < i; r++)
                        n[r] = parseFloat(e[r]);
                      return n;
                    }
                    function a(t) {
                      if (0 === t.length) return [];
                      const e = t.trim().split(/\s+/),
                        n = new Array(e.length);
                      for (let r = 0, i = e.length; r < i; r++)
                        n[r] = parseInt(e[r]);
                      return n;
                    }
                    function o(t) {
                      return t.substring(1);
                    }
                    function s() {
                      return "three_default_" + Re++;
                    }
                    function c(t) {
                      return 0 === Object.keys(t).length;
                    }
                    function l(t) {
                      return {
                        unit: u(n(t, "unit")[0]),
                        upAxis: h(n(t, "up_axis")[0]),
                      };
                    }
                    function u(t) {
                      return void 0 !== t && !0 === t.hasAttribute("meter")
                        ? parseFloat(t.getAttribute("meter"))
                        : 1;
                    }
                    function h(t) {
                      return void 0 !== t ? t.textContent : "Y_UP";
                    }
                    function d(t, e, r, i) {
                      const a = n(t, e)[0];
                      if (void 0 !== a) {
                        const t = n(a, r);
                        for (let e = 0; e < t.length; e++) i(t[e]);
                      }
                    }
                    function f(t, e) {
                      for (const n in t) {
                        const r = t[n];
                        r.build = e(t[n]);
                      }
                    }
                    function p(t, e) {
                      return void 0 !== t.build || (t.build = e(t)), t.build;
                    }
                    function m(t) {
                      const e = { sources: {}, samplers: {}, channels: {} };
                      let n = !1;
                      for (let r = 0, i = t.childNodes.length; r < i; r++) {
                        const i = t.childNodes[r];
                        if (1 !== i.nodeType) continue;
                        let a;
                        switch (i.nodeName) {
                          case "source":
                            (a = i.getAttribute("id")), (e.sources[a] = Et(i));
                            break;
                          case "sampler":
                            (a = i.getAttribute("id")), (e.samplers[a] = v(i));
                            break;
                          case "channel":
                            (a = i.getAttribute("target")),
                              (e.channels[a] = b(i));
                            break;
                          case "animation":
                            m(i), (n = !0);
                            break;
                          default:
                            console.log(i);
                        }
                      }
                      !1 === n &&
                        (Pe.animations[
                          t.getAttribute("id") || mn.generateUUID()
                        ] = e);
                    }
                    function v(t) {
                      const e = { inputs: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "input":
                              const t = o(r.getAttribute("source")),
                                n = r.getAttribute("semantic");
                              e.inputs[n] = t;
                              break;
                          }
                      }
                      return e;
                    }
                    function b(t) {
                      const e = {},
                        n = t.getAttribute("target");
                      let r = n.split("/");
                      const i = r.shift();
                      let a = r.shift();
                      const s = -1 !== a.indexOf("("),
                        c = -1 !== a.indexOf(".");
                      if (c)
                        (r = a.split(".")),
                          (a = r.shift()),
                          (e.member = r.shift());
                      else if (s) {
                        const t = a.split("(");
                        a = t.shift();
                        for (let e = 0; e < t.length; e++)
                          t[e] = parseInt(t[e].replace(/\)/, ""));
                        e.indices = t;
                      }
                      return (
                        (e.id = i),
                        (e.sid = a),
                        (e.arraySyntax = s),
                        (e.memberSyntax = c),
                        (e.sampler = o(t.getAttribute("source"))),
                        e
                      );
                    }
                    function x(t) {
                      const e = [],
                        n = t.channels,
                        r = t.samplers,
                        i = t.sources;
                      for (const a in n)
                        if (n.hasOwnProperty(a)) {
                          const t = n[a],
                            o = r[t.sampler],
                            s = o.inputs.INPUT,
                            c = o.inputs.OUTPUT,
                            l = i[s],
                            u = i[c],
                            h = w(t, l, u);
                          A(h, e);
                        }
                      return e;
                    }
                    function _(t) {
                      return p(Pe.animations[t], x);
                    }
                    function w(t, e, n) {
                      const r = Pe.nodes[t.id],
                        i = he(r.id),
                        a = r.transforms[t.sid],
                        o = r.matrix.clone().transpose();
                      let s, c, l, u, h, d;
                      const f = {};
                      switch (a) {
                        case "matrix":
                          for (l = 0, u = e.array.length; l < u; l++)
                            if (
                              ((s = e.array[l]),
                              (c = l * n.stride),
                              void 0 === f[s] && (f[s] = {}),
                              !0 === t.arraySyntax)
                            ) {
                              const e = n.array[c],
                                r = t.indices[0] + 4 * t.indices[1];
                              f[s][r] = e;
                            } else
                              for (h = 0, d = n.stride; h < d; h++)
                                f[s][h] = n.array[c + h];
                          break;
                        case "translate":
                          console.warn(
                            'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',
                            a
                          );
                          break;
                        case "rotate":
                          console.warn(
                            'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',
                            a
                          );
                          break;
                        case "scale":
                          console.warn(
                            'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',
                            a
                          );
                          break;
                      }
                      const p = S(f, o),
                        m = { name: i.uuid, keyframes: p };
                      return m;
                    }
                    function S(t, e) {
                      const n = [];
                      for (const i in t)
                        n.push({ time: parseFloat(i), value: t[i] });
                      n.sort(r);
                      for (let i = 0; i < 16; i++) C(n, i, e.elements[i]);
                      return n;
                      function r(t, e) {
                        return t.time - e.time;
                      }
                    }
                    const M = new Gn(),
                      T = new Gn(),
                      E = new Vn();
                    function A(t, e) {
                      const n = t.keyframes,
                        r = t.name,
                        i = [],
                        a = [],
                        o = [],
                        s = [];
                      for (let c = 0, l = n.length; c < l; c++) {
                        const t = n[c],
                          e = t.time,
                          r = t.value;
                        te.fromArray(r).transpose(),
                          te.decompose(M, E, T),
                          i.push(e),
                          a.push(M.x, M.y, M.z),
                          o.push(E.x, E.y, E.z, E.w),
                          s.push(T.x, T.y, T.z);
                      }
                      return (
                        a.length > 0 && e.push(new Qf(r + ".position", i, a)),
                        o.length > 0 && e.push(new Kf(r + ".quaternion", i, o)),
                        s.length > 0 && e.push(new Qf(r + ".scale", i, s)),
                        e
                      );
                    }
                    function C(t, e, n) {
                      let r,
                        i,
                        a,
                        o = !0;
                      for (i = 0, a = t.length; i < a; i++)
                        (r = t[i]),
                          void 0 === r.value[e]
                            ? (r.value[e] = null)
                            : (o = !1);
                      if (!0 === o)
                        for (i = 0, a = t.length; i < a; i++)
                          (r = t[i]), (r.value[e] = n);
                      else L(t, e);
                    }
                    function L(t, e) {
                      let n, r;
                      for (let i = 0, a = t.length; i < a; i++) {
                        const a = t[i];
                        if (null === a.value[e]) {
                          if (
                            ((n = R(t, i, e)), (r = P(t, i, e)), null === n)
                          ) {
                            a.value[e] = r.value[e];
                            continue;
                          }
                          if (null === r) {
                            a.value[e] = n.value[e];
                            continue;
                          }
                          I(a, n, r, e);
                        }
                      }
                    }
                    function R(t, e, n) {
                      while (e >= 0) {
                        const r = t[e];
                        if (null !== r.value[n]) return r;
                        e--;
                      }
                      return null;
                    }
                    function P(t, e, n) {
                      while (e < t.length) {
                        const r = t[e];
                        if (null !== r.value[n]) return r;
                        e++;
                      }
                      return null;
                    }
                    function I(t, e, n, r) {
                      n.time - e.time !== 0
                        ? (t.value[r] =
                            ((t.time - e.time) * (n.value[r] - e.value[r])) /
                              (n.time - e.time) +
                            e.value[r])
                        : (t.value[r] = e.value[r]);
                    }
                    function O(t) {
                      const e = {
                        name: t.getAttribute("id") || "default",
                        start: parseFloat(t.getAttribute("start") || 0),
                        end: parseFloat(t.getAttribute("end") || 0),
                        animations: [],
                      };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "instance_animation":
                              e.animations.push(o(r.getAttribute("url")));
                              break;
                          }
                      }
                      Pe.clips[t.getAttribute("id")] = e;
                    }
                    function k(t) {
                      const e = [],
                        n = t.name,
                        r = t.end - t.start || -1,
                        i = t.animations;
                      for (let a = 0, o = i.length; a < o; a++) {
                        const t = _(i[a]);
                        for (let n = 0, r = t.length; n < r; n++) e.push(t[n]);
                      }
                      return new tp(n, r, e);
                    }
                    function N(t) {
                      return p(Pe.clips[t], k);
                    }
                    function D(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "skin":
                              (e.id = o(r.getAttribute("source"))),
                                (e.skin = z(r));
                              break;
                            case "morph":
                              (e.id = o(r.getAttribute("source"))),
                                console.warn(
                                  "THREE.ColladaLoader: Morph target animation not supported yet."
                                );
                              break;
                          }
                      }
                      Pe.controllers[t.getAttribute("id")] = e;
                    }
                    function z(t) {
                      const e = { sources: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "bind_shape_matrix":
                              e.bindShapeMatrix = i(r.textContent);
                              break;
                            case "source":
                              const t = r.getAttribute("id");
                              e.sources[t] = Et(r);
                              break;
                            case "joints":
                              e.joints = F(r);
                              break;
                            case "vertex_weights":
                              e.vertexWeights = U(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function F(t) {
                      const e = { inputs: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "input":
                              const t = r.getAttribute("semantic"),
                                n = o(r.getAttribute("source"));
                              e.inputs[t] = n;
                              break;
                          }
                      }
                      return e;
                    }
                    function U(t) {
                      const e = { inputs: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "input":
                              const t = r.getAttribute("semantic"),
                                n = o(r.getAttribute("source")),
                                i = parseInt(r.getAttribute("offset"));
                              e.inputs[t] = { id: n, offset: i };
                              break;
                            case "vcount":
                              e.vcount = a(r.textContent);
                              break;
                            case "v":
                              e.v = a(r.textContent);
                              break;
                          }
                      }
                      return e;
                    }
                    function B(t) {
                      const e = { id: t.id },
                        n = Pe.geometries[e.id];
                      return (
                        void 0 !== t.skin &&
                          ((e.skin = j(t.skin)),
                          (n.sources.skinIndices = e.skin.indices),
                          (n.sources.skinWeights = e.skin.weights)),
                        e
                      );
                    }
                    function j(t) {
                      const e = 4,
                        n = {
                          joints: [],
                          indices: { array: [], stride: e },
                          weights: { array: [], stride: e },
                        },
                        r = t.sources,
                        i = t.vertexWeights,
                        a = i.vcount,
                        o = i.v,
                        s = i.inputs.JOINT.offset,
                        c = i.inputs.WEIGHT.offset,
                        l = t.sources[t.joints.inputs.JOINT],
                        u = t.sources[t.joints.inputs.INV_BIND_MATRIX],
                        h = r[i.inputs.WEIGHT.id].array;
                      let d,
                        f,
                        p,
                        m = 0;
                      for (d = 0, p = a.length; d < p; d++) {
                        const t = a[d],
                          r = [];
                        for (f = 0; f < t; f++) {
                          const t = o[m + s],
                            e = o[m + c],
                            n = h[e];
                          r.push({ index: t, weight: n }), (m += 2);
                        }
                        for (r.sort(g), f = 0; f < e; f++) {
                          const t = r[f];
                          void 0 !== t
                            ? (n.indices.array.push(t.index),
                              n.weights.array.push(t.weight))
                            : (n.indices.array.push(0),
                              n.weights.array.push(0));
                        }
                      }
                      for (
                        t.bindShapeMatrix
                          ? (n.bindMatrix = new _r()
                              .fromArray(t.bindShapeMatrix)
                              .transpose())
                          : (n.bindMatrix = new _r().identity()),
                          d = 0,
                          p = l.array.length;
                        d < p;
                        d++
                      ) {
                        const t = l.array[d],
                          e = new _r()
                            .fromArray(u.array, d * u.stride)
                            .transpose();
                        n.joints.push({ name: t, boneInverse: e });
                      }
                      return n;
                      function g(t, e) {
                        return e.weight - t.weight;
                      }
                    }
                    function H(t) {
                      return p(Pe.controllers[t], B);
                    }
                    function V(t) {
                      const e = { init_from: n(t, "init_from")[0].textContent };
                      Pe.images[t.getAttribute("id")] = e;
                    }
                    function G(t) {
                      return void 0 !== t.build ? t.build : t.init_from;
                    }
                    function W(t) {
                      const e = Pe.images[t];
                      return void 0 !== e
                        ? p(e, G)
                        : (console.warn(
                            "THREE.ColladaLoader: Couldn't find image with ID:",
                            t
                          ),
                          null);
                    }
                    function q(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "profile_COMMON":
                              e.profile = X(r);
                              break;
                          }
                      }
                      Pe.effects[t.getAttribute("id")] = e;
                    }
                    function X(t) {
                      const e = { surfaces: {}, samplers: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "newparam":
                              $(r, e);
                              break;
                            case "technique":
                              e.technique = K(r);
                              break;
                            case "extra":
                              e.extra = rt(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function $(t, e) {
                      const n = t.getAttribute("sid");
                      for (let r = 0, i = t.childNodes.length; r < i; r++) {
                        const i = t.childNodes[r];
                        if (1 === i.nodeType)
                          switch (i.nodeName) {
                            case "surface":
                              e.surfaces[n] = Y(i);
                              break;
                            case "sampler2D":
                              e.samplers[n] = J(i);
                              break;
                          }
                      }
                    }
                    function Y(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "init_from":
                              e.init_from = r.textContent;
                              break;
                          }
                      }
                      return e;
                    }
                    function J(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "source":
                              e.source = r.textContent;
                              break;
                          }
                      }
                      return e;
                    }
                    function K(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "constant":
                            case "lambert":
                            case "blinn":
                            case "phong":
                              (e.type = r.nodeName), (e.parameters = Z(r));
                              break;
                            case "extra":
                              e.extra = rt(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function Z(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "emission":
                            case "diffuse":
                            case "specular":
                            case "bump":
                            case "ambient":
                            case "shininess":
                            case "transparency":
                              e[r.nodeName] = Q(r);
                              break;
                            case "transparent":
                              e[r.nodeName] = {
                                opaque: r.hasAttribute("opaque")
                                  ? r.getAttribute("opaque")
                                  : "A_ONE",
                                data: Q(r),
                              };
                              break;
                          }
                      }
                      return e;
                    }
                    function Q(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "color":
                              e[r.nodeName] = i(r.textContent);
                              break;
                            case "float":
                              e[r.nodeName] = parseFloat(r.textContent);
                              break;
                            case "texture":
                              e[r.nodeName] = {
                                id: r.getAttribute("texture"),
                                extra: tt(r),
                              };
                              break;
                          }
                      }
                      return e;
                    }
                    function tt(t) {
                      const e = { technique: {} };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "extra":
                              et(r, e);
                              break;
                          }
                      }
                      return e;
                    }
                    function et(t, e) {
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "technique":
                              nt(r, e);
                              break;
                          }
                      }
                    }
                    function nt(t, e) {
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "repeatU":
                            case "repeatV":
                            case "offsetU":
                            case "offsetV":
                              e.technique[r.nodeName] = parseFloat(
                                r.textContent
                              );
                              break;
                            case "wrapU":
                            case "wrapV":
                              "TRUE" === r.textContent.toUpperCase()
                                ? (e.technique[r.nodeName] = 1)
                                : "FALSE" === r.textContent.toUpperCase()
                                ? (e.technique[r.nodeName] = 0)
                                : (e.technique[r.nodeName] = parseInt(
                                    r.textContent
                                  ));
                              break;
                            case "bump":
                              e[r.nodeName] = at(r);
                              break;
                          }
                      }
                    }
                    function rt(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "technique":
                              e.technique = it(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function it(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "double_sided":
                              e[r.nodeName] = parseInt(r.textContent);
                              break;
                            case "bump":
                              e[r.nodeName] = at(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function at(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "texture":
                              e[r.nodeName] = {
                                id: r.getAttribute("texture"),
                                texcoord: r.getAttribute("texcoord"),
                                extra: tt(r),
                              };
                              break;
                          }
                      }
                      return e;
                    }
                    function ot(t) {
                      return t;
                    }
                    function st(t) {
                      return p(Pe.effects[t], ot);
                    }
                    function ct(t) {
                      const e = { name: t.getAttribute("name") };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "instance_effect":
                              e.url = o(r.getAttribute("url"));
                              break;
                          }
                      }
                      Pe.materials[t.getAttribute("id")] = e;
                    }
                    function lt(t) {
                      let e,
                        n = t.slice(2 + ((t.lastIndexOf(".") - 1) >>> 0));
                      switch (((n = n.toLowerCase()), n)) {
                        case "tga":
                          e = Te;
                          break;
                        default:
                          e = Me;
                      }
                      return e;
                    }
                    function ut(t) {
                      const e = st(t.url),
                        n = e.profile.technique;
                      let r;
                      switch (n.type) {
                        case "phong":
                        case "blinn":
                          r = new Nf();
                          break;
                        case "lambert":
                          r = new Ff();
                          break;
                        default:
                          r = new oi();
                          break;
                      }
                      function i(t, n = null) {
                        const r = e.profile.samplers[t.id];
                        let i = null;
                        if (void 0 !== r) {
                          const t = e.profile.surfaces[r.source];
                          i = W(t.init_from);
                        } else
                          console.warn(
                            "THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."
                          ),
                            (i = W(t.id));
                        if (null !== i) {
                          const e = lt(i);
                          if (void 0 !== e) {
                            const r = e.load(i),
                              a = t.extra;
                            if (
                              void 0 !== a &&
                              void 0 !== a.technique &&
                              !1 === c(a.technique)
                            ) {
                              const t = a.technique;
                              (r.wrapS = t.wrapU ? ht : dt),
                                (r.wrapT = t.wrapV ? ht : dt),
                                r.offset.set(t.offsetU || 0, t.offsetV || 0),
                                r.repeat.set(t.repeatU || 1, t.repeatV || 1);
                            } else (r.wrapS = ht), (r.wrapT = ht);
                            return null !== n && (r.encoding = n), r;
                          }
                          return (
                            console.warn(
                              "THREE.ColladaLoader: Loader for texture %s not found.",
                              i
                            ),
                            null
                          );
                        }
                        return (
                          console.warn(
                            "THREE.ColladaLoader: Couldn't create texture with ID:",
                            t.id
                          ),
                          null
                        );
                      }
                      r.name = t.name || "";
                      const a = n.parameters;
                      for (const c in a) {
                        const t = a[c];
                        switch (c) {
                          case "diffuse":
                            t.color && r.color.fromArray(t.color),
                              t.texture && (r.map = i(t.texture, Le));
                            break;
                          case "specular":
                            t.color &&
                              r.specular &&
                              r.specular.fromArray(t.color),
                              t.texture && (r.specularMap = i(t.texture));
                            break;
                          case "bump":
                            t.texture && (r.normalMap = i(t.texture));
                            break;
                          case "ambient":
                            t.texture && (r.lightMap = i(t.texture, Le));
                            break;
                          case "shininess":
                            t.float && r.shininess && (r.shininess = t.float);
                            break;
                          case "emission":
                            t.color &&
                              r.emissive &&
                              r.emissive.fromArray(t.color),
                              t.texture && (r.emissiveMap = i(t.texture, Le));
                            break;
                        }
                      }
                      r.color.convertSRGBToLinear(),
                        r.specular && r.specular.convertSRGBToLinear(),
                        r.emissive && r.emissive.convertSRGBToLinear();
                      let o = a["transparent"],
                        s = a["transparency"];
                      if (
                        (void 0 === s && o && (s = { float: 1 }),
                        void 0 === o &&
                          s &&
                          (o = {
                            opaque: "A_ONE",
                            data: { color: [1, 1, 1, 1] },
                          }),
                        o && s)
                      )
                        if (o.data.texture) r.transparent = !0;
                        else {
                          const t = o.data.color;
                          switch (o.opaque) {
                            case "A_ONE":
                              r.opacity = t[3] * s.float;
                              break;
                            case "RGB_ZERO":
                              r.opacity = 1 - t[0] * s.float;
                              break;
                            case "A_ZERO":
                              r.opacity = 1 - t[3] * s.float;
                              break;
                            case "RGB_ONE":
                              r.opacity = t[0] * s.float;
                              break;
                            default:
                              console.warn(
                                'THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',
                                o.opaque
                              );
                          }
                          r.opacity < 1 && (r.transparent = !0);
                        }
                      if (void 0 !== n.extra && void 0 !== n.extra.technique) {
                        const t = n.extra.technique;
                        for (const e in t) {
                          const n = t[e];
                          switch (e) {
                            case "double_sided":
                              r.side = 1 === n ? y : g;
                              break;
                            case "bump":
                              (r.normalMap = i(n.texture)),
                                (r.normalScale = new gn(1, 1));
                              break;
                          }
                        }
                      }
                      return r;
                    }
                    function ft(t) {
                      return p(Pe.materials[t], ut);
                    }
                    function pt(t) {
                      const e = { name: t.getAttribute("name") };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "optics":
                              e.optics = mt(r);
                              break;
                          }
                      }
                      Pe.cameras[t.getAttribute("id")] = e;
                    }
                    function mt(t) {
                      for (let e = 0; e < t.childNodes.length; e++) {
                        const n = t.childNodes[e];
                        switch (n.nodeName) {
                          case "technique_common":
                            return gt(n);
                        }
                      }
                      return {};
                    }
                    function gt(t) {
                      const e = {};
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        switch (r.nodeName) {
                          case "perspective":
                          case "orthographic":
                            (e.technique = r.nodeName), (e.parameters = vt(r));
                            break;
                        }
                      }
                      return e;
                    }
                    function vt(t) {
                      const e = {};
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        switch (r.nodeName) {
                          case "xfov":
                          case "yfov":
                          case "xmag":
                          case "ymag":
                          case "znear":
                          case "zfar":
                          case "aspect_ratio":
                            e[r.nodeName] = parseFloat(r.textContent);
                            break;
                        }
                      }
                      return e;
                    }
                    function yt(t) {
                      let e;
                      switch (t.optics.technique) {
                        case "perspective":
                          e = new Yi(
                            t.optics.parameters.yfov,
                            t.optics.parameters.aspect_ratio,
                            t.optics.parameters.znear,
                            t.optics.parameters.zfar
                          );
                          break;
                        case "orthographic":
                          let n = t.optics.parameters.ymag,
                            r = t.optics.parameters.xmag;
                          const i = t.optics.parameters.aspect_ratio;
                          (r = void 0 === r ? n * i : r),
                            (n = void 0 === n ? r / i : n),
                            (r *= 0.5),
                            (n *= 0.5),
                            (e = new Js(
                              -r,
                              r,
                              n,
                              -n,
                              t.optics.parameters.znear,
                              t.optics.parameters.zfar
                            ));
                          break;
                        default:
                          e = new Yi();
                          break;
                      }
                      return (e.name = t.name || ""), e;
                    }
                    function bt(t) {
                      const e = Pe.cameras[t];
                      return void 0 !== e
                        ? p(e, yt)
                        : (console.warn(
                            "THREE.ColladaLoader: Couldn't find camera with ID:",
                            t
                          ),
                          null);
                    }
                    function xt(t) {
                      let e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "technique_common":
                              e = _t(r);
                              break;
                          }
                      }
                      Pe.lights[t.getAttribute("id")] = e;
                    }
                    function _t(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "directional":
                            case "point":
                            case "spot":
                            case "ambient":
                              (e.technique = r.nodeName),
                                (e.parameters = wt(r));
                          }
                      }
                      return e;
                    }
                    function wt(t) {
                      const e = {};
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "color":
                              const t = i(r.textContent);
                              e.color = new In()
                                .fromArray(t)
                                .convertSRGBToLinear();
                              break;
                            case "falloff_angle":
                              e.falloffAngle = parseFloat(r.textContent);
                              break;
                            case "quadratic_attenuation":
                              const n = parseFloat(r.textContent);
                              e.distance = n ? Math.sqrt(1 / n) : 0;
                              break;
                          }
                      }
                      return e;
                    }
                    function St(t) {
                      let e;
                      switch (t.technique) {
                        case "directional":
                          e = new Ap();
                          break;
                        case "point":
                          e = new Tp();
                          break;
                        case "spot":
                          e = new xp();
                          break;
                        case "ambient":
                          e = new Cp();
                          break;
                      }
                      return (
                        t.parameters.color && e.color.copy(t.parameters.color),
                        t.parameters.distance &&
                          (e.distance = t.parameters.distance),
                        e
                      );
                    }
                    function Mt(t) {
                      const e = Pe.lights[t];
                      return void 0 !== e
                        ? p(e, St)
                        : (console.warn(
                            "THREE.ColladaLoader: Couldn't find light with ID:",
                            t
                          ),
                          null);
                    }
                    function Tt(t) {
                      const e = {
                          name: t.getAttribute("name"),
                          sources: {},
                          vertices: {},
                          primitives: [],
                        },
                        r = n(t, "mesh")[0];
                      if (void 0 !== r) {
                        for (let t = 0; t < r.childNodes.length; t++) {
                          const n = r.childNodes[t];
                          if (1 !== n.nodeType) continue;
                          const i = n.getAttribute("id");
                          switch (n.nodeName) {
                            case "source":
                              e.sources[i] = Et(n);
                              break;
                            case "vertices":
                              e.vertices = At(n);
                              break;
                            case "polygons":
                              console.warn(
                                "THREE.ColladaLoader: Unsupported primitive type: ",
                                n.nodeName
                              );
                              break;
                            case "lines":
                            case "linestrips":
                            case "polylist":
                            case "triangles":
                              e.primitives.push(Ct(n));
                              break;
                            default:
                              console.log(n);
                          }
                        }
                        Pe.geometries[t.getAttribute("id")] = e;
                      }
                    }
                    function Et(t) {
                      const e = { array: [], stride: 3 };
                      for (let a = 0; a < t.childNodes.length; a++) {
                        const o = t.childNodes[a];
                        if (1 === o.nodeType)
                          switch (o.nodeName) {
                            case "float_array":
                              e.array = i(o.textContent);
                              break;
                            case "Name_array":
                              e.array = r(o.textContent);
                              break;
                            case "technique_common":
                              const t = n(o, "accessor")[0];
                              void 0 !== t &&
                                (e.stride = parseInt(t.getAttribute("stride")));
                              break;
                          }
                      }
                      return e;
                    }
                    function At(t) {
                      const e = {};
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        1 === r.nodeType &&
                          (e[r.getAttribute("semantic")] = o(
                            r.getAttribute("source")
                          ));
                      }
                      return e;
                    }
                    function Ct(t) {
                      const e = {
                        type: t.nodeName,
                        material: t.getAttribute("material"),
                        count: parseInt(t.getAttribute("count")),
                        inputs: {},
                        stride: 0,
                        hasUV: !1,
                      };
                      for (let n = 0, r = t.childNodes.length; n < r; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "input":
                              const t = o(r.getAttribute("source")),
                                n = r.getAttribute("semantic"),
                                i = parseInt(r.getAttribute("offset")),
                                s = parseInt(r.getAttribute("set")),
                                c = s > 0 ? n + s : n;
                              (e.inputs[c] = { id: t, offset: i }),
                                (e.stride = Math.max(e.stride, i + 1)),
                                "TEXCOORD" === n && (e.hasUV = !0);
                              break;
                            case "vcount":
                              e.vcount = a(r.textContent);
                              break;
                            case "p":
                              e.p = a(r.textContent);
                              break;
                          }
                      }
                      return e;
                    }
                    function Lt(t) {
                      const e = {};
                      for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        void 0 === e[r.type] && (e[r.type] = []),
                          e[r.type].push(r);
                      }
                      return e;
                    }
                    function Rt(t) {
                      let e = 0;
                      for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        !0 === r.hasUV && e++;
                      }
                      e > 0 && e < t.length && (t.uvsNeedsFix = !0);
                    }
                    function Pt(t) {
                      const e = {},
                        n = t.sources,
                        r = t.vertices,
                        i = t.primitives;
                      if (0 === i.length) return {};
                      const a = Lt(i);
                      for (const o in a) {
                        const t = a[o];
                        Rt(t), (e[o] = It(t, n, r));
                      }
                      return e;
                    }
                    function It(t, e, n) {
                      const r = {},
                        i = { array: [], stride: 0 },
                        a = { array: [], stride: 0 },
                        o = { array: [], stride: 0 },
                        s = { array: [], stride: 0 },
                        c = { array: [], stride: 0 },
                        l = { array: [], stride: 4 },
                        u = { array: [], stride: 4 },
                        h = new xi(),
                        d = [];
                      let f = 0;
                      for (let p = 0; p < t.length; p++) {
                        const r = t[p],
                          m = r.inputs;
                        let g = 0;
                        switch (r.type) {
                          case "lines":
                          case "linestrips":
                            g = 2 * r.count;
                            break;
                          case "triangles":
                            g = 3 * r.count;
                            break;
                          case "polylist":
                            for (let t = 0; t < r.count; t++) {
                              const e = r.vcount[t];
                              switch (e) {
                                case 3:
                                  g += 3;
                                  break;
                                case 4:
                                  g += 6;
                                  break;
                                default:
                                  g += 3 * (e - 2);
                                  break;
                              }
                            }
                            break;
                          default:
                            console.warn(
                              "THREE.ColladaLoader: Unknow primitive type:",
                              r.type
                            );
                        }
                        h.addGroup(f, g, p),
                          (f += g),
                          r.material && d.push(r.material);
                        for (const h in m) {
                          const d = m[h];
                          switch (h) {
                            case "VERTEX":
                              for (const h in n) {
                                const f = n[h];
                                switch (h) {
                                  case "POSITION":
                                    const n = i.array.length;
                                    if (
                                      (Ot(r, e[f], d.offset, i.array),
                                      (i.stride = e[f].stride),
                                      e.skinWeights &&
                                        e.skinIndices &&
                                        (Ot(
                                          r,
                                          e.skinIndices,
                                          d.offset,
                                          l.array
                                        ),
                                        Ot(
                                          r,
                                          e.skinWeights,
                                          d.offset,
                                          u.array
                                        )),
                                      !1 === r.hasUV && !0 === t.uvsNeedsFix)
                                    ) {
                                      const t = (i.array.length - n) / i.stride;
                                      for (let e = 0; e < t; e++)
                                        o.array.push(0, 0);
                                    }
                                    break;
                                  case "NORMAL":
                                    Ot(r, e[f], d.offset, a.array),
                                      (a.stride = e[f].stride);
                                    break;
                                  case "COLOR":
                                    Ot(r, e[f], d.offset, c.array),
                                      (c.stride = e[f].stride);
                                    break;
                                  case "TEXCOORD":
                                    Ot(r, e[f], d.offset, o.array),
                                      (o.stride = e[f].stride);
                                    break;
                                  case "TEXCOORD1":
                                    Ot(r, e[f], d.offset, s.array),
                                      (o.stride = e[f].stride);
                                    break;
                                  default:
                                    console.warn(
                                      'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',
                                      h
                                    );
                                }
                              }
                              break;
                            case "NORMAL":
                              Ot(r, e[d.id], d.offset, a.array),
                                (a.stride = e[d.id].stride);
                              break;
                            case "COLOR":
                              Ot(r, e[d.id], d.offset, c.array, !0),
                                (c.stride = e[d.id].stride);
                              break;
                            case "TEXCOORD":
                              Ot(r, e[d.id], d.offset, o.array),
                                (o.stride = e[d.id].stride);
                              break;
                            case "TEXCOORD1":
                              Ot(r, e[d.id], d.offset, s.array),
                                (s.stride = e[d.id].stride);
                              break;
                          }
                        }
                      }
                      return (
                        i.array.length > 0 &&
                          h.setAttribute("position", new di(i.array, i.stride)),
                        a.array.length > 0 &&
                          h.setAttribute("normal", new di(a.array, a.stride)),
                        c.array.length > 0 &&
                          h.setAttribute("color", new di(c.array, c.stride)),
                        o.array.length > 0 &&
                          h.setAttribute("uv", new di(o.array, o.stride)),
                        s.array.length > 0 &&
                          h.setAttribute("uv2", new di(s.array, s.stride)),
                        l.array.length > 0 &&
                          h.setAttribute(
                            "skinIndex",
                            new di(l.array, l.stride)
                          ),
                        u.array.length > 0 &&
                          h.setAttribute(
                            "skinWeight",
                            new di(u.array, u.stride)
                          ),
                        (r.data = h),
                        (r.type = t[0].type),
                        (r.materialKeys = d),
                        r
                      );
                    }
                    function Ot(t, e, n, r, i = !1) {
                      const a = t.p,
                        o = t.stride,
                        s = t.vcount;
                      function c(t) {
                        let e = a[t + n] * u;
                        const o = e + u;
                        for (; e < o; e++) r.push(l[e]);
                        if (i) {
                          const t = r.length - u - 1;
                          Ee.setRGB(
                            r[t + 0],
                            r[t + 1],
                            r[t + 2]
                          ).convertSRGBToLinear(),
                            (r[t + 0] = Ee.r),
                            (r[t + 1] = Ee.g),
                            (r[t + 2] = Ee.b);
                        }
                      }
                      const l = e.array,
                        u = e.stride;
                      if (void 0 !== t.vcount) {
                        let t = 0;
                        for (let e = 0, n = s.length; e < n; e++) {
                          const n = s[e];
                          if (4 === n) {
                            const e = t + 0 * o,
                              n = t + 1 * o,
                              r = t + 2 * o,
                              i = t + 3 * o;
                            c(e), c(n), c(i), c(n), c(r), c(i);
                          } else if (3 === n) {
                            const e = t + 0 * o,
                              n = t + 1 * o,
                              r = t + 2 * o;
                            c(e), c(n), c(r);
                          } else if (n > 4)
                            for (let e = 1, r = n - 2; e <= r; e++) {
                              const n = t + 0 * o,
                                r = t + o * e,
                                i = t + o * (e + 1);
                              c(n), c(r), c(i);
                            }
                          t += o * n;
                        }
                      } else for (let h = 0, d = a.length; h < d; h += o) c(h);
                    }
                    function kt(t) {
                      return p(Pe.geometries[t], Pt);
                    }
                    function Nt(t) {
                      const e = {
                        name: t.getAttribute("name") || "",
                        joints: {},
                        links: [],
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "technique_common":
                              Ft(r, e);
                              break;
                          }
                      }
                      Pe.kinematicsModels[t.getAttribute("id")] = e;
                    }
                    function Dt(t) {
                      return void 0 !== t.build ? t.build : t;
                    }
                    function zt(t) {
                      return p(Pe.kinematicsModels[t], Dt);
                    }
                    function Ft(t, e) {
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "joint":
                              e.joints[r.getAttribute("sid")] = Ut(r);
                              break;
                            case "link":
                              e.links.push(jt(r));
                              break;
                          }
                      }
                    }
                    function Ut(t) {
                      let e;
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "prismatic":
                            case "revolute":
                              e = Bt(r);
                              break;
                          }
                      }
                      return e;
                    }
                    function Bt(t) {
                      const e = {
                        sid: t.getAttribute("sid"),
                        name: t.getAttribute("name") || "",
                        axis: new Gn(),
                        limits: { min: 0, max: 0 },
                        type: t.nodeName,
                        static: !1,
                        zeroPosition: 0,
                        middlePosition: 0,
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "axis":
                              const t = i(r.textContent);
                              e.axis.fromArray(t);
                              break;
                            case "limits":
                              const n = r.getElementsByTagName("max")[0],
                                a = r.getElementsByTagName("min")[0];
                              (e.limits.max = parseFloat(n.textContent)),
                                (e.limits.min = parseFloat(a.textContent));
                              break;
                          }
                      }
                      return (
                        e.limits.min >= e.limits.max && (e.static = !0),
                        (e.middlePosition = (e.limits.min + e.limits.max) / 2),
                        e
                      );
                    }
                    function jt(t) {
                      const e = {
                        sid: t.getAttribute("sid"),
                        name: t.getAttribute("name") || "",
                        attachments: [],
                        transforms: [],
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "attachment_full":
                              e.attachments.push(Ht(r));
                              break;
                            case "matrix":
                            case "translate":
                            case "rotate":
                              e.transforms.push(Vt(r));
                              break;
                          }
                      }
                      return e;
                    }
                    function Ht(t) {
                      const e = {
                        joint: t.getAttribute("joint").split("/").pop(),
                        transforms: [],
                        links: [],
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "link":
                              e.links.push(jt(r));
                              break;
                            case "matrix":
                            case "translate":
                            case "rotate":
                              e.transforms.push(Vt(r));
                              break;
                          }
                      }
                      return e;
                    }
                    function Vt(t) {
                      const e = { type: t.nodeName },
                        n = i(t.textContent);
                      switch (e.type) {
                        case "matrix":
                          (e.obj = new _r()), e.obj.fromArray(n).transpose();
                          break;
                        case "translate":
                          (e.obj = new Gn()), e.obj.fromArray(n);
                          break;
                        case "rotate":
                          (e.obj = new Gn()),
                            e.obj.fromArray(n),
                            (e.angle = mn.degToRad(n[3]));
                          break;
                      }
                      return e;
                    }
                    function Gt(t) {
                      const e = {
                        name: t.getAttribute("name") || "",
                        rigidBodies: {},
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "rigid_body":
                              (e.rigidBodies[r.getAttribute("name")] = {}),
                                Wt(r, e.rigidBodies[r.getAttribute("name")]);
                              break;
                          }
                      }
                      Pe.physicsModels[t.getAttribute("id")] = e;
                    }
                    function Wt(t, e) {
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "technique_common":
                              qt(r, e);
                              break;
                          }
                      }
                    }
                    function qt(t, e) {
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "inertia":
                              e.inertia = i(r.textContent);
                              break;
                            case "mass":
                              e.mass = i(r.textContent)[0];
                              break;
                          }
                      }
                    }
                    function Xt(t) {
                      const e = { bindJointAxis: [] };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "bind_joint_axis":
                              e.bindJointAxis.push($t(r));
                              break;
                          }
                      }
                      Pe.kinematicsScenes[o(t.getAttribute("url"))] = e;
                    }
                    function $t(t) {
                      const e = {
                        target: t.getAttribute("target").split("/").pop(),
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 === r.nodeType)
                          switch (r.nodeName) {
                            case "axis":
                              const t = r.getElementsByTagName("param")[0];
                              e.axis = t.textContent;
                              const n = e.axis
                                .split("inst_")
                                .pop()
                                .split("axis")[0];
                              e.jointIndex = n.substring(0, n.length - 1);
                              break;
                          }
                      }
                      return e;
                    }
                    function Yt(t) {
                      return void 0 !== t.build ? t.build : t;
                    }
                    function Jt(t) {
                      return p(Pe.kinematicsScenes[t], Yt);
                    }
                    function Kt() {
                      const t = Object.keys(Pe.kinematicsModels)[0],
                        e = Object.keys(Pe.kinematicsScenes)[0],
                        n = Object.keys(Pe.visualScenes)[0];
                      if (void 0 === t || void 0 === e) return;
                      const r = zt(t),
                        i = Jt(e),
                        a = me(n),
                        o = i.bindJointAxis,
                        s = {};
                      for (let u = 0, h = o.length; u < h; u++) {
                        const t = o[u],
                          e = xe.querySelector('[sid="' + t.target + '"]');
                        if (e) {
                          const n = e.parentElement;
                          c(t.jointIndex, n);
                        }
                      }
                      function c(t, e) {
                        const n = e.getAttribute("name"),
                          i = r.joints[t];
                        a.traverse(function (r) {
                          r.name === n &&
                            (s[t] = {
                              object: r,
                              transforms: Zt(e),
                              joint: i,
                              position: i.zeroPosition,
                            });
                        });
                      }
                      const l = new _r();
                      Ce = {
                        joints: r && r.joints,
                        getJointValue: function (t) {
                          const e = s[t];
                          if (e) return e.position;
                          console.warn(
                            "THREE.ColladaLoader: Joint " +
                              t +
                              " doesn't exist."
                          );
                        },
                        setJointValue: function (t, e) {
                          const n = s[t];
                          if (n) {
                            const r = n.joint;
                            if (e > r.limits.max || e < r.limits.min)
                              console.warn(
                                "THREE.ColladaLoader: Joint " +
                                  t +
                                  " value " +
                                  e +
                                  " outside of limits (min: " +
                                  r.limits.min +
                                  ", max: " +
                                  r.limits.max +
                                  ")."
                              );
                            else if (r.static)
                              console.warn(
                                "THREE.ColladaLoader: Joint " +
                                  t +
                                  " is static."
                              );
                            else {
                              const i = n.object,
                                a = r.axis,
                                o = n.transforms;
                              te.identity();
                              for (let n = 0; n < o.length; n++) {
                                const i = o[n];
                                if (i.sid && -1 !== i.sid.indexOf(t))
                                  switch (r.type) {
                                    case "revolute":
                                      te.multiply(
                                        l.makeRotationAxis(a, mn.degToRad(e))
                                      );
                                      break;
                                    case "prismatic":
                                      te.multiply(
                                        l.makeTranslation(
                                          a.x * e,
                                          a.y * e,
                                          a.z * e
                                        )
                                      );
                                      break;
                                    default:
                                      console.warn(
                                        "THREE.ColladaLoader: Unknown joint type: " +
                                          r.type
                                      );
                                      break;
                                  }
                                else
                                  switch (i.type) {
                                    case "matrix":
                                      te.multiply(i.obj);
                                      break;
                                    case "translate":
                                      te.multiply(
                                        l.makeTranslation(
                                          i.obj.x,
                                          i.obj.y,
                                          i.obj.z
                                        )
                                      );
                                      break;
                                    case "scale":
                                      te.scale(i.obj);
                                      break;
                                    case "rotate":
                                      te.multiply(
                                        l.makeRotationAxis(i.obj, i.angle)
                                      );
                                      break;
                                  }
                              }
                              i.matrix.copy(te),
                                i.matrix.decompose(
                                  i.position,
                                  i.quaternion,
                                  i.scale
                                ),
                                (s[t].position = e);
                            }
                          } else
                            console.log(
                              "THREE.ColladaLoader: " + t + " does not exist."
                            );
                        },
                      };
                    }
                    function Zt(t) {
                      const e = [],
                        n = xe.querySelector('[id="' + t.id + '"]');
                      for (let r = 0; r < n.childNodes.length; r++) {
                        const t = n.childNodes[r];
                        if (1 !== t.nodeType) continue;
                        let a, o;
                        switch (t.nodeName) {
                          case "matrix":
                            a = i(t.textContent);
                            const n = new _r().fromArray(a).transpose();
                            e.push({
                              sid: t.getAttribute("sid"),
                              type: t.nodeName,
                              obj: n,
                            });
                            break;
                          case "translate":
                          case "scale":
                            (a = i(t.textContent)),
                              (o = new Gn().fromArray(a)),
                              e.push({
                                sid: t.getAttribute("sid"),
                                type: t.nodeName,
                                obj: o,
                              });
                            break;
                          case "rotate":
                            (a = i(t.textContent)), (o = new Gn().fromArray(a));
                            const r = mn.degToRad(a[3]);
                            e.push({
                              sid: t.getAttribute("sid"),
                              type: t.nodeName,
                              obj: o,
                              angle: r,
                            });
                            break;
                        }
                      }
                      return e;
                    }
                    function Qt(t) {
                      const e = t.getElementsByTagName("node");
                      for (let n = 0; n < e.length; n++) {
                        const t = e[n];
                        !1 === t.hasAttribute("id") &&
                          t.setAttribute("id", s());
                      }
                    }
                    const te = new _r(),
                      ee = new Gn();
                    function ne(t) {
                      const e = {
                        name: t.getAttribute("name") || "",
                        type: t.getAttribute("type"),
                        id: t.getAttribute("id"),
                        sid: t.getAttribute("sid"),
                        matrix: new _r(),
                        nodes: [],
                        instanceCameras: [],
                        instanceControllers: [],
                        instanceLights: [],
                        instanceGeometries: [],
                        instanceNodes: [],
                        transforms: {},
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        if (1 !== r.nodeType) continue;
                        let a;
                        switch (r.nodeName) {
                          case "node":
                            e.nodes.push(r.getAttribute("id")), ne(r);
                            break;
                          case "instance_camera":
                            e.instanceCameras.push(o(r.getAttribute("url")));
                            break;
                          case "instance_controller":
                            e.instanceControllers.push(re(r));
                            break;
                          case "instance_light":
                            e.instanceLights.push(o(r.getAttribute("url")));
                            break;
                          case "instance_geometry":
                            e.instanceGeometries.push(re(r));
                            break;
                          case "instance_node":
                            e.instanceNodes.push(o(r.getAttribute("url")));
                            break;
                          case "matrix":
                            (a = i(r.textContent)),
                              e.matrix.multiply(te.fromArray(a).transpose()),
                              (e.transforms[r.getAttribute("sid")] =
                                r.nodeName);
                            break;
                          case "translate":
                            (a = i(r.textContent)),
                              ee.fromArray(a),
                              e.matrix.multiply(
                                te.makeTranslation(ee.x, ee.y, ee.z)
                              ),
                              (e.transforms[r.getAttribute("sid")] =
                                r.nodeName);
                            break;
                          case "rotate":
                            a = i(r.textContent);
                            const t = mn.degToRad(a[3]);
                            e.matrix.multiply(
                              te.makeRotationAxis(ee.fromArray(a), t)
                            ),
                              (e.transforms[r.getAttribute("sid")] =
                                r.nodeName);
                            break;
                          case "scale":
                            (a = i(r.textContent)),
                              e.matrix.scale(ee.fromArray(a)),
                              (e.transforms[r.getAttribute("sid")] =
                                r.nodeName);
                            break;
                          case "extra":
                            break;
                          default:
                            console.log(r);
                        }
                      }
                      return (
                        ue(e.id)
                          ? console.warn(
                              "THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",
                              e.id
                            )
                          : (Pe.nodes[e.id] = e),
                        e
                      );
                    }
                    function re(t) {
                      const e = {
                        id: o(t.getAttribute("url")),
                        materials: {},
                        skeletons: [],
                      };
                      for (let n = 0; n < t.childNodes.length; n++) {
                        const r = t.childNodes[n];
                        switch (r.nodeName) {
                          case "bind_material":
                            const t =
                              r.getElementsByTagName("instance_material");
                            for (let n = 0; n < t.length; n++) {
                              const r = t[n],
                                i = r.getAttribute("symbol"),
                                a = r.getAttribute("target");
                              e.materials[i] = o(a);
                            }
                            break;
                          case "skeleton":
                            e.skeletons.push(o(r.textContent));
                            break;
                          default:
                            break;
                        }
                      }
                      return e;
                    }
                    function ie(t, e) {
                      const n = [],
                        r = [];
                      let i, a, o;
                      for (i = 0; i < t.length; i++) {
                        const r = t[i];
                        let a;
                        if (ue(r)) (a = he(r)), ae(a, e, n);
                        else if (pe(r)) {
                          const t = Pe.visualScenes[r],
                            i = t.children;
                          for (let r = 0; r < i.length; r++) {
                            const t = i[r];
                            if ("JOINT" === t.type) {
                              const r = he(t.id);
                              ae(r, e, n);
                            }
                          }
                        } else
                          console.error(
                            "THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",
                            r
                          );
                      }
                      for (i = 0; i < e.length; i++)
                        for (a = 0; a < n.length; a++)
                          if (((o = n[a]), o.bone.name === e[i].name)) {
                            (r[i] = o), (o.processed = !0);
                            break;
                          }
                      for (i = 0; i < n.length; i++)
                        (o = n[i]),
                          !1 === o.processed && (r.push(o), (o.processed = !0));
                      const s = [],
                        c = [];
                      for (i = 0; i < r.length; i++)
                        (o = r[i]), s.push(o.bone), c.push(o.boneInverse);
                      return new bh(s, c);
                    }
                    function ae(t, e, n) {
                      t.traverse(function (t) {
                        if (!0 === t.isBone) {
                          let r;
                          for (let n = 0; n < e.length; n++) {
                            const i = e[n];
                            if (i.name === t.name) {
                              r = i.boneInverse;
                              break;
                            }
                          }
                          void 0 === r && (r = new _r()),
                            n.push({ bone: t, boneInverse: r, processed: !1 });
                        }
                      });
                    }
                    function oe(t) {
                      const e = [],
                        n = t.matrix,
                        r = t.nodes,
                        i = t.type,
                        a = t.instanceCameras,
                        o = t.instanceControllers,
                        s = t.instanceLights,
                        c = t.instanceGeometries,
                        l = t.instanceNodes;
                      for (let h = 0, d = r.length; h < d; h++)
                        e.push(he(r[h]));
                      for (let h = 0, d = a.length; h < d; h++) {
                        const t = bt(a[h]);
                        null !== t && e.push(t.clone());
                      }
                      for (let h = 0, d = o.length; h < d; h++) {
                        const t = o[h],
                          n = H(t.id),
                          r = kt(n.id),
                          i = le(r, t.materials),
                          a = t.skeletons,
                          s = n.skin.joints,
                          c = ie(a, s);
                        for (let o = 0, l = i.length; o < l; o++) {
                          const t = i[o];
                          t.isSkinnedMesh &&
                            (t.bind(c, n.skin.bindMatrix),
                            t.normalizeSkinWeights()),
                            e.push(t);
                        }
                      }
                      for (let h = 0, d = s.length; h < d; h++) {
                        const t = Mt(s[h]);
                        null !== t && e.push(t.clone());
                      }
                      for (let h = 0, d = c.length; h < d; h++) {
                        const t = c[h],
                          n = kt(t.id),
                          r = le(n, t.materials);
                        for (let i = 0, a = r.length; i < a; i++) e.push(r[i]);
                      }
                      for (let h = 0, d = l.length; h < d; h++)
                        e.push(he(l[h]).clone());
                      let u;
                      if (0 === r.length && 1 === e.length) u = e[0];
                      else {
                        u = "JOINT" === i ? new mh() : new Lu();
                        for (let t = 0; t < e.length; t++) u.add(e[t]);
                      }
                      return (
                        (u.name = "JOINT" === i ? t.sid : t.name),
                        u.matrix.copy(n),
                        u.matrix.decompose(u.position, u.quaternion, u.scale),
                        u
                      );
                    }
                    const se = new oi({ color: 16711935 });
                    function ce(t, e) {
                      const n = [];
                      for (let r = 0, i = t.length; r < i; r++) {
                        const i = e[t[r]];
                        void 0 === i
                          ? (console.warn(
                              "THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",
                              t[r]
                            ),
                            n.push(se))
                          : n.push(ft(i));
                      }
                      return n;
                    }
                    function le(t, e) {
                      const n = [];
                      for (const r in t) {
                        const i = t[r],
                          a = ce(i.materialKeys, e);
                        0 === a.length &&
                          ("lines" === r || "linestrips" === r
                            ? a.push(new Eh())
                            : a.push(new Nf()));
                        const o = void 0 !== i.data.attributes.skinIndex,
                          s = 1 === a.length ? a[0] : a;
                        let c;
                        switch (r) {
                          case "lines":
                            c = new Nh(i.data, s);
                            break;
                          case "linestrips":
                            c = new Ih(i.data, s);
                            break;
                          case "triangles":
                          case "polylist":
                            c = o ? new ph(i.data, s) : new Fi(i.data, s);
                            break;
                        }
                        n.push(c);
                      }
                      return n;
                    }
                    function ue(t) {
                      return void 0 !== Pe.nodes[t];
                    }
                    function he(t) {
                      return p(Pe.nodes[t], oe);
                    }
                    function de(t) {
                      const e = { name: t.getAttribute("name"), children: [] };
                      Qt(t);
                      const r = n(t, "node");
                      for (let n = 0; n < r.length; n++)
                        e.children.push(ne(r[n]));
                      Pe.visualScenes[t.getAttribute("id")] = e;
                    }
                    function fe(t) {
                      const e = new Lu();
                      e.name = t.name;
                      const n = t.children;
                      for (let r = 0; r < n.length; r++) {
                        const t = n[r];
                        e.add(he(t.id));
                      }
                      return e;
                    }
                    function pe(t) {
                      return void 0 !== Pe.visualScenes[t];
                    }
                    function me(t) {
                      return p(Pe.visualScenes[t], fe);
                    }
                    function ge(t) {
                      const e = n(t, "instance_visual_scene")[0];
                      return me(o(e.getAttribute("url")));
                    }
                    function ve() {
                      const t = Pe.clips;
                      if (!0 === c(t)) {
                        if (!1 === c(Pe.animations)) {
                          const t = [];
                          for (const e in Pe.animations) {
                            const n = _(e);
                            for (let e = 0, r = n.length; e < r; e++)
                              t.push(n[e]);
                          }
                          Ae.push(new tp("default", -1, t));
                        }
                      } else for (const e in t) Ae.push(N(e));
                    }
                    function ye(t) {
                      let e = "";
                      const n = [t];
                      while (n.length) {
                        const t = n.shift();
                        t.nodeType === Node.TEXT_NODE
                          ? (e += t.textContent)
                          : ((e += "\n"), n.push.apply(n, t.childNodes));
                      }
                      return e.trim();
                    }
                    if (0 === t.length) return { scene: new Bu() };
                    const be = new DOMParser().parseFromString(
                        t,
                        "application/xml"
                      ),
                      xe = n(be, "COLLADA")[0],
                      _e = be.getElementsByTagName("parsererror")[0];
                    if (void 0 !== _e) {
                      const t = n(_e, "div")[0];
                      let e;
                      return (
                        (e = t ? t.textContent : ye(_e)),
                        console.error(
                          "THREE.ColladaLoader: Failed to parse collada file.\n",
                          e
                        ),
                        null
                      );
                    }
                    const we = xe.getAttribute("version");
                    console.log("THREE.ColladaLoader: File version", we);
                    const Se = l(n(xe, "asset")[0]),
                      Me = new dp(this.manager);
                    let Te;
                    Me.setPath(this.resourcePath || e).setCrossOrigin(
                      this.crossOrigin
                    ),
                      Ay &&
                        ((Te = new Ay(this.manager)),
                        Te.setPath(this.resourcePath || e));
                    const Ee = new In(),
                      Ae = [];
                    let Ce = {},
                      Re = 0;
                    const Pe = {
                      animations: {},
                      clips: {},
                      controllers: {},
                      images: {},
                      effects: {},
                      materials: {},
                      cameras: {},
                      lights: {},
                      geometries: {},
                      nodes: {},
                      visualScenes: {},
                      kinematicsModels: {},
                      physicsModels: {},
                      kinematicsScenes: {},
                    };
                    d(xe, "library_animations", "animation", m),
                      d(xe, "library_animation_clips", "animation_clip", O),
                      d(xe, "library_controllers", "controller", D),
                      d(xe, "library_images", "image", V),
                      d(xe, "library_effects", "effect", q),
                      d(xe, "library_materials", "material", ct),
                      d(xe, "library_cameras", "camera", pt),
                      d(xe, "library_lights", "light", xt),
                      d(xe, "library_geometries", "geometry", Tt),
                      d(xe, "library_nodes", "node", ne),
                      d(xe, "library_visual_scenes", "visual_scene", de),
                      d(
                        xe,
                        "library_kinematics_models",
                        "kinematics_model",
                        Nt
                      ),
                      d(xe, "library_physics_models", "physics_model", Gt),
                      d(xe, "scene", "instance_kinematics_scene", Xt),
                      f(Pe.animations, x),
                      f(Pe.clips, k),
                      f(Pe.controllers, B),
                      f(Pe.images, G),
                      f(Pe.effects, ot),
                      f(Pe.materials, ut),
                      f(Pe.cameras, yt),
                      f(Pe.lights, St),
                      f(Pe.geometries, Pt),
                      f(Pe.visualScenes, fe),
                      ve(),
                      Kt();
                    const Ie = ge(n(xe, "scene")[0]);
                    return (
                      (Ie.animations = Ae),
                      "Z_UP" === Se.upAxis &&
                        Ie.quaternion.setFromEuler(new Pr(-Math.PI / 2, 0, 0)),
                      Ie.scale.multiplyScalar(Se.unit),
                      {
                        get animations() {
                          return (
                            console.warn(
                              "THREE.ColladaLoader: Please access animations over scene.animations now."
                            ),
                            Ae
                          );
                        },
                        kinematics: Ce,
                        library: Pe,
                        scene: Ie,
                      }
                    );
                  }
                }
                class Ly extends op {
                  constructor(t) {
                    super(t),
                      (this.dracoLoader = null),
                      (this.ktx2Loader = null),
                      (this.meshoptDecoder = null),
                      (this.pluginCallbacks = []),
                      this.register(function (t) {
                        return new Ny(t);
                      }),
                      this.register(function (t) {
                        return new Hy(t);
                      }),
                      this.register(function (t) {
                        return new Vy(t);
                      }),
                      this.register(function (t) {
                        return new zy(t);
                      }),
                      this.register(function (t) {
                        return new Fy(t);
                      }),
                      this.register(function (t) {
                        return new Uy(t);
                      }),
                      this.register(function (t) {
                        return new By(t);
                      }),
                      this.register(function (t) {
                        return new ky(t);
                      }),
                      this.register(function (t) {
                        return new jy(t);
                      }),
                      this.register(function (t) {
                        return new Dy(t);
                      }),
                      this.register(function (t) {
                        return new Iy(t);
                      }),
                      this.register(function (t) {
                        return new Gy(t);
                      });
                  }
                  load(t, e, n, r) {
                    const i = this;
                    let a;
                    (a =
                      "" !== this.resourcePath
                        ? this.resourcePath
                        : "" !== this.path
                        ? this.path
                        : Op.extractUrlBase(t)),
                      this.manager.itemStart(t);
                    const o = function (e) {
                        r ? r(e) : console.error(e),
                          i.manager.itemError(t),
                          i.manager.itemEnd(t);
                      },
                      s = new cp(this.manager);
                    s.setPath(this.path),
                      s.setResponseType("arraybuffer"),
                      s.setRequestHeader(this.requestHeader),
                      s.setWithCredentials(this.withCredentials),
                      s.load(
                        t,
                        function (n) {
                          try {
                            i.parse(
                              n,
                              a,
                              function (n) {
                                e(n), i.manager.itemEnd(t);
                              },
                              o
                            );
                          } catch (dx) {
                            o(dx);
                          }
                        },
                        n,
                        o
                      );
                  }
                  setDRACOLoader(t) {
                    return (this.dracoLoader = t), this;
                  }
                  setDDSLoader() {
                    throw new Error(
                      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
                    );
                  }
                  setKTX2Loader(t) {
                    return (this.ktx2Loader = t), this;
                  }
                  setMeshoptDecoder(t) {
                    return (this.meshoptDecoder = t), this;
                  }
                  register(t) {
                    return (
                      -1 === this.pluginCallbacks.indexOf(t) &&
                        this.pluginCallbacks.push(t),
                      this
                    );
                  }
                  unregister(t) {
                    return (
                      -1 !== this.pluginCallbacks.indexOf(t) &&
                        this.pluginCallbacks.splice(
                          this.pluginCallbacks.indexOf(t),
                          1
                        ),
                      this
                    );
                  }
                  parse(t, e, n, r) {
                    let i;
                    const a = {},
                      o = {};
                    if ("string" === typeof t) i = t;
                    else {
                      const e = Op.decodeText(new Uint8Array(t, 0, 4));
                      if (e === Wy) {
                        try {
                          a[Py.KHR_BINARY_GLTF] = new $y(t);
                        } catch (l) {
                          return void (r && r(l));
                        }
                        i = a[Py.KHR_BINARY_GLTF].content;
                      } else i = Op.decodeText(new Uint8Array(t));
                    }
                    const s = JSON.parse(i);
                    if (void 0 === s.asset || s.asset.version[0] < 2)
                      return void (
                        r &&
                        r(
                          new Error(
                            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                          )
                        )
                      );
                    const c = new _b(s, {
                      path: e || this.resourcePath || "",
                      crossOrigin: this.crossOrigin,
                      requestHeader: this.requestHeader,
                      manager: this.manager,
                      ktx2Loader: this.ktx2Loader,
                      meshoptDecoder: this.meshoptDecoder,
                    });
                    c.fileLoader.setRequestHeader(this.requestHeader);
                    for (let l = 0; l < this.pluginCallbacks.length; l++) {
                      const t = this.pluginCallbacks[l](c);
                      (o[t.name] = t), (a[t.name] = !0);
                    }
                    if (s.extensionsUsed)
                      for (let l = 0; l < s.extensionsUsed.length; ++l) {
                        const t = s.extensionsUsed[l],
                          e = s.extensionsRequired || [];
                        switch (t) {
                          case Py.KHR_MATERIALS_UNLIT:
                            a[t] = new Oy();
                            break;
                          case Py.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            a[t] = new Zy();
                            break;
                          case Py.KHR_DRACO_MESH_COMPRESSION:
                            a[t] = new Yy(s, this.dracoLoader);
                            break;
                          case Py.KHR_TEXTURE_TRANSFORM:
                            a[t] = new Jy();
                            break;
                          case Py.KHR_MESH_QUANTIZATION:
                            a[t] = new Qy();
                            break;
                          default:
                            e.indexOf(t) >= 0 &&
                              void 0 === o[t] &&
                              console.warn(
                                'THREE.GLTFLoader: Unknown extension "' +
                                  t +
                                  '".'
                              );
                        }
                      }
                    c.setExtensions(a), c.setPlugins(o), c.parse(n, r);
                  }
                  parseAsync(t, e) {
                    const n = this;
                    return new Promise(function (r, i) {
                      n.parse(t, e, r, i);
                    });
                  }
                }
                function Ry() {
                  let t = {};
                  return {
                    get: function (e) {
                      return t[e];
                    },
                    add: function (e, n) {
                      t[e] = n;
                    },
                    remove: function (e) {
                      delete t[e];
                    },
                    removeAll: function () {
                      t = {};
                    },
                  };
                }
                const Py = {
                  KHR_BINARY_GLTF: "KHR_binary_glTF",
                  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                  KHR_MATERIALS_IOR: "KHR_materials_ior",
                  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    "KHR_materials_pbrSpecularGlossiness",
                  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                  KHR_MATERIALS_EMISSIVE_STRENGTH:
                    "KHR_materials_emissive_strength",
                  EXT_TEXTURE_WEBP: "EXT_texture_webp",
                  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                };
                class Iy {
                  constructor(t) {
                    (this.parser = t),
                      (this.name = Py.KHR_LIGHTS_PUNCTUAL),
                      (this.cache = { refs: {}, uses: {} });
                  }
                  _markDefs() {
                    const t = this.parser,
                      e = this.parser.json.nodes || [];
                    for (let n = 0, r = e.length; n < r; n++) {
                      const r = e[n];
                      r.extensions &&
                        r.extensions[this.name] &&
                        void 0 !== r.extensions[this.name].light &&
                        t._addNodeRef(
                          this.cache,
                          r.extensions[this.name].light
                        );
                    }
                  }
                  _loadLight(t) {
                    const e = this.parser,
                      n = "light:" + t;
                    let r = e.cache.get(n);
                    if (r) return r;
                    const i = e.json,
                      a = (i.extensions && i.extensions[this.name]) || {},
                      o = a.lights || [],
                      s = o[t];
                    let c;
                    const l = new In(16777215);
                    void 0 !== s.color && l.fromArray(s.color);
                    const u = void 0 !== s.range ? s.range : 0;
                    switch (s.type) {
                      case "directional":
                        (c = new Ap(l)),
                          c.target.position.set(0, 0, -1),
                          c.add(c.target);
                        break;
                      case "point":
                        (c = new Tp(l)), (c.distance = u);
                        break;
                      case "spot":
                        (c = new xp(l)),
                          (c.distance = u),
                          (s.spot = s.spot || {}),
                          (s.spot.innerConeAngle =
                            void 0 !== s.spot.innerConeAngle
                              ? s.spot.innerConeAngle
                              : 0),
                          (s.spot.outerConeAngle =
                            void 0 !== s.spot.outerConeAngle
                              ? s.spot.outerConeAngle
                              : Math.PI / 4),
                          (c.angle = s.spot.outerConeAngle),
                          (c.penumbra =
                            1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                          c.target.position.set(0, 0, -1),
                          c.add(c.target);
                        break;
                      default:
                        throw new Error(
                          "THREE.GLTFLoader: Unexpected light type: " + s.type
                        );
                    }
                    return (
                      c.position.set(0, 0, 0),
                      (c.decay = 2),
                      void 0 !== s.intensity && (c.intensity = s.intensity),
                      (c.name = e.createUniqueName(s.name || "light_" + t)),
                      (r = Promise.resolve(c)),
                      e.cache.add(n, r),
                      r
                    );
                  }
                  createNodeAttachment(t) {
                    const e = this,
                      n = this.parser,
                      r = n.json,
                      i = r.nodes[t],
                      a = (i.extensions && i.extensions[this.name]) || {},
                      o = a.light;
                    return void 0 === o
                      ? null
                      : this._loadLight(o).then(function (t) {
                          return n._getNodeRef(e.cache, o, t);
                        });
                  }
                }
                class Oy {
                  constructor() {
                    this.name = Py.KHR_MATERIALS_UNLIT;
                  }
                  getMaterialType() {
                    return oi;
                  }
                  extendParams(t, e, n) {
                    const r = [];
                    (t.color = new In(1, 1, 1)), (t.opacity = 1);
                    const i = e.pbrMetallicRoughness;
                    if (i) {
                      if (Array.isArray(i.baseColorFactor)) {
                        const e = i.baseColorFactor;
                        t.color.fromArray(e), (t.opacity = e[3]);
                      }
                      void 0 !== i.baseColorTexture &&
                        r.push(
                          n.assignTexture(t, "map", i.baseColorTexture, Le)
                        );
                    }
                    return Promise.all(r);
                  }
                }
                class ky {
                  constructor(t) {
                    (this.parser = t),
                      (this.name = Py.KHR_MATERIALS_EMISSIVE_STRENGTH);
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = r.extensions[this.name].emissiveStrength;
                    return (
                      void 0 !== i && (e.emissiveIntensity = i),
                      Promise.resolve()
                    );
                  }
                }
                class Ny {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_MATERIALS_CLEARCOAT);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [],
                      a = r.extensions[this.name];
                    if (
                      (void 0 !== a.clearcoatFactor &&
                        (e.clearcoat = a.clearcoatFactor),
                      void 0 !== a.clearcoatTexture &&
                        i.push(
                          n.assignTexture(e, "clearcoatMap", a.clearcoatTexture)
                        ),
                      void 0 !== a.clearcoatRoughnessFactor &&
                        (e.clearcoatRoughness = a.clearcoatRoughnessFactor),
                      void 0 !== a.clearcoatRoughnessTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "clearcoatRoughnessMap",
                            a.clearcoatRoughnessTexture
                          )
                        ),
                      void 0 !== a.clearcoatNormalTexture &&
                        (i.push(
                          n.assignTexture(
                            e,
                            "clearcoatNormalMap",
                            a.clearcoatNormalTexture
                          )
                        ),
                        void 0 !== a.clearcoatNormalTexture.scale))
                    ) {
                      const t = a.clearcoatNormalTexture.scale;
                      e.clearcoatNormalScale = new gn(t, t);
                    }
                    return Promise.all(i);
                  }
                }
                class Dy {
                  constructor(t) {
                    (this.parser = t),
                      (this.name = Py.KHR_MATERIALS_IRIDESCENCE);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [],
                      a = r.extensions[this.name];
                    return (
                      void 0 !== a.iridescenceFactor &&
                        (e.iridescence = a.iridescenceFactor),
                      void 0 !== a.iridescenceTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "iridescenceMap",
                            a.iridescenceTexture
                          )
                        ),
                      void 0 !== a.iridescenceIor &&
                        (e.iridescenceIOR = a.iridescenceIor),
                      void 0 === e.iridescenceThicknessRange &&
                        (e.iridescenceThicknessRange = [100, 400]),
                      void 0 !== a.iridescenceThicknessMinimum &&
                        (e.iridescenceThicknessRange[0] =
                          a.iridescenceThicknessMinimum),
                      void 0 !== a.iridescenceThicknessMaximum &&
                        (e.iridescenceThicknessRange[1] =
                          a.iridescenceThicknessMaximum),
                      void 0 !== a.iridescenceThicknessTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "iridescenceThicknessMap",
                            a.iridescenceThicknessTexture
                          )
                        ),
                      Promise.all(i)
                    );
                  }
                }
                class zy {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_MATERIALS_SHEEN);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [];
                    (e.sheenColor = new In(0, 0, 0)),
                      (e.sheenRoughness = 0),
                      (e.sheen = 1);
                    const a = r.extensions[this.name];
                    return (
                      void 0 !== a.sheenColorFactor &&
                        e.sheenColor.fromArray(a.sheenColorFactor),
                      void 0 !== a.sheenRoughnessFactor &&
                        (e.sheenRoughness = a.sheenRoughnessFactor),
                      void 0 !== a.sheenColorTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "sheenColorMap",
                            a.sheenColorTexture,
                            Le
                          )
                        ),
                      void 0 !== a.sheenRoughnessTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "sheenRoughnessMap",
                            a.sheenRoughnessTexture
                          )
                        ),
                      Promise.all(i)
                    );
                  }
                }
                class Fy {
                  constructor(t) {
                    (this.parser = t),
                      (this.name = Py.KHR_MATERIALS_TRANSMISSION);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [],
                      a = r.extensions[this.name];
                    return (
                      void 0 !== a.transmissionFactor &&
                        (e.transmission = a.transmissionFactor),
                      void 0 !== a.transmissionTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "transmissionMap",
                            a.transmissionTexture
                          )
                        ),
                      Promise.all(i)
                    );
                  }
                }
                class Uy {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_MATERIALS_VOLUME);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [],
                      a = r.extensions[this.name];
                    (e.thickness =
                      void 0 !== a.thicknessFactor ? a.thicknessFactor : 0),
                      void 0 !== a.thicknessTexture &&
                        i.push(
                          n.assignTexture(e, "thicknessMap", a.thicknessTexture)
                        ),
                      (e.attenuationDistance = a.attenuationDistance || 0);
                    const o = a.attenuationColor || [1, 1, 1];
                    return (
                      (e.attenuationColor = new In(o[0], o[1], o[2])),
                      Promise.all(i)
                    );
                  }
                }
                class By {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_MATERIALS_IOR);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = r.extensions[this.name];
                    return (
                      (e.ior = void 0 !== i.ior ? i.ior : 1.5),
                      Promise.resolve()
                    );
                  }
                }
                class jy {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_MATERIALS_SPECULAR);
                  }
                  getMaterialType(t) {
                    const e = this.parser,
                      n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? kf : null;
                  }
                  extendMaterialParams(t, e) {
                    const n = this.parser,
                      r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                      return Promise.resolve();
                    const i = [],
                      a = r.extensions[this.name];
                    (e.specularIntensity =
                      void 0 !== a.specularFactor ? a.specularFactor : 1),
                      void 0 !== a.specularTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "specularIntensityMap",
                            a.specularTexture
                          )
                        );
                    const o = a.specularColorFactor || [1, 1, 1];
                    return (
                      (e.specularColor = new In(o[0], o[1], o[2])),
                      void 0 !== a.specularColorTexture &&
                        i.push(
                          n.assignTexture(
                            e,
                            "specularColorMap",
                            a.specularColorTexture,
                            Le
                          )
                        ),
                      Promise.all(i)
                    );
                  }
                }
                class Hy {
                  constructor(t) {
                    (this.parser = t), (this.name = Py.KHR_TEXTURE_BASISU);
                  }
                  loadTexture(t) {
                    const e = this.parser,
                      n = e.json,
                      r = n.textures[t];
                    if (!r.extensions || !r.extensions[this.name]) return null;
                    const i = r.extensions[this.name],
                      a = e.options.ktx2Loader;
                    if (!a) {
                      if (
                        n.extensionsRequired &&
                        n.extensionsRequired.indexOf(this.name) >= 0
                      )
                        throw new Error(
                          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                        );
                      return null;
                    }
                    return e.loadTextureImage(t, i.source, a);
                  }
                }
                class Vy {
                  constructor(t) {
                    (this.parser = t),
                      (this.name = Py.EXT_TEXTURE_WEBP),
                      (this.isSupported = null);
                  }
                  loadTexture(t) {
                    const e = this.name,
                      n = this.parser,
                      r = n.json,
                      i = r.textures[t];
                    if (!i.extensions || !i.extensions[e]) return null;
                    const a = i.extensions[e],
                      o = r.images[a.source];
                    let s = n.textureLoader;
                    if (o.uri) {
                      const t = n.options.manager.getHandler(o.uri);
                      null !== t && (s = t);
                    }
                    return this.detectSupport().then(function (i) {
                      if (i) return n.loadTextureImage(t, a.source, s);
                      if (
                        r.extensionsRequired &&
                        r.extensionsRequired.indexOf(e) >= 0
                      )
                        throw new Error(
                          "THREE.GLTFLoader: WebP required by asset but unsupported."
                        );
                      return n.loadTexture(t);
                    });
                  }
                  detectSupport() {
                    return (
                      this.isSupported ||
                        (this.isSupported = new Promise(function (t) {
                          const e = new Image();
                          (e.src =
                            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                            (e.onload = e.onerror =
                              function () {
                                t(1 === e.height);
                              });
                        })),
                      this.isSupported
                    );
                  }
                }
                class Gy {
                  constructor(t) {
                    (this.name = Py.EXT_MESHOPT_COMPRESSION), (this.parser = t);
                  }
                  loadBufferView(t) {
                    const e = this.parser.json,
                      n = e.bufferViews[t];
                    if (n.extensions && n.extensions[this.name]) {
                      const t = n.extensions[this.name],
                        r = this.parser.getDependency("buffer", t.buffer),
                        i = this.parser.options.meshoptDecoder;
                      if (!i || !i.supported) {
                        if (
                          e.extensionsRequired &&
                          e.extensionsRequired.indexOf(this.name) >= 0
                        )
                          throw new Error(
                            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                          );
                        return null;
                      }
                      return Promise.all([r, i.ready]).then(function (e) {
                        const n = t.byteOffset || 0,
                          r = t.byteLength || 0,
                          a = t.count,
                          o = t.byteStride,
                          s = new ArrayBuffer(a * o),
                          c = new Uint8Array(e[0], n, r);
                        return (
                          i.decodeGltfBuffer(
                            new Uint8Array(s),
                            a,
                            o,
                            c,
                            t.mode,
                            t.filter
                          ),
                          s
                        );
                      });
                    }
                    return null;
                  }
                }
                const Wy = "glTF",
                  qy = 12,
                  Xy = { JSON: 1313821514, BIN: 5130562 };
                class $y {
                  constructor(t) {
                    (this.name = Py.KHR_BINARY_GLTF),
                      (this.content = null),
                      (this.body = null);
                    const e = new DataView(t, 0, qy);
                    if (
                      ((this.header = {
                        magic: Op.decodeText(new Uint8Array(t.slice(0, 4))),
                        version: e.getUint32(4, !0),
                        length: e.getUint32(8, !0),
                      }),
                      this.header.magic !== Wy)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported glTF-Binary header."
                      );
                    if (this.header.version < 2)
                      throw new Error(
                        "THREE.GLTFLoader: Legacy binary file detected."
                      );
                    const n = this.header.length - qy,
                      r = new DataView(t, qy);
                    let i = 0;
                    while (i < n) {
                      const e = r.getUint32(i, !0);
                      i += 4;
                      const n = r.getUint32(i, !0);
                      if (((i += 4), n === Xy.JSON)) {
                        const n = new Uint8Array(t, qy + i, e);
                        this.content = Op.decodeText(n);
                      } else if (n === Xy.BIN) {
                        const n = qy + i;
                        this.body = t.slice(n, n + e);
                      }
                      i += e;
                    }
                    if (null === this.content)
                      throw new Error(
                        "THREE.GLTFLoader: JSON content not found."
                      );
                  }
                }
                class Yy {
                  constructor(t, e) {
                    if (!e)
                      throw new Error(
                        "THREE.GLTFLoader: No DRACOLoader instance provided."
                      );
                    (this.name = Py.KHR_DRACO_MESH_COMPRESSION),
                      (this.json = t),
                      (this.dracoLoader = e),
                      this.dracoLoader.preload();
                  }
                  decodePrimitive(t, e) {
                    const n = this.json,
                      r = this.dracoLoader,
                      i = t.extensions[this.name].bufferView,
                      a = t.extensions[this.name].attributes,
                      o = {},
                      s = {},
                      c = {};
                    for (const l in a) {
                      const t = cb[l] || l.toLowerCase();
                      o[t] = a[l];
                    }
                    for (const l in t.attributes) {
                      const e = cb[l] || l.toLowerCase();
                      if (void 0 !== a[l]) {
                        const r = n.accessors[t.attributes[l]],
                          i = ib[r.componentType];
                        (c[e] = i), (s[e] = !0 === r.normalized);
                      }
                    }
                    return e.getDependency("bufferView", i).then(function (t) {
                      return new Promise(function (e) {
                        r.decodeDracoFile(
                          t,
                          function (t) {
                            for (const e in t.attributes) {
                              const n = t.attributes[e],
                                r = s[e];
                              void 0 !== r && (n.normalized = r);
                            }
                            e(t);
                          },
                          o,
                          c
                        );
                      });
                    });
                  }
                }
                class Jy {
                  constructor() {
                    this.name = Py.KHR_TEXTURE_TRANSFORM;
                  }
                  extendTexture(t, e) {
                    return (
                      void 0 !== e.texCoord &&
                        console.warn(
                          'THREE.GLTFLoader: Custom UV sets in "' +
                            this.name +
                            '" extension not yet supported.'
                        ),
                      (void 0 === e.offset &&
                        void 0 === e.rotation &&
                        void 0 === e.scale) ||
                        ((t = t.clone()),
                        void 0 !== e.offset && t.offset.fromArray(e.offset),
                        void 0 !== e.rotation && (t.rotation = e.rotation),
                        void 0 !== e.scale && t.repeat.fromArray(e.scale),
                        (t.needsUpdate = !0)),
                      t
                    );
                  }
                }
                class Ky extends Of {
                  constructor(t) {
                    super(), (this.isGLTFSpecularGlossinessMaterial = !0);
                    const e = [
                        "#ifdef USE_SPECULARMAP",
                        "\tuniform sampler2D specularMap;",
                        "#endif",
                      ].join("\n"),
                      n = [
                        "#ifdef USE_GLOSSINESSMAP",
                        "\tuniform sampler2D glossinessMap;",
                        "#endif",
                      ].join("\n"),
                      r = [
                        "vec3 specularFactor = specular;",
                        "#ifdef USE_SPECULARMAP",
                        "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
                        "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
                        "\tspecularFactor *= texelSpecular.rgb;",
                        "#endif",
                      ].join("\n"),
                      i = [
                        "float glossinessFactor = glossiness;",
                        "#ifdef USE_GLOSSINESSMAP",
                        "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
                        "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
                        "\tglossinessFactor *= texelGlossiness.a;",
                        "#endif",
                      ].join("\n"),
                      a = [
                        "PhysicalMaterial material;",
                        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
                        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
                        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
                        "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
                        "material.roughness += geometryRoughness;",
                        "material.roughness = min( material.roughness, 1.0 );",
                        "material.specularColor = specularFactor;",
                      ].join("\n"),
                      o = {
                        specular: { value: new In().setHex(16777215) },
                        glossiness: { value: 1 },
                        specularMap: { value: null },
                        glossinessMap: { value: null },
                      };
                    (this._extraUniforms = o),
                      (this.onBeforeCompile = function (t) {
                        for (const e in o) t.uniforms[e] = o[e];
                        t.fragmentShader = t.fragmentShader
                          .replace(
                            "uniform float roughness;",
                            "uniform vec3 specular;"
                          )
                          .replace(
                            "uniform float metalness;",
                            "uniform float glossiness;"
                          )
                          .replace("#include <roughnessmap_pars_fragment>", e)
                          .replace("#include <metalnessmap_pars_fragment>", n)
                          .replace("#include <roughnessmap_fragment>", r)
                          .replace("#include <metalnessmap_fragment>", i)
                          .replace("#include <lights_physical_fragment>", a);
                      }),
                      Object.defineProperties(this, {
                        specular: {
                          get: function () {
                            return o.specular.value;
                          },
                          set: function (t) {
                            o.specular.value = t;
                          },
                        },
                        specularMap: {
                          get: function () {
                            return o.specularMap.value;
                          },
                          set: function (t) {
                            (o.specularMap.value = t),
                              t
                                ? (this.defines.USE_SPECULARMAP = "")
                                : delete this.defines.USE_SPECULARMAP;
                          },
                        },
                        glossiness: {
                          get: function () {
                            return o.glossiness.value;
                          },
                          set: function (t) {
                            o.glossiness.value = t;
                          },
                        },
                        glossinessMap: {
                          get: function () {
                            return o.glossinessMap.value;
                          },
                          set: function (t) {
                            (o.glossinessMap.value = t),
                              t
                                ? ((this.defines.USE_GLOSSINESSMAP = ""),
                                  (this.defines.USE_UV = ""))
                                : (delete this.defines.USE_GLOSSINESSMAP,
                                  delete this.defines.USE_UV);
                          },
                        },
                      }),
                      delete this.metalness,
                      delete this.roughness,
                      delete this.metalnessMap,
                      delete this.roughnessMap,
                      this.setValues(t);
                  }
                  copy(t) {
                    return (
                      super.copy(t),
                      (this.specularMap = t.specularMap),
                      this.specular.copy(t.specular),
                      (this.glossinessMap = t.glossinessMap),
                      (this.glossiness = t.glossiness),
                      delete this.metalness,
                      delete this.roughness,
                      delete this.metalnessMap,
                      delete this.roughnessMap,
                      this
                    );
                  }
                }
                class Zy {
                  constructor() {
                    (this.name = Py.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
                      (this.specularGlossinessParams = [
                        "color",
                        "map",
                        "lightMap",
                        "lightMapIntensity",
                        "aoMap",
                        "aoMapIntensity",
                        "emissive",
                        "emissiveIntensity",
                        "emissiveMap",
                        "bumpMap",
                        "bumpScale",
                        "normalMap",
                        "normalMapType",
                        "displacementMap",
                        "displacementScale",
                        "displacementBias",
                        "specularMap",
                        "specular",
                        "glossinessMap",
                        "glossiness",
                        "alphaMap",
                        "envMap",
                        "envMapIntensity",
                      ]);
                  }
                  getMaterialType() {
                    return Ky;
                  }
                  extendParams(t, e, n) {
                    const r = e.extensions[this.name];
                    (t.color = new In(1, 1, 1)), (t.opacity = 1);
                    const i = [];
                    if (Array.isArray(r.diffuseFactor)) {
                      const e = r.diffuseFactor;
                      t.color.fromArray(e), (t.opacity = e[3]);
                    }
                    if (
                      (void 0 !== r.diffuseTexture &&
                        i.push(n.assignTexture(t, "map", r.diffuseTexture, Le)),
                      (t.emissive = new In(0, 0, 0)),
                      (t.glossiness =
                        void 0 !== r.glossinessFactor ? r.glossinessFactor : 1),
                      (t.specular = new In(1, 1, 1)),
                      Array.isArray(r.specularFactor) &&
                        t.specular.fromArray(r.specularFactor),
                      void 0 !== r.specularGlossinessTexture)
                    ) {
                      const e = r.specularGlossinessTexture;
                      i.push(n.assignTexture(t, "glossinessMap", e)),
                        i.push(n.assignTexture(t, "specularMap", e, Le));
                    }
                    return Promise.all(i);
                  }
                  createMaterial(t) {
                    const e = new Ky(t);
                    return (
                      (e.fog = !0),
                      (e.color = t.color),
                      (e.map = void 0 === t.map ? null : t.map),
                      (e.lightMap = null),
                      (e.lightMapIntensity = 1),
                      (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
                      (e.aoMapIntensity = 1),
                      (e.emissive = t.emissive),
                      (e.emissiveIntensity =
                        void 0 === t.emissiveIntensity
                          ? 1
                          : t.emissiveIntensity),
                      (e.emissiveMap =
                        void 0 === t.emissiveMap ? null : t.emissiveMap),
                      (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
                      (e.bumpScale = 1),
                      (e.normalMap =
                        void 0 === t.normalMap ? null : t.normalMap),
                      (e.normalMapType = Ie),
                      t.normalScale && (e.normalScale = t.normalScale),
                      (e.displacementMap = null),
                      (e.displacementScale = 1),
                      (e.displacementBias = 0),
                      (e.specularMap =
                        void 0 === t.specularMap ? null : t.specularMap),
                      (e.specular = t.specular),
                      (e.glossinessMap =
                        void 0 === t.glossinessMap ? null : t.glossinessMap),
                      (e.glossiness = t.glossiness),
                      (e.alphaMap = null),
                      (e.envMap = void 0 === t.envMap ? null : t.envMap),
                      (e.envMapIntensity = 1),
                      e
                    );
                  }
                }
                class Qy {
                  constructor() {
                    this.name = Py.KHR_MESH_QUANTIZATION;
                  }
                }
                class tb extends Hf {
                  constructor(t, e, n, r) {
                    super(t, e, n, r);
                  }
                  copySampleValue_(t) {
                    const e = this.resultBuffer,
                      n = this.sampleValues,
                      r = this.valueSize,
                      i = t * r * 3 + r;
                    for (let a = 0; a !== r; a++) e[a] = n[i + a];
                    return e;
                  }
                  interpolate_(t, e, n, r) {
                    const i = this.resultBuffer,
                      a = this.sampleValues,
                      o = this.valueSize,
                      s = 2 * o,
                      c = 3 * o,
                      l = r - e,
                      u = (n - e) / l,
                      h = u * u,
                      d = h * u,
                      f = t * c,
                      p = f - c,
                      m = -2 * d + 3 * h,
                      g = d - h,
                      v = 1 - m,
                      y = g - h + u;
                    for (let b = 0; b !== o; b++) {
                      const t = a[p + b + o],
                        e = a[p + b + s] * l,
                        n = a[f + b + o],
                        r = a[f + b] * l;
                      i[b] = v * t + y * e + m * n + g * r;
                    }
                    return i;
                  }
                }
                const eb = new Vn();
                class nb extends tb {
                  interpolate_(t, e, n, r) {
                    const i = super.interpolate_(t, e, n, r);
                    return eb.fromArray(i).normalize().toArray(i), i;
                  }
                }
                const rb = {
                    FLOAT: 5126,
                    FLOAT_MAT3: 35675,
                    FLOAT_MAT4: 35676,
                    FLOAT_VEC2: 35664,
                    FLOAT_VEC3: 35665,
                    FLOAT_VEC4: 35666,
                    LINEAR: 9729,
                    REPEAT: 10497,
                    SAMPLER_2D: 35678,
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6,
                    UNSIGNED_BYTE: 5121,
                    UNSIGNED_SHORT: 5123,
                  },
                  ib = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array,
                  },
                  ab = {
                    9728: pt,
                    9729: vt,
                    9984: mt,
                    9985: yt,
                    9986: gt,
                    9987: bt,
                  },
                  ob = { 33071: dt, 33648: ft, 10497: ht },
                  sb = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16,
                  },
                  cb = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex",
                  },
                  lb = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences",
                  },
                  ub = { CUBICSPLINE: void 0, LINEAR: be, STEP: ye },
                  hb = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
                function db(t) {
                  return (
                    void 0 === t["DefaultMaterial"] &&
                      (t["DefaultMaterial"] = new Of({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: g,
                      })),
                    t["DefaultMaterial"]
                  );
                }
                function fb(t, e, n) {
                  for (const r in n.extensions)
                    void 0 === t[r] &&
                      ((e.userData.gltfExtensions =
                        e.userData.gltfExtensions || {}),
                      (e.userData.gltfExtensions[r] = n.extensions[r]));
                }
                function pb(t, e) {
                  void 0 !== e.extras &&
                    ("object" === typeof e.extras
                      ? Object.assign(t.userData, e.extras)
                      : console.warn(
                          "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                            e.extras
                        ));
                }
                function mb(t, e, n) {
                  let r = !1,
                    i = !1,
                    a = !1;
                  for (let l = 0, u = e.length; l < u; l++) {
                    const t = e[l];
                    if (
                      (void 0 !== t.POSITION && (r = !0),
                      void 0 !== t.NORMAL && (i = !0),
                      void 0 !== t.COLOR_0 && (a = !0),
                      r && i && a)
                    )
                      break;
                  }
                  if (!r && !i && !a) return Promise.resolve(t);
                  const o = [],
                    s = [],
                    c = [];
                  for (let l = 0, u = e.length; l < u; l++) {
                    const u = e[l];
                    if (r) {
                      const e =
                        void 0 !== u.POSITION
                          ? n.getDependency("accessor", u.POSITION)
                          : t.attributes.position;
                      o.push(e);
                    }
                    if (i) {
                      const e =
                        void 0 !== u.NORMAL
                          ? n.getDependency("accessor", u.NORMAL)
                          : t.attributes.normal;
                      s.push(e);
                    }
                    if (a) {
                      const e =
                        void 0 !== u.COLOR_0
                          ? n.getDependency("accessor", u.COLOR_0)
                          : t.attributes.color;
                      c.push(e);
                    }
                  }
                  return Promise.all([
                    Promise.all(o),
                    Promise.all(s),
                    Promise.all(c),
                  ]).then(function (e) {
                    const n = e[0],
                      o = e[1],
                      s = e[2];
                    return (
                      r && (t.morphAttributes.position = n),
                      i && (t.morphAttributes.normal = o),
                      a && (t.morphAttributes.color = s),
                      (t.morphTargetsRelative = !0),
                      t
                    );
                  });
                }
                function gb(t, e) {
                  if ((t.updateMorphTargets(), void 0 !== e.weights))
                    for (let n = 0, r = e.weights.length; n < r; n++)
                      t.morphTargetInfluences[n] = e.weights[n];
                  if (e.extras && Array.isArray(e.extras.targetNames)) {
                    const n = e.extras.targetNames;
                    if (t.morphTargetInfluences.length === n.length) {
                      t.morphTargetDictionary = {};
                      for (let e = 0, r = n.length; e < r; e++)
                        t.morphTargetDictionary[n[e]] = e;
                    } else
                      console.warn(
                        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
                      );
                  }
                }
                function vb(t) {
                  const e =
                    t.extensions && t.extensions[Py.KHR_DRACO_MESH_COMPRESSION];
                  let n;
                  return (
                    (n = e
                      ? "draco:" +
                        e.bufferView +
                        ":" +
                        e.indices +
                        ":" +
                        yb(e.attributes)
                      : t.indices + ":" + yb(t.attributes) + ":" + t.mode),
                    n
                  );
                }
                function yb(t) {
                  let e = "";
                  const n = Object.keys(t).sort();
                  for (let r = 0, i = n.length; r < i; r++)
                    e += n[r] + ":" + t[n[r]] + ";";
                  return e;
                }
                function bb(t) {
                  switch (t) {
                    case Int8Array:
                      return 1 / 127;
                    case Uint8Array:
                      return 1 / 255;
                    case Int16Array:
                      return 1 / 32767;
                    case Uint16Array:
                      return 1 / 65535;
                    default:
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported normalized accessor component type."
                      );
                  }
                }
                function xb(t) {
                  return t.search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === t.search(/^data\:image\/jpeg/)
                    ? "image/jpeg"
                    : t.search(/\.webp($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/webp/)
                    ? "image/webp"
                    : "image/png";
                }
                class _b {
                  constructor(t = {}, e = {}) {
                    (this.json = t),
                      (this.extensions = {}),
                      (this.plugins = {}),
                      (this.options = e),
                      (this.cache = new Ry()),
                      (this.associations = new Map()),
                      (this.primitiveCache = {}),
                      (this.meshCache = { refs: {}, uses: {} }),
                      (this.cameraCache = { refs: {}, uses: {} }),
                      (this.lightCache = { refs: {}, uses: {} }),
                      (this.sourceCache = {}),
                      (this.textureCache = {}),
                      (this.nodeNamesUsed = {});
                    const n =
                        !0 ===
                        /^((?!chrome|android).)*safari/i.test(
                          navigator.userAgent
                        ),
                      r = navigator.userAgent.indexOf("Firefox") > -1,
                      i = r
                        ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]
                        : -1;
                    "undefined" === typeof createImageBitmap ||
                    n ||
                    (r && i < 98)
                      ? (this.textureLoader = new dp(this.options.manager))
                      : (this.textureLoader = new Bp(this.options.manager)),
                      this.textureLoader.setCrossOrigin(
                        this.options.crossOrigin
                      ),
                      this.textureLoader.setRequestHeader(
                        this.options.requestHeader
                      ),
                      (this.fileLoader = new cp(this.options.manager)),
                      this.fileLoader.setResponseType("arraybuffer"),
                      "use-credentials" === this.options.crossOrigin &&
                        this.fileLoader.setWithCredentials(!0);
                  }
                  setExtensions(t) {
                    this.extensions = t;
                  }
                  setPlugins(t) {
                    this.plugins = t;
                  }
                  parse(t, e) {
                    const n = this,
                      r = this.json,
                      i = this.extensions;
                    this.cache.removeAll(),
                      this._invokeAll(function (t) {
                        return t._markDefs && t._markDefs();
                      }),
                      Promise.all(
                        this._invokeAll(function (t) {
                          return t.beforeRoot && t.beforeRoot();
                        })
                      )
                        .then(function () {
                          return Promise.all([
                            n.getDependencies("scene"),
                            n.getDependencies("animation"),
                            n.getDependencies("camera"),
                          ]);
                        })
                        .then(function (e) {
                          const a = {
                            scene: e[0][r.scene || 0],
                            scenes: e[0],
                            animations: e[1],
                            cameras: e[2],
                            asset: r.asset,
                            parser: n,
                            userData: {},
                          };
                          fb(i, a, r),
                            pb(a, r),
                            Promise.all(
                              n._invokeAll(function (t) {
                                return t.afterRoot && t.afterRoot(a);
                              })
                            ).then(function () {
                              t(a);
                            });
                        })
                        .catch(e);
                  }
                  _markDefs() {
                    const t = this.json.nodes || [],
                      e = this.json.skins || [],
                      n = this.json.meshes || [];
                    for (let r = 0, i = e.length; r < i; r++) {
                      const n = e[r].joints;
                      for (let e = 0, r = n.length; e < r; e++)
                        t[n[e]].isBone = !0;
                    }
                    for (let r = 0, i = t.length; r < i; r++) {
                      const e = t[r];
                      void 0 !== e.mesh &&
                        (this._addNodeRef(this.meshCache, e.mesh),
                        void 0 !== e.skin && (n[e.mesh].isSkinnedMesh = !0)),
                        void 0 !== e.camera &&
                          this._addNodeRef(this.cameraCache, e.camera);
                    }
                  }
                  _addNodeRef(t, e) {
                    void 0 !== e &&
                      (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                      t.refs[e]++);
                  }
                  _getNodeRef(t, e, n) {
                    if (t.refs[e] <= 1) return n;
                    const r = n.clone(),
                      i = (t, e) => {
                        const n = this.associations.get(t);
                        null != n && this.associations.set(e, n);
                        for (const [r, a] of t.children.entries())
                          i(a, e.children[r]);
                      };
                    return i(n, r), (r.name += "_instance_" + t.uses[e]++), r;
                  }
                  _invokeOne(t) {
                    const e = Object.values(this.plugins);
                    e.push(this);
                    for (let n = 0; n < e.length; n++) {
                      const r = t(e[n]);
                      if (r) return r;
                    }
                    return null;
                  }
                  _invokeAll(t) {
                    const e = Object.values(this.plugins);
                    e.unshift(this);
                    const n = [];
                    for (let r = 0; r < e.length; r++) {
                      const i = t(e[r]);
                      i && n.push(i);
                    }
                    return n;
                  }
                  getDependency(t, e) {
                    const n = t + ":" + e;
                    let r = this.cache.get(n);
                    if (!r) {
                      switch (t) {
                        case "scene":
                          r = this.loadScene(e);
                          break;
                        case "node":
                          r = this.loadNode(e);
                          break;
                        case "mesh":
                          r = this._invokeOne(function (t) {
                            return t.loadMesh && t.loadMesh(e);
                          });
                          break;
                        case "accessor":
                          r = this.loadAccessor(e);
                          break;
                        case "bufferView":
                          r = this._invokeOne(function (t) {
                            return t.loadBufferView && t.loadBufferView(e);
                          });
                          break;
                        case "buffer":
                          r = this.loadBuffer(e);
                          break;
                        case "material":
                          r = this._invokeOne(function (t) {
                            return t.loadMaterial && t.loadMaterial(e);
                          });
                          break;
                        case "texture":
                          r = this._invokeOne(function (t) {
                            return t.loadTexture && t.loadTexture(e);
                          });
                          break;
                        case "skin":
                          r = this.loadSkin(e);
                          break;
                        case "animation":
                          r = this._invokeOne(function (t) {
                            return t.loadAnimation && t.loadAnimation(e);
                          });
                          break;
                        case "camera":
                          r = this.loadCamera(e);
                          break;
                        default:
                          throw new Error("Unknown type: " + t);
                      }
                      this.cache.add(n, r);
                    }
                    return r;
                  }
                  getDependencies(t) {
                    let e = this.cache.get(t);
                    if (!e) {
                      const n = this,
                        r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                      (e = Promise.all(
                        r.map(function (e, r) {
                          return n.getDependency(t, r);
                        })
                      )),
                        this.cache.add(t, e);
                    }
                    return e;
                  }
                  loadBuffer(t) {
                    const e = this.json.buffers[t],
                      n = this.fileLoader;
                    if (e.type && "arraybuffer" !== e.type)
                      throw new Error(
                        "THREE.GLTFLoader: " +
                          e.type +
                          " buffer type is not supported."
                      );
                    if (void 0 === e.uri && 0 === t)
                      return Promise.resolve(
                        this.extensions[Py.KHR_BINARY_GLTF].body
                      );
                    const r = this.options;
                    return new Promise(function (t, i) {
                      n.load(
                        Op.resolveURL(e.uri, r.path),
                        t,
                        void 0,
                        function () {
                          i(
                            new Error(
                              'THREE.GLTFLoader: Failed to load buffer "' +
                                e.uri +
                                '".'
                            )
                          );
                        }
                      );
                    });
                  }
                  loadBufferView(t) {
                    const e = this.json.bufferViews[t];
                    return this.getDependency("buffer", e.buffer).then(
                      function (t) {
                        const n = e.byteLength || 0,
                          r = e.byteOffset || 0;
                        return t.slice(r, r + n);
                      }
                    );
                  }
                  loadAccessor(t) {
                    const e = this,
                      n = this.json,
                      r = this.json.accessors[t];
                    if (void 0 === r.bufferView && void 0 === r.sparse)
                      return Promise.resolve(null);
                    const i = [];
                    return (
                      void 0 !== r.bufferView
                        ? i.push(this.getDependency("bufferView", r.bufferView))
                        : i.push(null),
                      void 0 !== r.sparse &&
                        (i.push(
                          this.getDependency(
                            "bufferView",
                            r.sparse.indices.bufferView
                          )
                        ),
                        i.push(
                          this.getDependency(
                            "bufferView",
                            r.sparse.values.bufferView
                          )
                        )),
                      Promise.all(i).then(function (t) {
                        const i = t[0],
                          a = sb[r.type],
                          o = ib[r.componentType],
                          s = o.BYTES_PER_ELEMENT,
                          c = s * a,
                          l = r.byteOffset || 0,
                          u =
                            void 0 !== r.bufferView
                              ? n.bufferViews[r.bufferView].byteStride
                              : void 0,
                          h = !0 === r.normalized;
                        let d, f;
                        if (u && u !== c) {
                          const t = Math.floor(l / u),
                            n =
                              "InterleavedBuffer:" +
                              r.bufferView +
                              ":" +
                              r.componentType +
                              ":" +
                              t +
                              ":" +
                              r.count;
                          let c = e.cache.get(n);
                          c ||
                            ((d = new o(i, t * u, (r.count * u) / s)),
                            (c = new ju(d, u / s)),
                            e.cache.add(n, c)),
                            (f = new Vu(c, a, (l % u) / s, h));
                        } else (d = null === i ? new o(r.count * a) : new o(i, l, r.count * a)), (f = new li(d, a, h));
                        if (void 0 !== r.sparse) {
                          const e = sb.SCALAR,
                            n = ib[r.sparse.indices.componentType],
                            s = r.sparse.indices.byteOffset || 0,
                            c = r.sparse.values.byteOffset || 0,
                            l = new n(t[1], s, r.sparse.count * e),
                            u = new o(t[2], c, r.sparse.count * a);
                          null !== i &&
                            (f = new li(
                              f.array.slice(),
                              f.itemSize,
                              f.normalized
                            ));
                          for (let t = 0, r = l.length; t < r; t++) {
                            const e = l[t];
                            if (
                              (f.setX(e, u[t * a]),
                              a >= 2 && f.setY(e, u[t * a + 1]),
                              a >= 3 && f.setZ(e, u[t * a + 2]),
                              a >= 4 && f.setW(e, u[t * a + 3]),
                              a >= 5)
                            )
                              throw new Error(
                                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                              );
                          }
                        }
                        return f;
                      })
                    );
                  }
                  loadTexture(t) {
                    const e = this.json,
                      n = this.options,
                      r = e.textures[t],
                      i = r.source,
                      a = e.images[i];
                    let o = this.textureLoader;
                    if (a.uri) {
                      const t = n.manager.getHandler(a.uri);
                      null !== t && (o = t);
                    }
                    return this.loadTextureImage(t, i, o);
                  }
                  loadTextureImage(t, e, n) {
                    const r = this,
                      i = this.json,
                      a = i.textures[t],
                      o = i.images[e],
                      s = (o.uri || o.bufferView) + ":" + a.sampler;
                    if (this.textureCache[s]) return this.textureCache[s];
                    const c = this.loadImageSource(e, n)
                      .then(function (e) {
                        (e.flipY = !1), a.name && (e.name = a.name);
                        const n = i.samplers || {},
                          o = n[a.sampler] || {};
                        return (
                          (e.magFilter = ab[o.magFilter] || vt),
                          (e.minFilter = ab[o.minFilter] || bt),
                          (e.wrapS = ob[o.wrapS] || ht),
                          (e.wrapT = ob[o.wrapT] || ht),
                          r.associations.set(e, { textures: t }),
                          e
                        );
                      })
                      .catch(function () {
                        return null;
                      });
                    return (this.textureCache[s] = c), c;
                  }
                  loadImageSource(t, e) {
                    const n = this,
                      r = this.json,
                      i = this.options;
                    if (void 0 !== this.sourceCache[t])
                      return this.sourceCache[t].then((t) => t.clone());
                    const a = r.images[t],
                      o = self.URL || self.webkitURL;
                    let s = a.uri || "",
                      c = !1;
                    if (void 0 !== a.bufferView)
                      s = n
                        .getDependency("bufferView", a.bufferView)
                        .then(function (t) {
                          c = !0;
                          const e = new Blob([t], { type: a.mimeType });
                          return (s = o.createObjectURL(e)), s;
                        });
                    else if (void 0 === a.uri)
                      throw new Error(
                        "THREE.GLTFLoader: Image " +
                          t +
                          " is missing URI and bufferView"
                      );
                    const l = Promise.resolve(s)
                      .then(function (t) {
                        return new Promise(function (n, r) {
                          let a = n;
                          !0 === e.isImageBitmapLoader &&
                            (a = function (t) {
                              const e = new Fn(t);
                              (e.needsUpdate = !0), n(e);
                            }),
                            e.load(Op.resolveURL(t, i.path), a, void 0, r);
                        });
                      })
                      .then(function (t) {
                        return (
                          !0 === c && o.revokeObjectURL(s),
                          (t.userData.mimeType = a.mimeType || xb(a.uri)),
                          t
                        );
                      })
                      .catch(function (t) {
                        throw (
                          (console.error(
                            "THREE.GLTFLoader: Couldn't load texture",
                            s
                          ),
                          t)
                        );
                      });
                    return (this.sourceCache[t] = l), l;
                  }
                  assignTexture(t, e, n, r) {
                    const i = this;
                    return this.getDependency("texture", n.index).then(
                      function (a) {
                        if (
                          (void 0 === n.texCoord ||
                            0 == n.texCoord ||
                            ("aoMap" === e && 1 == n.texCoord) ||
                            console.warn(
                              "THREE.GLTFLoader: Custom UV set " +
                                n.texCoord +
                                " for texture " +
                                e +
                                " not yet supported."
                            ),
                          i.extensions[Py.KHR_TEXTURE_TRANSFORM])
                        ) {
                          const t =
                            void 0 !== n.extensions
                              ? n.extensions[Py.KHR_TEXTURE_TRANSFORM]
                              : void 0;
                          if (t) {
                            const e = i.associations.get(a);
                            (a = i.extensions[
                              Py.KHR_TEXTURE_TRANSFORM
                            ].extendTexture(a, t)),
                              i.associations.set(a, e);
                          }
                        }
                        return void 0 !== r && (a.encoding = r), (t[e] = a), a;
                      }
                    );
                  }
                  assignFinalMaterial(t) {
                    const e = t.geometry;
                    let n = t.material;
                    const r = void 0 === e.attributes.tangent,
                      i = void 0 !== e.attributes.color,
                      a = void 0 === e.attributes.normal;
                    if (t.isPoints) {
                      const t = "PointsMaterial:" + n.uuid;
                      let e = this.cache.get(t);
                      e ||
                        ((e = new zh()),
                        ai.prototype.copy.call(e, n),
                        e.color.copy(n.color),
                        (e.map = n.map),
                        (e.sizeAttenuation = !1),
                        this.cache.add(t, e)),
                        (n = e);
                    } else if (t.isLine) {
                      const t = "LineBasicMaterial:" + n.uuid;
                      let e = this.cache.get(t);
                      e ||
                        ((e = new Eh()),
                        ai.prototype.copy.call(e, n),
                        e.color.copy(n.color),
                        this.cache.add(t, e)),
                        (n = e);
                    }
                    if (r || i || a) {
                      let t = "ClonedMaterial:" + n.uuid + ":";
                      n.isGLTFSpecularGlossinessMaterial &&
                        (t += "specular-glossiness:"),
                        r && (t += "derivative-tangents:"),
                        i && (t += "vertex-colors:"),
                        a && (t += "flat-shading:");
                      let e = this.cache.get(t);
                      e ||
                        ((e = n.clone()),
                        i && (e.vertexColors = !0),
                        a && (e.flatShading = !0),
                        r &&
                          (e.normalScale && (e.normalScale.y *= -1),
                          e.clearcoatNormalScale &&
                            (e.clearcoatNormalScale.y *= -1)),
                        this.cache.add(t, e),
                        this.associations.set(e, this.associations.get(n))),
                        (n = e);
                    }
                    n.aoMap &&
                      void 0 === e.attributes.uv2 &&
                      void 0 !== e.attributes.uv &&
                      e.setAttribute("uv2", e.attributes.uv),
                      (t.material = n);
                  }
                  getMaterialType() {
                    return Of;
                  }
                  loadMaterial(t) {
                    const e = this,
                      n = this.json,
                      r = this.extensions,
                      i = n.materials[t];
                    let a;
                    const o = {},
                      s = i.extensions || {},
                      c = [];
                    if (s[Py.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                      const t = r[Py.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                      (a = t.getMaterialType()),
                        c.push(t.extendParams(o, i, e));
                    } else if (s[Py.KHR_MATERIALS_UNLIT]) {
                      const t = r[Py.KHR_MATERIALS_UNLIT];
                      (a = t.getMaterialType()),
                        c.push(t.extendParams(o, i, e));
                    } else {
                      const n = i.pbrMetallicRoughness || {};
                      if (
                        ((o.color = new In(1, 1, 1)),
                        (o.opacity = 1),
                        Array.isArray(n.baseColorFactor))
                      ) {
                        const t = n.baseColorFactor;
                        o.color.fromArray(t), (o.opacity = t[3]);
                      }
                      void 0 !== n.baseColorTexture &&
                        c.push(
                          e.assignTexture(o, "map", n.baseColorTexture, Le)
                        ),
                        (o.metalness =
                          void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                        (o.roughness =
                          void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                        void 0 !== n.metallicRoughnessTexture &&
                          (c.push(
                            e.assignTexture(
                              o,
                              "metalnessMap",
                              n.metallicRoughnessTexture
                            )
                          ),
                          c.push(
                            e.assignTexture(
                              o,
                              "roughnessMap",
                              n.metallicRoughnessTexture
                            )
                          )),
                        (a = this._invokeOne(function (e) {
                          return e.getMaterialType && e.getMaterialType(t);
                        })),
                        c.push(
                          Promise.all(
                            this._invokeAll(function (e) {
                              return (
                                e.extendMaterialParams &&
                                e.extendMaterialParams(t, o)
                              );
                            })
                          )
                        );
                    }
                    !0 === i.doubleSided && (o.side = y);
                    const l = i.alphaMode || hb.OPAQUE;
                    if (
                      (l === hb.BLEND
                        ? ((o.transparent = !0), (o.depthWrite = !1))
                        : ((o.transparent = !1),
                          l === hb.MASK &&
                            (o.alphaTest =
                              void 0 !== i.alphaCutoff ? i.alphaCutoff : 0.5)),
                      void 0 !== i.normalTexture &&
                        a !== oi &&
                        (c.push(
                          e.assignTexture(o, "normalMap", i.normalTexture)
                        ),
                        (o.normalScale = new gn(1, 1)),
                        void 0 !== i.normalTexture.scale))
                    ) {
                      const t = i.normalTexture.scale;
                      o.normalScale.set(t, t);
                    }
                    return (
                      void 0 !== i.occlusionTexture &&
                        a !== oi &&
                        (c.push(
                          e.assignTexture(o, "aoMap", i.occlusionTexture)
                        ),
                        void 0 !== i.occlusionTexture.strength &&
                          (o.aoMapIntensity = i.occlusionTexture.strength)),
                      void 0 !== i.emissiveFactor &&
                        a !== oi &&
                        (o.emissive = new In().fromArray(i.emissiveFactor)),
                      void 0 !== i.emissiveTexture &&
                        a !== oi &&
                        c.push(
                          e.assignTexture(
                            o,
                            "emissiveMap",
                            i.emissiveTexture,
                            Le
                          )
                        ),
                      Promise.all(c).then(function () {
                        let n;
                        return (
                          (n =
                            a === Ky
                              ? r[
                                  Py.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                                ].createMaterial(o)
                              : new a(o)),
                          i.name && (n.name = i.name),
                          pb(n, i),
                          e.associations.set(n, { materials: t }),
                          i.extensions && fb(r, n, i),
                          n
                        );
                      })
                    );
                  }
                  createUniqueName(t) {
                    const e = em.sanitizeNodeName(t || "");
                    let n = e;
                    for (let r = 1; this.nodeNamesUsed[n]; ++r) n = e + "_" + r;
                    return (this.nodeNamesUsed[n] = !0), n;
                  }
                  loadGeometries(t) {
                    const e = this,
                      n = this.extensions,
                      r = this.primitiveCache;
                    function i(t) {
                      return n[Py.KHR_DRACO_MESH_COMPRESSION]
                        .decodePrimitive(t, e)
                        .then(function (n) {
                          return Mb(n, t, e);
                        });
                    }
                    const a = [];
                    for (let o = 0, s = t.length; o < s; o++) {
                      const n = t[o],
                        s = vb(n),
                        c = r[s];
                      if (c) a.push(c.promise);
                      else {
                        let t;
                        (t =
                          n.extensions &&
                          n.extensions[Py.KHR_DRACO_MESH_COMPRESSION]
                            ? i(n)
                            : Mb(new xi(), n, e)),
                          (r[s] = { primitive: n, promise: t }),
                          a.push(t);
                      }
                    }
                    return Promise.all(a);
                  }
                  loadMesh(t) {
                    const e = this,
                      n = this.json,
                      r = this.extensions,
                      i = n.meshes[t],
                      a = i.primitives,
                      o = [];
                    for (let s = 0, c = a.length; s < c; s++) {
                      const t =
                        void 0 === a[s].material
                          ? db(this.cache)
                          : this.getDependency("material", a[s].material);
                      o.push(t);
                    }
                    return (
                      o.push(e.loadGeometries(a)),
                      Promise.all(o).then(function (n) {
                        const o = n.slice(0, n.length - 1),
                          s = n[n.length - 1],
                          c = [];
                        for (let u = 0, h = s.length; u < h; u++) {
                          const n = s[u],
                            l = a[u];
                          let h;
                          const d = o[u];
                          if (
                            l.mode === rb.TRIANGLES ||
                            l.mode === rb.TRIANGLE_STRIP ||
                            l.mode === rb.TRIANGLE_FAN ||
                            void 0 === l.mode
                          )
                            (h =
                              !0 === i.isSkinnedMesh
                                ? new ph(n, d)
                                : new Fi(n, d)),
                              !0 !== h.isSkinnedMesh ||
                                h.geometry.attributes.skinWeight.normalized ||
                                h.normalizeSkinWeights(),
                              l.mode === rb.TRIANGLE_STRIP
                                ? (h.geometry = Tb(h.geometry, Ee))
                                : l.mode === rb.TRIANGLE_FAN &&
                                  (h.geometry = Tb(h.geometry, Ae));
                          else if (l.mode === rb.LINES) h = new Nh(n, d);
                          else if (l.mode === rb.LINE_STRIP) h = new Ih(n, d);
                          else if (l.mode === rb.LINE_LOOP) h = new Dh(n, d);
                          else {
                            if (l.mode !== rb.POINTS)
                              throw new Error(
                                "THREE.GLTFLoader: Primitive mode unsupported: " +
                                  l.mode
                              );
                            h = new Hh(n, d);
                          }
                          Object.keys(h.geometry.morphAttributes).length > 0 &&
                            gb(h, i),
                            (h.name = e.createUniqueName(
                              i.name || "mesh_" + t
                            )),
                            pb(h, i),
                            l.extensions && fb(r, h, l),
                            e.assignFinalMaterial(h),
                            c.push(h);
                        }
                        for (let r = 0, i = c.length; r < i; r++)
                          e.associations.set(c[r], {
                            meshes: t,
                            primitives: r,
                          });
                        if (1 === c.length) return c[0];
                        const l = new Lu();
                        e.associations.set(l, { meshes: t });
                        for (let t = 0, e = c.length; t < e; t++) l.add(c[t]);
                        return l;
                      })
                    );
                  }
                  loadCamera(t) {
                    let e;
                    const n = this.json.cameras[t],
                      r = n[n.type];
                    if (r)
                      return (
                        "perspective" === n.type
                          ? (e = new Yi(
                              mn.radToDeg(r.yfov),
                              r.aspectRatio || 1,
                              r.znear || 1,
                              r.zfar || 2e6
                            ))
                          : "orthographic" === n.type &&
                            (e = new Js(
                              -r.xmag,
                              r.xmag,
                              r.ymag,
                              -r.ymag,
                              r.znear,
                              r.zfar
                            )),
                        n.name && (e.name = this.createUniqueName(n.name)),
                        pb(e, n),
                        Promise.resolve(e)
                      );
                    console.warn(
                      "THREE.GLTFLoader: Missing camera parameters."
                    );
                  }
                  loadSkin(t) {
                    const e = this.json.skins[t],
                      n = { joints: e.joints };
                    return void 0 === e.inverseBindMatrices
                      ? Promise.resolve(n)
                      : this.getDependency(
                          "accessor",
                          e.inverseBindMatrices
                        ).then(function (t) {
                          return (n.inverseBindMatrices = t), n;
                        });
                  }
                  loadAnimation(t) {
                    const e = this.json,
                      n = e.animations[t],
                      r = [],
                      i = [],
                      a = [],
                      o = [],
                      s = [];
                    for (let c = 0, l = n.channels.length; c < l; c++) {
                      const t = n.channels[c],
                        e = n.samplers[t.sampler],
                        l = t.target,
                        u = void 0 !== l.node ? l.node : l.id,
                        h =
                          void 0 !== n.parameters
                            ? n.parameters[e.input]
                            : e.input,
                        d =
                          void 0 !== n.parameters
                            ? n.parameters[e.output]
                            : e.output;
                      r.push(this.getDependency("node", u)),
                        i.push(this.getDependency("accessor", h)),
                        a.push(this.getDependency("accessor", d)),
                        o.push(e),
                        s.push(l);
                    }
                    return Promise.all([
                      Promise.all(r),
                      Promise.all(i),
                      Promise.all(a),
                      Promise.all(o),
                      Promise.all(s),
                    ]).then(function (e) {
                      const r = e[0],
                        i = e[1],
                        a = e[2],
                        o = e[3],
                        s = e[4],
                        c = [];
                      for (let t = 0, n = r.length; t < n; t++) {
                        const e = r[t],
                          n = i[t],
                          l = a[t],
                          u = o[t],
                          h = s[t];
                        if (void 0 === e) continue;
                        let d;
                        switch (
                          (e.updateMatrix(),
                          (e.matrixAutoUpdate = !0),
                          lb[h.path])
                        ) {
                          case lb.weights:
                            d = Yf;
                            break;
                          case lb.rotation:
                            d = Kf;
                            break;
                          case lb.position:
                          case lb.scale:
                          default:
                            d = Qf;
                            break;
                        }
                        const f = e.name ? e.name : e.uuid,
                          p =
                            void 0 !== u.interpolation
                              ? ub[u.interpolation]
                              : be,
                          m = [];
                        lb[h.path] === lb.weights
                          ? e.traverse(function (t) {
                              t.morphTargetInfluences &&
                                m.push(t.name ? t.name : t.uuid);
                            })
                          : m.push(f);
                        let g = l.array;
                        if (l.normalized) {
                          const t = bb(g.constructor),
                            e = new Float32Array(g.length);
                          for (let n = 0, r = g.length; n < r; n++)
                            e[n] = g[n] * t;
                          g = e;
                        }
                        for (let t = 0, r = m.length; t < r; t++) {
                          const e = new d(
                            m[t] + "." + lb[h.path],
                            n.array,
                            g,
                            p
                          );
                          "CUBICSPLINE" === u.interpolation &&
                            ((e.createInterpolant = function (t) {
                              const e = this instanceof Kf ? nb : tb;
                              return new e(
                                this.times,
                                this.values,
                                this.getValueSize() / 3,
                                t
                              );
                            }),
                            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                              !0)),
                            c.push(e);
                        }
                      }
                      const l = n.name ? n.name : "animation_" + t;
                      return new tp(l, void 0, c);
                    });
                  }
                  createNodeMesh(t) {
                    const e = this.json,
                      n = this,
                      r = e.nodes[t];
                    return void 0 === r.mesh
                      ? null
                      : n.getDependency("mesh", r.mesh).then(function (t) {
                          const e = n._getNodeRef(n.meshCache, r.mesh, t);
                          return (
                            void 0 !== r.weights &&
                              e.traverse(function (t) {
                                if (t.isMesh)
                                  for (
                                    let e = 0, n = r.weights.length;
                                    e < n;
                                    e++
                                  )
                                    t.morphTargetInfluences[e] = r.weights[e];
                              }),
                            e
                          );
                        });
                  }
                  loadNode(t) {
                    const e = this.json,
                      n = this.extensions,
                      r = this,
                      i = e.nodes[t],
                      a = i.name ? r.createUniqueName(i.name) : "";
                    return (function () {
                      const e = [],
                        n = r._invokeOne(function (e) {
                          return e.createNodeMesh && e.createNodeMesh(t);
                        });
                      return (
                        n && e.push(n),
                        void 0 !== i.camera &&
                          e.push(
                            r
                              .getDependency("camera", i.camera)
                              .then(function (t) {
                                return r._getNodeRef(
                                  r.cameraCache,
                                  i.camera,
                                  t
                                );
                              })
                          ),
                        r
                          ._invokeAll(function (e) {
                            return (
                              e.createNodeAttachment &&
                              e.createNodeAttachment(t)
                            );
                          })
                          .forEach(function (t) {
                            e.push(t);
                          }),
                        Promise.all(e)
                      );
                    })().then(function (e) {
                      let o;
                      if (
                        ((o =
                          !0 === i.isBone
                            ? new mh()
                            : e.length > 1
                            ? new Lu()
                            : 1 === e.length
                            ? e[0]
                            : new qr()),
                        o !== e[0])
                      )
                        for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                      if (
                        (i.name && ((o.userData.name = i.name), (o.name = a)),
                        pb(o, i),
                        i.extensions && fb(n, o, i),
                        void 0 !== i.matrix)
                      ) {
                        const t = new _r();
                        t.fromArray(i.matrix), o.applyMatrix4(t);
                      } else void 0 !== i.translation && o.position.fromArray(i.translation), void 0 !== i.rotation && o.quaternion.fromArray(i.rotation), void 0 !== i.scale && o.scale.fromArray(i.scale);
                      return (
                        r.associations.has(o) || r.associations.set(o, {}),
                        (r.associations.get(o).nodes = t),
                        o
                      );
                    });
                  }
                  loadScene(t) {
                    const e = this.json,
                      n = this.extensions,
                      r = this.json.scenes[t],
                      i = this,
                      a = new Lu();
                    r.name && (a.name = i.createUniqueName(r.name)),
                      pb(a, r),
                      r.extensions && fb(n, a, r);
                    const o = r.nodes || [],
                      s = [];
                    for (let c = 0, l = o.length; c < l; c++)
                      s.push(wb(o[c], a, e, i));
                    return Promise.all(s).then(function () {
                      const t = (t) => {
                        const e = new Map();
                        for (const [n, r] of i.associations)
                          (n instanceof ai || n instanceof Fn) && e.set(n, r);
                        return (
                          t.traverse((t) => {
                            const n = i.associations.get(t);
                            null != n && e.set(t, n);
                          }),
                          e
                        );
                      };
                      return (i.associations = t(a)), a;
                    });
                  }
                }
                function wb(t, e, n, r) {
                  const i = n.nodes[t];
                  return r
                    .getDependency("node", t)
                    .then(function (t) {
                      if (void 0 === i.skin) return t;
                      let e;
                      return r
                        .getDependency("skin", i.skin)
                        .then(function (t) {
                          e = t;
                          const n = [];
                          for (let i = 0, a = e.joints.length; i < a; i++)
                            n.push(r.getDependency("node", e.joints[i]));
                          return Promise.all(n);
                        })
                        .then(function (n) {
                          return (
                            t.traverse(function (t) {
                              if (!t.isMesh) return;
                              const r = [],
                                i = [];
                              for (let a = 0, o = n.length; a < o; a++) {
                                const t = n[a];
                                if (t) {
                                  r.push(t);
                                  const n = new _r();
                                  void 0 !== e.inverseBindMatrices &&
                                    n.fromArray(
                                      e.inverseBindMatrices.array,
                                      16 * a
                                    ),
                                    i.push(n);
                                } else
                                  console.warn(
                                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                                    e.joints[a]
                                  );
                              }
                              t.bind(new bh(r, i), t.matrixWorld);
                            }),
                            t
                          );
                        });
                    })
                    .then(function (t) {
                      e.add(t);
                      const a = [];
                      if (i.children) {
                        const e = i.children;
                        for (let i = 0, o = e.length; i < o; i++) {
                          const o = e[i];
                          a.push(wb(o, t, n, r));
                        }
                      }
                      return Promise.all(a);
                    });
                }
                function Sb(t, e, n) {
                  const r = e.attributes,
                    i = new Xn();
                  if (void 0 === r.POSITION) return;
                  {
                    const t = n.json.accessors[r.POSITION],
                      e = t.min,
                      a = t.max;
                    if (void 0 === e || void 0 === a)
                      return void console.warn(
                        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                      );
                    if (
                      (i.set(
                        new Gn(e[0], e[1], e[2]),
                        new Gn(a[0], a[1], a[2])
                      ),
                      t.normalized)
                    ) {
                      const e = bb(ib[t.componentType]);
                      i.min.multiplyScalar(e), i.max.multiplyScalar(e);
                    }
                  }
                  const a = e.targets;
                  if (void 0 !== a) {
                    const t = new Gn(),
                      e = new Gn();
                    for (let r = 0, i = a.length; r < i; r++) {
                      const i = a[r];
                      if (void 0 !== i.POSITION) {
                        const r = n.json.accessors[i.POSITION],
                          a = r.min,
                          o = r.max;
                        if (void 0 !== a && void 0 !== o) {
                          if (
                            (e.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))),
                            e.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))),
                            e.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))),
                            r.normalized)
                          ) {
                            const t = bb(ib[r.componentType]);
                            e.multiplyScalar(t);
                          }
                          t.max(e);
                        } else
                          console.warn(
                            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                          );
                      }
                    }
                    i.expandByVector(t);
                  }
                  t.boundingBox = i;
                  const o = new dr();
                  i.getCenter(o.center),
                    (o.radius = i.min.distanceTo(i.max) / 2),
                    (t.boundingSphere = o);
                }
                function Mb(t, e, n) {
                  const r = e.attributes,
                    i = [];
                  function a(e, r) {
                    return n.getDependency("accessor", e).then(function (e) {
                      t.setAttribute(r, e);
                    });
                  }
                  for (const o in r) {
                    const e = cb[o] || o.toLowerCase();
                    e in t.attributes || i.push(a(r[o], e));
                  }
                  if (void 0 !== e.indices && !t.index) {
                    const r = n
                      .getDependency("accessor", e.indices)
                      .then(function (e) {
                        t.setIndex(e);
                      });
                    i.push(r);
                  }
                  return (
                    pb(t, e),
                    Sb(t, e, n),
                    Promise.all(i).then(function () {
                      return void 0 !== e.targets ? mb(t, e.targets, n) : t;
                    })
                  );
                }
                function Tb(t, e) {
                  let n = t.getIndex();
                  if (null === n) {
                    const e = [],
                      r = t.getAttribute("position");
                    if (void 0 === r)
                      return (
                        console.error(
                          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                        ),
                        t
                      );
                    for (let t = 0; t < r.count; t++) e.push(t);
                    t.setIndex(e), (n = t.getIndex());
                  }
                  const r = n.count - 2,
                    i = [];
                  if (e === Ae)
                    for (let o = 1; o <= r; o++)
                      i.push(n.getX(0)),
                        i.push(n.getX(o)),
                        i.push(n.getX(o + 1));
                  else
                    for (let o = 0; o < r; o++)
                      o % 2 === 0
                        ? (i.push(n.getX(o)),
                          i.push(n.getX(o + 1)),
                          i.push(n.getX(o + 2)))
                        : (i.push(n.getX(o + 2)),
                          i.push(n.getX(o + 1)),
                          i.push(n.getX(o)));
                  i.length / 3 !== r &&
                    console.error(
                      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
                    );
                  const a = t.clone();
                  return a.setIndex(i), a;
                }
                const Eb = /^[og]\s*(.+)?/,
                  Ab = /^mtllib /,
                  Cb = /^usemtl /,
                  Lb = /^usemap /,
                  Rb = /\s+/,
                  Pb = new Gn(),
                  Ib = new Gn(),
                  Ob = new Gn(),
                  kb = new Gn(),
                  Nb = new Gn(),
                  Db = new In();
                function zb() {
                  const t = {
                    objects: [],
                    object: {},
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    materials: {},
                    materialLibraries: [],
                    startObject: function (t, e) {
                      if (this.object && !1 === this.object.fromDeclaration)
                        return (
                          (this.object.name = t),
                          void (this.object.fromDeclaration = !1 !== e)
                        );
                      const n =
                        this.object &&
                        "function" === typeof this.object.currentMaterial
                          ? this.object.currentMaterial()
                          : void 0;
                      if (
                        (this.object &&
                          "function" === typeof this.object._finalize &&
                          this.object._finalize(!0),
                        (this.object = {
                          name: t || "",
                          fromDeclaration: !1 !== e,
                          geometry: {
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            hasUVIndices: !1,
                          },
                          materials: [],
                          smooth: !0,
                          startMaterial: function (t, e) {
                            const n = this._finalize(!1);
                            n &&
                              (n.inherited || n.groupCount <= 0) &&
                              this.materials.splice(n.index, 1);
                            const r = {
                              index: this.materials.length,
                              name: t || "",
                              mtllib:
                                Array.isArray(e) && e.length > 0
                                  ? e[e.length - 1]
                                  : "",
                              smooth: void 0 !== n ? n.smooth : this.smooth,
                              groupStart: void 0 !== n ? n.groupEnd : 0,
                              groupEnd: -1,
                              groupCount: -1,
                              inherited: !1,
                              clone: function (t) {
                                const e = {
                                  index: "number" === typeof t ? t : this.index,
                                  name: this.name,
                                  mtllib: this.mtllib,
                                  smooth: this.smooth,
                                  groupStart: 0,
                                  groupEnd: -1,
                                  groupCount: -1,
                                  inherited: !1,
                                };
                                return (e.clone = this.clone.bind(e)), e;
                              },
                            };
                            return this.materials.push(r), r;
                          },
                          currentMaterial: function () {
                            if (this.materials.length > 0)
                              return this.materials[this.materials.length - 1];
                          },
                          _finalize: function (t) {
                            const e = this.currentMaterial();
                            if (
                              (e &&
                                -1 === e.groupEnd &&
                                ((e.groupEnd =
                                  this.geometry.vertices.length / 3),
                                (e.groupCount = e.groupEnd - e.groupStart),
                                (e.inherited = !1)),
                              t && this.materials.length > 1)
                            )
                              for (
                                let n = this.materials.length - 1;
                                n >= 0;
                                n--
                              )
                                this.materials[n].groupCount <= 0 &&
                                  this.materials.splice(n, 1);
                            return (
                              t &&
                                0 === this.materials.length &&
                                this.materials.push({
                                  name: "",
                                  smooth: this.smooth,
                                }),
                              e
                            );
                          },
                        }),
                        n && n.name && "function" === typeof n.clone)
                      ) {
                        const t = n.clone(0);
                        (t.inherited = !0), this.object.materials.push(t);
                      }
                      this.objects.push(this.object);
                    },
                    finalize: function () {
                      this.object &&
                        "function" === typeof this.object._finalize &&
                        this.object._finalize(!0);
                    },
                    parseVertexIndex: function (t, e) {
                      const n = parseInt(t, 10);
                      return 3 * (n >= 0 ? n - 1 : n + e / 3);
                    },
                    parseNormalIndex: function (t, e) {
                      const n = parseInt(t, 10);
                      return 3 * (n >= 0 ? n - 1 : n + e / 3);
                    },
                    parseUVIndex: function (t, e) {
                      const n = parseInt(t, 10);
                      return 2 * (n >= 0 ? n - 1 : n + e / 2);
                    },
                    addVertex: function (t, e, n) {
                      const r = this.vertices,
                        i = this.object.geometry.vertices;
                      i.push(r[t + 0], r[t + 1], r[t + 2]),
                        i.push(r[e + 0], r[e + 1], r[e + 2]),
                        i.push(r[n + 0], r[n + 1], r[n + 2]);
                    },
                    addVertexPoint: function (t) {
                      const e = this.vertices,
                        n = this.object.geometry.vertices;
                      n.push(e[t + 0], e[t + 1], e[t + 2]);
                    },
                    addVertexLine: function (t) {
                      const e = this.vertices,
                        n = this.object.geometry.vertices;
                      n.push(e[t + 0], e[t + 1], e[t + 2]);
                    },
                    addNormal: function (t, e, n) {
                      const r = this.normals,
                        i = this.object.geometry.normals;
                      i.push(r[t + 0], r[t + 1], r[t + 2]),
                        i.push(r[e + 0], r[e + 1], r[e + 2]),
                        i.push(r[n + 0], r[n + 1], r[n + 2]);
                    },
                    addFaceNormal: function (t, e, n) {
                      const r = this.vertices,
                        i = this.object.geometry.normals;
                      Pb.fromArray(r, t),
                        Ib.fromArray(r, e),
                        Ob.fromArray(r, n),
                        Nb.subVectors(Ob, Ib),
                        kb.subVectors(Pb, Ib),
                        Nb.cross(kb),
                        Nb.normalize(),
                        i.push(Nb.x, Nb.y, Nb.z),
                        i.push(Nb.x, Nb.y, Nb.z),
                        i.push(Nb.x, Nb.y, Nb.z);
                    },
                    addColor: function (t, e, n) {
                      const r = this.colors,
                        i = this.object.geometry.colors;
                      void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]),
                        void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]),
                        void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2]);
                    },
                    addUV: function (t, e, n) {
                      const r = this.uvs,
                        i = this.object.geometry.uvs;
                      i.push(r[t + 0], r[t + 1]),
                        i.push(r[e + 0], r[e + 1]),
                        i.push(r[n + 0], r[n + 1]);
                    },
                    addDefaultUV: function () {
                      const t = this.object.geometry.uvs;
                      t.push(0, 0), t.push(0, 0), t.push(0, 0);
                    },
                    addUVLine: function (t) {
                      const e = this.uvs,
                        n = this.object.geometry.uvs;
                      n.push(e[t + 0], e[t + 1]);
                    },
                    addFace: function (t, e, n, r, i, a, o, s, c) {
                      const l = this.vertices.length;
                      let u = this.parseVertexIndex(t, l),
                        h = this.parseVertexIndex(e, l),
                        d = this.parseVertexIndex(n, l);
                      if (
                        (this.addVertex(u, h, d),
                        this.addColor(u, h, d),
                        void 0 !== o && "" !== o)
                      ) {
                        const t = this.normals.length;
                        (u = this.parseNormalIndex(o, t)),
                          (h = this.parseNormalIndex(s, t)),
                          (d = this.parseNormalIndex(c, t)),
                          this.addNormal(u, h, d);
                      } else this.addFaceNormal(u, h, d);
                      if (void 0 !== r && "" !== r) {
                        const t = this.uvs.length;
                        (u = this.parseUVIndex(r, t)),
                          (h = this.parseUVIndex(i, t)),
                          (d = this.parseUVIndex(a, t)),
                          this.addUV(u, h, d),
                          (this.object.geometry.hasUVIndices = !0);
                      } else this.addDefaultUV();
                    },
                    addPointGeometry: function (t) {
                      this.object.geometry.type = "Points";
                      const e = this.vertices.length;
                      for (let n = 0, r = t.length; n < r; n++) {
                        const r = this.parseVertexIndex(t[n], e);
                        this.addVertexPoint(r), this.addColor(r);
                      }
                    },
                    addLineGeometry: function (t, e) {
                      this.object.geometry.type = "Line";
                      const n = this.vertices.length,
                        r = this.uvs.length;
                      for (let i = 0, a = t.length; i < a; i++)
                        this.addVertexLine(this.parseVertexIndex(t[i], n));
                      for (let i = 0, a = e.length; i < a; i++)
                        this.addUVLine(this.parseUVIndex(e[i], r));
                    },
                  };
                  return t.startObject("", !1), t;
                }
                class Fb extends op {
                  constructor(t) {
                    super(t), (this.materials = null);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new cp(this.manager);
                    a.setPath(this.path),
                      a.setRequestHeader(this.requestHeader),
                      a.setWithCredentials(this.withCredentials),
                      a.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  setMaterials(t) {
                    return (this.materials = t), this;
                  }
                  parse(t) {
                    const e = new zb();
                    -1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")),
                      -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, ""));
                    const n = t.split("\n");
                    let r = [];
                    for (let o = 0, s = n.length; o < s; o++) {
                      const t = n[o].trimStart();
                      if (0 === t.length) continue;
                      const i = t.charAt(0);
                      if ("#" !== i)
                        if ("v" === i) {
                          const n = t.split(Rb);
                          switch (n[0]) {
                            case "v":
                              e.vertices.push(
                                parseFloat(n[1]),
                                parseFloat(n[2]),
                                parseFloat(n[3])
                              ),
                                n.length >= 7
                                  ? (Db.setRGB(
                                      parseFloat(n[4]),
                                      parseFloat(n[5]),
                                      parseFloat(n[6])
                                    ).convertSRGBToLinear(),
                                    e.colors.push(Db.r, Db.g, Db.b))
                                  : e.colors.push(void 0, void 0, void 0);
                              break;
                            case "vn":
                              e.normals.push(
                                parseFloat(n[1]),
                                parseFloat(n[2]),
                                parseFloat(n[3])
                              );
                              break;
                            case "vt":
                              e.uvs.push(parseFloat(n[1]), parseFloat(n[2]));
                              break;
                          }
                        } else if ("f" === i) {
                          const n = t.slice(1).trim(),
                            r = n.split(Rb),
                            i = [];
                          for (let t = 0, e = r.length; t < e; t++) {
                            const e = r[t];
                            if (e.length > 0) {
                              const t = e.split("/");
                              i.push(t);
                            }
                          }
                          const a = i[0];
                          for (let t = 1, o = i.length - 1; t < o; t++) {
                            const n = i[t],
                              r = i[t + 1];
                            e.addFace(
                              a[0],
                              n[0],
                              r[0],
                              a[1],
                              n[1],
                              r[1],
                              a[2],
                              n[2],
                              r[2]
                            );
                          }
                        } else if ("l" === i) {
                          const n = t.substring(1).trim().split(" ");
                          let r = [];
                          const i = [];
                          if (-1 === t.indexOf("/")) r = n;
                          else
                            for (let t = 0, e = n.length; t < e; t++) {
                              const e = n[t].split("/");
                              "" !== e[0] && r.push(e[0]),
                                "" !== e[1] && i.push(e[1]);
                            }
                          e.addLineGeometry(r, i);
                        } else if ("p" === i) {
                          const n = t.slice(1).trim(),
                            r = n.split(" ");
                          e.addPointGeometry(r);
                        } else if (null !== (r = Eb.exec(t))) {
                          const t = (" " + r[0].slice(1).trim()).slice(1);
                          e.startObject(t);
                        } else if (Cb.test(t))
                          e.object.startMaterial(
                            t.substring(7).trim(),
                            e.materialLibraries
                          );
                        else if (Ab.test(t))
                          e.materialLibraries.push(t.substring(7).trim());
                        else if (Lb.test(t))
                          console.warn(
                            'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
                          );
                        else if ("s" === i) {
                          if (((r = t.split(" ")), r.length > 1)) {
                            const t = r[1].trim().toLowerCase();
                            e.object.smooth = "0" !== t && "off" !== t;
                          } else e.object.smooth = !0;
                          const n = e.object.currentMaterial();
                          n && (n.smooth = e.object.smooth);
                        } else {
                          if ("\0" === t) continue;
                          console.warn(
                            'THREE.OBJLoader: Unexpected line: "' + t + '"'
                          );
                        }
                    }
                    e.finalize();
                    const i = new Lu();
                    i.materialLibraries = [].concat(e.materialLibraries);
                    const a = !(
                      1 === e.objects.length &&
                      0 === e.objects[0].geometry.vertices.length
                    );
                    if (!0 === a)
                      for (let o = 0, s = e.objects.length; o < s; o++) {
                        const t = e.objects[o],
                          n = t.geometry,
                          r = t.materials,
                          a = "Line" === n.type,
                          s = "Points" === n.type;
                        let c = !1;
                        if (0 === n.vertices.length) continue;
                        const l = new xi();
                        l.setAttribute("position", new di(n.vertices, 3)),
                          n.normals.length > 0 &&
                            l.setAttribute("normal", new di(n.normals, 3)),
                          n.colors.length > 0 &&
                            ((c = !0),
                            l.setAttribute("color", new di(n.colors, 3))),
                          !0 === n.hasUVIndices &&
                            l.setAttribute("uv", new di(n.uvs, 2));
                        const u = [];
                        for (let i = 0, o = r.length; i < o; i++) {
                          const t = r[i],
                            n = t.name + "_" + t.smooth + "_" + c;
                          let o = e.materials[n];
                          if (null !== this.materials)
                            if (
                              ((o = this.materials.create(t.name)),
                              !a || !o || o instanceof Eh)
                            ) {
                              if (s && o && !(o instanceof zh)) {
                                const t = new zh({
                                  size: 10,
                                  sizeAttenuation: !1,
                                });
                                ai.prototype.copy.call(t, o),
                                  t.color.copy(o.color),
                                  (t.map = o.map),
                                  (o = t);
                              }
                            } else {
                              const t = new Eh();
                              ai.prototype.copy.call(t, o),
                                t.color.copy(o.color),
                                (o = t);
                            }
                          void 0 === o &&
                            ((o = a
                              ? new Eh()
                              : s
                              ? new zh({ size: 1, sizeAttenuation: !1 })
                              : new Nf()),
                            (o.name = t.name),
                            (o.flatShading = !t.smooth),
                            (o.vertexColors = c),
                            (e.materials[n] = o)),
                            u.push(o);
                        }
                        let h;
                        if (u.length > 1) {
                          for (let t = 0, e = r.length; t < e; t++) {
                            const e = r[t];
                            l.addGroup(e.groupStart, e.groupCount, t);
                          }
                          h = a
                            ? new Nh(l, u)
                            : s
                            ? new Hh(l, u)
                            : new Fi(l, u);
                        } else
                          h = a
                            ? new Nh(l, u[0])
                            : s
                            ? new Hh(l, u[0])
                            : new Fi(l, u[0]);
                        (h.name = t.name), i.add(h);
                      }
                    else if (e.vertices.length > 0) {
                      const t = new zh({ size: 1, sizeAttenuation: !1 }),
                        n = new xi();
                      n.setAttribute("position", new di(e.vertices, 3)),
                        e.colors.length > 0 &&
                          void 0 !== e.colors[0] &&
                          (n.setAttribute("color", new di(e.colors, 3)),
                          (t.vertexColors = !0));
                      const r = new Hh(n, t);
                      i.add(r);
                    }
                    return i;
                  }
                }
                class Ub extends lp {
                  constructor(t) {
                    super(t);
                  }
                  parse(t, e) {
                    const n = {
                        mipmaps: [],
                        width: 0,
                        height: 0,
                        format: null,
                        mipmapCount: 1,
                      },
                      r = 542327876,
                      i = 131072,
                      a = 512,
                      o = 1024,
                      s = 2048,
                      c = 4096,
                      l = 8192,
                      u = 16384,
                      h = 32768;
                    function d(t) {
                      return (
                        t.charCodeAt(0) +
                        (t.charCodeAt(1) << 8) +
                        (t.charCodeAt(2) << 16) +
                        (t.charCodeAt(3) << 24)
                      );
                    }
                    function f(t) {
                      return String.fromCharCode(
                        255 & t,
                        (t >> 8) & 255,
                        (t >> 16) & 255,
                        (t >> 24) & 255
                      );
                    }
                    function p(t, e, n, r) {
                      const i = n * r * 4,
                        a = new Uint8Array(t, e, i),
                        o = new Uint8Array(i);
                      let s = 0,
                        c = 0;
                      for (let l = 0; l < r; l++)
                        for (let t = 0; t < n; t++) {
                          const t = a[c];
                          c++;
                          const e = a[c];
                          c++;
                          const n = a[c];
                          c++;
                          const r = a[c];
                          c++,
                            (o[s] = n),
                            s++,
                            (o[s] = e),
                            s++,
                            (o[s] = t),
                            s++,
                            (o[s] = r),
                            s++;
                        }
                      return o;
                    }
                    const m = d("DXT1"),
                      g = d("DXT3"),
                      v = d("DXT5"),
                      y = d("ETC1"),
                      b = 31,
                      x = 0,
                      _ = 1,
                      w = 2,
                      S = 3,
                      M = 4,
                      T = 7,
                      E = 21,
                      A = 22,
                      C = 23,
                      L = 24,
                      R = 25,
                      P = 26,
                      I = 28,
                      O = new Int32Array(t, 0, b);
                    if (O[x] !== r)
                      return (
                        console.error(
                          "THREE.DDSLoader.parse: Invalid magic number in DDS header."
                        ),
                        n
                      );
                    let k;
                    const N = O[E];
                    let D = !1;
                    switch (N) {
                      case m:
                        (k = 8), (n.format = Vt);
                        break;
                      case g:
                        (k = 16), (n.format = Wt);
                        break;
                      case v:
                        (k = 16), (n.format = qt);
                        break;
                      case y:
                        (k = 8), (n.format = Kt);
                        break;
                      default:
                        if (
                          !(
                            32 === O[A] &&
                            16711680 & O[C] &&
                            65280 & O[L] &&
                            255 & O[R] &&
                            4278190080 & O[P]
                          )
                        )
                          return (
                            console.error(
                              "THREE.DDSLoader.parse: Unsupported FourCC code ",
                              f(N)
                            ),
                            n
                          );
                        (D = !0), (k = 64), (n.format = Ot);
                    }
                    (n.mipmapCount = 1),
                      O[w] & i &&
                        !1 !== e &&
                        (n.mipmapCount = Math.max(1, O[T]));
                    const z = O[I];
                    if (
                      ((n.isCubemap = !!(z & a)),
                      n.isCubemap &&
                        (!(z & o) ||
                          !(z & s) ||
                          !(z & c) ||
                          !(z & l) ||
                          !(z & u) ||
                          !(z & h)))
                    )
                      return (
                        console.error(
                          "THREE.DDSLoader.parse: Incomplete cubemap faces"
                        ),
                        n
                      );
                    (n.width = O[M]), (n.height = O[S]);
                    let F = O[_] + 4;
                    const U = n.isCubemap ? 6 : 1;
                    for (let B = 0; B < U; B++) {
                      let e = n.width,
                        r = n.height;
                      for (let i = 0; i < n.mipmapCount; i++) {
                        let i, a;
                        D
                          ? ((i = p(t, F, e, r)), (a = i.length))
                          : ((a =
                              (((Math.max(4, e) / 4) * Math.max(4, r)) / 4) *
                              k),
                            (i = new Uint8Array(t, F, a)));
                        const o = { data: i, width: e, height: r };
                        n.mipmaps.push(o),
                          (F += a),
                          (e = Math.max(e >> 1, 1)),
                          (r = Math.max(r >> 1, 1));
                      }
                    }
                    return n;
                  }
                }
                class Bb {
                  constructor(t, e, n) {
                    const r = this;
                    let i,
                      a = !1,
                      o = 0,
                      s = 0;
                    const c = [];
                    (this.onStart = void 0),
                      (this.onLoad = t),
                      (this.onProgress = e),
                      (this.onError = n),
                      (this.itemStart = function (t) {
                        s++,
                          !1 === a &&
                            void 0 !== r.onStart &&
                            r.onStart(t, o, s),
                          (a = !0);
                      }),
                      (this.itemEnd = function (t) {
                        o++,
                          void 0 !== r.onProgress && r.onProgress(t, o, s),
                          o === s &&
                            ((a = !1), void 0 !== r.onLoad && r.onLoad());
                      }),
                      (this.itemError = function (t) {
                        void 0 !== r.onError && r.onError(t);
                      }),
                      (this.resolveURL = function (t) {
                        return i ? i(t) : t;
                      }),
                      (this.setURLModifier = function (t) {
                        return (i = t), this;
                      }),
                      (this.addHandler = function (t, e) {
                        return c.push(t, e), this;
                      }),
                      (this.removeHandler = function (t) {
                        const e = c.indexOf(t);
                        return -1 !== e && c.splice(e, 2), this;
                      }),
                      (this.getHandler = function (t) {
                        for (let e = 0, n = c.length; e < n; e += 2) {
                          const n = c[e],
                            r = c[e + 1];
                          if ((n.global && (n.lastIndex = 0), n.test(t)))
                            return r;
                        }
                        return null;
                      });
                  }
                }
                new Bb();
                const jb = new In();
                class Hb extends op {
                  constructor(t) {
                    super(t), (this.propertyNameMapping = {});
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new cp(this.manager);
                    a.setPath(this.path),
                      a.setResponseType("arraybuffer"),
                      a.setRequestHeader(this.requestHeader),
                      a.setWithCredentials(this.withCredentials),
                      a.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  setPropertyNameMapping(t) {
                    this.propertyNameMapping = t;
                  }
                  parse(t) {
                    function e(t) {
                      const e = /^ply([\s\S]*)end_header(\r\n|\r|\n)/;
                      let n = "",
                        r = 0;
                      const i = e.exec(t);
                      null !== i && ((n = i[1]), (r = new Blob([i[0]]).size));
                      const a = {
                          comments: [],
                          elements: [],
                          headerLength: r,
                          objInfo: "",
                        },
                        o = n.split(/\r\n|\r|\n/);
                      let s;
                      function c(t, e) {
                        const n = { type: t[0] };
                        return (
                          "list" === n.type
                            ? ((n.name = t[3]),
                              (n.countType = t[1]),
                              (n.itemType = t[2]))
                            : (n.name = t[1]),
                          n.name in e && (n.name = e[n.name]),
                          n
                        );
                      }
                      for (let l = 0; l < o.length; l++) {
                        let t = o[l];
                        if (((t = t.trim()), "" === t)) continue;
                        const e = t.split(/\s+/),
                          n = e.shift();
                        switch (((t = e.join(" ")), n)) {
                          case "format":
                            (a.format = e[0]), (a.version = e[1]);
                            break;
                          case "comment":
                            a.comments.push(t);
                            break;
                          case "element":
                            void 0 !== s && a.elements.push(s),
                              (s = {}),
                              (s.name = e[0]),
                              (s.count = parseInt(e[1])),
                              (s.properties = []);
                            break;
                          case "property":
                            s.properties.push(c(e, h.propertyNameMapping));
                            break;
                          case "obj_info":
                            a.objInfo = t;
                            break;
                          default:
                            console.log("unhandled", n, e);
                        }
                      }
                      return void 0 !== s && a.elements.push(s), a;
                    }
                    function n(t, e) {
                      switch (e) {
                        case "char":
                        case "uchar":
                        case "short":
                        case "ushort":
                        case "int":
                        case "uint":
                        case "int8":
                        case "uint8":
                        case "int16":
                        case "uint16":
                        case "int32":
                        case "uint32":
                          return parseInt(t);
                        case "float":
                        case "double":
                        case "float32":
                        case "float64":
                          return parseFloat(t);
                      }
                    }
                    function r(t, e) {
                      const r = e.split(/\s+/),
                        i = {};
                      for (let a = 0; a < t.length; a++)
                        if ("list" === t[a].type) {
                          const e = [],
                            o = n(r.shift(), t[a].countType);
                          for (let i = 0; i < o; i++)
                            e.push(n(r.shift(), t[a].itemType));
                          i[t[a].name] = e;
                        } else i[t[a].name] = n(r.shift(), t[a].type);
                      return i;
                    }
                    function i(t, e) {
                      const n = {
                        indices: [],
                        vertices: [],
                        normals: [],
                        uvs: [],
                        faceVertexUvs: [],
                        colors: [],
                      };
                      let i;
                      const s = /end_header\s([\s\S]*)$/;
                      let c = "";
                      null !== (i = s.exec(t)) && (c = i[1]);
                      const l = c.split(/\r\n|\r|\n/);
                      let u = 0,
                        h = 0;
                      for (let a = 0; a < l.length; a++) {
                        let t = l[a];
                        if (((t = t.trim()), "" === t)) continue;
                        h >= e.elements[u].count && (u++, (h = 0));
                        const i = r(e.elements[u].properties, t);
                        o(n, e.elements[u].name, i), h++;
                      }
                      return a(n);
                    }
                    function a(t) {
                      let e = new xi();
                      return (
                        t.indices.length > 0 && e.setIndex(t.indices),
                        e.setAttribute("position", new di(t.vertices, 3)),
                        t.normals.length > 0 &&
                          e.setAttribute("normal", new di(t.normals, 3)),
                        t.uvs.length > 0 &&
                          e.setAttribute("uv", new di(t.uvs, 2)),
                        t.colors.length > 0 &&
                          e.setAttribute("color", new di(t.colors, 3)),
                        t.faceVertexUvs.length > 0 &&
                          ((e = e.toNonIndexed()),
                          e.setAttribute("uv", new di(t.faceVertexUvs, 2))),
                        e.computeBoundingSphere(),
                        e
                      );
                    }
                    function o(t, e, n) {
                      function r(t) {
                        for (let e = 0, r = t.length; e < r; e++) {
                          const r = t[e];
                          if (r in n) return r;
                        }
                        return null;
                      }
                      const i = r(["x", "px", "posx"]) || "x",
                        a = r(["y", "py", "posy"]) || "y",
                        o = r(["z", "pz", "posz"]) || "z",
                        s = r(["nx", "normalx"]),
                        c = r(["ny", "normaly"]),
                        l = r(["nz", "normalz"]),
                        u = r(["s", "u", "texture_u", "tx"]),
                        h = r(["t", "v", "texture_v", "ty"]),
                        d = r(["red", "diffuse_red", "r", "diffuse_r"]),
                        f = r(["green", "diffuse_green", "g", "diffuse_g"]),
                        p = r(["blue", "diffuse_blue", "b", "diffuse_b"]);
                      if ("vertex" === e)
                        t.vertices.push(n[i], n[a], n[o]),
                          null !== s &&
                            null !== c &&
                            null !== l &&
                            t.normals.push(n[s], n[c], n[l]),
                          null !== u && null !== h && t.uvs.push(n[u], n[h]),
                          null !== d &&
                            null !== f &&
                            null !== p &&
                            (jb
                              .setRGB(n[d] / 255, n[f] / 255, n[p] / 255)
                              .convertSRGBToLinear(),
                            t.colors.push(jb.r, jb.g, jb.b));
                      else if ("face" === e) {
                        const e = n.vertex_indices || n.vertex_index,
                          r = n.texcoord;
                        3 === e.length
                          ? (t.indices.push(e[0], e[1], e[2]),
                            r &&
                              6 === r.length &&
                              (t.faceVertexUvs.push(r[0], r[1]),
                              t.faceVertexUvs.push(r[2], r[3]),
                              t.faceVertexUvs.push(r[4], r[5])))
                          : 4 === e.length &&
                            (t.indices.push(e[0], e[1], e[3]),
                            t.indices.push(e[1], e[2], e[3]));
                      }
                    }
                    function s(t, e, n, r) {
                      switch (n) {
                        case "int8":
                        case "char":
                          return [t.getInt8(e), 1];
                        case "uint8":
                        case "uchar":
                          return [t.getUint8(e), 1];
                        case "int16":
                        case "short":
                          return [t.getInt16(e, r), 2];
                        case "uint16":
                        case "ushort":
                          return [t.getUint16(e, r), 2];
                        case "int32":
                        case "int":
                          return [t.getInt32(e, r), 4];
                        case "uint32":
                        case "uint":
                          return [t.getUint32(e, r), 4];
                        case "float32":
                        case "float":
                          return [t.getFloat32(e, r), 4];
                        case "float64":
                        case "double":
                          return [t.getFloat64(e, r), 8];
                      }
                    }
                    function c(t, e, n, r) {
                      const i = {};
                      let a,
                        o = 0;
                      for (let c = 0; c < n.length; c++)
                        if ("list" === n[c].type) {
                          const l = [];
                          a = s(t, e + o, n[c].countType, r);
                          const u = a[0];
                          o += a[1];
                          for (let i = 0; i < u; i++)
                            (a = s(t, e + o, n[c].itemType, r)),
                              l.push(a[0]),
                              (o += a[1]);
                          i[n[c].name] = l;
                        } else
                          (a = s(t, e + o, n[c].type, r)),
                            (i[n[c].name] = a[0]),
                            (o += a[1]);
                      return [i, o];
                    }
                    function l(t, e) {
                      const n = {
                          indices: [],
                          vertices: [],
                          normals: [],
                          uvs: [],
                          faceVertexUvs: [],
                          colors: [],
                        },
                        r = "binary_little_endian" === e.format,
                        i = new DataView(t, e.headerLength);
                      let s,
                        l = 0;
                      for (let a = 0; a < e.elements.length; a++)
                        for (let t = 0; t < e.elements[a].count; t++) {
                          (s = c(i, l, e.elements[a].properties, r)),
                            (l += s[1]);
                          const t = s[0];
                          o(n, e.elements[a].name, t);
                        }
                      return a(n);
                    }
                    let u;
                    const h = this;
                    if (t instanceof ArrayBuffer) {
                      const n = Op.decodeText(new Uint8Array(t)),
                        r = e(n);
                      u = "ascii" === r.format ? i(n, r) : l(t, r);
                    } else u = i(t, e(t));
                    return u;
                  }
                }
                class Vb extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = new cp(this.manager);
                    a.setPath(this.path),
                      a.setResponseType("arraybuffer"),
                      a.setRequestHeader(this.requestHeader),
                      a.setWithCredentials(this.withCredentials),
                      a.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  parse(t) {
                    function e(t) {
                      const e = new DataView(t),
                        r = 50,
                        i = e.getUint32(80, !0),
                        a = 84 + i * r;
                      if (a === e.byteLength) return !0;
                      const o = [115, 111, 108, 105, 100];
                      for (let s = 0; s < 5; s++) if (n(o, e, s)) return !1;
                      return !0;
                    }
                    function n(t, e, n) {
                      for (let r = 0, i = t.length; r < i; r++)
                        if (t[r] !== e.getUint8(n + r)) return !1;
                      return !0;
                    }
                    function r(t) {
                      const e = new DataView(t),
                        n = e.getUint32(80, !0);
                      let r,
                        i,
                        a,
                        o,
                        s,
                        c,
                        l,
                        u,
                        h = !1;
                      for (let v = 0; v < 70; v++)
                        1129270351 == e.getUint32(v, !1) &&
                          82 == e.getUint8(v + 4) &&
                          61 == e.getUint8(v + 5) &&
                          ((h = !0),
                          (o = new Float32Array(3 * n * 3)),
                          (s = e.getUint8(v + 6) / 255),
                          (c = e.getUint8(v + 7) / 255),
                          (l = e.getUint8(v + 8) / 255),
                          (u = e.getUint8(v + 9) / 255));
                      const d = 84,
                        f = 50,
                        p = new xi(),
                        m = new Float32Array(3 * n * 3),
                        g = new Float32Array(3 * n * 3);
                      for (let v = 0; v < n; v++) {
                        const t = d + v * f,
                          n = e.getFloat32(t, !0),
                          u = e.getFloat32(t + 4, !0),
                          p = e.getFloat32(t + 8, !0);
                        if (h) {
                          const n = e.getUint16(t + 48, !0);
                          0 === (32768 & n)
                            ? ((r = (31 & n) / 31),
                              (i = ((n >> 5) & 31) / 31),
                              (a = ((n >> 10) & 31) / 31))
                            : ((r = s), (i = c), (a = l));
                        }
                        for (let s = 1; s <= 3; s++) {
                          const c = t + 12 * s,
                            l = 3 * v * 3 + 3 * (s - 1);
                          (m[l] = e.getFloat32(c, !0)),
                            (m[l + 1] = e.getFloat32(c + 4, !0)),
                            (m[l + 2] = e.getFloat32(c + 8, !0)),
                            (g[l] = n),
                            (g[l + 1] = u),
                            (g[l + 2] = p),
                            h && ((o[l] = r), (o[l + 1] = i), (o[l + 2] = a));
                        }
                      }
                      return (
                        p.setAttribute("position", new li(m, 3)),
                        p.setAttribute("normal", new li(g, 3)),
                        h &&
                          (p.setAttribute("color", new li(o, 3)),
                          (p.hasColors = !0),
                          (p.alpha = u)),
                        p
                      );
                    }
                    function i(t) {
                      const e = new xi(),
                        n = /solid([\s\S]*?)endsolid/g,
                        r = /facet([\s\S]*?)endfacet/g;
                      let i = 0;
                      const a = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/
                          .source,
                        o = new RegExp("vertex" + a + a + a, "g"),
                        s = new RegExp("normal" + a + a + a, "g"),
                        c = [],
                        l = [],
                        u = new Gn();
                      let h,
                        d = 0,
                        f = 0,
                        p = 0;
                      while (null !== (h = n.exec(t))) {
                        f = p;
                        const t = h[0];
                        while (null !== (h = r.exec(t))) {
                          let t = 0,
                            e = 0;
                          const n = h[0];
                          while (null !== (h = s.exec(n)))
                            (u.x = parseFloat(h[1])),
                              (u.y = parseFloat(h[2])),
                              (u.z = parseFloat(h[3])),
                              e++;
                          while (null !== (h = o.exec(n)))
                            c.push(
                              parseFloat(h[1]),
                              parseFloat(h[2]),
                              parseFloat(h[3])
                            ),
                              l.push(u.x, u.y, u.z),
                              t++,
                              p++;
                          1 !== e &&
                            console.error(
                              "THREE.STLLoader: Something isn't right with the normal of face number " +
                                i
                            ),
                            3 !== t &&
                              console.error(
                                "THREE.STLLoader: Something isn't right with the vertices of face number " +
                                  i
                              ),
                            i++;
                        }
                        const n = f,
                          a = p - f;
                        e.addGroup(n, a, d), d++;
                      }
                      return (
                        e.setAttribute("position", new di(c, 3)),
                        e.setAttribute("normal", new di(l, 3)),
                        e
                      );
                    }
                    function a(t) {
                      return "string" !== typeof t
                        ? Op.decodeText(new Uint8Array(t))
                        : t;
                    }
                    function o(t) {
                      if ("string" === typeof t) {
                        const e = new Uint8Array(t.length);
                        for (let n = 0; n < t.length; n++)
                          e[n] = 255 & t.charCodeAt(n);
                        return e.buffer || e;
                      }
                      return t;
                    }
                    const s = o(t);
                    return e(s) ? r(s) : i(a(t));
                  }
                }
                class Gb extends op {
                  constructor(t) {
                    super(t);
                  }
                  load(t, e, n, r) {
                    const i = this,
                      a = "" === this.path ? Op.extractUrlBase(t) : this.path,
                      o = new cp(this.manager);
                    o.setPath(this.path),
                      o.setRequestHeader(this.requestHeader),
                      o.setWithCredentials(this.withCredentials),
                      o.load(
                        t,
                        function (n) {
                          try {
                            e(i.parse(n, a));
                          } catch (dx) {
                            r ? r(dx) : console.error(dx),
                              i.manager.itemError(t);
                          }
                        },
                        n,
                        r
                      );
                  }
                  setMaterialOptions(t) {
                    return (this.materialOptions = t), this;
                  }
                  parse(t, e) {
                    const n = t.split("\n");
                    let r = {};
                    const i = /\s+/,
                      a = {};
                    for (let s = 0; s < n.length; s++) {
                      let t = n[s];
                      if (
                        ((t = t.trim()), 0 === t.length || "#" === t.charAt(0))
                      )
                        continue;
                      const e = t.indexOf(" ");
                      let o = e >= 0 ? t.substring(0, e) : t;
                      o = o.toLowerCase();
                      let c = e >= 0 ? t.substring(e + 1) : "";
                      if (((c = c.trim()), "newmtl" === o))
                        (r = { name: c }), (a[c] = r);
                      else if (
                        "ka" === o ||
                        "kd" === o ||
                        "ks" === o ||
                        "ke" === o
                      ) {
                        const t = c.split(i, 3);
                        r[o] = [
                          parseFloat(t[0]),
                          parseFloat(t[1]),
                          parseFloat(t[2]),
                        ];
                      } else r[o] = c;
                    }
                    const o = new Wb(
                      this.resourcePath || e,
                      this.materialOptions
                    );
                    return (
                      o.setCrossOrigin(this.crossOrigin),
                      o.setManager(this.manager),
                      o.setMaterials(a),
                      o
                    );
                  }
                }
                class Wb {
                  constructor(t = "", e = {}) {
                    (this.baseUrl = t),
                      (this.options = e),
                      (this.materialsInfo = {}),
                      (this.materials = {}),
                      (this.materialsArray = []),
                      (this.nameLookup = {}),
                      (this.crossOrigin = "anonymous"),
                      (this.side =
                        void 0 !== this.options.side ? this.options.side : g),
                      (this.wrap =
                        void 0 !== this.options.wrap ? this.options.wrap : ht);
                  }
                  setCrossOrigin(t) {
                    return (this.crossOrigin = t), this;
                  }
                  setManager(t) {
                    this.manager = t;
                  }
                  setMaterials(t) {
                    (this.materialsInfo = this.convert(t)),
                      (this.materials = {}),
                      (this.materialsArray = []),
                      (this.nameLookup = {});
                  }
                  convert(t) {
                    if (!this.options) return t;
                    const e = {};
                    for (const n in t) {
                      const r = t[n],
                        i = {};
                      e[n] = i;
                      for (const t in r) {
                        let e = !0,
                          n = r[t];
                        const a = t.toLowerCase();
                        switch (a) {
                          case "kd":
                          case "ka":
                          case "ks":
                            this.options &&
                              this.options.normalizeRGB &&
                              (n = [n[0] / 255, n[1] / 255, n[2] / 255]),
                              this.options &&
                                this.options.ignoreZeroRGBs &&
                                0 === n[0] &&
                                0 === n[1] &&
                                0 === n[2] &&
                                (e = !1);
                            break;
                          default:
                            break;
                        }
                        e && (i[a] = n);
                      }
                    }
                    return e;
                  }
                  preload() {
                    for (const t in this.materialsInfo) this.create(t);
                  }
                  getIndex(t) {
                    return this.nameLookup[t];
                  }
                  getAsArray() {
                    let t = 0;
                    for (const e in this.materialsInfo)
                      (this.materialsArray[t] = this.create(e)),
                        (this.nameLookup[e] = t),
                        t++;
                    return this.materialsArray;
                  }
                  create(t) {
                    return (
                      void 0 === this.materials[t] && this.createMaterial_(t),
                      this.materials[t]
                    );
                  }
                  createMaterial_(t) {
                    const e = this,
                      n = this.materialsInfo[t],
                      r = { name: t, side: this.side };
                    function i(t, e) {
                      return "string" !== typeof e || "" === e
                        ? ""
                        : /^https?:\/\//i.test(e)
                        ? e
                        : t + e;
                    }
                    function a(t, n) {
                      if (r[t]) return;
                      const a = e.getTextureParams(n, r),
                        o = e.loadTexture(i(e.baseUrl, a.url));
                      o.repeat.copy(a.scale),
                        o.offset.copy(a.offset),
                        (o.wrapS = e.wrap),
                        (o.wrapT = e.wrap),
                        ("map" !== t && "emissiveMap" !== t) ||
                          (o.encoding = Le),
                        (r[t] = o);
                    }
                    for (const o in n) {
                      const t = n[o];
                      let e;
                      if ("" !== t)
                        switch (o.toLowerCase()) {
                          case "kd":
                            r.color = new In()
                              .fromArray(t)
                              .convertSRGBToLinear();
                            break;
                          case "ks":
                            r.specular = new In()
                              .fromArray(t)
                              .convertSRGBToLinear();
                            break;
                          case "ke":
                            r.emissive = new In()
                              .fromArray(t)
                              .convertSRGBToLinear();
                            break;
                          case "map_kd":
                            a("map", t);
                            break;
                          case "map_ks":
                            a("specularMap", t);
                            break;
                          case "map_ke":
                            a("emissiveMap", t);
                            break;
                          case "norm":
                            a("normalMap", t);
                            break;
                          case "map_bump":
                          case "bump":
                            a("bumpMap", t);
                            break;
                          case "map_d":
                            a("alphaMap", t), (r.transparent = !0);
                            break;
                          case "ns":
                            r.shininess = parseFloat(t);
                            break;
                          case "d":
                            (e = parseFloat(t)),
                              e < 1 && ((r.opacity = e), (r.transparent = !0));
                            break;
                          case "tr":
                            (e = parseFloat(t)),
                              this.options &&
                                this.options.invertTrProperty &&
                                (e = 1 - e),
                              e > 0 &&
                                ((r.opacity = 1 - e), (r.transparent = !0));
                            break;
                          default:
                            break;
                        }
                    }
                    return (this.materials[t] = new Nf(r)), this.materials[t];
                  }
                  getTextureParams(t, e) {
                    const n = { scale: new gn(1, 1), offset: new gn(0, 0) },
                      r = t.split(/\s+/);
                    let i;
                    return (
                      (i = r.indexOf("-bm")),
                      i >= 0 &&
                        ((e.bumpScale = parseFloat(r[i + 1])), r.splice(i, 2)),
                      (i = r.indexOf("-s")),
                      i >= 0 &&
                        (n.scale.set(
                          parseFloat(r[i + 1]),
                          parseFloat(r[i + 2])
                        ),
                        r.splice(i, 4)),
                      (i = r.indexOf("-o")),
                      i >= 0 &&
                        (n.offset.set(
                          parseFloat(r[i + 1]),
                          parseFloat(r[i + 2])
                        ),
                        r.splice(i, 4)),
                      (n.url = r.join(" ").trim()),
                      n
                    );
                  }
                  loadTexture(t, e, n, r, i) {
                    const a = void 0 !== this.manager ? this.manager : ap;
                    let o = a.getHandler(t);
                    null === o && (o = new dp(a)),
                      o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin);
                    const s = o.load(t, n, r, i);
                    return void 0 !== e && (s.mapping = e), s;
                  }
                }
                const qb = new WeakMap();
                class Xb extends op {
                  constructor(t) {
                    super(t),
                      (this.decoderPath = ""),
                      (this.decoderConfig = {}),
                      (this.decoderBinary = null),
                      (this.decoderPending = null),
                      (this.workerLimit = 4),
                      (this.workerPool = []),
                      (this.workerNextTaskID = 1),
                      (this.workerSourceURL = ""),
                      (this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD",
                      }),
                      (this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array",
                      });
                  }
                  setDecoderPath(t) {
                    return (this.decoderPath = t), this;
                  }
                  setDecoderConfig(t) {
                    return (this.decoderConfig = t), this;
                  }
                  setWorkerLimit(t) {
                    return (this.workerLimit = t), this;
                  }
                  load(t, e, n, r) {
                    const i = new cp(this.manager);
                    i.setPath(this.path),
                      i.setResponseType("arraybuffer"),
                      i.setRequestHeader(this.requestHeader),
                      i.setWithCredentials(this.withCredentials),
                      i.load(
                        t,
                        (t) => {
                          const n = {
                            attributeIDs: this.defaultAttributeIDs,
                            attributeTypes: this.defaultAttributeTypes,
                            useUniqueIDs: !1,
                          };
                          this.decodeGeometry(t, n).then(e).catch(r);
                        },
                        n,
                        r
                      );
                  }
                  decodeDracoFile(t, e, n, r) {
                    const i = {
                      attributeIDs: n || this.defaultAttributeIDs,
                      attributeTypes: r || this.defaultAttributeTypes,
                      useUniqueIDs: !!n,
                    };
                    this.decodeGeometry(t, i).then(e);
                  }
                  decodeGeometry(t, e) {
                    for (const s in e.attributeTypes) {
                      const t = e.attributeTypes[s];
                      void 0 !== t.BYTES_PER_ELEMENT &&
                        (e.attributeTypes[s] = t.name);
                    }
                    const n = JSON.stringify(e);
                    if (qb.has(t)) {
                      const e = qb.get(t);
                      if (e.key === n) return e.promise;
                      if (0 === t.byteLength)
                        throw new Error(
                          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
                        );
                    }
                    let r;
                    const i = this.workerNextTaskID++,
                      a = t.byteLength,
                      o = this._getWorker(i, a)
                        .then(
                          (n) => (
                            (r = n),
                            new Promise((n, a) => {
                              (r._callbacks[i] = { resolve: n, reject: a }),
                                r.postMessage(
                                  {
                                    type: "decode",
                                    id: i,
                                    taskConfig: e,
                                    buffer: t,
                                  },
                                  [t]
                                );
                            })
                          )
                        )
                        .then((t) => this._createGeometry(t.geometry));
                    return (
                      o
                        .catch(() => !0)
                        .then(() => {
                          r && i && this._releaseTask(r, i);
                        }),
                      qb.set(t, { key: n, promise: o }),
                      o
                    );
                  }
                  _createGeometry(t) {
                    const e = new xi();
                    t.index && e.setIndex(new li(t.index.array, 1));
                    for (let n = 0; n < t.attributes.length; n++) {
                      const r = t.attributes[n],
                        i = r.name,
                        a = r.array,
                        o = r.itemSize;
                      e.setAttribute(i, new li(a, o));
                    }
                    return e;
                  }
                  _loadLibrary(t, e) {
                    const n = new cp(this.manager);
                    return (
                      n.setPath(this.decoderPath),
                      n.setResponseType(e),
                      n.setWithCredentials(this.withCredentials),
                      new Promise((e, r) => {
                        n.load(t, e, void 0, r);
                      })
                    );
                  }
                  preload() {
                    return this._initDecoder(), this;
                  }
                  _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const t =
                        "object" !== typeof WebAssembly ||
                        "js" === this.decoderConfig.type,
                      e = [];
                    return (
                      t
                        ? e.push(this._loadLibrary("draco_decoder.js", "text"))
                        : (e.push(
                            this._loadLibrary("draco_wasm_wrapper.js", "text")
                          ),
                          e.push(
                            this._loadLibrary(
                              "draco_decoder.wasm",
                              "arraybuffer"
                            )
                          )),
                      (this.decoderPending = Promise.all(e).then((e) => {
                        const n = e[0];
                        t || (this.decoderConfig.wasmBinary = e[1]);
                        const r = $b.toString(),
                          i = [
                            "/* draco decoder */",
                            n,
                            "",
                            "/* worker */",
                            r.substring(r.indexOf("{") + 1, r.lastIndexOf("}")),
                          ].join("\n");
                        this.workerSourceURL = URL.createObjectURL(
                          new Blob([i])
                        );
                      })),
                      this.decoderPending
                    );
                  }
                  _getWorker(t, e) {
                    return this._initDecoder().then(() => {
                      if (this.workerPool.length < this.workerLimit) {
                        const t = new Worker(this.workerSourceURL);
                        (t._callbacks = {}),
                          (t._taskCosts = {}),
                          (t._taskLoad = 0),
                          t.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig,
                          }),
                          (t.onmessage = function (e) {
                            const n = e.data;
                            switch (n.type) {
                              case "decode":
                                t._callbacks[n.id].resolve(n);
                                break;
                              case "error":
                                t._callbacks[n.id].reject(n);
                                break;
                              default:
                                console.error(
                                  'THREE.DRACOLoader: Unexpected message, "' +
                                    n.type +
                                    '"'
                                );
                            }
                          }),
                          this.workerPool.push(t);
                      } else
                        this.workerPool.sort(function (t, e) {
                          return t._taskLoad > e._taskLoad ? -1 : 1;
                        });
                      const n = this.workerPool[this.workerPool.length - 1];
                      return (n._taskCosts[t] = e), (n._taskLoad += e), n;
                    });
                  }
                  _releaseTask(t, e) {
                    (t._taskLoad -= t._taskCosts[e]),
                      delete t._callbacks[e],
                      delete t._taskCosts[e];
                  }
                  debug() {
                    console.log(
                      "Task load: ",
                      this.workerPool.map((t) => t._taskLoad)
                    );
                  }
                  dispose() {
                    for (let t = 0; t < this.workerPool.length; ++t)
                      this.workerPool[t].terminate();
                    return (this.workerPool.length = 0), this;
                  }
                }
                function $b() {
                  let t, e;
                  function n(t, e, n, a) {
                    const o = a.attributeIDs,
                      s = a.attributeTypes;
                    let c, l;
                    const u = e.GetEncodedGeometryType(n);
                    if (u === t.TRIANGULAR_MESH)
                      (c = new t.Mesh()), (l = e.DecodeBufferToMesh(n, c));
                    else {
                      if (u !== t.POINT_CLOUD)
                        throw new Error(
                          "THREE.DRACOLoader: Unexpected geometry type."
                        );
                      (c = new t.PointCloud()),
                        (l = e.DecodeBufferToPointCloud(n, c));
                    }
                    if (!l.ok() || 0 === c.ptr)
                      throw new Error(
                        "THREE.DRACOLoader: Decoding failed: " + l.error_msg()
                      );
                    const h = { index: null, attributes: [] };
                    for (const r in o) {
                      const n = self[s[r]];
                      let l, u;
                      if (a.useUniqueIDs)
                        (u = o[r]), (l = e.GetAttributeByUniqueId(c, u));
                      else {
                        if (((u = e.GetAttributeId(c, t[o[r]])), -1 === u))
                          continue;
                        l = e.GetAttribute(c, u);
                      }
                      h.attributes.push(i(t, e, c, r, n, l));
                    }
                    return (
                      u === t.TRIANGULAR_MESH && (h.index = r(t, e, c)),
                      t.destroy(c),
                      h
                    );
                  }
                  function r(t, e, n) {
                    const r = n.num_faces(),
                      i = 3 * r,
                      a = 4 * i,
                      o = t._malloc(a);
                    e.GetTrianglesUInt32Array(n, a, o);
                    const s = new Uint32Array(t.HEAPF32.buffer, o, i).slice();
                    return t._free(o), { array: s, itemSize: 1 };
                  }
                  function i(t, e, n, r, i, o) {
                    const s = o.num_components(),
                      c = n.num_points(),
                      l = c * s,
                      u = l * i.BYTES_PER_ELEMENT,
                      h = a(t, i),
                      d = t._malloc(u);
                    e.GetAttributeDataArrayForAllPoints(n, o, h, u, d);
                    const f = new i(t.HEAPF32.buffer, d, l).slice();
                    return t._free(d), { name: r, array: f, itemSize: s };
                  }
                  function a(t, e) {
                    switch (e) {
                      case Float32Array:
                        return t.DT_FLOAT32;
                      case Int8Array:
                        return t.DT_INT8;
                      case Int16Array:
                        return t.DT_INT16;
                      case Int32Array:
                        return t.DT_INT32;
                      case Uint8Array:
                        return t.DT_UINT8;
                      case Uint16Array:
                        return t.DT_UINT16;
                      case Uint32Array:
                        return t.DT_UINT32;
                    }
                  }
                  onmessage = function (r) {
                    const i = r.data;
                    switch (i.type) {
                      case "init":
                        (t = i.decoderConfig),
                          (e = new Promise(function (e) {
                            (t.onModuleLoaded = function (t) {
                              e({ draco: t });
                            }),
                              DracoDecoderModule(t);
                          }));
                        break;
                      case "decode":
                        const r = i.buffer,
                          a = i.taskConfig;
                        e.then((t) => {
                          const e = t.draco,
                            o = new e.Decoder(),
                            s = new e.DecoderBuffer();
                          s.Init(new Int8Array(r), r.byteLength);
                          try {
                            const t = n(e, o, s, a),
                              r = t.attributes.map((t) => t.array.buffer);
                            t.index && r.push(t.index.array.buffer),
                              self.postMessage(
                                { type: "decode", id: i.id, geometry: t },
                                r
                              );
                          } catch (c) {
                            console.error(c),
                              self.postMessage({
                                type: "error",
                                id: i.id,
                                error: c.message,
                              });
                          } finally {
                            e.destroy(s), e.destroy(o);
                          }
                        });
                        break;
                    }
                  };
                }
                const Yb = new Xn(),
                  Jb = new Bb();
                function Kb(t) {
                  return Yb.setFromObject(t), Yb.getSize(new Gn());
                }
                function Zb(t) {
                  return Yb.setFromObject(t), Yb.getCenter(new Gn());
                }
                function Qb(t) {
                  const e = t.split(".");
                  if (e.length <= 1) return "";
                  {
                    let t = e.pop();
                    return (t = t.toLowerCase()), t;
                  }
                }
                function tx(t, e, n, r = "") {
                  let i;
                  (i = e || Qb(t)), "glb" === i && (i = "gltf");
                  let a = { loader: null, getObject: null };
                  switch (i) {
                    case "dae":
                      a = { loader: new Cy(Jb), getObject: (t) => t.scene };
                      break;
                    case "fbx":
                      a = { loader: new iy(Jb) };
                      break;
                    case "gltf":
                      (a = {
                        loader: new Ly(Jb),
                        getObject: (t) => {
                          const e = t.scene;
                          return e;
                        },
                      }),
                        nx(n, a, r);
                      break;
                    case "obj":
                      a = { loader: new Fb(Jb) };
                      break;
                    case "ply":
                      a = {
                        loader: new Hb(Jb),
                        getObject: (t) => (
                          t.computeVertexNormals(), new Fi(t, new Of())
                        ),
                      };
                      break;
                    case "stl":
                      a = {
                        loader: new Vb(Jb),
                        getObject: (t) => new Fi(t, new Nf()),
                      };
                      break;
                    case "json":
                      a = { loader: new Dp(Jb) };
                      break;
                  }
                  return a;
                }
                function ex() {
                  const t = new Gb(Jb);
                  return t;
                }
                function nx(t, e, n = "") {
                  if (t) {
                    const t = new Xb();
                    t.setDecoderPath(n || "assets/draco/gltf/"),
                      t.setDecoderConfig({ type: "js" }),
                      e.loader.setDRACOLoader(t);
                  }
                }
                Jb.addHandler(/\.dds$/i, new Ub()),
                  Jb.addHandler(/\.tga$/i, new Ay());
                var rx = {
                    name: "vue3dLoader",
                    props: {
                      filePath: { type: [String, Array] },
                      fileType: { type: [String, Array] },
                      width: Number,
                      height: Number,
                      position: { type: [Object, Array] },
                      rotation: { type: [Object, Array] },
                      scale: {
                        type: [Object, Array],
                        default: () => ({ x: 1, y: 1, z: 1 }),
                      },
                      lights: {
                        type: Array,
                        default: () => [
                          { type: "AmbientLight", color: 11184810 },
                          {
                            type: "DirectionalLight",
                            position: { x: 1, y: 1, z: 1 },
                            color: 16777215,
                            intensity: 0.8,
                          },
                        ],
                      },
                      cameraPosition: {
                        type: Object,
                        default: () => ({ x: 0, y: 0, z: 0 }),
                      },
                      cameraRotation: Object,
                      cameraUp: Object,
                      cameraLookAt: Object,
                      backgroundColor: {
                        typeof: [Number, String],
                        default: () => 16777215,
                      },
                      backgroundAlpha: { type: Number, default: 1 },
                      controlsOptions: Object,
                      crossOrigin: { type: String, default: "anonymous" },
                      requestHeader: { type: Object, default: () => {} },
                      outputEncoding: { type: String, default: "linear" },
                      webGLRendererOptions: Object,
                      mtlPath: { type: [String, Array] },
                      showFps: { type: Boolean, default: !1 },
                      textureImage: { type: [String, Array] },
                      clearScene: { type: Boolean, default: () => !1 },
                      parallelLoad: { type: Boolean, default: () => !1 },
                      labels: Array,
                      autoPlay: { type: Boolean, default: () => !0 },
                      enableDraco: { type: Boolean, default: () => !1 },
                      dracoDir: String,
                      intersectRecursive: { type: Boolean, default: () => !1 },
                    },
                    data() {
                      const t = {
                        size: { width: this.width, height: this.height },
                        object: null,
                        raycaster: new am(),
                        camera: new Yi(45, 1, 1, 1e5),
                        scene: new Bu(),
                        wrapper: new qr(),
                        renderer: null,
                        controls: null,
                        allLights: [],
                        clock: new jp(),
                        loader: null,
                        requestAnimationId: null,
                        stats: null,
                        mixer: null,
                        textureLoader: null,
                        css2DRenderer: null,
                      };
                      return (
                        Object.assign(this, t),
                        {
                          loaderIndex: 0,
                          timer: null,
                          objectPositionHasSet: !1,
                          isMultipleModels: !1,
                        }
                      );
                    },
                    mounted() {
                      this.filePath &&
                        "object" === typeof this.filePath &&
                        (this.isMultipleModels = !0);
                      const t = this.$refs.container;
                      this.onResize();
                      const e = { antialias: !0, alpha: !0 },
                        n = Object.assign({}, e, this.webGLRendererOptions, {
                          canvas: this.$refs.canvas,
                        });
                      (this.renderer = new Du(n)),
                        (this.renderer.hadowMapEnabled = !0),
                        (this.renderer.shadowMap.enabled = !0),
                        (this.renderer.outputEncoding =
                          "linear" === this.outputEncoding ? Ce : Le),
                        (this.controls = new xm(this.camera, t)),
                        this.scene.add(this.wrapper),
                        this.loadModelSelect(),
                        this.update(),
                        t.addEventListener("mousedown", this.onMouseDown, !1),
                        this.enableMousemoveEvent(this.enableMousemove),
                        t.addEventListener("mouseup", this.onMouseUp, !1),
                        t.addEventListener("click", this.onClick, !1),
                        t.addEventListener("dblclick", this.onDblclick, !1),
                        window.addEventListener("resize", this.onResize, !1),
                        this.showFps &&
                          ((this.stats = new wm()),
                          t.appendChild(this.stats.dom)),
                        this.animate();
                    },
                    beforeDestroy() {
                      cancelAnimationFrame(this.requestAnimationId),
                        this.renderer.dispose(),
                        this.controls && this.controls.dispose();
                      const t = this.$refs.container;
                      this.enableMousemoveEvent(!0),
                        t.removeEventListener(
                          "mousedown",
                          this.onMouseDown,
                          !1
                        ),
                        t.removeEventListener(
                          "mousemove",
                          this.onMouseMove,
                          !1
                        ),
                        t.removeEventListener("mouseup", this.onMouseUp, !1),
                        t.removeEventListener("click", this.onClick, !1),
                        t.removeEventListener("dblclick", this.onDblclick, !1),
                        window.removeEventListener("resize", this.onResize, !1);
                    },
                    watch: {
                      filePath() {
                        this.loadModelSelect();
                      },
                      fileType() {
                        this.loadModelSelect();
                      },
                      rotation: {
                        deep: !0,
                        handler(t) {
                          this.setObjectAttr("rotation", t);
                        },
                      },
                      position: {
                        deep: !0,
                        handler(t) {
                          this.setObjectAttr("position", t);
                        },
                      },
                      scale: {
                        deep: !0,
                        handler(t) {
                          this.setObjectAttr("scale", t);
                        },
                      },
                      lights: {
                        deep: !0,
                        handler() {
                          this.updateLights();
                        },
                      },
                      size: {
                        deep: !0,
                        handler() {
                          this.updateCamera(), this.updateRenderer();
                        },
                      },
                      controlsOptions: {
                        deep: !0,
                        handler() {
                          this.updateControls();
                        },
                      },
                      backgroundAlpha() {
                        this.updateRenderer();
                      },
                      backgroundColor() {
                        this.updateRenderer();
                      },
                      cameraRotation: {
                        deep: !0,
                        handler() {
                          this.updateCamera();
                        },
                      },
                      cameraPosition: {
                        deep: !0,
                        handler() {
                          this.updateCamera();
                        },
                      },
                      clearScene(t) {
                        t && this.clearSceneWrapper();
                      },
                      autoPlay() {
                        this.playAnimations();
                      },
                    },
                    methods: {
                      onResize() {
                        (this.width && this.height) ||
                          this.$nextTick(() => {
                            let t = this.$refs.container;
                            (this.size = {
                              width: this.width ? this.width : t.offsetWidth,
                              height: this.height
                                ? this.height
                                : t.offsetHeight,
                            }),
                              this.update(!0);
                          });
                      },
                      enableMousemoveEvent(t) {
                        const e = this.$refs.container;
                        t
                          ? e.addEventListener(
                              "mousemove",
                              this.onMouseMove,
                              !1
                            )
                          : e.removeEventListener(
                              "mousemove",
                              this.onMouseMove,
                              !1
                            );
                      },
                      onMouseDown(t) {
                        this.enableMousemoveEvent(!1);
                        const e = this.pick(t.clientX, t.clientY);
                        this.$emit("mousedown", t, e);
                      },
                      onMouseMove(t) {
                        const e = this.pick(t.clientX, t.clientY);
                        this.$emit("mousemove", t, e);
                      },
                      onMouseUp(t) {
                        const e = this.pick(t.clientX, t.clientY);
                        this.$emit("mouseup", t, e),
                          this.enableMousemoveEvent(!0);
                      },
                      onClick(t) {
                        const e = this.pick(t.clientX, t.clientY);
                        this.$emit("click", t, e);
                      },
                      onDblclick(t) {
                        const e = this.pick(t.clientX, t.clientY);
                        this.$emit("dblclick", t, e);
                      },
                      pick(t, e) {
                        let n = this.returnObject();
                        if (!n) return null;
                        if (!this.$refs.container) return;
                        const r = this.$refs.container.getBoundingClientRect();
                        (t -= r.left), (e -= r.top);
                        const i = new gn(0, 0);
                        (i.x = (t / this.size.width) * 2 - 1),
                          (i.y = (-e / this.size.height) * 2 + 1),
                          this.raycaster.setFromCamera(i, this.camera);
                        const a = this.raycaster.intersectObject(
                          n,
                          this.intersectRecursive
                        );
                        return (a && a.length) > 0 ? a[0] : null;
                      },
                      update(t = !1) {
                        this.updateRenderer(),
                          this.updateCamera(t),
                          this.updateLights(),
                          this.updateControls();
                      },
                      updateModel() {
                        const {
                          object: t,
                          position: e,
                          rotation: n,
                          scale: r,
                        } = this;
                        if (!t) return;
                        const i = (t) => t instanceof Array,
                          a = this.isMultipleModels
                            ? this.getObjectIndex(t)
                            : null;
                        e &&
                          (i(e)
                            ? e[a]
                              ? t.position.set(e[a].x, e[a].y, e[a].z)
                              : t.position.set(0, 0, 0)
                            : t.position.set(e.x, e.y, e.z)),
                          n &&
                            (i(n)
                              ? n[a]
                                ? t.rotation.set(n[a].x, n[a].y, n[a].z)
                                : t.rotation.set(0, 0, 0)
                              : t.rotation.set(n.x, n.y, n.z)),
                          r &&
                            (i(r)
                              ? r[a]
                                ? t.scale.set(r[a].x, r[a].y, r[a].z)
                                : t.scale.set(1, 1, 1)
                              : t.scale.set(r.x, r.y, r.z));
                      },
                      getObjectIndex(t) {
                        return this.filePath
                          .map((e, n) => {
                            if (e.indexOf(t.fileName) > -1) return n;
                          })
                          .filter((t) => void 0 != t)[0];
                      },
                      updateRenderer() {
                        const {
                          renderer: t,
                          size: e,
                          backgroundAlpha: n,
                          backgroundColor: r,
                        } = this;
                        t.setSize(e.width, e.height),
                          t.setPixelRatio(window.devicePixelRatio || 1),
                          t.setClearColor(new In(r).getHex()),
                          t.setClearAlpha(n);
                      },
                      updateCamera(t = !1) {
                        const {
                          size: e,
                          camera: n,
                          object: r,
                          cameraLookAt: i,
                          cameraUp: a,
                          cameraPosition: o,
                          cameraRotation: s,
                        } = this;
                        if (
                          ((n.aspect = e.width / e.height),
                          n.updateProjectionMatrix(),
                          !t)
                        )
                          if (i && a)
                            n.position.set(o.x, o.y, o.z),
                              s && n.rotation.set(s.x, s.y, s.z),
                              n.up.set(a.x, a.y, a.z),
                              n.lookAt(new Gn(i.x, i.y, i.z));
                          else {
                            if (!r) return;
                            const t = Kb(r).length();
                            n.position.set(o.x, o.y, o.z),
                              s && n.rotation.set(s.x, s.y, s.z),
                              0 === o.x &&
                                0 === o.y &&
                                0 === o.z &&
                                (n.position.z = t),
                              n.lookAt(new Gn());
                          }
                      },
                      updateLights() {
                        this.scene.remove(...this.allLights),
                          (this.allLights = []),
                          this.lights.forEach((t) => {
                            if (!t.type) return;
                            const e = t.type.toLowerCase();
                            let n = null;
                            if ("ambient" === e || "ambientlight" === e) {
                              const e =
                                  0 === t.color ? t.color : t.color || 4210752,
                                r =
                                  0 === t.intensity
                                    ? t.intensity
                                    : t.intensity || 1;
                              n = new Cp(e, r);
                            } else if ("point" === e || "pointlight" === e) {
                              const e =
                                  0 === t.color ? t.color : t.color || 16777215,
                                r =
                                  0 === t.intensity
                                    ? t.intensity
                                    : t.intensity || 1,
                                i = t.distance || 0,
                                a = 0 === t.decay ? t.decay : t.decay || 1;
                              (n = new Tp(e, r, i, a)),
                                t.position && n.position.copy(t.position);
                            } else if (
                              "directional" === e ||
                              "directionallight" === e
                            ) {
                              const e =
                                  0 === t.color ? t.color : t.color || 16777215,
                                r =
                                  0 === t.intensity
                                    ? t.intensity
                                    : t.intensity || 1;
                              (n = new Ap(e, r)),
                                t.position && n.position.copy(t.position),
                                t.target && n.target.copy(t.target);
                            } else if (
                              "hemisphere" === e ||
                              "hemispherelight" === e
                            ) {
                              const e =
                                  0 === t.skyColor
                                    ? t.skyColor
                                    : t.skyColor || 16777215,
                                r =
                                  0 === t.groundColor
                                    ? t.groundColor
                                    : t.groundColor || 16777215,
                                i =
                                  0 === t.intensity
                                    ? t.intensity
                                    : t.intensity || 1;
                              (n = new pp(e, r, i)),
                                t.position && n.position.copy(t.position);
                            }
                            n && (this.allLights.push(n), this.scene.add(n));
                          });
                      },
                      updateControls() {
                        this.controlsOptions &&
                          Object.assign(this.controls, this.controlsOptions);
                      },
                      loadModelSelect() {
                        this.parallelLoad && this.isMultipleModels
                          ? this.filePath.forEach((t, e) => {
                              this.load(e);
                            })
                          : this.load();
                      },
                      load(t = null) {
                        if (!this.filePath) return;
                        let e = t || this.loaderIndex;
                        const n = this.isMultipleModels
                            ? this.filePath[e]
                            : this.filePath,
                          r =
                            "string" === typeof this.fileType
                              ? this.fileType
                              : this.fileType
                              ? this.fileType[e]
                              : "",
                          i = tx(n, r, this.enableDraco, this.dracoDir);
                        this.loader = i.loader;
                        const a = i.getObject ? i.getObject : this.getObject;
                        if (
                          (this.object &&
                            0 === e &&
                            this.wrapper.remove(this.object),
                          this.requestHeader &&
                            this.loader.setRequestHeader(this.requestHeader),
                          this.crossOrigin &&
                            this.loader.setCrossOrigin(this.crossOrigin),
                          this.mtlPath)
                        ) {
                          const t = "string" === typeof this.mtlPath;
                          if (t) this.loadMtl(n, a, e);
                          else {
                            if (!this.mtlPath[e])
                              return void this.loadFilePath(n, a, e);
                            this.loadMtl(n, a, e);
                          }
                        } else this.loadFilePath(n, a, e);
                      },
                      loadFilePath(t, e, n) {
                        this.loader.load(
                          t,
                          (...r) => {
                            const i = e(...r);
                            if (
                              ((this.object = i),
                              this.addObject(i, t),
                              this.textureImage)
                            ) {
                              let t =
                                "string" === typeof this.textureImage
                                  ? this.textureImage
                                  : this.textureImage[n];
                              t && this.addTexture(i, t);
                            }
                            this.setLabel(), this.$emit("load", this.wrapper);
                          },
                          (t) => {
                            this.parallelLoad || this.onProcess(t);
                            let e = this.loaderIndex + 1;
                            this.$emit("process", t, e);
                          },
                          (t) => {
                            this.$emit("error", t);
                          }
                        );
                      },
                      loadMtl(t, e, n) {
                        const r = ex();
                        this.crossOrigin && r.setCrossOrigin(this.crossOrigin),
                          this.requestHeader &&
                            r.setRequestHeader(this.requestHeader);
                        const i =
                            "string" === typeof this.mtlPath
                              ? this.mtlPath
                              : this.mtlPath[n],
                          a = /^(.*\/)([^/]*)$/.exec(i),
                          o = a[1],
                          s = a[2];
                        r.setPath(o).load(s, (r) => {
                          r.preload(),
                            this.loader.setMaterials(r),
                            this.loadFilePath(t, e, n);
                        });
                      },
                      getObject(t) {
                        return t;
                      },
                      addObject(t, e) {
                        const n = Zb(t);
                        this.objectPositionHasSet ||
                          (this.wrapper.position.copy(n.negate()),
                          (this.objectPositionHasSet = !0)),
                          (this.object = t);
                        let r = e.split("/");
                        (r = r[r.length - 1]),
                          (this.object.fileName = r),
                          this.wrapper.add(t),
                          t.isMesh
                            ? this.update()
                            : (this.updateCamera(),
                              this.updateModel(),
                              this.playAnimations());
                      },
                      animate() {
                        (this.requestAnimationId = requestAnimationFrame(
                          this.animate
                        )),
                          this.updateStats();
                        const t = this.clock.getDelta();
                        this.mixer && this.mixer.update(t), this.render();
                      },
                      render() {
                        this.renderer.render(this.scene, this.camera);
                      },
                      updateStats() {
                        this.showFps && this.stats.update();
                      },
                      onProcess(t) {
                        let e = Math.floor((t.loaded / t.total) * 100);
                        const n = () => {
                          100 === e &&
                            (this.isMultipleModels &&
                            this.filePath.length > this.loaderIndex
                              ? this.$nextTick(() => {
                                  this.loaderIndex++,
                                    this.loaderIndex !== this.filePath.length
                                      ? this.load()
                                      : (this.loaderIndex = 0);
                                })
                              : (this.loaderIndex = 0));
                        };
                        e === 1 / 0 &&
                          (clearTimeout(this.timer),
                          (this.timer = setTimeout(() => {
                            (e = 100), n();
                          }, 200))),
                          n();
                      },
                      addTexture(t, e) {
                        this.textureLoader || (this.textureLoader = new dp()),
                          t.traverse((t) => {
                            t.isMesh &&
                              this.textureLoader.load(
                                e,
                                (e) => {
                                  (t.material.map = e),
                                    (t.material.needsUpdate = !0);
                                },
                                () => {},
                                (t) => {
                                  this.$emit("error", t);
                                }
                              );
                          });
                      },
                      clearSceneWrapper() {
                        this.wrapper.clear();
                      },
                      setObjectAttr(t, e) {
                        let n = this.returnObject();
                        n &&
                          (this.isMultipleModels
                            ? n.children.forEach((n) => {
                                const r = this.getObjectIndex(n);
                                if (e[r]) n[t].set(e[r].x, e[r].y, e[r].z);
                                else {
                                  const e = "scale" == t ? 1 : 0;
                                  n[t].set(e, e, e);
                                }
                              })
                            : n[t].set(e.x, e.y, e.z));
                      },
                      returnObject() {
                        return this.isMultipleModels
                          ? this.wrapper
                          : this.object;
                      },
                      setLabel() {
                        this.isMultipleModels
                          ? this.loaderIndex === this.filePath.length &&
                            this.setSpriteLabel()
                          : this.setSpriteLabel();
                      },
                      setSpriteLabel() {
                        if (!this.labels) return;
                        let t = this.isMultipleModels
                          ? this.wrapper
                          : this.object;
                        const e = (t) => {
                            this.textureLoader ||
                              (this.textureLoader = new dp());
                            const e = this.textureLoader.load(t);
                            return e;
                          },
                          n = (t, e) => {
                            const n = this.generateCanvas(t, e),
                              r = new Fn(n);
                            return (r.needsUpdate = !0), r;
                          };
                        this.labels.forEach((r) => {
                          const i = r.image
                              ? e(r.image)
                              : n(r.text, r.textStyle || {}),
                            a = new Gu({
                              map: i,
                              color: r.spriteMaterialColor || 16777215,
                            }),
                            o = new ih(a);
                          r.scale
                            ? o.scale.set(
                                r.scale.x || 1,
                                r.scale.y || 1,
                                r.scale.z || 0
                              )
                            : o.scale.set(1, 1, 0),
                            r.position &&
                              o.position.set(
                                r.position.x,
                                r.position.y,
                                r.position.z
                              ),
                            r.sid && (o.sid = r.sid),
                            t.add(o);
                        });
                      },
                      generateCanvas(t, e) {
                        void 0 === e && (e = {});
                        const n = (t, e, n, r, i, a) => {
                            t.beginPath(),
                              t.moveTo(e + a, n),
                              t.lineTo(e + r - a, n),
                              t.quadraticCurveTo(e + r, n, e + r, n + a),
                              t.lineTo(e + r, n + i - a),
                              t.quadraticCurveTo(
                                e + r,
                                n + i,
                                e + r - a,
                                n + i
                              ),
                              t.lineTo(e + a, n + i),
                              t.quadraticCurveTo(e, n + i, e, n + i - a),
                              t.lineTo(e, n + a),
                              t.quadraticCurveTo(e, n, e + a, n),
                              t.closePath(),
                              t.fill(),
                              t.stroke();
                          },
                          r = e.fontFamily || "Arial",
                          i = 0 === e.fontSize || e.fontSize ? e.fontSize : 18,
                          a = e.color || "#ffffff",
                          o = e.fontWeight || "normal",
                          s =
                            0 === e.borderWidth || e.borderWidth
                              ? e.borderWidth
                              : 4,
                          c = e.borderColor || "rgba(0,0,0,1)",
                          l =
                            0 === e.borderRadius || e.borderRadius
                              ? e.borderRadius
                              : 4,
                          u = e.backgroundColor || "rgba(255, 255, 255, 1)",
                          h = document.createElement("canvas"),
                          d = h.getContext("2d");
                        d.font = `${o} ${i}px ${r}`;
                        const f = d.measureText(t),
                          p = f.width;
                        return (
                          (d.fillStyle = u),
                          (d.strokeStyle = c),
                          (d.lineWidth = s),
                          n(d, s / 2, s / 2, p + s, 1.4 * i + s, l),
                          (d.fillStyle = a),
                          d.fillText(t, s, i + s),
                          h
                        );
                      },
                      playAnimations() {
                        const t = (t) => {
                          (this.mixer = new im(this.wrapper)),
                            t.animations &&
                              t.animations.forEach((t) => {
                                if (t) {
                                  const e = this.mixer.clipAction(t);
                                  this.autoPlay ? e.play() : e.stop();
                                }
                              });
                        };
                        this.isMultipleModels
                          ? this.wrapper.children.forEach((e) => {
                              t(e);
                            })
                          : t(this.object);
                      },
                    },
                  },
                  ix = rx;
                function ax(t, e, n, r, i, a, o, s) {
                  var c,
                    l = "function" === typeof t ? t.options : t;
                  if (
                    (e &&
                      ((l.render = e),
                      (l.staticRenderFns = n),
                      (l._compiled = !0)),
                    r && (l.functional = !0),
                    a && (l._scopeId = "data-v-" + a),
                    o
                      ? ((c = function (t) {
                          (t =
                            t ||
                            (this.$vnode && this.$vnode.ssrContext) ||
                            (this.parent &&
                              this.parent.$vnode &&
                              this.parent.$vnode.ssrContext)),
                            t ||
                              "undefined" === typeof __VUE_SSR_CONTEXT__ ||
                              (t = __VUE_SSR_CONTEXT__),
                            i && i.call(this, t),
                            t &&
                              t._registeredComponents &&
                              t._registeredComponents.add(o);
                        }),
                        (l._ssrRegister = c))
                      : i &&
                        (c = s
                          ? function () {
                              i.call(
                                this,
                                (l.functional ? this.parent : this).$root
                                  .$options.shadowRoot
                              );
                            }
                          : i),
                    c)
                  )
                    if (l.functional) {
                      l._injectStyles = c;
                      var u = l.render;
                      l.render = function (t, e) {
                        return c.call(e), u(t, e);
                      };
                    } else {
                      var h = l.beforeCreate;
                      l.beforeCreate = h ? [].concat(h, c) : [c];
                    }
                  return { exports: t, options: l };
                }
                var ox = ax(ix, a, o, !1, null, null, null),
                  sx = ox.exports;
                const cx = [sx],
                  lx = function (t) {
                    cx.map((e) => {
                      t.component(e.name, e);
                    });
                  };
                "undefined" !== typeof window && window.Vue && lx(window.Vue);
                var ux = { install: lx, ...cx },
                  hx = ux;
              })(),
              r
            );
          })();
        });
    },
    2631: function (t, e) {
      "use strict";
      /**
       * vue-router v2.8.1
       * (c) 2017 Evan You
       * @license MIT
       */ function n(t, e) {
        0;
      }
      function r(t) {
        return Object.prototype.toString.call(t).indexOf("Error") > -1;
      }
      var i = {
        name: "router-view",
        functional: !0,
        props: { name: { type: String, default: "default" } },
        render: function (t, e) {
          var n = e.props,
            r = e.children,
            i = e.parent,
            s = e.data;
          s.routerView = !0;
          var c = i.$createElement,
            l = n.name,
            u = i.$route,
            h = i._routerViewCache || (i._routerViewCache = {}),
            d = 0,
            f = !1;
          while (i && i._routerRoot !== i)
            i.$vnode && i.$vnode.data.routerView && d++,
              i._inactive && (f = !0),
              (i = i.$parent);
          if (((s.routerViewDepth = d), f)) return c(h[l], s, r);
          var p = u.matched[d];
          if (!p) return (h[l] = null), c();
          var m = (h[l] = p.components[l]);
          (s.registerRouteInstance = function (t, e) {
            var n = p.instances[l];
            ((e && n !== t) || (!e && n === t)) && (p.instances[l] = e);
          }),
            ((s.hook || (s.hook = {})).prepatch = function (t, e) {
              p.instances[l] = e.componentInstance;
            });
          var g = (s.props = a(u, p.props && p.props[l]));
          if (g) {
            g = s.props = o({}, g);
            var v = (s.attrs = s.attrs || {});
            for (var y in g)
              (m.props && y in m.props) || ((v[y] = g[y]), delete g[y]);
          }
          return c(m, s, r);
        },
      };
      function a(t, e) {
        switch (typeof e) {
          case "undefined":
            return;
          case "object":
            return e;
          case "function":
            return e(t);
          case "boolean":
            return e ? t.params : void 0;
          default:
            0;
        }
      }
      function o(t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      }
      var s = /[!'()*]/g,
        c = function (t) {
          return "%" + t.charCodeAt(0).toString(16);
        },
        l = /%2C/g,
        u = function (t) {
          return encodeURIComponent(t).replace(s, c).replace(l, ",");
        },
        h = decodeURIComponent;
      function d(t, e, n) {
        void 0 === e && (e = {});
        var r,
          i = n || f;
        try {
          r = i(t || "");
        } catch (o) {
          r = {};
        }
        for (var a in e) r[a] = e[a];
        return r;
      }
      function f(t) {
        var e = {};
        return (
          (t = t.trim().replace(/^(\?|#|&)/, "")),
          t
            ? (t.split("&").forEach(function (t) {
                var n = t.replace(/\+/g, " ").split("="),
                  r = h(n.shift()),
                  i = n.length > 0 ? h(n.join("=")) : null;
                void 0 === e[r]
                  ? (e[r] = i)
                  : Array.isArray(e[r])
                  ? e[r].push(i)
                  : (e[r] = [e[r], i]);
              }),
              e)
            : e
        );
      }
      function p(t) {
        var e = t
          ? Object.keys(t)
              .map(function (e) {
                var n = t[e];
                if (void 0 === n) return "";
                if (null === n) return u(e);
                if (Array.isArray(n)) {
                  var r = [];
                  return (
                    n.forEach(function (t) {
                      void 0 !== t &&
                        (null === t ? r.push(u(e)) : r.push(u(e) + "=" + u(t)));
                    }),
                    r.join("&")
                  );
                }
                return u(e) + "=" + u(n);
              })
              .filter(function (t) {
                return t.length > 0;
              })
              .join("&")
          : null;
        return e ? "?" + e : "";
      }
      var m = /\/?$/;
      function g(t, e, n, r) {
        var i = r && r.options.stringifyQuery,
          a = e.query || {};
        try {
          a = v(a);
        } catch (s) {}
        var o = {
          name: e.name || (t && t.name),
          meta: (t && t.meta) || {},
          path: e.path || "/",
          hash: e.hash || "",
          query: a,
          params: e.params || {},
          fullPath: x(e, i),
          matched: t ? b(t) : [],
        };
        return n && (o.redirectedFrom = x(n, i)), Object.freeze(o);
      }
      function v(t) {
        if (Array.isArray(t)) return t.map(v);
        if (t && "object" === typeof t) {
          var e = {};
          for (var n in t) e[n] = v(t[n]);
          return e;
        }
        return t;
      }
      var y = g(null, { path: "/" });
      function b(t) {
        var e = [];
        while (t) e.unshift(t), (t = t.parent);
        return e;
      }
      function x(t, e) {
        var n = t.path,
          r = t.query;
        void 0 === r && (r = {});
        var i = t.hash;
        void 0 === i && (i = "");
        var a = e || p;
        return (n || "/") + a(r) + i;
      }
      function _(t, e) {
        return e === y
          ? t === e
          : !!e &&
              (t.path && e.path
                ? t.path.replace(m, "") === e.path.replace(m, "") &&
                  t.hash === e.hash &&
                  w(t.query, e.query)
                : !(!t.name || !e.name) &&
                  t.name === e.name &&
                  t.hash === e.hash &&
                  w(t.query, e.query) &&
                  w(t.params, e.params));
      }
      function w(t, e) {
        if ((void 0 === t && (t = {}), void 0 === e && (e = {}), !t || !e))
          return t === e;
        var n = Object.keys(t),
          r = Object.keys(e);
        return (
          n.length === r.length &&
          n.every(function (n) {
            var r = t[n],
              i = e[n];
            return "object" === typeof r && "object" === typeof i
              ? w(r, i)
              : String(r) === String(i);
          })
        );
      }
      function S(t, e) {
        return (
          0 === t.path.replace(m, "/").indexOf(e.path.replace(m, "/")) &&
          (!e.hash || t.hash === e.hash) &&
          M(t.query, e.query)
        );
      }
      function M(t, e) {
        for (var n in e) if (!(n in t)) return !1;
        return !0;
      }
      var T,
        E = [String, Object],
        A = [String, Array],
        C = {
          name: "router-link",
          props: {
            to: { type: E, required: !0 },
            tag: { type: String, default: "a" },
            exact: Boolean,
            append: Boolean,
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            event: { type: A, default: "click" },
          },
          render: function (t) {
            var e = this,
              n = this.$router,
              r = this.$route,
              i = n.resolve(this.to, r, this.append),
              a = i.location,
              o = i.route,
              s = i.href,
              c = {},
              l = n.options.linkActiveClass,
              u = n.options.linkExactActiveClass,
              h = null == l ? "router-link-active" : l,
              d = null == u ? "router-link-exact-active" : u,
              f = null == this.activeClass ? h : this.activeClass,
              p = null == this.exactActiveClass ? d : this.exactActiveClass,
              m = a.path ? g(null, a, null, n) : o;
            (c[p] = _(r, m)), (c[f] = this.exact ? c[p] : S(r, m));
            var v = function (t) {
                L(t) && (e.replace ? n.replace(a) : n.push(a));
              },
              y = { click: L };
            Array.isArray(this.event)
              ? this.event.forEach(function (t) {
                  y[t] = v;
                })
              : (y[this.event] = v);
            var b = { class: c };
            if ("a" === this.tag) (b.on = y), (b.attrs = { href: s });
            else {
              var x = R(this.$slots.default);
              if (x) {
                x.isStatic = !1;
                var w = T.util.extend,
                  M = (x.data = w({}, x.data));
                M.on = y;
                var E = (x.data.attrs = w({}, x.data.attrs));
                E.href = s;
              } else b.on = y;
            }
            return t(this.tag, b, this.$slots.default);
          },
        };
      function L(t) {
        if (
          !(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
          !t.defaultPrevented &&
          (void 0 === t.button || 0 === t.button)
        ) {
          if (t.currentTarget && t.currentTarget.getAttribute) {
            var e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return;
          }
          return t.preventDefault && t.preventDefault(), !0;
        }
      }
      function R(t) {
        if (t)
          for (var e, n = 0; n < t.length; n++) {
            if (((e = t[n]), "a" === e.tag)) return e;
            if (e.children && (e = R(e.children))) return e;
          }
      }
      function P(t) {
        if (!P.installed || T !== t) {
          (P.installed = !0), (T = t);
          var e = function (t) {
              return void 0 !== t;
            },
            n = function (t, n) {
              var r = t.$options._parentVnode;
              e(r) &&
                e((r = r.data)) &&
                e((r = r.registerRouteInstance)) &&
                r(t, n);
            };
          t.mixin({
            beforeCreate: function () {
              e(this.$options.router)
                ? ((this._routerRoot = this),
                  (this._router = this.$options.router),
                  this._router.init(this),
                  t.util.defineReactive(
                    this,
                    "_route",
                    this._router.history.current
                  ))
                : (this._routerRoot =
                    (this.$parent && this.$parent._routerRoot) || this),
                n(this, this);
            },
            destroyed: function () {
              n(this);
            },
          }),
            Object.defineProperty(t.prototype, "$router", {
              get: function () {
                return this._routerRoot._router;
              },
            }),
            Object.defineProperty(t.prototype, "$route", {
              get: function () {
                return this._routerRoot._route;
              },
            }),
            t.component("router-view", i),
            t.component("router-link", C);
          var r = t.config.optionMergeStrategies;
          r.beforeRouteEnter =
            r.beforeRouteLeave =
            r.beforeRouteUpdate =
              r.created;
        }
      }
      var I = "undefined" !== typeof window;
      function O(t, e, n) {
        var r = t.charAt(0);
        if ("/" === r) return t;
        if ("?" === r || "#" === r) return e + t;
        var i = e.split("/");
        (n && i[i.length - 1]) || i.pop();
        for (
          var a = t.replace(/^\//, "").split("/"), o = 0;
          o < a.length;
          o++
        ) {
          var s = a[o];
          ".." === s ? i.pop() : "." !== s && i.push(s);
        }
        return "" !== i[0] && i.unshift(""), i.join("/");
      }
      function k(t) {
        var e = "",
          n = "",
          r = t.indexOf("#");
        r >= 0 && ((e = t.slice(r)), (t = t.slice(0, r)));
        var i = t.indexOf("?");
        return (
          i >= 0 && ((n = t.slice(i + 1)), (t = t.slice(0, i))),
          { path: t, query: n, hash: e }
        );
      }
      function N(t) {
        return t.replace(/\/\//g, "/");
      }
      var D =
          Array.isArray ||
          function (t) {
            return "[object Array]" == Object.prototype.toString.call(t);
          },
        z = nt,
        F = V,
        U = G,
        B = X,
        j = et,
        H = new RegExp(
          [
            "(\\\\.)",
            "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))",
          ].join("|"),
          "g"
        );
      function V(t, e) {
        var n,
          r = [],
          i = 0,
          a = 0,
          o = "",
          s = (e && e.delimiter) || "/";
        while (null != (n = H.exec(t))) {
          var c = n[0],
            l = n[1],
            u = n.index;
          if (((o += t.slice(a, u)), (a = u + c.length), l)) o += l[1];
          else {
            var h = t[a],
              d = n[2],
              f = n[3],
              p = n[4],
              m = n[5],
              g = n[6],
              v = n[7];
            o && (r.push(o), (o = ""));
            var y = null != d && null != h && h !== d,
              b = "+" === g || "*" === g,
              x = "?" === g || "*" === g,
              _ = n[2] || s,
              w = p || m;
            r.push({
              name: f || i++,
              prefix: d || "",
              delimiter: _,
              optional: x,
              repeat: b,
              partial: y,
              asterisk: !!v,
              pattern: w ? Y(w) : v ? ".*" : "[^" + $(_) + "]+?",
            });
          }
        }
        return a < t.length && (o += t.substr(a)), o && r.push(o), r;
      }
      function G(t, e) {
        return X(V(t, e));
      }
      function W(t) {
        return encodeURI(t).replace(/[\/?#]/g, function (t) {
          return "%" + t.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function q(t) {
        return encodeURI(t).replace(/[?#]/g, function (t) {
          return "%" + t.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function X(t) {
        for (var e = new Array(t.length), n = 0; n < t.length; n++)
          "object" === typeof t[n] &&
            (e[n] = new RegExp("^(?:" + t[n].pattern + ")$"));
        return function (n, r) {
          for (
            var i = "",
              a = n || {},
              o = r || {},
              s = o.pretty ? W : encodeURIComponent,
              c = 0;
            c < t.length;
            c++
          ) {
            var l = t[c];
            if ("string" !== typeof l) {
              var u,
                h = a[l.name];
              if (null == h) {
                if (l.optional) {
                  l.partial && (i += l.prefix);
                  continue;
                }
                throw new TypeError('Expected "' + l.name + '" to be defined');
              }
              if (D(h)) {
                if (!l.repeat)
                  throw new TypeError(
                    'Expected "' +
                      l.name +
                      '" to not repeat, but received `' +
                      JSON.stringify(h) +
                      "`"
                  );
                if (0 === h.length) {
                  if (l.optional) continue;
                  throw new TypeError(
                    'Expected "' + l.name + '" to not be empty'
                  );
                }
                for (var d = 0; d < h.length; d++) {
                  if (((u = s(h[d])), !e[c].test(u)))
                    throw new TypeError(
                      'Expected all "' +
                        l.name +
                        '" to match "' +
                        l.pattern +
                        '", but received `' +
                        JSON.stringify(u) +
                        "`"
                    );
                  i += (0 === d ? l.prefix : l.delimiter) + u;
                }
              } else {
                if (((u = l.asterisk ? q(h) : s(h)), !e[c].test(u)))
                  throw new TypeError(
                    'Expected "' +
                      l.name +
                      '" to match "' +
                      l.pattern +
                      '", but received "' +
                      u +
                      '"'
                  );
                i += l.prefix + u;
              }
            } else i += l;
          }
          return i;
        };
      }
      function $(t) {
        return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
      }
      function Y(t) {
        return t.replace(/([=!:$\/()])/g, "\\$1");
      }
      function J(t, e) {
        return (t.keys = e), t;
      }
      function K(t) {
        return t.sensitive ? "" : "i";
      }
      function Z(t, e) {
        var n = t.source.match(/\((?!\?)/g);
        if (n)
          for (var r = 0; r < n.length; r++)
            e.push({
              name: r,
              prefix: null,
              delimiter: null,
              optional: !1,
              repeat: !1,
              partial: !1,
              asterisk: !1,
              pattern: null,
            });
        return J(t, e);
      }
      function Q(t, e, n) {
        for (var r = [], i = 0; i < t.length; i++)
          r.push(nt(t[i], e, n).source);
        var a = new RegExp("(?:" + r.join("|") + ")", K(n));
        return J(a, e);
      }
      function tt(t, e, n) {
        return et(V(t, n), e, n);
      }
      function et(t, e, n) {
        D(e) || ((n = e || n), (e = [])), (n = n || {});
        for (
          var r = n.strict, i = !1 !== n.end, a = "", o = 0;
          o < t.length;
          o++
        ) {
          var s = t[o];
          if ("string" === typeof s) a += $(s);
          else {
            var c = $(s.prefix),
              l = "(?:" + s.pattern + ")";
            e.push(s),
              s.repeat && (l += "(?:" + c + l + ")*"),
              (l = s.optional
                ? s.partial
                  ? c + "(" + l + ")?"
                  : "(?:" + c + "(" + l + "))?"
                : c + "(" + l + ")"),
              (a += l);
          }
        }
        var u = $(n.delimiter || "/"),
          h = a.slice(-u.length) === u;
        return (
          r || (a = (h ? a.slice(0, -u.length) : a) + "(?:" + u + "(?=$))?"),
          (a += i ? "$" : r && h ? "" : "(?=" + u + "|$)"),
          J(new RegExp("^" + a, K(n)), e)
        );
      }
      function nt(t, e, n) {
        return (
          D(e) || ((n = e || n), (e = [])),
          (n = n || {}),
          t instanceof RegExp ? Z(t, e) : D(t) ? Q(t, e, n) : tt(t, e, n)
        );
      }
      (z.parse = F),
        (z.compile = U),
        (z.tokensToFunction = B),
        (z.tokensToRegExp = j);
      var rt = Object.create(null);
      function it(t, e, n) {
        try {
          var r = rt[t] || (rt[t] = z.compile(t));
          return r(e || {}, { pretty: !0 });
        } catch (i) {
          return "";
        }
      }
      function at(t, e, n, r) {
        var i = e || [],
          a = n || Object.create(null),
          o = r || Object.create(null);
        t.forEach(function (t) {
          ot(i, a, o, t);
        });
        for (var s = 0, c = i.length; s < c; s++)
          "*" === i[s] && (i.push(i.splice(s, 1)[0]), c--, s--);
        return { pathList: i, pathMap: a, nameMap: o };
      }
      function ot(t, e, n, r, i, a) {
        var o = r.path,
          s = r.name;
        var c = r.pathToRegexpOptions || {},
          l = ct(o, i, c.strict);
        "boolean" === typeof r.caseSensitive && (c.sensitive = r.caseSensitive);
        var u = {
          path: l,
          regex: st(l, c),
          components: r.components || { default: r.component },
          instances: {},
          name: s,
          parent: i,
          matchAs: a,
          redirect: r.redirect,
          beforeEnter: r.beforeEnter,
          meta: r.meta || {},
          props:
            null == r.props
              ? {}
              : r.components
              ? r.props
              : { default: r.props },
        };
        if (
          (r.children &&
            r.children.forEach(function (r) {
              var i = a ? N(a + "/" + r.path) : void 0;
              ot(t, e, n, r, u, i);
            }),
          void 0 !== r.alias)
        ) {
          var h = Array.isArray(r.alias) ? r.alias : [r.alias];
          h.forEach(function (a) {
            var o = { path: a, children: r.children };
            ot(t, e, n, o, i, u.path || "/");
          });
        }
        e[u.path] || (t.push(u.path), (e[u.path] = u)),
          s && (n[s] || (n[s] = u));
      }
      function st(t, e) {
        var n = z(t, [], e);
        return n;
      }
      function ct(t, e, n) {
        return (
          n || (t = t.replace(/\/$/, "")),
          "/" === t[0] || null == e ? t : N(e.path + "/" + t)
        );
      }
      function lt(t, e, n, r) {
        var i = "string" === typeof t ? { path: t } : t;
        if (i.name || i._normalized) return i;
        if (!i.path && i.params && e) {
          (i = ut({}, i)), (i._normalized = !0);
          var a = ut(ut({}, e.params), i.params);
          if (e.name) (i.name = e.name), (i.params = a);
          else if (e.matched.length) {
            var o = e.matched[e.matched.length - 1].path;
            i.path = it(o, a, "path " + e.path);
          } else 0;
          return i;
        }
        var s = k(i.path || ""),
          c = (e && e.path) || "/",
          l = s.path ? O(s.path, c, n || i.append) : c,
          u = d(s.query, i.query, r && r.options.parseQuery),
          h = i.hash || s.hash;
        return (
          h && "#" !== h.charAt(0) && (h = "#" + h),
          { _normalized: !0, path: l, query: u, hash: h }
        );
      }
      function ut(t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      }
      function ht(t, e) {
        var n = at(t),
          r = n.pathList,
          i = n.pathMap,
          a = n.nameMap;
        function o(t) {
          at(t, r, i, a);
        }
        function s(t, n, o) {
          var s = lt(t, n, !1, e),
            c = s.name;
          if (c) {
            var l = a[c];
            if (!l) return u(null, s);
            var h = l.regex.keys
              .filter(function (t) {
                return !t.optional;
              })
              .map(function (t) {
                return t.name;
              });
            if (
              ("object" !== typeof s.params && (s.params = {}),
              n && "object" === typeof n.params)
            )
              for (var d in n.params)
                !(d in s.params) &&
                  h.indexOf(d) > -1 &&
                  (s.params[d] = n.params[d]);
            if (l)
              return (
                (s.path = it(l.path, s.params, 'named route "' + c + '"')),
                u(l, s, o)
              );
          } else if (s.path) {
            s.params = {};
            for (var f = 0; f < r.length; f++) {
              var p = r[f],
                m = i[p];
              if (dt(m.regex, s.path, s.params)) return u(m, s, o);
            }
          }
          return u(null, s);
        }
        function c(t, n) {
          var r = t.redirect,
            i = "function" === typeof r ? r(g(t, n, null, e)) : r;
          if (
            ("string" === typeof i && (i = { path: i }),
            !i || "object" !== typeof i)
          )
            return u(null, n);
          var o = i,
            c = o.name,
            l = o.path,
            h = n.query,
            d = n.hash,
            f = n.params;
          if (
            ((h = o.hasOwnProperty("query") ? o.query : h),
            (d = o.hasOwnProperty("hash") ? o.hash : d),
            (f = o.hasOwnProperty("params") ? o.params : f),
            c)
          ) {
            a[c];
            return s(
              { _normalized: !0, name: c, query: h, hash: d, params: f },
              void 0,
              n
            );
          }
          if (l) {
            var p = ft(l, t),
              m = it(p, f, 'redirect route with path "' + p + '"');
            return s(
              { _normalized: !0, path: m, query: h, hash: d },
              void 0,
              n
            );
          }
          return u(null, n);
        }
        function l(t, e, n) {
          var r = it(n, e.params, 'aliased route with path "' + n + '"'),
            i = s({ _normalized: !0, path: r });
          if (i) {
            var a = i.matched,
              o = a[a.length - 1];
            return (e.params = i.params), u(o, e);
          }
          return u(null, e);
        }
        function u(t, n, r) {
          return t && t.redirect
            ? c(t, r || n)
            : t && t.matchAs
            ? l(t, n, t.matchAs)
            : g(t, n, r, e);
        }
        return { match: s, addRoutes: o };
      }
      function dt(t, e, n) {
        var r = e.match(t);
        if (!r) return !1;
        if (!n) return !0;
        for (var i = 1, a = r.length; i < a; ++i) {
          var o = t.keys[i - 1],
            s = "string" === typeof r[i] ? decodeURIComponent(r[i]) : r[i];
          o && (n[o.name] = s);
        }
        return !0;
      }
      function ft(t, e) {
        return O(t, e.parent ? e.parent.path : "/", !0);
      }
      var pt = Object.create(null);
      function mt() {
        window.history.replaceState({ key: Lt() }, ""),
          window.addEventListener("popstate", function (t) {
            vt(), t.state && t.state.key && Rt(t.state.key);
          });
      }
      function gt(t, e, n, r) {
        if (t.app) {
          var i = t.options.scrollBehavior;
          i &&
            t.app.$nextTick(function () {
              var t = yt(),
                a = i(e, n, r ? t : null);
              a &&
                ("function" === typeof a.then
                  ? a
                      .then(function (e) {
                        Mt(e, t);
                      })
                      .catch(function (t) {
                        0;
                      })
                  : Mt(a, t));
            });
        }
      }
      function vt() {
        var t = Lt();
        t && (pt[t] = { x: window.pageXOffset, y: window.pageYOffset });
      }
      function yt() {
        var t = Lt();
        if (t) return pt[t];
      }
      function bt(t, e) {
        var n = document.documentElement,
          r = n.getBoundingClientRect(),
          i = t.getBoundingClientRect();
        return { x: i.left - r.left - e.x, y: i.top - r.top - e.y };
      }
      function xt(t) {
        return St(t.x) || St(t.y);
      }
      function _t(t) {
        return {
          x: St(t.x) ? t.x : window.pageXOffset,
          y: St(t.y) ? t.y : window.pageYOffset,
        };
      }
      function wt(t) {
        return { x: St(t.x) ? t.x : 0, y: St(t.y) ? t.y : 0 };
      }
      function St(t) {
        return "number" === typeof t;
      }
      function Mt(t, e) {
        var n = "object" === typeof t;
        if (n && "string" === typeof t.selector) {
          var r = document.querySelector(t.selector);
          if (r) {
            var i = t.offset && "object" === typeof t.offset ? t.offset : {};
            (i = wt(i)), (e = bt(r, i));
          } else xt(t) && (e = _t(t));
        } else n && xt(t) && (e = _t(t));
        e && window.scrollTo(e.x, e.y);
      }
      var Tt =
          I &&
          (function () {
            var t = window.navigator.userAgent;
            return (
              ((-1 === t.indexOf("Android 2.") &&
                -1 === t.indexOf("Android 4.0")) ||
                -1 === t.indexOf("Mobile Safari") ||
                -1 !== t.indexOf("Chrome") ||
                -1 !== t.indexOf("Windows Phone")) &&
              window.history &&
              "pushState" in window.history
            );
          })(),
        Et =
          I && window.performance && window.performance.now
            ? window.performance
            : Date,
        At = Ct();
      function Ct() {
        return Et.now().toFixed(3);
      }
      function Lt() {
        return At;
      }
      function Rt(t) {
        At = t;
      }
      function Pt(t, e) {
        vt();
        var n = window.history;
        try {
          e
            ? n.replaceState({ key: At }, "", t)
            : ((At = Ct()), n.pushState({ key: At }, "", t));
        } catch (r) {
          window.location[e ? "replace" : "assign"](t);
        }
      }
      function It(t) {
        Pt(t, !0);
      }
      function Ot(t, e, n) {
        var r = function (i) {
          i >= t.length
            ? n()
            : t[i]
            ? e(t[i], function () {
                r(i + 1);
              })
            : r(i + 1);
        };
        r(0);
      }
      function kt(t) {
        return function (e, n, i) {
          var a = !1,
            o = 0,
            s = null;
          Nt(t, function (t, e, n, c) {
            if ("function" === typeof t && void 0 === t.cid) {
              (a = !0), o++;
              var l,
                u = Ut(function (e) {
                  Ft(e) && (e = e.default),
                    (t.resolved = "function" === typeof e ? e : T.extend(e)),
                    (n.components[c] = e),
                    o--,
                    o <= 0 && i();
                }),
                h = Ut(function (t) {
                  var e = "Failed to resolve async component " + c + ": " + t;
                  s || ((s = r(t) ? t : new Error(e)), i(s));
                });
              try {
                l = t(u, h);
              } catch (f) {
                h(f);
              }
              if (l)
                if ("function" === typeof l.then) l.then(u, h);
                else {
                  var d = l.component;
                  d && "function" === typeof d.then && d.then(u, h);
                }
            }
          }),
            a || i();
        };
      }
      function Nt(t, e) {
        return Dt(
          t.map(function (t) {
            return Object.keys(t.components).map(function (n) {
              return e(t.components[n], t.instances[n], t, n);
            });
          })
        );
      }
      function Dt(t) {
        return Array.prototype.concat.apply([], t);
      }
      var zt =
        "function" === typeof Symbol && "symbol" === typeof Symbol.toStringTag;
      function Ft(t) {
        return t.__esModule || (zt && "Module" === t[Symbol.toStringTag]);
      }
      function Ut(t) {
        var e = !1;
        return function () {
          var n = [],
            r = arguments.length;
          while (r--) n[r] = arguments[r];
          if (!e) return (e = !0), t.apply(this, n);
        };
      }
      var Bt = function (t, e) {
        (this.router = t),
          (this.base = jt(e)),
          (this.current = y),
          (this.pending = null),
          (this.ready = !1),
          (this.readyCbs = []),
          (this.readyErrorCbs = []),
          (this.errorCbs = []);
      };
      function jt(t) {
        if (!t)
          if (I) {
            var e = document.querySelector("base");
            (t = (e && e.getAttribute("href")) || "/"),
              (t = t.replace(/^https?:\/\/[^\/]+/, ""));
          } else t = "/";
        return "/" !== t.charAt(0) && (t = "/" + t), t.replace(/\/$/, "");
      }
      function Ht(t, e) {
        var n,
          r = Math.max(t.length, e.length);
        for (n = 0; n < r; n++) if (t[n] !== e[n]) break;
        return {
          updated: e.slice(0, n),
          activated: e.slice(n),
          deactivated: t.slice(n),
        };
      }
      function Vt(t, e, n, r) {
        var i = Nt(t, function (t, r, i, a) {
          var o = Gt(t, e);
          if (o)
            return Array.isArray(o)
              ? o.map(function (t) {
                  return n(t, r, i, a);
                })
              : n(o, r, i, a);
        });
        return Dt(r ? i.reverse() : i);
      }
      function Gt(t, e) {
        return "function" !== typeof t && (t = T.extend(t)), t.options[e];
      }
      function Wt(t) {
        return Vt(t, "beforeRouteLeave", Xt, !0);
      }
      function qt(t) {
        return Vt(t, "beforeRouteUpdate", Xt);
      }
      function Xt(t, e) {
        if (e)
          return function () {
            return t.apply(e, arguments);
          };
      }
      function $t(t, e, n) {
        return Vt(t, "beforeRouteEnter", function (t, r, i, a) {
          return Yt(t, i, a, e, n);
        });
      }
      function Yt(t, e, n, r, i) {
        return function (a, o, s) {
          return t(a, o, function (t) {
            s(t),
              "function" === typeof t &&
                r.push(function () {
                  Jt(t, e.instances, n, i);
                });
          });
        };
      }
      function Jt(t, e, n, r) {
        e[n]
          ? t(e[n])
          : r() &&
            setTimeout(function () {
              Jt(t, e, n, r);
            }, 16);
      }
      (Bt.prototype.listen = function (t) {
        this.cb = t;
      }),
        (Bt.prototype.onReady = function (t, e) {
          this.ready
            ? t()
            : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e));
        }),
        (Bt.prototype.onError = function (t) {
          this.errorCbs.push(t);
        }),
        (Bt.prototype.transitionTo = function (t, e, n) {
          var r = this,
            i = this.router.match(t, this.current);
          this.confirmTransition(
            i,
            function () {
              r.updateRoute(i),
                e && e(i),
                r.ensureURL(),
                r.ready ||
                  ((r.ready = !0),
                  r.readyCbs.forEach(function (t) {
                    t(i);
                  }));
            },
            function (t) {
              n && n(t),
                t &&
                  !r.ready &&
                  ((r.ready = !0),
                  r.readyErrorCbs.forEach(function (e) {
                    e(t);
                  }));
            }
          );
        }),
        (Bt.prototype.confirmTransition = function (t, e, i) {
          var a = this,
            o = this.current,
            s = function (t) {
              r(t) &&
                (a.errorCbs.length
                  ? a.errorCbs.forEach(function (e) {
                      e(t);
                    })
                  : (n(!1, "uncaught error during route navigation:"),
                    console.error(t))),
                i && i(t);
            };
          if (_(t, o) && t.matched.length === o.matched.length)
            return this.ensureURL(), s();
          var c = Ht(this.current.matched, t.matched),
            l = c.updated,
            u = c.deactivated,
            h = c.activated,
            d = [].concat(
              Wt(u),
              this.router.beforeHooks,
              qt(l),
              h.map(function (t) {
                return t.beforeEnter;
              }),
              kt(h)
            );
          this.pending = t;
          var f = function (e, n) {
            if (a.pending !== t) return s();
            try {
              e(t, o, function (t) {
                !1 === t || r(t)
                  ? (a.ensureURL(!0), s(t))
                  : "string" === typeof t ||
                    ("object" === typeof t &&
                      ("string" === typeof t.path ||
                        "string" === typeof t.name))
                  ? (s(),
                    "object" === typeof t && t.replace
                      ? a.replace(t)
                      : a.push(t))
                  : n(t);
              });
            } catch (i) {
              s(i);
            }
          };
          Ot(d, f, function () {
            var n = [],
              r = function () {
                return a.current === t;
              },
              i = $t(h, n, r),
              o = i.concat(a.router.resolveHooks);
            Ot(o, f, function () {
              if (a.pending !== t) return s();
              (a.pending = null),
                e(t),
                a.router.app &&
                  a.router.app.$nextTick(function () {
                    n.forEach(function (t) {
                      t();
                    });
                  });
            });
          });
        }),
        (Bt.prototype.updateRoute = function (t) {
          var e = this.current;
          (this.current = t),
            this.cb && this.cb(t),
            this.router.afterHooks.forEach(function (n) {
              n && n(t, e);
            });
        });
      var Kt = (function (t) {
        function e(e, n) {
          var r = this;
          t.call(this, e, n);
          var i = e.options.scrollBehavior;
          i && mt();
          var a = Zt(this.base);
          window.addEventListener("popstate", function (t) {
            var n = r.current,
              o = Zt(r.base);
            (r.current === y && o === a) ||
              r.transitionTo(o, function (t) {
                i && gt(e, t, n, !0);
              });
          });
        }
        return (
          t && (e.__proto__ = t),
          (e.prototype = Object.create(t && t.prototype)),
          (e.prototype.constructor = e),
          (e.prototype.go = function (t) {
            window.history.go(t);
          }),
          (e.prototype.push = function (t, e, n) {
            var r = this,
              i = this,
              a = i.current;
            this.transitionTo(
              t,
              function (t) {
                Pt(N(r.base + t.fullPath)), gt(r.router, t, a, !1), e && e(t);
              },
              n
            );
          }),
          (e.prototype.replace = function (t, e, n) {
            var r = this,
              i = this,
              a = i.current;
            this.transitionTo(
              t,
              function (t) {
                It(N(r.base + t.fullPath)), gt(r.router, t, a, !1), e && e(t);
              },
              n
            );
          }),
          (e.prototype.ensureURL = function (t) {
            if (Zt(this.base) !== this.current.fullPath) {
              var e = N(this.base + this.current.fullPath);
              t ? Pt(e) : It(e);
            }
          }),
          (e.prototype.getCurrentLocation = function () {
            return Zt(this.base);
          }),
          e
        );
      })(Bt);
      function Zt(t) {
        var e = window.location.pathname;
        return (
          t && 0 === e.indexOf(t) && (e = e.slice(t.length)),
          (e || "/") + window.location.search + window.location.hash
        );
      }
      var Qt = (function (t) {
        function e(e, n, r) {
          t.call(this, e, n), (r && te(this.base)) || ee();
        }
        return (
          t && (e.__proto__ = t),
          (e.prototype = Object.create(t && t.prototype)),
          (e.prototype.constructor = e),
          (e.prototype.setupListeners = function () {
            var t = this,
              e = this.router,
              n = e.options.scrollBehavior,
              r = Tt && n;
            r && mt(),
              window.addEventListener(
                Tt ? "popstate" : "hashchange",
                function () {
                  var e = t.current;
                  ee() &&
                    t.transitionTo(ne(), function (n) {
                      r && gt(t.router, n, e, !0), Tt || ae(n.fullPath);
                    });
                }
              );
          }),
          (e.prototype.push = function (t, e, n) {
            var r = this,
              i = this,
              a = i.current;
            this.transitionTo(
              t,
              function (t) {
                ie(t.fullPath), gt(r.router, t, a, !1), e && e(t);
              },
              n
            );
          }),
          (e.prototype.replace = function (t, e, n) {
            var r = this,
              i = this,
              a = i.current;
            this.transitionTo(
              t,
              function (t) {
                ae(t.fullPath), gt(r.router, t, a, !1), e && e(t);
              },
              n
            );
          }),
          (e.prototype.go = function (t) {
            window.history.go(t);
          }),
          (e.prototype.ensureURL = function (t) {
            var e = this.current.fullPath;
            ne() !== e && (t ? ie(e) : ae(e));
          }),
          (e.prototype.getCurrentLocation = function () {
            return ne();
          }),
          e
        );
      })(Bt);
      function te(t) {
        var e = Zt(t);
        if (!/^\/#/.test(e))
          return window.location.replace(N(t + "/#" + e)), !0;
      }
      function ee() {
        var t = ne();
        return "/" === t.charAt(0) || (ae("/" + t), !1);
      }
      function ne() {
        var t = window.location.href,
          e = t.indexOf("#");
        return -1 === e ? "" : t.slice(e + 1);
      }
      function re(t) {
        var e = window.location.href,
          n = e.indexOf("#"),
          r = n >= 0 ? e.slice(0, n) : e;
        return r + "#" + t;
      }
      function ie(t) {
        Tt ? Pt(re(t)) : (window.location.hash = t);
      }
      function ae(t) {
        Tt ? It(re(t)) : window.location.replace(re(t));
      }
      var oe = (function (t) {
          function e(e, n) {
            t.call(this, e, n), (this.stack = []), (this.index = -1);
          }
          return (
            t && (e.__proto__ = t),
            (e.prototype = Object.create(t && t.prototype)),
            (e.prototype.constructor = e),
            (e.prototype.push = function (t, e, n) {
              var r = this;
              this.transitionTo(
                t,
                function (t) {
                  (r.stack = r.stack.slice(0, r.index + 1).concat(t)),
                    r.index++,
                    e && e(t);
                },
                n
              );
            }),
            (e.prototype.replace = function (t, e, n) {
              var r = this;
              this.transitionTo(
                t,
                function (t) {
                  (r.stack = r.stack.slice(0, r.index).concat(t)), e && e(t);
                },
                n
              );
            }),
            (e.prototype.go = function (t) {
              var e = this,
                n = this.index + t;
              if (!(n < 0 || n >= this.stack.length)) {
                var r = this.stack[n];
                this.confirmTransition(r, function () {
                  (e.index = n), e.updateRoute(r);
                });
              }
            }),
            (e.prototype.getCurrentLocation = function () {
              var t = this.stack[this.stack.length - 1];
              return t ? t.fullPath : "/";
            }),
            (e.prototype.ensureURL = function () {}),
            e
          );
        })(Bt),
        se = function (t) {
          void 0 === t && (t = {}),
            (this.app = null),
            (this.apps = []),
            (this.options = t),
            (this.beforeHooks = []),
            (this.resolveHooks = []),
            (this.afterHooks = []),
            (this.matcher = ht(t.routes || [], this));
          var e = t.mode || "hash";
          switch (
            ((this.fallback = "history" === e && !Tt && !1 !== t.fallback),
            this.fallback && (e = "hash"),
            I || (e = "abstract"),
            (this.mode = e),
            e)
          ) {
            case "history":
              this.history = new Kt(this, t.base);
              break;
            case "hash":
              this.history = new Qt(this, t.base, this.fallback);
              break;
            case "abstract":
              this.history = new oe(this, t.base);
              break;
            default:
              0;
          }
        },
        ce = { currentRoute: { configurable: !0 } };
      function le(t, e) {
        return (
          t.push(e),
          function () {
            var n = t.indexOf(e);
            n > -1 && t.splice(n, 1);
          }
        );
      }
      function ue(t, e, n) {
        var r = "hash" === n ? "#" + e : e;
        return t ? N(t + "/" + r) : r;
      }
      (se.prototype.match = function (t, e, n) {
        return this.matcher.match(t, e, n);
      }),
        (ce.currentRoute.get = function () {
          return this.history && this.history.current;
        }),
        (se.prototype.init = function (t) {
          var e = this;
          if ((this.apps.push(t), !this.app)) {
            this.app = t;
            var n = this.history;
            if (n instanceof Kt) n.transitionTo(n.getCurrentLocation());
            else if (n instanceof Qt) {
              var r = function () {
                n.setupListeners();
              };
              n.transitionTo(n.getCurrentLocation(), r, r);
            }
            n.listen(function (t) {
              e.apps.forEach(function (e) {
                e._route = t;
              });
            });
          }
        }),
        (se.prototype.beforeEach = function (t) {
          return le(this.beforeHooks, t);
        }),
        (se.prototype.beforeResolve = function (t) {
          return le(this.resolveHooks, t);
        }),
        (se.prototype.afterEach = function (t) {
          return le(this.afterHooks, t);
        }),
        (se.prototype.onReady = function (t, e) {
          this.history.onReady(t, e);
        }),
        (se.prototype.onError = function (t) {
          this.history.onError(t);
        }),
        (se.prototype.push = function (t, e, n) {
          this.history.push(t, e, n);
        }),
        (se.prototype.replace = function (t, e, n) {
          this.history.replace(t, e, n);
        }),
        (se.prototype.go = function (t) {
          this.history.go(t);
        }),
        (se.prototype.back = function () {
          this.go(-1);
        }),
        (se.prototype.forward = function () {
          this.go(1);
        }),
        (se.prototype.getMatchedComponents = function (t) {
          var e = t
            ? t.matched
              ? t
              : this.resolve(t).route
            : this.currentRoute;
          return e
            ? [].concat.apply(
                [],
                e.matched.map(function (t) {
                  return Object.keys(t.components).map(function (e) {
                    return t.components[e];
                  });
                })
              )
            : [];
        }),
        (se.prototype.resolve = function (t, e, n) {
          var r = lt(t, e || this.history.current, n, this),
            i = this.match(r, e),
            a = i.redirectedFrom || i.fullPath,
            o = this.history.base,
            s = ue(o, a, this.mode);
          return {
            location: r,
            route: i,
            href: s,
            normalizedTo: r,
            resolved: i,
          };
        }),
        (se.prototype.addRoutes = function (t) {
          this.matcher.addRoutes(t),
            this.history.current !== y &&
              this.history.transitionTo(this.history.getCurrentLocation());
        }),
        Object.defineProperties(se.prototype, ce),
        (se.install = P),
        (se.version = "2.8.1"),
        I && window.Vue && window.Vue.use(se),
        (e["Z"] = se);
    },
    6369: function (t, e, n) {
      "use strict";
      n.d(e, {
        ZP: function () {
          return $r;
        },
      });
      n(4633);
      var r = Object.freeze({}),
        i = Array.isArray;
      function a(t) {
        return void 0 === t || null === t;
      }
      function o(t) {
        return void 0 !== t && null !== t;
      }
      function s(t) {
        return !0 === t;
      }
      function c(t) {
        return !1 === t;
      }
      function l(t) {
        return (
          "string" === typeof t ||
          "number" === typeof t ||
          "symbol" === typeof t ||
          "boolean" === typeof t
        );
      }
      function u(t) {
        return "function" === typeof t;
      }
      function h(t) {
        return null !== t && "object" === typeof t;
      }
      var d = Object.prototype.toString;
      function f(t) {
        return "[object Object]" === d.call(t);
      }
      function p(t) {
        return "[object RegExp]" === d.call(t);
      }
      function m(t) {
        var e = parseFloat(String(t));
        return e >= 0 && Math.floor(e) === e && isFinite(t);
      }
      function g(t) {
        return (
          o(t) && "function" === typeof t.then && "function" === typeof t.catch
        );
      }
      function v(t) {
        return null == t
          ? ""
          : Array.isArray(t) || (f(t) && t.toString === d)
          ? JSON.stringify(t, null, 2)
          : String(t);
      }
      function y(t) {
        var e = parseFloat(t);
        return isNaN(e) ? t : e;
      }
      function b(t, e) {
        for (
          var n = Object.create(null), r = t.split(","), i = 0;
          i < r.length;
          i++
        )
          n[r[i]] = !0;
        return e
          ? function (t) {
              return n[t.toLowerCase()];
            }
          : function (t) {
              return n[t];
            };
      }
      b("slot,component", !0);
      var x = b("key,ref,slot,slot-scope,is");
      function _(t, e) {
        if (t.length) {
          var n = t.indexOf(e);
          if (n > -1) return t.splice(n, 1);
        }
      }
      var w = Object.prototype.hasOwnProperty;
      function S(t, e) {
        return w.call(t, e);
      }
      function M(t) {
        var e = Object.create(null);
        return function (n) {
          var r = e[n];
          return r || (e[n] = t(n));
        };
      }
      var T = /-(\w)/g,
        E = M(function (t) {
          return t.replace(T, function (t, e) {
            return e ? e.toUpperCase() : "";
          });
        }),
        A = M(function (t) {
          return t.charAt(0).toUpperCase() + t.slice(1);
        }),
        C = /\B([A-Z])/g,
        L = M(function (t) {
          return t.replace(C, "-$1").toLowerCase();
        });
      function R(t, e) {
        function n(n) {
          var r = arguments.length;
          return r ? (r > 1 ? t.apply(e, arguments) : t.call(e, n)) : t.call(e);
        }
        return (n._length = t.length), n;
      }
      function P(t, e) {
        return t.bind(e);
      }
      var I = Function.prototype.bind ? P : R;
      function O(t, e) {
        e = e || 0;
        var n = t.length - e,
          r = new Array(n);
        while (n--) r[n] = t[n + e];
        return r;
      }
      function k(t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      }
      function N(t) {
        for (var e = {}, n = 0; n < t.length; n++) t[n] && k(e, t[n]);
        return e;
      }
      function D(t, e, n) {}
      var z = function (t, e, n) {
          return !1;
        },
        F = function (t) {
          return t;
        };
      function U(t, e) {
        if (t === e) return !0;
        var n = h(t),
          r = h(e);
        if (!n || !r) return !n && !r && String(t) === String(e);
        try {
          var i = Array.isArray(t),
            a = Array.isArray(e);
          if (i && a)
            return (
              t.length === e.length &&
              t.every(function (t, n) {
                return U(t, e[n]);
              })
            );
          if (t instanceof Date && e instanceof Date)
            return t.getTime() === e.getTime();
          if (i || a) return !1;
          var o = Object.keys(t),
            s = Object.keys(e);
          return (
            o.length === s.length &&
            o.every(function (n) {
              return U(t[n], e[n]);
            })
          );
        } catch (c) {
          return !1;
        }
      }
      function B(t, e) {
        for (var n = 0; n < t.length; n++) if (U(t[n], e)) return n;
        return -1;
      }
      function j(t) {
        var e = !1;
        return function () {
          e || ((e = !0), t.apply(this, arguments));
        };
      }
      function H(t, e) {
        return t === e ? 0 === t && 1 / t !== 1 / e : t === t || e === e;
      }
      var V = "data-server-rendered",
        G = ["component", "directive", "filter"],
        W = [
          "beforeCreate",
          "created",
          "beforeMount",
          "mounted",
          "beforeUpdate",
          "updated",
          "beforeDestroy",
          "destroyed",
          "activated",
          "deactivated",
          "errorCaptured",
          "serverPrefetch",
          "renderTracked",
          "renderTriggered",
        ],
        q = {
          optionMergeStrategies: Object.create(null),
          silent: !1,
          productionTip: !1,
          devtools: !1,
          performance: !1,
          errorHandler: null,
          warnHandler: null,
          ignoredElements: [],
          keyCodes: Object.create(null),
          isReservedTag: z,
          isReservedAttr: z,
          isUnknownElement: z,
          getTagNamespace: D,
          parsePlatformTagName: F,
          mustUseProp: z,
          async: !0,
          _lifecycleHooks: W,
        },
        X =
          /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
      function $(t) {
        var e = (t + "").charCodeAt(0);
        return 36 === e || 95 === e;
      }
      function Y(t, e, n, r) {
        Object.defineProperty(t, e, {
          value: n,
          enumerable: !!r,
          writable: !0,
          configurable: !0,
        });
      }
      var J = new RegExp("[^".concat(X.source, ".$_\\d]"));
      function K(t) {
        if (!J.test(t)) {
          var e = t.split(".");
          return function (t) {
            for (var n = 0; n < e.length; n++) {
              if (!t) return;
              t = t[e[n]];
            }
            return t;
          };
        }
      }
      var Z = "__proto__" in {},
        Q = "undefined" !== typeof window,
        tt = Q && window.navigator.userAgent.toLowerCase(),
        et = tt && /msie|trident/.test(tt),
        nt = tt && tt.indexOf("msie 9.0") > 0,
        rt = tt && tt.indexOf("edge/") > 0;
      tt && tt.indexOf("android");
      var it = tt && /iphone|ipad|ipod|ios/.test(tt);
      tt && /chrome\/\d+/.test(tt), tt && /phantomjs/.test(tt);
      var at,
        ot = tt && tt.match(/firefox\/(\d+)/),
        st = {}.watch,
        ct = !1;
      if (Q)
        try {
          var lt = {};
          Object.defineProperty(lt, "passive", {
            get: function () {
              ct = !0;
            },
          }),
            window.addEventListener("test-passive", null, lt);
        } catch (Yo) {}
      var ut = function () {
          return (
            void 0 === at &&
              (at =
                !Q &&
                "undefined" !== typeof n.g &&
                n.g["process"] &&
                "server" === n.g["process"].env.VUE_ENV),
            at
          );
        },
        ht = Q && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
      function dt(t) {
        return "function" === typeof t && /native code/.test(t.toString());
      }
      var ft,
        pt =
          "undefined" !== typeof Symbol &&
          dt(Symbol) &&
          "undefined" !== typeof Reflect &&
          dt(Reflect.ownKeys);
      ft =
        "undefined" !== typeof Set && dt(Set)
          ? Set
          : (function () {
              function t() {
                this.set = Object.create(null);
              }
              return (
                (t.prototype.has = function (t) {
                  return !0 === this.set[t];
                }),
                (t.prototype.add = function (t) {
                  this.set[t] = !0;
                }),
                (t.prototype.clear = function () {
                  this.set = Object.create(null);
                }),
                t
              );
            })();
      var mt = null;
      function gt(t) {
        void 0 === t && (t = null),
          t || (mt && mt._scope.off()),
          (mt = t),
          t && t._scope.on();
      }
      var vt = (function () {
          function t(t, e, n, r, i, a, o, s) {
            (this.tag = t),
              (this.data = e),
              (this.children = n),
              (this.text = r),
              (this.elm = i),
              (this.ns = void 0),
              (this.context = a),
              (this.fnContext = void 0),
              (this.fnOptions = void 0),
              (this.fnScopeId = void 0),
              (this.key = e && e.key),
              (this.componentOptions = o),
              (this.componentInstance = void 0),
              (this.parent = void 0),
              (this.raw = !1),
              (this.isStatic = !1),
              (this.isRootInsert = !0),
              (this.isComment = !1),
              (this.isCloned = !1),
              (this.isOnce = !1),
              (this.asyncFactory = s),
              (this.asyncMeta = void 0),
              (this.isAsyncPlaceholder = !1);
          }
          return (
            Object.defineProperty(t.prototype, "child", {
              get: function () {
                return this.componentInstance;
              },
              enumerable: !1,
              configurable: !0,
            }),
            t
          );
        })(),
        yt = function (t) {
          void 0 === t && (t = "");
          var e = new vt();
          return (e.text = t), (e.isComment = !0), e;
        };
      function bt(t) {
        return new vt(void 0, void 0, void 0, String(t));
      }
      function xt(t) {
        var e = new vt(
          t.tag,
          t.data,
          t.children && t.children.slice(),
          t.text,
          t.elm,
          t.context,
          t.componentOptions,
          t.asyncFactory
        );
        return (
          (e.ns = t.ns),
          (e.isStatic = t.isStatic),
          (e.key = t.key),
          (e.isComment = t.isComment),
          (e.fnContext = t.fnContext),
          (e.fnOptions = t.fnOptions),
          (e.fnScopeId = t.fnScopeId),
          (e.asyncMeta = t.asyncMeta),
          (e.isCloned = !0),
          e
        );
      }
      var _t = 0,
        wt = (function () {
          function t() {
            (this.id = _t++), (this.subs = []);
          }
          return (
            (t.prototype.addSub = function (t) {
              this.subs.push(t);
            }),
            (t.prototype.removeSub = function (t) {
              _(this.subs, t);
            }),
            (t.prototype.depend = function (e) {
              t.target && t.target.addDep(this);
            }),
            (t.prototype.notify = function (t) {
              var e = this.subs.slice();
              for (var n = 0, r = e.length; n < r; n++) {
                e[n].update();
              }
            }),
            t
          );
        })();
      wt.target = null;
      var St = [];
      function Mt(t) {
        St.push(t), (wt.target = t);
      }
      function Tt() {
        St.pop(), (wt.target = St[St.length - 1]);
      }
      var Et = Array.prototype,
        At = Object.create(Et),
        Ct = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
      Ct.forEach(function (t) {
        var e = Et[t];
        Y(At, t, function () {
          for (var n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          var i,
            a = e.apply(this, n),
            o = this.__ob__;
          switch (t) {
            case "push":
            case "unshift":
              i = n;
              break;
            case "splice":
              i = n.slice(2);
              break;
          }
          return i && o.observeArray(i), o.dep.notify(), a;
        });
      });
      var Lt = Object.getOwnPropertyNames(At),
        Rt = {},
        Pt = !0;
      function It(t) {
        Pt = t;
      }
      var Ot = { notify: D, depend: D, addSub: D, removeSub: D },
        kt = (function () {
          function t(t, e, n) {
            if (
              (void 0 === e && (e = !1),
              void 0 === n && (n = !1),
              (this.value = t),
              (this.shallow = e),
              (this.mock = n),
              (this.dep = n ? Ot : new wt()),
              (this.vmCount = 0),
              Y(t, "__ob__", this),
              i(t))
            ) {
              if (!n)
                if (Z) t.__proto__ = At;
                else
                  for (var r = 0, a = Lt.length; r < a; r++) {
                    var o = Lt[r];
                    Y(t, o, At[o]);
                  }
              e || this.observeArray(t);
            } else {
              var s = Object.keys(t);
              for (r = 0; r < s.length; r++) {
                o = s[r];
                Dt(t, o, Rt, void 0, e, n);
              }
            }
          }
          return (
            (t.prototype.observeArray = function (t) {
              for (var e = 0, n = t.length; e < n; e++) Nt(t[e], !1, this.mock);
            }),
            t
          );
        })();
      function Nt(t, e, n) {
        var r;
        if (!(!h(t) || Vt(t) || t instanceof vt))
          return (
            S(t, "__ob__") && t.__ob__ instanceof kt
              ? (r = t.__ob__)
              : !Pt ||
                (!n && ut()) ||
                (!i(t) && !f(t)) ||
                !Object.isExtensible(t) ||
                t.__v_skip ||
                (r = new kt(t, e, n)),
            r
          );
      }
      function Dt(t, e, n, r, a, o) {
        var s = new wt(),
          c = Object.getOwnPropertyDescriptor(t, e);
        if (!c || !1 !== c.configurable) {
          var l = c && c.get,
            u = c && c.set;
          (l && !u) || (n !== Rt && 2 !== arguments.length) || (n = t[e]);
          var h = !a && Nt(n, !1, o);
          return (
            Object.defineProperty(t, e, {
              enumerable: !0,
              configurable: !0,
              get: function () {
                var e = l ? l.call(t) : n;
                return (
                  wt.target &&
                    (s.depend(), h && (h.dep.depend(), i(e) && Ut(e))),
                  Vt(e) && !a ? e.value : e
                );
              },
              set: function (e) {
                var r = l ? l.call(t) : n;
                if (H(r, e)) {
                  if (u) u.call(t, e);
                  else {
                    if (l) return;
                    if (!a && Vt(r) && !Vt(e)) return void (r.value = e);
                    n = e;
                  }
                  (h = !a && Nt(e, !1, o)), s.notify();
                }
              },
            }),
            s
          );
        }
      }
      function zt(t, e, n) {
        if (!Ht(t)) {
          var r = t.__ob__;
          return i(t) && m(e)
            ? ((t.length = Math.max(t.length, e)),
              t.splice(e, 1, n),
              r && !r.shallow && r.mock && Nt(n, !1, !0),
              n)
            : e in t && !(e in Object.prototype)
            ? ((t[e] = n), n)
            : t._isVue || (r && r.vmCount)
            ? n
            : r
            ? (Dt(r.value, e, n, void 0, r.shallow, r.mock), r.dep.notify(), n)
            : ((t[e] = n), n);
        }
      }
      function Ft(t, e) {
        if (i(t) && m(e)) t.splice(e, 1);
        else {
          var n = t.__ob__;
          t._isVue ||
            (n && n.vmCount) ||
            Ht(t) ||
            (S(t, e) && (delete t[e], n && n.dep.notify()));
        }
      }
      function Ut(t) {
        for (var e = void 0, n = 0, r = t.length; n < r; n++)
          (e = t[n]), e && e.__ob__ && e.__ob__.dep.depend(), i(e) && Ut(e);
      }
      function Bt(t) {
        return jt(t, !0), Y(t, "__v_isShallow", !0), t;
      }
      function jt(t, e) {
        if (!Ht(t)) {
          Nt(t, e, ut());
          0;
        }
      }
      function Ht(t) {
        return !(!t || !t.__v_isReadonly);
      }
      function Vt(t) {
        return !(!t || !0 !== t.__v_isRef);
      }
      function Gt(t, e, n) {
        Object.defineProperty(t, n, {
          enumerable: !0,
          configurable: !0,
          get: function () {
            var t = e[n];
            if (Vt(t)) return t.value;
            var r = t && t.__ob__;
            return r && r.dep.depend(), t;
          },
          set: function (t) {
            var r = e[n];
            Vt(r) && !Vt(t) ? (r.value = t) : (e[n] = t);
          },
        });
      }
      var Wt = "watcher";
      "".concat(Wt, " callback"),
        "".concat(Wt, " getter"),
        "".concat(Wt, " cleanup");
      var qt;
      var Xt = (function () {
        function t(t) {
          void 0 === t && (t = !1),
            (this.active = !0),
            (this.effects = []),
            (this.cleanups = []),
            !t &&
              qt &&
              ((this.parent = qt),
              (this.index = (qt.scopes || (qt.scopes = [])).push(this) - 1));
        }
        return (
          (t.prototype.run = function (t) {
            if (this.active) {
              var e = qt;
              try {
                return (qt = this), t();
              } finally {
                qt = e;
              }
            } else 0;
          }),
          (t.prototype.on = function () {
            qt = this;
          }),
          (t.prototype.off = function () {
            qt = this.parent;
          }),
          (t.prototype.stop = function (t) {
            if (this.active) {
              var e = void 0,
                n = void 0;
              for (e = 0, n = this.effects.length; e < n; e++)
                this.effects[e].teardown();
              for (e = 0, n = this.cleanups.length; e < n; e++)
                this.cleanups[e]();
              if (this.scopes)
                for (e = 0, n = this.scopes.length; e < n; e++)
                  this.scopes[e].stop(!0);
              if (this.parent && !t) {
                var r = this.parent.scopes.pop();
                r &&
                  r !== this &&
                  ((this.parent.scopes[this.index] = r),
                  (r.index = this.index));
              }
              this.active = !1;
            }
          }),
          t
        );
      })();
      function $t(t, e) {
        void 0 === e && (e = qt), e && e.active && e.effects.push(t);
      }
      function Yt(t) {
        var e = t._provided,
          n = t.$parent && t.$parent._provided;
        return n === e ? (t._provided = Object.create(n)) : e;
      }
      var Jt = M(function (t) {
        var e = "&" === t.charAt(0);
        t = e ? t.slice(1) : t;
        var n = "~" === t.charAt(0);
        t = n ? t.slice(1) : t;
        var r = "!" === t.charAt(0);
        return (
          (t = r ? t.slice(1) : t), { name: t, once: n, capture: r, passive: e }
        );
      });
      function Kt(t, e) {
        function n() {
          var t = n.fns;
          if (!i(t)) return Xe(t, null, arguments, e, "v-on handler");
          for (var r = t.slice(), a = 0; a < r.length; a++)
            Xe(r[a], null, arguments, e, "v-on handler");
        }
        return (n.fns = t), n;
      }
      function Zt(t, e, n, r, i, o) {
        var c, l, u, h;
        for (c in t)
          (l = t[c]),
            (u = e[c]),
            (h = Jt(c)),
            a(l) ||
              (a(u)
                ? (a(l.fns) && (l = t[c] = Kt(l, o)),
                  s(h.once) && (l = t[c] = i(h.name, l, h.capture)),
                  n(h.name, l, h.capture, h.passive, h.params))
                : l !== u && ((u.fns = l), (t[c] = u)));
        for (c in e) a(t[c]) && ((h = Jt(c)), r(h.name, e[c], h.capture));
      }
      function Qt(t, e, n) {
        var r;
        t instanceof vt && (t = t.data.hook || (t.data.hook = {}));
        var i = t[e];
        function c() {
          n.apply(this, arguments), _(r.fns, c);
        }
        a(i)
          ? (r = Kt([c]))
          : o(i.fns) && s(i.merged)
          ? ((r = i), r.fns.push(c))
          : (r = Kt([i, c])),
          (r.merged = !0),
          (t[e] = r);
      }
      function te(t, e, n) {
        var r = e.options.props;
        if (!a(r)) {
          var i = {},
            s = t.attrs,
            c = t.props;
          if (o(s) || o(c))
            for (var l in r) {
              var u = L(l);
              ee(i, c, l, u, !0) || ee(i, s, l, u, !1);
            }
          return i;
        }
      }
      function ee(t, e, n, r, i) {
        if (o(e)) {
          if (S(e, n)) return (t[n] = e[n]), i || delete e[n], !0;
          if (S(e, r)) return (t[n] = e[r]), i || delete e[r], !0;
        }
        return !1;
      }
      function ne(t) {
        for (var e = 0; e < t.length; e++)
          if (i(t[e])) return Array.prototype.concat.apply([], t);
        return t;
      }
      function re(t) {
        return l(t) ? [bt(t)] : i(t) ? ae(t) : void 0;
      }
      function ie(t) {
        return o(t) && o(t.text) && c(t.isComment);
      }
      function ae(t, e) {
        var n,
          r,
          c,
          u,
          h = [];
        for (n = 0; n < t.length; n++)
          (r = t[n]),
            a(r) ||
              "boolean" === typeof r ||
              ((c = h.length - 1),
              (u = h[c]),
              i(r)
                ? r.length > 0 &&
                  ((r = ae(r, "".concat(e || "", "_").concat(n))),
                  ie(r[0]) &&
                    ie(u) &&
                    ((h[c] = bt(u.text + r[0].text)), r.shift()),
                  h.push.apply(h, r))
                : l(r)
                ? ie(u)
                  ? (h[c] = bt(u.text + r))
                  : "" !== r && h.push(bt(r))
                : ie(r) && ie(u)
                ? (h[c] = bt(u.text + r.text))
                : (s(t._isVList) &&
                    o(r.tag) &&
                    a(r.key) &&
                    o(e) &&
                    (r.key = "__vlist".concat(e, "_").concat(n, "__")),
                  h.push(r)));
        return h;
      }
      function oe(t, e) {
        var n,
          r,
          a,
          s,
          c = null;
        if (i(t) || "string" === typeof t)
          for (c = new Array(t.length), n = 0, r = t.length; n < r; n++)
            c[n] = e(t[n], n);
        else if ("number" === typeof t)
          for (c = new Array(t), n = 0; n < t; n++) c[n] = e(n + 1, n);
        else if (h(t))
          if (pt && t[Symbol.iterator]) {
            c = [];
            var l = t[Symbol.iterator](),
              u = l.next();
            while (!u.done) c.push(e(u.value, c.length)), (u = l.next());
          } else
            for (
              a = Object.keys(t), c = new Array(a.length), n = 0, r = a.length;
              n < r;
              n++
            )
              (s = a[n]), (c[n] = e(t[s], s, n));
        return o(c) || (c = []), (c._isVList = !0), c;
      }
      function se(t, e, n, r) {
        var i,
          a = this.$scopedSlots[t];
        a
          ? ((n = n || {}),
            r && (n = k(k({}, r), n)),
            (i = a(n) || (u(e) ? e() : e)))
          : (i = this.$slots[t] || (u(e) ? e() : e));
        var o = n && n.slot;
        return o ? this.$createElement("template", { slot: o }, i) : i;
      }
      function ce(t) {
        return _r(this.$options, "filters", t, !0) || F;
      }
      function le(t, e) {
        return i(t) ? -1 === t.indexOf(e) : t !== e;
      }
      function ue(t, e, n, r, i) {
        var a = q.keyCodes[e] || n;
        return i && r && !q.keyCodes[e]
          ? le(i, r)
          : a
          ? le(a, t)
          : r
          ? L(r) !== e
          : void 0 === t;
      }
      function he(t, e, n, r, a) {
        if (n)
          if (h(n)) {
            i(n) && (n = N(n));
            var o = void 0,
              s = function (i) {
                if ("class" === i || "style" === i || x(i)) o = t;
                else {
                  var s = t.attrs && t.attrs.type;
                  o =
                    r || q.mustUseProp(e, s, i)
                      ? t.domProps || (t.domProps = {})
                      : t.attrs || (t.attrs = {});
                }
                var c = E(i),
                  l = L(i);
                if (!(c in o) && !(l in o) && ((o[i] = n[i]), a)) {
                  var u = t.on || (t.on = {});
                  u["update:".concat(i)] = function (t) {
                    n[i] = t;
                  };
                }
              };
            for (var c in n) s(c);
          } else;
        return t;
      }
      function de(t, e) {
        var n = this._staticTrees || (this._staticTrees = []),
          r = n[t];
        return (
          (r && !e) ||
            ((r = n[t] =
              this.$options.staticRenderFns[t].call(
                this._renderProxy,
                this._c,
                this
              )),
            pe(r, "__static__".concat(t), !1)),
          r
        );
      }
      function fe(t, e, n) {
        return (
          pe(t, "__once__".concat(e).concat(n ? "_".concat(n) : ""), !0), t
        );
      }
      function pe(t, e, n) {
        if (i(t))
          for (var r = 0; r < t.length; r++)
            t[r] &&
              "string" !== typeof t[r] &&
              me(t[r], "".concat(e, "_").concat(r), n);
        else me(t, e, n);
      }
      function me(t, e, n) {
        (t.isStatic = !0), (t.key = e), (t.isOnce = n);
      }
      function ge(t, e) {
        if (e)
          if (f(e)) {
            var n = (t.on = t.on ? k({}, t.on) : {});
            for (var r in e) {
              var i = n[r],
                a = e[r];
              n[r] = i ? [].concat(i, a) : a;
            }
          } else;
        return t;
      }
      function ve(t, e, n, r) {
        e = e || { $stable: !n };
        for (var a = 0; a < t.length; a++) {
          var o = t[a];
          i(o)
            ? ve(o, e, n)
            : o && (o.proxy && (o.fn.proxy = !0), (e[o.key] = o.fn));
        }
        return r && (e.$key = r), e;
      }
      function ye(t, e) {
        for (var n = 0; n < e.length; n += 2) {
          var r = e[n];
          "string" === typeof r && r && (t[e[n]] = e[n + 1]);
        }
        return t;
      }
      function be(t, e) {
        return "string" === typeof t ? e + t : t;
      }
      function xe(t) {
        (t._o = fe),
          (t._n = y),
          (t._s = v),
          (t._l = oe),
          (t._t = se),
          (t._q = U),
          (t._i = B),
          (t._m = de),
          (t._f = ce),
          (t._k = ue),
          (t._b = he),
          (t._v = bt),
          (t._e = yt),
          (t._u = ve),
          (t._g = ge),
          (t._d = ye),
          (t._p = be);
      }
      function _e(t, e) {
        if (!t || !t.length) return {};
        for (var n = {}, r = 0, i = t.length; r < i; r++) {
          var a = t[r],
            o = a.data;
          if (
            (o && o.attrs && o.attrs.slot && delete o.attrs.slot,
            (a.context !== e && a.fnContext !== e) || !o || null == o.slot)
          )
            (n.default || (n.default = [])).push(a);
          else {
            var s = o.slot,
              c = n[s] || (n[s] = []);
            "template" === a.tag
              ? c.push.apply(c, a.children || [])
              : c.push(a);
          }
        }
        for (var l in n) n[l].every(we) && delete n[l];
        return n;
      }
      function we(t) {
        return (t.isComment && !t.asyncFactory) || " " === t.text;
      }
      function Se(t) {
        return t.isComment && t.asyncFactory;
      }
      function Me(t, e, n, i) {
        var a,
          o = Object.keys(n).length > 0,
          s = e ? !!e.$stable : !o,
          c = e && e.$key;
        if (e) {
          if (e._normalized) return e._normalized;
          if (s && i && i !== r && c === i.$key && !o && !i.$hasNormal)
            return i;
          for (var l in ((a = {}), e))
            e[l] && "$" !== l[0] && (a[l] = Te(t, n, l, e[l]));
        } else a = {};
        for (var u in n) u in a || (a[u] = Ee(n, u));
        return (
          e && Object.isExtensible(e) && (e._normalized = a),
          Y(a, "$stable", s),
          Y(a, "$key", c),
          Y(a, "$hasNormal", o),
          a
        );
      }
      function Te(t, e, n, r) {
        var a = function () {
          var e = mt;
          gt(t);
          var n = arguments.length ? r.apply(null, arguments) : r({});
          n = n && "object" === typeof n && !i(n) ? [n] : re(n);
          var a = n && n[0];
          return (
            gt(e),
            n && (!a || (1 === n.length && a.isComment && !Se(a))) ? void 0 : n
          );
        };
        return (
          r.proxy &&
            Object.defineProperty(e, n, {
              get: a,
              enumerable: !0,
              configurable: !0,
            }),
          a
        );
      }
      function Ee(t, e) {
        return function () {
          return t[e];
        };
      }
      function Ae(t) {
        var e = t.$options,
          n = e.setup;
        if (n) {
          var r = (t._setupContext = Ce(t));
          gt(t), Mt();
          var i = Xe(n, null, [t._props || Bt({}), r], t, "setup");
          if ((Tt(), gt(), u(i))) e.render = i;
          else if (h(i))
            if (((t._setupState = i), i.__sfc)) {
              var a = (t._setupProxy = {});
              for (var o in i) "__sfc" !== o && Gt(a, i, o);
            } else for (var o in i) $(o) || Gt(t, i, o);
          else 0;
        }
      }
      function Ce(t) {
        return {
          get attrs() {
            if (!t._attrsProxy) {
              var e = (t._attrsProxy = {});
              Y(e, "_v_attr_proxy", !0), Le(e, t.$attrs, r, t, "$attrs");
            }
            return t._attrsProxy;
          },
          get listeners() {
            if (!t._listenersProxy) {
              var e = (t._listenersProxy = {});
              Le(e, t.$listeners, r, t, "$listeners");
            }
            return t._listenersProxy;
          },
          get slots() {
            return Pe(t);
          },
          emit: I(t.$emit, t),
          expose: function (e) {
            e &&
              Object.keys(e).forEach(function (n) {
                return Gt(t, e, n);
              });
          },
        };
      }
      function Le(t, e, n, r, i) {
        var a = !1;
        for (var o in e)
          o in t ? e[o] !== n[o] && (a = !0) : ((a = !0), Re(t, o, r, i));
        for (var o in t) o in e || ((a = !0), delete t[o]);
        return a;
      }
      function Re(t, e, n, r) {
        Object.defineProperty(t, e, {
          enumerable: !0,
          configurable: !0,
          get: function () {
            return n[r][e];
          },
        });
      }
      function Pe(t) {
        return (
          t._slotsProxy || Ie((t._slotsProxy = {}), t.$scopedSlots),
          t._slotsProxy
        );
      }
      function Ie(t, e) {
        for (var n in e) t[n] = e[n];
        for (var n in t) n in e || delete t[n];
      }
      function Oe(t) {
        (t._vnode = null), (t._staticTrees = null);
        var e = t.$options,
          n = (t.$vnode = e._parentVnode),
          i = n && n.context;
        (t.$slots = _e(e._renderChildren, i)),
          (t.$scopedSlots = n
            ? Me(t.$parent, n.data.scopedSlots, t.$slots)
            : r),
          (t._c = function (e, n, r, i) {
            return He(t, e, n, r, i, !1);
          }),
          (t.$createElement = function (e, n, r, i) {
            return He(t, e, n, r, i, !0);
          });
        var a = n && n.data;
        Dt(t, "$attrs", (a && a.attrs) || r, null, !0),
          Dt(t, "$listeners", e._parentListeners || r, null, !0);
      }
      var ke = null;
      function Ne(t) {
        xe(t.prototype),
          (t.prototype.$nextTick = function (t) {
            return on(t, this);
          }),
          (t.prototype._render = function () {
            var t,
              e = this,
              n = e.$options,
              r = n.render,
              a = n._parentVnode;
            a &&
              e._isMounted &&
              ((e.$scopedSlots = Me(
                e.$parent,
                a.data.scopedSlots,
                e.$slots,
                e.$scopedSlots
              )),
              e._slotsProxy && Ie(e._slotsProxy, e.$scopedSlots)),
              (e.$vnode = a);
            try {
              gt(e), (ke = e), (t = r.call(e._renderProxy, e.$createElement));
            } catch (Yo) {
              qe(Yo, e, "render"), (t = e._vnode);
            } finally {
              (ke = null), gt();
            }
            return (
              i(t) && 1 === t.length && (t = t[0]),
              t instanceof vt || (t = yt()),
              (t.parent = a),
              t
            );
          });
      }
      function De(t, e) {
        return (
          (t.__esModule || (pt && "Module" === t[Symbol.toStringTag])) &&
            (t = t.default),
          h(t) ? e.extend(t) : t
        );
      }
      function ze(t, e, n, r, i) {
        var a = yt();
        return (
          (a.asyncFactory = t),
          (a.asyncMeta = { data: e, context: n, children: r, tag: i }),
          a
        );
      }
      function Fe(t, e) {
        if (s(t.error) && o(t.errorComp)) return t.errorComp;
        if (o(t.resolved)) return t.resolved;
        var n = ke;
        if (
          (n && o(t.owners) && -1 === t.owners.indexOf(n) && t.owners.push(n),
          s(t.loading) && o(t.loadingComp))
        )
          return t.loadingComp;
        if (n && !o(t.owners)) {
          var r = (t.owners = [n]),
            i = !0,
            c = null,
            l = null;
          n.$on("hook:destroyed", function () {
            return _(r, n);
          });
          var u = function (t) {
              for (var e = 0, n = r.length; e < n; e++) r[e].$forceUpdate();
              t &&
                ((r.length = 0),
                null !== c && (clearTimeout(c), (c = null)),
                null !== l && (clearTimeout(l), (l = null)));
            },
            d = j(function (n) {
              (t.resolved = De(n, e)), i ? (r.length = 0) : u(!0);
            }),
            f = j(function (e) {
              o(t.errorComp) && ((t.error = !0), u(!0));
            }),
            p = t(d, f);
          return (
            h(p) &&
              (g(p)
                ? a(t.resolved) && p.then(d, f)
                : g(p.component) &&
                  (p.component.then(d, f),
                  o(p.error) && (t.errorComp = De(p.error, e)),
                  o(p.loading) &&
                    ((t.loadingComp = De(p.loading, e)),
                    0 === p.delay
                      ? (t.loading = !0)
                      : (c = setTimeout(function () {
                          (c = null),
                            a(t.resolved) &&
                              a(t.error) &&
                              ((t.loading = !0), u(!1));
                        }, p.delay || 200))),
                  o(p.timeout) &&
                    (l = setTimeout(function () {
                      (l = null), a(t.resolved) && f(null);
                    }, p.timeout)))),
            (i = !1),
            t.loading ? t.loadingComp : t.resolved
          );
        }
      }
      function Ue(t) {
        if (i(t))
          for (var e = 0; e < t.length; e++) {
            var n = t[e];
            if (o(n) && (o(n.componentOptions) || Se(n))) return n;
          }
      }
      var Be = 1,
        je = 2;
      function He(t, e, n, r, a, o) {
        return (
          (i(n) || l(n)) && ((a = r), (r = n), (n = void 0)),
          s(o) && (a = je),
          Ve(t, e, n, r, a)
        );
      }
      function Ve(t, e, n, r, a) {
        if (o(n) && o(n.__ob__)) return yt();
        if ((o(n) && o(n.is) && (e = n.is), !e)) return yt();
        var s, c;
        if (
          (i(r) &&
            u(r[0]) &&
            ((n = n || {}),
            (n.scopedSlots = { default: r[0] }),
            (r.length = 0)),
          a === je ? (r = re(r)) : a === Be && (r = ne(r)),
          "string" === typeof e)
        ) {
          var l = void 0;
          (c = (t.$vnode && t.$vnode.ns) || q.getTagNamespace(e)),
            (s = q.isReservedTag(e)
              ? new vt(q.parsePlatformTagName(e), n, r, void 0, void 0, t)
              : (n && n.pre) || !o((l = _r(t.$options, "components", e)))
              ? new vt(e, n, r, void 0, void 0, t)
              : ir(l, n, t, r, e));
        } else s = ir(e, n, t, r);
        return i(s) ? s : o(s) ? (o(c) && Ge(s, c), o(n) && We(n), s) : yt();
      }
      function Ge(t, e, n) {
        if (
          ((t.ns = e),
          "foreignObject" === t.tag && ((e = void 0), (n = !0)),
          o(t.children))
        )
          for (var r = 0, i = t.children.length; r < i; r++) {
            var c = t.children[r];
            o(c.tag) && (a(c.ns) || (s(n) && "svg" !== c.tag)) && Ge(c, e, n);
          }
      }
      function We(t) {
        h(t.style) && hn(t.style), h(t.class) && hn(t.class);
      }
      function qe(t, e, n) {
        Mt();
        try {
          if (e) {
            var r = e;
            while ((r = r.$parent)) {
              var i = r.$options.errorCaptured;
              if (i)
                for (var a = 0; a < i.length; a++)
                  try {
                    var o = !1 === i[a].call(r, t, e, n);
                    if (o) return;
                  } catch (Yo) {
                    $e(Yo, r, "errorCaptured hook");
                  }
            }
          }
          $e(t, e, n);
        } finally {
          Tt();
        }
      }
      function Xe(t, e, n, r, i) {
        var a;
        try {
          (a = n ? t.apply(e, n) : t.call(e)),
            a &&
              !a._isVue &&
              g(a) &&
              !a._handled &&
              (a.catch(function (t) {
                return qe(t, r, i + " (Promise/async)");
              }),
              (a._handled = !0));
        } catch (Yo) {
          qe(Yo, r, i);
        }
        return a;
      }
      function $e(t, e, n) {
        if (q.errorHandler)
          try {
            return q.errorHandler.call(null, t, e, n);
          } catch (Yo) {
            Yo !== t && Ye(Yo, null, "config.errorHandler");
          }
        Ye(t, e, n);
      }
      function Ye(t, e, n) {
        if (!Q || "undefined" === typeof console) throw t;
        console.error(t);
      }
      var Je,
        Ke = !1,
        Ze = [],
        Qe = !1;
      function tn() {
        Qe = !1;
        var t = Ze.slice(0);
        Ze.length = 0;
        for (var e = 0; e < t.length; e++) t[e]();
      }
      if ("undefined" !== typeof Promise && dt(Promise)) {
        var en = Promise.resolve();
        (Je = function () {
          en.then(tn), it && setTimeout(D);
        }),
          (Ke = !0);
      } else if (
        et ||
        "undefined" === typeof MutationObserver ||
        (!dt(MutationObserver) &&
          "[object MutationObserverConstructor]" !==
            MutationObserver.toString())
      )
        Je =
          "undefined" !== typeof setImmediate && dt(setImmediate)
            ? function () {
                setImmediate(tn);
              }
            : function () {
                setTimeout(tn, 0);
              };
      else {
        var nn = 1,
          rn = new MutationObserver(tn),
          an = document.createTextNode(String(nn));
        rn.observe(an, { characterData: !0 }),
          (Je = function () {
            (nn = (nn + 1) % 2), (an.data = String(nn));
          }),
          (Ke = !0);
      }
      function on(t, e) {
        var n;
        if (
          (Ze.push(function () {
            if (t)
              try {
                t.call(e);
              } catch (Yo) {
                qe(Yo, e, "nextTick");
              }
            else n && n(e);
          }),
          Qe || ((Qe = !0), Je()),
          !t && "undefined" !== typeof Promise)
        )
          return new Promise(function (t) {
            n = t;
          });
      }
      function sn(t) {
        return function (e, n) {
          if ((void 0 === n && (n = mt), n)) return cn(n, t, e);
        };
      }
      function cn(t, e, n) {
        var r = t.$options;
        r[e] = fr(r[e], n);
      }
      sn("beforeMount"),
        sn("mounted"),
        sn("beforeUpdate"),
        sn("updated"),
        sn("beforeDestroy"),
        sn("destroyed"),
        sn("errorCaptured"),
        sn("activated"),
        sn("deactivated"),
        sn("serverPrefetch"),
        sn("renderTracked"),
        sn("renderTriggered");
      var ln = "2.7.8";
      var un = new ft();
      function hn(t) {
        return dn(t, un), un.clear(), t;
      }
      function dn(t, e) {
        var n,
          r,
          a = i(t);
        if (!((!a && !h(t)) || Object.isFrozen(t) || t instanceof vt)) {
          if (t.__ob__) {
            var o = t.__ob__.dep.id;
            if (e.has(o)) return;
            e.add(o);
          }
          if (a) {
            n = t.length;
            while (n--) dn(t[n], e);
          } else if (Vt(t)) dn(t.value, e);
          else {
            (r = Object.keys(t)), (n = r.length);
            while (n--) dn(t[r[n]], e);
          }
        }
      }
      var fn,
        pn = 0,
        mn = (function () {
          function t(t, e, n, r, i) {
            $t(this, qt || (t ? t._scope : void 0)),
              (this.vm = t) && i && (t._watcher = this),
              r
                ? ((this.deep = !!r.deep),
                  (this.user = !!r.user),
                  (this.lazy = !!r.lazy),
                  (this.sync = !!r.sync),
                  (this.before = r.before))
                : (this.deep = this.user = this.lazy = this.sync = !1),
              (this.cb = n),
              (this.id = ++pn),
              (this.active = !0),
              (this.post = !1),
              (this.dirty = this.lazy),
              (this.deps = []),
              (this.newDeps = []),
              (this.depIds = new ft()),
              (this.newDepIds = new ft()),
              (this.expression = ""),
              u(e)
                ? (this.getter = e)
                : ((this.getter = K(e)), this.getter || (this.getter = D)),
              (this.value = this.lazy ? void 0 : this.get());
          }
          return (
            (t.prototype.get = function () {
              var t;
              Mt(this);
              var e = this.vm;
              try {
                t = this.getter.call(e, e);
              } catch (Yo) {
                if (!this.user) throw Yo;
                qe(Yo, e, 'getter for watcher "'.concat(this.expression, '"'));
              } finally {
                this.deep && hn(t), Tt(), this.cleanupDeps();
              }
              return t;
            }),
            (t.prototype.addDep = function (t) {
              var e = t.id;
              this.newDepIds.has(e) ||
                (this.newDepIds.add(e),
                this.newDeps.push(t),
                this.depIds.has(e) || t.addSub(this));
            }),
            (t.prototype.cleanupDeps = function () {
              var t = this.deps.length;
              while (t--) {
                var e = this.deps[t];
                this.newDepIds.has(e.id) || e.removeSub(this);
              }
              var n = this.depIds;
              (this.depIds = this.newDepIds),
                (this.newDepIds = n),
                this.newDepIds.clear(),
                (n = this.deps),
                (this.deps = this.newDeps),
                (this.newDeps = n),
                (this.newDeps.length = 0);
            }),
            (t.prototype.update = function () {
              this.lazy ? (this.dirty = !0) : this.sync ? this.run() : Xn(this);
            }),
            (t.prototype.run = function () {
              if (this.active) {
                var t = this.get();
                if (t !== this.value || h(t) || this.deep) {
                  var e = this.value;
                  if (((this.value = t), this.user)) {
                    var n = 'callback for watcher "'.concat(
                      this.expression,
                      '"'
                    );
                    Xe(this.cb, this.vm, [t, e], this.vm, n);
                  } else this.cb.call(this.vm, t, e);
                }
              }
            }),
            (t.prototype.evaluate = function () {
              (this.value = this.get()), (this.dirty = !1);
            }),
            (t.prototype.depend = function () {
              var t = this.deps.length;
              while (t--) this.deps[t].depend();
            }),
            (t.prototype.teardown = function () {
              if (
                (this.vm &&
                  !this.vm._isBeingDestroyed &&
                  _(this.vm._scope.effects, this),
                this.active)
              ) {
                var t = this.deps.length;
                while (t--) this.deps[t].removeSub(this);
                (this.active = !1), this.onStop && this.onStop();
              }
            }),
            t
          );
        })();
      function gn(t) {
        (t._events = Object.create(null)), (t._hasHookEvent = !1);
        var e = t.$options._parentListeners;
        e && xn(t, e);
      }
      function vn(t, e) {
        fn.$on(t, e);
      }
      function yn(t, e) {
        fn.$off(t, e);
      }
      function bn(t, e) {
        var n = fn;
        return function r() {
          var i = e.apply(null, arguments);
          null !== i && n.$off(t, r);
        };
      }
      function xn(t, e, n) {
        (fn = t), Zt(e, n || {}, vn, yn, bn, t), (fn = void 0);
      }
      function _n(t) {
        var e = /^hook:/;
        (t.prototype.$on = function (t, n) {
          var r = this;
          if (i(t)) for (var a = 0, o = t.length; a < o; a++) r.$on(t[a], n);
          else
            (r._events[t] || (r._events[t] = [])).push(n),
              e.test(t) && (r._hasHookEvent = !0);
          return r;
        }),
          (t.prototype.$once = function (t, e) {
            var n = this;
            function r() {
              n.$off(t, r), e.apply(n, arguments);
            }
            return (r.fn = e), n.$on(t, r), n;
          }),
          (t.prototype.$off = function (t, e) {
            var n = this;
            if (!arguments.length) return (n._events = Object.create(null)), n;
            if (i(t)) {
              for (var r = 0, a = t.length; r < a; r++) n.$off(t[r], e);
              return n;
            }
            var o,
              s = n._events[t];
            if (!s) return n;
            if (!e) return (n._events[t] = null), n;
            var c = s.length;
            while (c--)
              if (((o = s[c]), o === e || o.fn === e)) {
                s.splice(c, 1);
                break;
              }
            return n;
          }),
          (t.prototype.$emit = function (t) {
            var e = this,
              n = e._events[t];
            if (n) {
              n = n.length > 1 ? O(n) : n;
              for (
                var r = O(arguments, 1),
                  i = 'event handler for "'.concat(t, '"'),
                  a = 0,
                  o = n.length;
                a < o;
                a++
              )
                Xe(n[a], e, r, e, i);
            }
            return e;
          });
      }
      var wn = null;
      function Sn(t) {
        var e = wn;
        return (
          (wn = t),
          function () {
            wn = e;
          }
        );
      }
      function Mn(t) {
        var e = t.$options,
          n = e.parent;
        if (n && !e.abstract) {
          while (n.$options.abstract && n.$parent) n = n.$parent;
          n.$children.push(t);
        }
        (t.$parent = n),
          (t.$root = n ? n.$root : t),
          (t.$children = []),
          (t.$refs = {}),
          (t._provided = n ? n._provided : Object.create(null)),
          (t._watcher = null),
          (t._inactive = null),
          (t._directInactive = !1),
          (t._isMounted = !1),
          (t._isDestroyed = !1),
          (t._isBeingDestroyed = !1);
      }
      function Tn(t) {
        (t.prototype._update = function (t, e) {
          var n = this,
            r = n.$el,
            i = n._vnode,
            a = Sn(n);
          (n._vnode = t),
            (n.$el = i ? n.__patch__(i, t) : n.__patch__(n.$el, t, e, !1)),
            a(),
            r && (r.__vue__ = null),
            n.$el && (n.$el.__vue__ = n),
            n.$vnode &&
              n.$parent &&
              n.$vnode === n.$parent._vnode &&
              (n.$parent.$el = n.$el);
        }),
          (t.prototype.$forceUpdate = function () {
            var t = this;
            t._watcher && t._watcher.update();
          }),
          (t.prototype.$destroy = function () {
            var t = this;
            if (!t._isBeingDestroyed) {
              Pn(t, "beforeDestroy"), (t._isBeingDestroyed = !0);
              var e = t.$parent;
              !e ||
                e._isBeingDestroyed ||
                t.$options.abstract ||
                _(e.$children, t),
                t._scope.stop(),
                t._data.__ob__ && t._data.__ob__.vmCount--,
                (t._isDestroyed = !0),
                t.__patch__(t._vnode, null),
                Pn(t, "destroyed"),
                t.$off(),
                t.$el && (t.$el.__vue__ = null),
                t.$vnode && (t.$vnode.parent = null);
            }
          });
      }
      function En(t, e, n) {
        var r;
        (t.$el = e),
          t.$options.render || (t.$options.render = yt),
          Pn(t, "beforeMount"),
          (r = function () {
            t._update(t._render(), n);
          });
        var i = {
          before: function () {
            t._isMounted && !t._isDestroyed && Pn(t, "beforeUpdate");
          },
        };
        new mn(t, r, D, i, !0), (n = !1);
        var a = t._preWatchers;
        if (a) for (var o = 0; o < a.length; o++) a[o].run();
        return null == t.$vnode && ((t._isMounted = !0), Pn(t, "mounted")), t;
      }
      function An(t, e, n, i, a) {
        var o = i.data.scopedSlots,
          s = t.$scopedSlots,
          c = !!(
            (o && !o.$stable) ||
            (s !== r && !s.$stable) ||
            (o && t.$scopedSlots.$key !== o.$key) ||
            (!o && t.$scopedSlots.$key)
          ),
          l = !!(a || t.$options._renderChildren || c),
          u = t.$vnode;
        (t.$options._parentVnode = i),
          (t.$vnode = i),
          t._vnode && (t._vnode.parent = i),
          (t.$options._renderChildren = a);
        var h = i.data.attrs || r;
        t._attrsProxy &&
          Le(t._attrsProxy, h, (u.data && u.data.attrs) || r, t, "$attrs") &&
          (l = !0),
          (t.$attrs = h),
          (n = n || r);
        var d = t.$options._parentListeners;
        if (
          (t._listenersProxy &&
            Le(t._listenersProxy, n, d || r, t, "$listeners"),
          (t.$listeners = t.$options._parentListeners = n),
          xn(t, n, d),
          e && t.$options.props)
        ) {
          It(!1);
          for (
            var f = t._props, p = t.$options._propKeys || [], m = 0;
            m < p.length;
            m++
          ) {
            var g = p[m],
              v = t.$options.props;
            f[g] = wr(g, v, e, t);
          }
          It(!0), (t.$options.propsData = e);
        }
        l && ((t.$slots = _e(a, i.context)), t.$forceUpdate());
      }
      function Cn(t) {
        while (t && (t = t.$parent)) if (t._inactive) return !0;
        return !1;
      }
      function Ln(t, e) {
        if (e) {
          if (((t._directInactive = !1), Cn(t))) return;
        } else if (t._directInactive) return;
        if (t._inactive || null === t._inactive) {
          t._inactive = !1;
          for (var n = 0; n < t.$children.length; n++) Ln(t.$children[n]);
          Pn(t, "activated");
        }
      }
      function Rn(t, e) {
        if ((!e || ((t._directInactive = !0), !Cn(t))) && !t._inactive) {
          t._inactive = !0;
          for (var n = 0; n < t.$children.length; n++) Rn(t.$children[n]);
          Pn(t, "deactivated");
        }
      }
      function Pn(t, e, n, r) {
        void 0 === r && (r = !0), Mt();
        var i = mt;
        r && gt(t);
        var a = t.$options[e],
          o = "".concat(e, " hook");
        if (a)
          for (var s = 0, c = a.length; s < c; s++)
            Xe(a[s], t, n || null, t, o);
        t._hasHookEvent && t.$emit("hook:" + e), r && gt(i), Tt();
      }
      var In = [],
        On = [],
        kn = {},
        Nn = !1,
        Dn = !1,
        zn = 0;
      function Fn() {
        (zn = In.length = On.length = 0), (kn = {}), (Nn = Dn = !1);
      }
      var Un = 0,
        Bn = Date.now;
      if (Q && !et) {
        var jn = window.performance;
        jn &&
          "function" === typeof jn.now &&
          Bn() > document.createEvent("Event").timeStamp &&
          (Bn = function () {
            return jn.now();
          });
      }
      var Hn = function (t, e) {
        if (t.post) {
          if (!e.post) return 1;
        } else if (e.post) return -1;
        return t.id - e.id;
      };
      function Vn() {
        var t, e;
        for (Un = Bn(), Dn = !0, In.sort(Hn), zn = 0; zn < In.length; zn++)
          (t = In[zn]),
            t.before && t.before(),
            (e = t.id),
            (kn[e] = null),
            t.run();
        var n = On.slice(),
          r = In.slice();
        Fn(), qn(n), Gn(r), ht && q.devtools && ht.emit("flush");
      }
      function Gn(t) {
        var e = t.length;
        while (e--) {
          var n = t[e],
            r = n.vm;
          r &&
            r._watcher === n &&
            r._isMounted &&
            !r._isDestroyed &&
            Pn(r, "updated");
        }
      }
      function Wn(t) {
        (t._inactive = !1), On.push(t);
      }
      function qn(t) {
        for (var e = 0; e < t.length; e++) (t[e]._inactive = !0), Ln(t[e], !0);
      }
      function Xn(t) {
        var e = t.id;
        if (null == kn[e] && (t !== wt.target || !t.noRecurse)) {
          if (((kn[e] = !0), Dn)) {
            var n = In.length - 1;
            while (n > zn && In[n].id > t.id) n--;
            In.splice(n + 1, 0, t);
          } else In.push(t);
          Nn || ((Nn = !0), on(Vn));
        }
      }
      function $n(t) {
        var e = t.$options.provide;
        if (e) {
          var n = u(e) ? e.call(t) : e;
          if (!h(n)) return;
          for (
            var r = Yt(t), i = pt ? Reflect.ownKeys(n) : Object.keys(n), a = 0;
            a < i.length;
            a++
          ) {
            var o = i[a];
            Object.defineProperty(r, o, Object.getOwnPropertyDescriptor(n, o));
          }
        }
      }
      function Yn(t) {
        var e = Jn(t.$options.inject, t);
        e &&
          (It(!1),
          Object.keys(e).forEach(function (n) {
            Dt(t, n, e[n]);
          }),
          It(!0));
      }
      function Jn(t, e) {
        if (t) {
          for (
            var n = Object.create(null),
              r = pt ? Reflect.ownKeys(t) : Object.keys(t),
              i = 0;
            i < r.length;
            i++
          ) {
            var a = r[i];
            if ("__ob__" !== a) {
              var o = t[a].from;
              if (o in e._provided) n[a] = e._provided[o];
              else if ("default" in t[a]) {
                var s = t[a].default;
                n[a] = u(s) ? s.call(e) : s;
              } else 0;
            }
          }
          return n;
        }
      }
      function Kn(t, e, n, a, o) {
        var c,
          l = this,
          u = o.options;
        S(a, "_uid")
          ? ((c = Object.create(a)), (c._original = a))
          : ((c = a), (a = a._original));
        var h = s(u._compiled),
          d = !h;
        (this.data = t),
          (this.props = e),
          (this.children = n),
          (this.parent = a),
          (this.listeners = t.on || r),
          (this.injections = Jn(u.inject, a)),
          (this.slots = function () {
            return (
              l.$slots || Me(a, t.scopedSlots, (l.$slots = _e(n, a))), l.$slots
            );
          }),
          Object.defineProperty(this, "scopedSlots", {
            enumerable: !0,
            get: function () {
              return Me(a, t.scopedSlots, this.slots());
            },
          }),
          h &&
            ((this.$options = u),
            (this.$slots = this.slots()),
            (this.$scopedSlots = Me(a, t.scopedSlots, this.$slots))),
          u._scopeId
            ? (this._c = function (t, e, n, r) {
                var o = He(c, t, e, n, r, d);
                return (
                  o && !i(o) && ((o.fnScopeId = u._scopeId), (o.fnContext = a)),
                  o
                );
              })
            : (this._c = function (t, e, n, r) {
                return He(c, t, e, n, r, d);
              });
      }
      function Zn(t, e, n, a, s) {
        var c = t.options,
          l = {},
          u = c.props;
        if (o(u)) for (var h in u) l[h] = wr(h, u, e || r);
        else o(n.attrs) && tr(l, n.attrs), o(n.props) && tr(l, n.props);
        var d = new Kn(n, l, s, a, t),
          f = c.render.call(null, d._c, d);
        if (f instanceof vt) return Qn(f, n, d.parent, c, d);
        if (i(f)) {
          for (
            var p = re(f) || [], m = new Array(p.length), g = 0;
            g < p.length;
            g++
          )
            m[g] = Qn(p[g], n, d.parent, c, d);
          return m;
        }
      }
      function Qn(t, e, n, r, i) {
        var a = xt(t);
        return (
          (a.fnContext = n),
          (a.fnOptions = r),
          e.slot && ((a.data || (a.data = {})).slot = e.slot),
          a
        );
      }
      function tr(t, e) {
        for (var n in e) t[E(n)] = e[n];
      }
      function er(t) {
        return t.name || t.__name || t._componentTag;
      }
      xe(Kn.prototype);
      var nr = {
          init: function (t, e) {
            if (
              t.componentInstance &&
              !t.componentInstance._isDestroyed &&
              t.data.keepAlive
            ) {
              var n = t;
              nr.prepatch(n, n);
            } else {
              var r = (t.componentInstance = ar(t, wn));
              r.$mount(e ? t.elm : void 0, e);
            }
          },
          prepatch: function (t, e) {
            var n = e.componentOptions,
              r = (e.componentInstance = t.componentInstance);
            An(r, n.propsData, n.listeners, e, n.children);
          },
          insert: function (t) {
            var e = t.context,
              n = t.componentInstance;
            n._isMounted || ((n._isMounted = !0), Pn(n, "mounted")),
              t.data.keepAlive && (e._isMounted ? Wn(n) : Ln(n, !0));
          },
          destroy: function (t) {
            var e = t.componentInstance;
            e._isDestroyed || (t.data.keepAlive ? Rn(e, !0) : e.$destroy());
          },
        },
        rr = Object.keys(nr);
      function ir(t, e, n, r, i) {
        if (!a(t)) {
          var c = n.$options._base;
          if ((h(t) && (t = c.extend(t)), "function" === typeof t)) {
            var l;
            if (a(t.cid) && ((l = t), (t = Fe(l, c)), void 0 === t))
              return ze(l, e, n, r, i);
            (e = e || {}), qr(t), o(e.model) && cr(t.options, e);
            var u = te(e, t, i);
            if (s(t.options.functional)) return Zn(t, u, e, n, r);
            var d = e.on;
            if (((e.on = e.nativeOn), s(t.options.abstract))) {
              var f = e.slot;
              (e = {}), f && (e.slot = f);
            }
            or(e);
            var p = er(t.options) || i,
              m = new vt(
                "vue-component-".concat(t.cid).concat(p ? "-".concat(p) : ""),
                e,
                void 0,
                void 0,
                void 0,
                n,
                { Ctor: t, propsData: u, listeners: d, tag: i, children: r },
                l
              );
            return m;
          }
        }
      }
      function ar(t, e) {
        var n = { _isComponent: !0, _parentVnode: t, parent: e },
          r = t.data.inlineTemplate;
        return (
          o(r) &&
            ((n.render = r.render), (n.staticRenderFns = r.staticRenderFns)),
          new t.componentOptions.Ctor(n)
        );
      }
      function or(t) {
        for (var e = t.hook || (t.hook = {}), n = 0; n < rr.length; n++) {
          var r = rr[n],
            i = e[r],
            a = nr[r];
          i === a || (i && i._merged) || (e[r] = i ? sr(a, i) : a);
        }
      }
      function sr(t, e) {
        var n = function (n, r) {
          t(n, r), e(n, r);
        };
        return (n._merged = !0), n;
      }
      function cr(t, e) {
        var n = (t.model && t.model.prop) || "value",
          r = (t.model && t.model.event) || "input";
        (e.attrs || (e.attrs = {}))[n] = e.model.value;
        var a = e.on || (e.on = {}),
          s = a[r],
          c = e.model.callback;
        o(s)
          ? (i(s) ? -1 === s.indexOf(c) : s !== c) && (a[r] = [c].concat(s))
          : (a[r] = c);
      }
      var lr = D,
        ur = q.optionMergeStrategies;
      function hr(t, e) {
        if (!e) return t;
        for (
          var n, r, i, a = pt ? Reflect.ownKeys(e) : Object.keys(e), o = 0;
          o < a.length;
          o++
        )
          (n = a[o]),
            "__ob__" !== n &&
              ((r = t[n]),
              (i = e[n]),
              S(t, n) ? r !== i && f(r) && f(i) && hr(r, i) : zt(t, n, i));
        return t;
      }
      function dr(t, e, n) {
        return n
          ? function () {
              var r = u(e) ? e.call(n, n) : e,
                i = u(t) ? t.call(n, n) : t;
              return r ? hr(r, i) : i;
            }
          : e
          ? t
            ? function () {
                return hr(
                  u(e) ? e.call(this, this) : e,
                  u(t) ? t.call(this, this) : t
                );
              }
            : e
          : t;
      }
      function fr(t, e) {
        var n = e ? (t ? t.concat(e) : i(e) ? e : [e]) : t;
        return n ? pr(n) : n;
      }
      function pr(t) {
        for (var e = [], n = 0; n < t.length; n++)
          -1 === e.indexOf(t[n]) && e.push(t[n]);
        return e;
      }
      function mr(t, e, n, r) {
        var i = Object.create(t || null);
        return e ? k(i, e) : i;
      }
      (ur.data = function (t, e, n) {
        return n ? dr(t, e, n) : e && "function" !== typeof e ? t : dr(t, e);
      }),
        W.forEach(function (t) {
          ur[t] = fr;
        }),
        G.forEach(function (t) {
          ur[t + "s"] = mr;
        }),
        (ur.watch = function (t, e, n, r) {
          if ((t === st && (t = void 0), e === st && (e = void 0), !e))
            return Object.create(t || null);
          if (!t) return e;
          var a = {};
          for (var o in (k(a, t), e)) {
            var s = a[o],
              c = e[o];
            s && !i(s) && (s = [s]), (a[o] = s ? s.concat(c) : i(c) ? c : [c]);
          }
          return a;
        }),
        (ur.props =
          ur.methods =
          ur.inject =
          ur.computed =
            function (t, e, n, r) {
              if (!t) return e;
              var i = Object.create(null);
              return k(i, t), e && k(i, e), i;
            }),
        (ur.provide = dr);
      var gr = function (t, e) {
        return void 0 === e ? t : e;
      };
      function vr(t, e) {
        var n = t.props;
        if (n) {
          var r,
            a,
            o,
            s = {};
          if (i(n)) {
            r = n.length;
            while (r--)
              (a = n[r]),
                "string" === typeof a && ((o = E(a)), (s[o] = { type: null }));
          } else if (f(n))
            for (var c in n)
              (a = n[c]), (o = E(c)), (s[o] = f(a) ? a : { type: a });
          else 0;
          t.props = s;
        }
      }
      function yr(t, e) {
        var n = t.inject;
        if (n) {
          var r = (t.inject = {});
          if (i(n)) for (var a = 0; a < n.length; a++) r[n[a]] = { from: n[a] };
          else if (f(n))
            for (var o in n) {
              var s = n[o];
              r[o] = f(s) ? k({ from: o }, s) : { from: s };
            }
          else 0;
        }
      }
      function br(t) {
        var e = t.directives;
        if (e)
          for (var n in e) {
            var r = e[n];
            u(r) && (e[n] = { bind: r, update: r });
          }
      }
      function xr(t, e, n) {
        if (
          (u(e) && (e = e.options),
          vr(e, n),
          yr(e, n),
          br(e),
          !e._base && (e.extends && (t = xr(t, e.extends, n)), e.mixins))
        )
          for (var r = 0, i = e.mixins.length; r < i; r++)
            t = xr(t, e.mixins[r], n);
        var a,
          o = {};
        for (a in t) s(a);
        for (a in e) S(t, a) || s(a);
        function s(r) {
          var i = ur[r] || gr;
          o[r] = i(t[r], e[r], n, r);
        }
        return o;
      }
      function _r(t, e, n, r) {
        if ("string" === typeof n) {
          var i = t[e];
          if (S(i, n)) return i[n];
          var a = E(n);
          if (S(i, a)) return i[a];
          var o = A(a);
          if (S(i, o)) return i[o];
          var s = i[n] || i[a] || i[o];
          return s;
        }
      }
      function wr(t, e, n, r) {
        var i = e[t],
          a = !S(n, t),
          o = n[t],
          s = Ar(Boolean, i.type);
        if (s > -1)
          if (a && !S(i, "default")) o = !1;
          else if ("" === o || o === L(t)) {
            var c = Ar(String, i.type);
            (c < 0 || s < c) && (o = !0);
          }
        if (void 0 === o) {
          o = Sr(r, i, t);
          var l = Pt;
          It(!0), Nt(o), It(l);
        }
        return o;
      }
      function Sr(t, e, n) {
        if (S(e, "default")) {
          var r = e.default;
          return t &&
            t.$options.propsData &&
            void 0 === t.$options.propsData[n] &&
            void 0 !== t._props[n]
            ? t._props[n]
            : u(r) && "Function" !== Tr(e.type)
            ? r.call(t)
            : r;
        }
      }
      var Mr = /^\s*function (\w+)/;
      function Tr(t) {
        var e = t && t.toString().match(Mr);
        return e ? e[1] : "";
      }
      function Er(t, e) {
        return Tr(t) === Tr(e);
      }
      function Ar(t, e) {
        if (!i(e)) return Er(e, t) ? 0 : -1;
        for (var n = 0, r = e.length; n < r; n++) if (Er(e[n], t)) return n;
        return -1;
      }
      var Cr = { enumerable: !0, configurable: !0, get: D, set: D };
      function Lr(t, e, n) {
        (Cr.get = function () {
          return this[e][n];
        }),
          (Cr.set = function (t) {
            this[e][n] = t;
          }),
          Object.defineProperty(t, n, Cr);
      }
      function Rr(t) {
        var e = t.$options;
        if (
          (e.props && Pr(t, e.props),
          Ae(t),
          e.methods && Ur(t, e.methods),
          e.data)
        )
          Ir(t);
        else {
          var n = Nt((t._data = {}));
          n && n.vmCount++;
        }
        e.computed && Nr(t, e.computed),
          e.watch && e.watch !== st && Br(t, e.watch);
      }
      function Pr(t, e) {
        var n = t.$options.propsData || {},
          r = (t._props = Bt({})),
          i = (t.$options._propKeys = []),
          a = !t.$parent;
        a || It(!1);
        var o = function (a) {
          i.push(a);
          var o = wr(a, e, n, t);
          Dt(r, a, o), a in t || Lr(t, "_props", a);
        };
        for (var s in e) o(s);
        It(!0);
      }
      function Ir(t) {
        var e = t.$options.data;
        (e = t._data = u(e) ? Or(e, t) : e || {}), f(e) || (e = {});
        var n = Object.keys(e),
          r = t.$options.props,
          i = (t.$options.methods, n.length);
        while (i--) {
          var a = n[i];
          0, (r && S(r, a)) || $(a) || Lr(t, "_data", a);
        }
        var o = Nt(e);
        o && o.vmCount++;
      }
      function Or(t, e) {
        Mt();
        try {
          return t.call(e, e);
        } catch (Yo) {
          return qe(Yo, e, "data()"), {};
        } finally {
          Tt();
        }
      }
      var kr = { lazy: !0 };
      function Nr(t, e) {
        var n = (t._computedWatchers = Object.create(null)),
          r = ut();
        for (var i in e) {
          var a = e[i],
            o = u(a) ? a : a.get;
          0, r || (n[i] = new mn(t, o || D, D, kr)), i in t || Dr(t, i, a);
        }
      }
      function Dr(t, e, n) {
        var r = !ut();
        u(n)
          ? ((Cr.get = r ? zr(e) : Fr(n)), (Cr.set = D))
          : ((Cr.get = n.get ? (r && !1 !== n.cache ? zr(e) : Fr(n.get)) : D),
            (Cr.set = n.set || D)),
          Object.defineProperty(t, e, Cr);
      }
      function zr(t) {
        return function () {
          var e = this._computedWatchers && this._computedWatchers[t];
          if (e)
            return e.dirty && e.evaluate(), wt.target && e.depend(), e.value;
        };
      }
      function Fr(t) {
        return function () {
          return t.call(this, this);
        };
      }
      function Ur(t, e) {
        t.$options.props;
        for (var n in e) t[n] = "function" !== typeof e[n] ? D : I(e[n], t);
      }
      function Br(t, e) {
        for (var n in e) {
          var r = e[n];
          if (i(r)) for (var a = 0; a < r.length; a++) jr(t, n, r[a]);
          else jr(t, n, r);
        }
      }
      function jr(t, e, n, r) {
        return (
          f(n) && ((r = n), (n = n.handler)),
          "string" === typeof n && (n = t[n]),
          t.$watch(e, n, r)
        );
      }
      function Hr(t) {
        var e = {
            get: function () {
              return this._data;
            },
          },
          n = {
            get: function () {
              return this._props;
            },
          };
        Object.defineProperty(t.prototype, "$data", e),
          Object.defineProperty(t.prototype, "$props", n),
          (t.prototype.$set = zt),
          (t.prototype.$delete = Ft),
          (t.prototype.$watch = function (t, e, n) {
            var r = this;
            if (f(e)) return jr(r, t, e, n);
            (n = n || {}), (n.user = !0);
            var i = new mn(r, t, e, n);
            if (n.immediate) {
              var a = 'callback for immediate watcher "'.concat(
                i.expression,
                '"'
              );
              Mt(), Xe(e, r, [i.value], r, a), Tt();
            }
            return function () {
              i.teardown();
            };
          });
      }
      var Vr = 0;
      function Gr(t) {
        t.prototype._init = function (t) {
          var e = this;
          (e._uid = Vr++),
            (e._isVue = !0),
            (e.__v_skip = !0),
            (e._scope = new Xt(!0)),
            t && t._isComponent
              ? Wr(e, t)
              : (e.$options = xr(qr(e.constructor), t || {}, e)),
            (e._renderProxy = e),
            (e._self = e),
            Mn(e),
            gn(e),
            Oe(e),
            Pn(e, "beforeCreate", void 0, !1),
            Yn(e),
            Rr(e),
            $n(e),
            Pn(e, "created"),
            e.$options.el && e.$mount(e.$options.el);
        };
      }
      function Wr(t, e) {
        var n = (t.$options = Object.create(t.constructor.options)),
          r = e._parentVnode;
        (n.parent = e.parent), (n._parentVnode = r);
        var i = r.componentOptions;
        (n.propsData = i.propsData),
          (n._parentListeners = i.listeners),
          (n._renderChildren = i.children),
          (n._componentTag = i.tag),
          e.render &&
            ((n.render = e.render), (n.staticRenderFns = e.staticRenderFns));
      }
      function qr(t) {
        var e = t.options;
        if (t.super) {
          var n = qr(t.super),
            r = t.superOptions;
          if (n !== r) {
            t.superOptions = n;
            var i = Xr(t);
            i && k(t.extendOptions, i),
              (e = t.options = xr(n, t.extendOptions)),
              e.name && (e.components[e.name] = t);
          }
        }
        return e;
      }
      function Xr(t) {
        var e,
          n = t.options,
          r = t.sealedOptions;
        for (var i in n) n[i] !== r[i] && (e || (e = {}), (e[i] = n[i]));
        return e;
      }
      function $r(t) {
        this._init(t);
      }
      function Yr(t) {
        t.use = function (t) {
          var e = this._installedPlugins || (this._installedPlugins = []);
          if (e.indexOf(t) > -1) return this;
          var n = O(arguments, 1);
          return (
            n.unshift(this),
            u(t.install) ? t.install.apply(t, n) : u(t) && t.apply(null, n),
            e.push(t),
            this
          );
        };
      }
      function Jr(t) {
        t.mixin = function (t) {
          return (this.options = xr(this.options, t)), this;
        };
      }
      function Kr(t) {
        t.cid = 0;
        var e = 1;
        t.extend = function (t) {
          t = t || {};
          var n = this,
            r = n.cid,
            i = t._Ctor || (t._Ctor = {});
          if (i[r]) return i[r];
          var a = er(t) || er(n.options);
          var o = function (t) {
            this._init(t);
          };
          return (
            (o.prototype = Object.create(n.prototype)),
            (o.prototype.constructor = o),
            (o.cid = e++),
            (o.options = xr(n.options, t)),
            (o["super"] = n),
            o.options.props && Zr(o),
            o.options.computed && Qr(o),
            (o.extend = n.extend),
            (o.mixin = n.mixin),
            (o.use = n.use),
            G.forEach(function (t) {
              o[t] = n[t];
            }),
            a && (o.options.components[a] = o),
            (o.superOptions = n.options),
            (o.extendOptions = t),
            (o.sealedOptions = k({}, o.options)),
            (i[r] = o),
            o
          );
        };
      }
      function Zr(t) {
        var e = t.options.props;
        for (var n in e) Lr(t.prototype, "_props", n);
      }
      function Qr(t) {
        var e = t.options.computed;
        for (var n in e) Dr(t.prototype, n, e[n]);
      }
      function ti(t) {
        G.forEach(function (e) {
          t[e] = function (t, n) {
            return n
              ? ("component" === e &&
                  f(n) &&
                  ((n.name = n.name || t), (n = this.options._base.extend(n))),
                "directive" === e && u(n) && (n = { bind: n, update: n }),
                (this.options[e + "s"][t] = n),
                n)
              : this.options[e + "s"][t];
          };
        });
      }
      function ei(t) {
        return t && (er(t.Ctor.options) || t.tag);
      }
      function ni(t, e) {
        return i(t)
          ? t.indexOf(e) > -1
          : "string" === typeof t
          ? t.split(",").indexOf(e) > -1
          : !!p(t) && t.test(e);
      }
      function ri(t, e) {
        var n = t.cache,
          r = t.keys,
          i = t._vnode;
        for (var a in n) {
          var o = n[a];
          if (o) {
            var s = o.name;
            s && !e(s) && ii(n, a, r, i);
          }
        }
      }
      function ii(t, e, n, r) {
        var i = t[e];
        !i || (r && i.tag === r.tag) || i.componentInstance.$destroy(),
          (t[e] = null),
          _(n, e);
      }
      Gr($r), Hr($r), _n($r), Tn($r), Ne($r);
      var ai = [String, RegExp, Array],
        oi = {
          name: "keep-alive",
          abstract: !0,
          props: { include: ai, exclude: ai, max: [String, Number] },
          methods: {
            cacheVNode: function () {
              var t = this,
                e = t.cache,
                n = t.keys,
                r = t.vnodeToCache,
                i = t.keyToCache;
              if (r) {
                var a = r.tag,
                  o = r.componentInstance,
                  s = r.componentOptions;
                (e[i] = { name: ei(s), tag: a, componentInstance: o }),
                  n.push(i),
                  this.max &&
                    n.length > parseInt(this.max) &&
                    ii(e, n[0], n, this._vnode),
                  (this.vnodeToCache = null);
              }
            },
          },
          created: function () {
            (this.cache = Object.create(null)), (this.keys = []);
          },
          destroyed: function () {
            for (var t in this.cache) ii(this.cache, t, this.keys);
          },
          mounted: function () {
            var t = this;
            this.cacheVNode(),
              this.$watch("include", function (e) {
                ri(t, function (t) {
                  return ni(e, t);
                });
              }),
              this.$watch("exclude", function (e) {
                ri(t, function (t) {
                  return !ni(e, t);
                });
              });
          },
          updated: function () {
            this.cacheVNode();
          },
          render: function () {
            var t = this.$slots.default,
              e = Ue(t),
              n = e && e.componentOptions;
            if (n) {
              var r = ei(n),
                i = this,
                a = i.include,
                o = i.exclude;
              if ((a && (!r || !ni(a, r))) || (o && r && ni(o, r))) return e;
              var s = this,
                c = s.cache,
                l = s.keys,
                u =
                  null == e.key
                    ? n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "")
                    : e.key;
              c[u]
                ? ((e.componentInstance = c[u].componentInstance),
                  _(l, u),
                  l.push(u))
                : ((this.vnodeToCache = e), (this.keyToCache = u)),
                (e.data.keepAlive = !0);
            }
            return e || (t && t[0]);
          },
        },
        si = { KeepAlive: oi };
      function ci(t) {
        var e = {
          get: function () {
            return q;
          },
        };
        Object.defineProperty(t, "config", e),
          (t.util = {
            warn: lr,
            extend: k,
            mergeOptions: xr,
            defineReactive: Dt,
          }),
          (t.set = zt),
          (t.delete = Ft),
          (t.nextTick = on),
          (t.observable = function (t) {
            return Nt(t), t;
          }),
          (t.options = Object.create(null)),
          G.forEach(function (e) {
            t.options[e + "s"] = Object.create(null);
          }),
          (t.options._base = t),
          k(t.options.components, si),
          Yr(t),
          Jr(t),
          Kr(t),
          ti(t);
      }
      ci($r),
        Object.defineProperty($r.prototype, "$isServer", { get: ut }),
        Object.defineProperty($r.prototype, "$ssrContext", {
          get: function () {
            return this.$vnode && this.$vnode.ssrContext;
          },
        }),
        Object.defineProperty($r, "FunctionalRenderContext", { value: Kn }),
        ($r.version = ln);
      var li = b("style,class"),
        ui = b("input,textarea,option,select,progress"),
        hi = function (t, e, n) {
          return (
            ("value" === n && ui(t) && "button" !== e) ||
            ("selected" === n && "option" === t) ||
            ("checked" === n && "input" === t) ||
            ("muted" === n && "video" === t)
          );
        },
        di = b("contenteditable,draggable,spellcheck"),
        fi = b("events,caret,typing,plaintext-only"),
        pi = function (t, e) {
          return bi(e) || "false" === e
            ? "false"
            : "contenteditable" === t && fi(e)
            ? e
            : "true";
        },
        mi = b(
          "allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"
        ),
        gi = "http://www.w3.org/1999/xlink",
        vi = function (t) {
          return ":" === t.charAt(5) && "xlink" === t.slice(0, 5);
        },
        yi = function (t) {
          return vi(t) ? t.slice(6, t.length) : "";
        },
        bi = function (t) {
          return null == t || !1 === t;
        };
      function xi(t) {
        var e = t.data,
          n = t,
          r = t;
        while (o(r.componentInstance))
          (r = r.componentInstance._vnode), r && r.data && (e = _i(r.data, e));
        while (o((n = n.parent))) n && n.data && (e = _i(e, n.data));
        return wi(e.staticClass, e.class);
      }
      function _i(t, e) {
        return {
          staticClass: Si(t.staticClass, e.staticClass),
          class: o(t.class) ? [t.class, e.class] : e.class,
        };
      }
      function wi(t, e) {
        return o(t) || o(e) ? Si(t, Mi(e)) : "";
      }
      function Si(t, e) {
        return t ? (e ? t + " " + e : t) : e || "";
      }
      function Mi(t) {
        return Array.isArray(t)
          ? Ti(t)
          : h(t)
          ? Ei(t)
          : "string" === typeof t
          ? t
          : "";
      }
      function Ti(t) {
        for (var e, n = "", r = 0, i = t.length; r < i; r++)
          o((e = Mi(t[r]))) && "" !== e && (n && (n += " "), (n += e));
        return n;
      }
      function Ei(t) {
        var e = "";
        for (var n in t) t[n] && (e && (e += " "), (e += n));
        return e;
      }
      var Ai = {
          svg: "http://www.w3.org/2000/svg",
          math: "http://www.w3.org/1998/Math/MathML",
        },
        Ci = b(
          "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"
        ),
        Li = b(
          "svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",
          !0
        ),
        Ri = function (t) {
          return Ci(t) || Li(t);
        };
      function Pi(t) {
        return Li(t) ? "svg" : "math" === t ? "math" : void 0;
      }
      var Ii = Object.create(null);
      function Oi(t) {
        if (!Q) return !0;
        if (Ri(t)) return !1;
        if (((t = t.toLowerCase()), null != Ii[t])) return Ii[t];
        var e = document.createElement(t);
        return t.indexOf("-") > -1
          ? (Ii[t] =
              e.constructor === window.HTMLUnknownElement ||
              e.constructor === window.HTMLElement)
          : (Ii[t] = /HTMLUnknownElement/.test(e.toString()));
      }
      var ki = b("text,number,password,search,email,tel,url");
      function Ni(t) {
        if ("string" === typeof t) {
          var e = document.querySelector(t);
          return e || document.createElement("div");
        }
        return t;
      }
      function Di(t, e) {
        var n = document.createElement(t);
        return (
          "select" !== t ||
            (e.data &&
              e.data.attrs &&
              void 0 !== e.data.attrs.multiple &&
              n.setAttribute("multiple", "multiple")),
          n
        );
      }
      function zi(t, e) {
        return document.createElementNS(Ai[t], e);
      }
      function Fi(t) {
        return document.createTextNode(t);
      }
      function Ui(t) {
        return document.createComment(t);
      }
      function Bi(t, e, n) {
        t.insertBefore(e, n);
      }
      function ji(t, e) {
        t.removeChild(e);
      }
      function Hi(t, e) {
        t.appendChild(e);
      }
      function Vi(t) {
        return t.parentNode;
      }
      function Gi(t) {
        return t.nextSibling;
      }
      function Wi(t) {
        return t.tagName;
      }
      function qi(t, e) {
        t.textContent = e;
      }
      function Xi(t, e) {
        t.setAttribute(e, "");
      }
      var $i = Object.freeze({
          __proto__: null,
          createElement: Di,
          createElementNS: zi,
          createTextNode: Fi,
          createComment: Ui,
          insertBefore: Bi,
          removeChild: ji,
          appendChild: Hi,
          parentNode: Vi,
          nextSibling: Gi,
          tagName: Wi,
          setTextContent: qi,
          setStyleScope: Xi,
        }),
        Yi = {
          create: function (t, e) {
            Ji(e);
          },
          update: function (t, e) {
            t.data.ref !== e.data.ref && (Ji(t, !0), Ji(e));
          },
          destroy: function (t) {
            Ji(t, !0);
          },
        };
      function Ji(t, e) {
        var n = t.data.ref;
        if (o(n)) {
          var r = t.context,
            a = t.componentInstance || t.elm,
            s = e ? null : a,
            c = e ? void 0 : a;
          if (u(n)) Xe(n, r, [s], r, "template ref function");
          else {
            var l = t.data.refInFor,
              h = "string" === typeof n || "number" === typeof n,
              d = Vt(n),
              f = r.$refs;
            if (h || d)
              if (l) {
                var p = h ? f[n] : n.value;
                e
                  ? i(p) && _(p, a)
                  : i(p)
                  ? p.includes(a) || p.push(a)
                  : h
                  ? ((f[n] = [a]), Ki(r, n, f[n]))
                  : (n.value = [a]);
              } else if (h) {
                if (e && f[n] !== a) return;
                (f[n] = c), Ki(r, n, s);
              } else if (d) {
                if (e && n.value !== a) return;
                n.value = s;
              } else 0;
          }
        }
      }
      function Ki(t, e, n) {
        var r = t._setupState;
        r && S(r, e) && (Vt(r[e]) ? (r[e].value = n) : (r[e] = n));
      }
      var Zi = new vt("", {}, []),
        Qi = ["create", "activate", "update", "remove", "destroy"];
      function ta(t, e) {
        return (
          t.key === e.key &&
          t.asyncFactory === e.asyncFactory &&
          ((t.tag === e.tag &&
            t.isComment === e.isComment &&
            o(t.data) === o(e.data) &&
            ea(t, e)) ||
            (s(t.isAsyncPlaceholder) && a(e.asyncFactory.error)))
        );
      }
      function ea(t, e) {
        if ("input" !== t.tag) return !0;
        var n,
          r = o((n = t.data)) && o((n = n.attrs)) && n.type,
          i = o((n = e.data)) && o((n = n.attrs)) && n.type;
        return r === i || (ki(r) && ki(i));
      }
      function na(t, e, n) {
        var r,
          i,
          a = {};
        for (r = e; r <= n; ++r) (i = t[r].key), o(i) && (a[i] = r);
        return a;
      }
      function ra(t) {
        var e,
          n,
          r = {},
          c = t.modules,
          u = t.nodeOps;
        for (e = 0; e < Qi.length; ++e)
          for (r[Qi[e]] = [], n = 0; n < c.length; ++n)
            o(c[n][Qi[e]]) && r[Qi[e]].push(c[n][Qi[e]]);
        function h(t) {
          return new vt(u.tagName(t).toLowerCase(), {}, [], void 0, t);
        }
        function d(t, e) {
          function n() {
            0 === --n.listeners && f(t);
          }
          return (n.listeners = e), n;
        }
        function f(t) {
          var e = u.parentNode(t);
          o(e) && u.removeChild(e, t);
        }
        function p(t, e, n, r, i, a, c) {
          if (
            (o(t.elm) && o(a) && (t = a[c] = xt(t)),
            (t.isRootInsert = !i),
            !m(t, e, n, r))
          ) {
            var l = t.data,
              h = t.children,
              d = t.tag;
            o(d)
              ? ((t.elm = t.ns
                  ? u.createElementNS(t.ns, d)
                  : u.createElement(d, t)),
                S(t),
                x(t, h, e),
                o(l) && w(t, e),
                y(n, t.elm, r))
              : s(t.isComment)
              ? ((t.elm = u.createComment(t.text)), y(n, t.elm, r))
              : ((t.elm = u.createTextNode(t.text)), y(n, t.elm, r));
          }
        }
        function m(t, e, n, r) {
          var i = t.data;
          if (o(i)) {
            var a = o(t.componentInstance) && i.keepAlive;
            if (
              (o((i = i.hook)) && o((i = i.init)) && i(t, !1),
              o(t.componentInstance))
            )
              return g(t, e), y(n, t.elm, r), s(a) && v(t, e, n, r), !0;
          }
        }
        function g(t, e) {
          o(t.data.pendingInsert) &&
            (e.push.apply(e, t.data.pendingInsert),
            (t.data.pendingInsert = null)),
            (t.elm = t.componentInstance.$el),
            _(t) ? (w(t, e), S(t)) : (Ji(t), e.push(t));
        }
        function v(t, e, n, i) {
          var a,
            s = t;
          while (s.componentInstance)
            if (
              ((s = s.componentInstance._vnode),
              o((a = s.data)) && o((a = a.transition)))
            ) {
              for (a = 0; a < r.activate.length; ++a) r.activate[a](Zi, s);
              e.push(s);
              break;
            }
          y(n, t.elm, i);
        }
        function y(t, e, n) {
          o(t) &&
            (o(n)
              ? u.parentNode(n) === t && u.insertBefore(t, e, n)
              : u.appendChild(t, e));
        }
        function x(t, e, n) {
          if (i(e)) {
            0;
            for (var r = 0; r < e.length; ++r)
              p(e[r], n, t.elm, null, !0, e, r);
          } else
            l(t.text) && u.appendChild(t.elm, u.createTextNode(String(t.text)));
        }
        function _(t) {
          while (t.componentInstance) t = t.componentInstance._vnode;
          return o(t.tag);
        }
        function w(t, n) {
          for (var i = 0; i < r.create.length; ++i) r.create[i](Zi, t);
          (e = t.data.hook),
            o(e) && (o(e.create) && e.create(Zi, t), o(e.insert) && n.push(t));
        }
        function S(t) {
          var e;
          if (o((e = t.fnScopeId))) u.setStyleScope(t.elm, e);
          else {
            var n = t;
            while (n)
              o((e = n.context)) &&
                o((e = e.$options._scopeId)) &&
                u.setStyleScope(t.elm, e),
                (n = n.parent);
          }
          o((e = wn)) &&
            e !== t.context &&
            e !== t.fnContext &&
            o((e = e.$options._scopeId)) &&
            u.setStyleScope(t.elm, e);
        }
        function M(t, e, n, r, i, a) {
          for (; r <= i; ++r) p(n[r], a, t, e, !1, n, r);
        }
        function T(t) {
          var e,
            n,
            i = t.data;
          if (o(i))
            for (
              o((e = i.hook)) && o((e = e.destroy)) && e(t), e = 0;
              e < r.destroy.length;
              ++e
            )
              r.destroy[e](t);
          if (o((e = t.children)))
            for (n = 0; n < t.children.length; ++n) T(t.children[n]);
        }
        function E(t, e, n) {
          for (; e <= n; ++e) {
            var r = t[e];
            o(r) && (o(r.tag) ? (A(r), T(r)) : f(r.elm));
          }
        }
        function A(t, e) {
          if (o(e) || o(t.data)) {
            var n,
              i = r.remove.length + 1;
            for (
              o(e) ? (e.listeners += i) : (e = d(t.elm, i)),
                o((n = t.componentInstance)) &&
                  o((n = n._vnode)) &&
                  o(n.data) &&
                  A(n, e),
                n = 0;
              n < r.remove.length;
              ++n
            )
              r.remove[n](t, e);
            o((n = t.data.hook)) && o((n = n.remove)) ? n(t, e) : e();
          } else f(t.elm);
        }
        function C(t, e, n, r, i) {
          var s,
            c,
            l,
            h,
            d = 0,
            f = 0,
            m = e.length - 1,
            g = e[0],
            v = e[m],
            y = n.length - 1,
            b = n[0],
            x = n[y],
            _ = !i;
          while (d <= m && f <= y)
            a(g)
              ? (g = e[++d])
              : a(v)
              ? (v = e[--m])
              : ta(g, b)
              ? (R(g, b, r, n, f), (g = e[++d]), (b = n[++f]))
              : ta(v, x)
              ? (R(v, x, r, n, y), (v = e[--m]), (x = n[--y]))
              : ta(g, x)
              ? (R(g, x, r, n, y),
                _ && u.insertBefore(t, g.elm, u.nextSibling(v.elm)),
                (g = e[++d]),
                (x = n[--y]))
              : ta(v, b)
              ? (R(v, b, r, n, f),
                _ && u.insertBefore(t, v.elm, g.elm),
                (v = e[--m]),
                (b = n[++f]))
              : (a(s) && (s = na(e, d, m)),
                (c = o(b.key) ? s[b.key] : L(b, e, d, m)),
                a(c)
                  ? p(b, r, t, g.elm, !1, n, f)
                  : ((l = e[c]),
                    ta(l, b)
                      ? (R(l, b, r, n, f),
                        (e[c] = void 0),
                        _ && u.insertBefore(t, l.elm, g.elm))
                      : p(b, r, t, g.elm, !1, n, f)),
                (b = n[++f]));
          d > m
            ? ((h = a(n[y + 1]) ? null : n[y + 1].elm), M(t, h, n, f, y, r))
            : f > y && E(e, d, m);
        }
        function L(t, e, n, r) {
          for (var i = n; i < r; i++) {
            var a = e[i];
            if (o(a) && ta(t, a)) return i;
          }
        }
        function R(t, e, n, i, c, l) {
          if (t !== e) {
            o(e.elm) && o(i) && (e = i[c] = xt(e));
            var h = (e.elm = t.elm);
            if (s(t.isAsyncPlaceholder))
              o(e.asyncFactory.resolved)
                ? O(t.elm, e, n)
                : (e.isAsyncPlaceholder = !0);
            else if (
              s(e.isStatic) &&
              s(t.isStatic) &&
              e.key === t.key &&
              (s(e.isCloned) || s(e.isOnce))
            )
              e.componentInstance = t.componentInstance;
            else {
              var d,
                f = e.data;
              o(f) && o((d = f.hook)) && o((d = d.prepatch)) && d(t, e);
              var p = t.children,
                m = e.children;
              if (o(f) && _(e)) {
                for (d = 0; d < r.update.length; ++d) r.update[d](t, e);
                o((d = f.hook)) && o((d = d.update)) && d(t, e);
              }
              a(e.text)
                ? o(p) && o(m)
                  ? p !== m && C(h, p, m, n, l)
                  : o(m)
                  ? (o(t.text) && u.setTextContent(h, ""),
                    M(h, null, m, 0, m.length - 1, n))
                  : o(p)
                  ? E(p, 0, p.length - 1)
                  : o(t.text) && u.setTextContent(h, "")
                : t.text !== e.text && u.setTextContent(h, e.text),
                o(f) && o((d = f.hook)) && o((d = d.postpatch)) && d(t, e);
            }
          }
        }
        function P(t, e, n) {
          if (s(n) && o(t.parent)) t.parent.data.pendingInsert = e;
          else for (var r = 0; r < e.length; ++r) e[r].data.hook.insert(e[r]);
        }
        var I = b("attrs,class,staticClass,staticStyle,key");
        function O(t, e, n, r) {
          var i,
            a = e.tag,
            c = e.data,
            l = e.children;
          if (
            ((r = r || (c && c.pre)),
            (e.elm = t),
            s(e.isComment) && o(e.asyncFactory))
          )
            return (e.isAsyncPlaceholder = !0), !0;
          if (
            o(c) &&
            (o((i = c.hook)) && o((i = i.init)) && i(e, !0),
            o((i = e.componentInstance)))
          )
            return g(e, n), !0;
          if (o(a)) {
            if (o(l))
              if (t.hasChildNodes())
                if (o((i = c)) && o((i = i.domProps)) && o((i = i.innerHTML))) {
                  if (i !== t.innerHTML) return !1;
                } else {
                  for (var u = !0, h = t.firstChild, d = 0; d < l.length; d++) {
                    if (!h || !O(h, l[d], n, r)) {
                      u = !1;
                      break;
                    }
                    h = h.nextSibling;
                  }
                  if (!u || h) return !1;
                }
              else x(e, l, n);
            if (o(c)) {
              var f = !1;
              for (var p in c)
                if (!I(p)) {
                  (f = !0), w(e, n);
                  break;
                }
              !f && c["class"] && hn(c["class"]);
            }
          } else t.data !== e.text && (t.data = e.text);
          return !0;
        }
        return function (t, e, n, i) {
          if (!a(e)) {
            var c = !1,
              l = [];
            if (a(t)) (c = !0), p(e, l);
            else {
              var d = o(t.nodeType);
              if (!d && ta(t, e)) R(t, e, l, null, null, i);
              else {
                if (d) {
                  if (
                    (1 === t.nodeType &&
                      t.hasAttribute(V) &&
                      (t.removeAttribute(V), (n = !0)),
                    s(n) && O(t, e, l))
                  )
                    return P(e, l, !0), t;
                  t = h(t);
                }
                var f = t.elm,
                  m = u.parentNode(f);
                if (
                  (p(e, l, f._leaveCb ? null : m, u.nextSibling(f)),
                  o(e.parent))
                ) {
                  var g = e.parent,
                    v = _(e);
                  while (g) {
                    for (var y = 0; y < r.destroy.length; ++y) r.destroy[y](g);
                    if (((g.elm = e.elm), v)) {
                      for (var b = 0; b < r.create.length; ++b)
                        r.create[b](Zi, g);
                      var x = g.data.hook.insert;
                      if (x.merged)
                        for (var w = 1; w < x.fns.length; w++) x.fns[w]();
                    } else Ji(g);
                    g = g.parent;
                  }
                }
                o(m) ? E([t], 0, 0) : o(t.tag) && T(t);
              }
            }
            return P(e, l, c), e.elm;
          }
          o(t) && T(t);
        };
      }
      var ia = {
        create: aa,
        update: aa,
        destroy: function (t) {
          aa(t, Zi);
        },
      };
      function aa(t, e) {
        (t.data.directives || e.data.directives) && oa(t, e);
      }
      function oa(t, e) {
        var n,
          r,
          i,
          a = t === Zi,
          o = e === Zi,
          s = ca(t.data.directives, t.context),
          c = ca(e.data.directives, e.context),
          l = [],
          u = [];
        for (n in c)
          (r = s[n]),
            (i = c[n]),
            r
              ? ((i.oldValue = r.value),
                (i.oldArg = r.arg),
                ua(i, "update", e, t),
                i.def && i.def.componentUpdated && u.push(i))
              : (ua(i, "bind", e, t), i.def && i.def.inserted && l.push(i));
        if (l.length) {
          var h = function () {
            for (var n = 0; n < l.length; n++) ua(l[n], "inserted", e, t);
          };
          a ? Qt(e, "insert", h) : h();
        }
        if (
          (u.length &&
            Qt(e, "postpatch", function () {
              for (var n = 0; n < u.length; n++)
                ua(u[n], "componentUpdated", e, t);
            }),
          !a)
        )
          for (n in s) c[n] || ua(s[n], "unbind", t, t, o);
      }
      var sa = Object.create(null);
      function ca(t, e) {
        var n,
          r,
          i = Object.create(null);
        if (!t) return i;
        for (n = 0; n < t.length; n++)
          (r = t[n]),
            r.modifiers || (r.modifiers = sa),
            (i[la(r)] = r),
            e._setupState &&
              e._setupState.__sfc &&
              (r.def = r.def || _r(e, "_setupState", "v-" + r.name)),
            (r.def = r.def || _r(e.$options, "directives", r.name, !0));
        return i;
      }
      function la(t) {
        return (
          t.rawName ||
          ""
            .concat(t.name, ".")
            .concat(Object.keys(t.modifiers || {}).join("."))
        );
      }
      function ua(t, e, n, r, i) {
        var a = t.def && t.def[e];
        if (a)
          try {
            a(n.elm, t, n, r, i);
          } catch (Yo) {
            qe(
              Yo,
              n.context,
              "directive ".concat(t.name, " ").concat(e, " hook")
            );
          }
      }
      var ha = [Yi, ia];
      function da(t, e) {
        var n = e.componentOptions;
        if (
          (!o(n) || !1 !== n.Ctor.options.inheritAttrs) &&
          (!a(t.data.attrs) || !a(e.data.attrs))
        ) {
          var r,
            i,
            c,
            l = e.elm,
            u = t.data.attrs || {},
            h = e.data.attrs || {};
          for (r in ((o(h.__ob__) || s(h._v_attr_proxy)) &&
            (h = e.data.attrs = k({}, h)),
          h))
            (i = h[r]), (c = u[r]), c !== i && fa(l, r, i, e.data.pre);
          for (r in ((et || rt) &&
            h.value !== u.value &&
            fa(l, "value", h.value),
          u))
            a(h[r]) &&
              (vi(r)
                ? l.removeAttributeNS(gi, yi(r))
                : di(r) || l.removeAttribute(r));
        }
      }
      function fa(t, e, n, r) {
        r || t.tagName.indexOf("-") > -1
          ? pa(t, e, n)
          : mi(e)
          ? bi(n)
            ? t.removeAttribute(e)
            : ((n =
                "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e),
              t.setAttribute(e, n))
          : di(e)
          ? t.setAttribute(e, pi(e, n))
          : vi(e)
          ? bi(n)
            ? t.removeAttributeNS(gi, yi(e))
            : t.setAttributeNS(gi, e, n)
          : pa(t, e, n);
      }
      function pa(t, e, n) {
        if (bi(n)) t.removeAttribute(e);
        else {
          if (
            et &&
            !nt &&
            "TEXTAREA" === t.tagName &&
            "placeholder" === e &&
            "" !== n &&
            !t.__ieph
          ) {
            var r = function (e) {
              e.stopImmediatePropagation(), t.removeEventListener("input", r);
            };
            t.addEventListener("input", r), (t.__ieph = !0);
          }
          t.setAttribute(e, n);
        }
      }
      var ma = { create: da, update: da };
      function ga(t, e) {
        var n = e.elm,
          r = e.data,
          i = t.data;
        if (
          !(
            a(r.staticClass) &&
            a(r.class) &&
            (a(i) || (a(i.staticClass) && a(i.class)))
          )
        ) {
          var s = xi(e),
            c = n._transitionClasses;
          o(c) && (s = Si(s, Mi(c))),
            s !== n._prevClass &&
              (n.setAttribute("class", s), (n._prevClass = s));
        }
      }
      var va,
        ya = { create: ga, update: ga },
        ba = "__r",
        xa = "__c";
      function _a(t) {
        if (o(t[ba])) {
          var e = et ? "change" : "input";
          (t[e] = [].concat(t[ba], t[e] || [])), delete t[ba];
        }
        o(t[xa]) &&
          ((t.change = [].concat(t[xa], t.change || [])), delete t[xa]);
      }
      function wa(t, e, n) {
        var r = va;
        return function i() {
          var a = e.apply(null, arguments);
          null !== a && Ta(t, i, n, r);
        };
      }
      var Sa = Ke && !(ot && Number(ot[1]) <= 53);
      function Ma(t, e, n, r) {
        if (Sa) {
          var i = Un,
            a = e;
          e = a._wrapper = function (t) {
            if (
              t.target === t.currentTarget ||
              t.timeStamp >= i ||
              t.timeStamp <= 0 ||
              t.target.ownerDocument !== document
            )
              return a.apply(this, arguments);
          };
        }
        va.addEventListener(t, e, ct ? { capture: n, passive: r } : n);
      }
      function Ta(t, e, n, r) {
        (r || va).removeEventListener(t, e._wrapper || e, n);
      }
      function Ea(t, e) {
        if (!a(t.data.on) || !a(e.data.on)) {
          var n = e.data.on || {},
            r = t.data.on || {};
          (va = e.elm || t.elm),
            _a(n),
            Zt(n, r, Ma, Ta, wa, e.context),
            (va = void 0);
        }
      }
      var Aa,
        Ca = {
          create: Ea,
          update: Ea,
          destroy: function (t) {
            return Ea(t, Zi);
          },
        };
      function La(t, e) {
        if (!a(t.data.domProps) || !a(e.data.domProps)) {
          var n,
            r,
            i = e.elm,
            c = t.data.domProps || {},
            l = e.data.domProps || {};
          for (n in ((o(l.__ob__) || s(l._v_attr_proxy)) &&
            (l = e.data.domProps = k({}, l)),
          c))
            n in l || (i[n] = "");
          for (n in l) {
            if (((r = l[n]), "textContent" === n || "innerHTML" === n)) {
              if ((e.children && (e.children.length = 0), r === c[n])) continue;
              1 === i.childNodes.length && i.removeChild(i.childNodes[0]);
            }
            if ("value" === n && "PROGRESS" !== i.tagName) {
              i._value = r;
              var u = a(r) ? "" : String(r);
              Ra(i, u) && (i.value = u);
            } else if ("innerHTML" === n && Li(i.tagName) && a(i.innerHTML)) {
              (Aa = Aa || document.createElement("div")),
                (Aa.innerHTML = "<svg>".concat(r, "</svg>"));
              var h = Aa.firstChild;
              while (i.firstChild) i.removeChild(i.firstChild);
              while (h.firstChild) i.appendChild(h.firstChild);
            } else if (r !== c[n])
              try {
                i[n] = r;
              } catch (Yo) {}
          }
        }
      }
      function Ra(t, e) {
        return !t.composing && ("OPTION" === t.tagName || Pa(t, e) || Ia(t, e));
      }
      function Pa(t, e) {
        var n = !0;
        try {
          n = document.activeElement !== t;
        } catch (Yo) {}
        return n && t.value !== e;
      }
      function Ia(t, e) {
        var n = t.value,
          r = t._vModifiers;
        if (o(r)) {
          if (r.number) return y(n) !== y(e);
          if (r.trim) return n.trim() !== e.trim();
        }
        return n !== e;
      }
      var Oa = { create: La, update: La },
        ka = M(function (t) {
          var e = {},
            n = /;(?![^(]*\))/g,
            r = /:(.+)/;
          return (
            t.split(n).forEach(function (t) {
              if (t) {
                var n = t.split(r);
                n.length > 1 && (e[n[0].trim()] = n[1].trim());
              }
            }),
            e
          );
        });
      function Na(t) {
        var e = Da(t.style);
        return t.staticStyle ? k(t.staticStyle, e) : e;
      }
      function Da(t) {
        return Array.isArray(t) ? N(t) : "string" === typeof t ? ka(t) : t;
      }
      function za(t, e) {
        var n,
          r = {};
        if (e) {
          var i = t;
          while (i.componentInstance)
            (i = i.componentInstance._vnode),
              i && i.data && (n = Na(i.data)) && k(r, n);
        }
        (n = Na(t.data)) && k(r, n);
        var a = t;
        while ((a = a.parent)) a.data && (n = Na(a.data)) && k(r, n);
        return r;
      }
      var Fa,
        Ua = /^--/,
        Ba = /\s*!important$/,
        ja = function (t, e, n) {
          if (Ua.test(e)) t.style.setProperty(e, n);
          else if (Ba.test(n))
            t.style.setProperty(L(e), n.replace(Ba, ""), "important");
          else {
            var r = Va(e);
            if (Array.isArray(n))
              for (var i = 0, a = n.length; i < a; i++) t.style[r] = n[i];
            else t.style[r] = n;
          }
        },
        Ha = ["Webkit", "Moz", "ms"],
        Va = M(function (t) {
          if (
            ((Fa = Fa || document.createElement("div").style),
            (t = E(t)),
            "filter" !== t && t in Fa)
          )
            return t;
          for (
            var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0;
            n < Ha.length;
            n++
          ) {
            var r = Ha[n] + e;
            if (r in Fa) return r;
          }
        });
      function Ga(t, e) {
        var n = e.data,
          r = t.data;
        if (
          !(a(n.staticStyle) && a(n.style) && a(r.staticStyle) && a(r.style))
        ) {
          var i,
            s,
            c = e.elm,
            l = r.staticStyle,
            u = r.normalizedStyle || r.style || {},
            h = l || u,
            d = Da(e.data.style) || {};
          e.data.normalizedStyle = o(d.__ob__) ? k({}, d) : d;
          var f = za(e, !0);
          for (s in h) a(f[s]) && ja(c, s, "");
          for (s in f) (i = f[s]), i !== h[s] && ja(c, s, null == i ? "" : i);
        }
      }
      var Wa = { create: Ga, update: Ga },
        qa = /\s+/;
      function Xa(t, e) {
        if (e && (e = e.trim()))
          if (t.classList)
            e.indexOf(" ") > -1
              ? e.split(qa).forEach(function (e) {
                  return t.classList.add(e);
                })
              : t.classList.add(e);
          else {
            var n = " ".concat(t.getAttribute("class") || "", " ");
            n.indexOf(" " + e + " ") < 0 &&
              t.setAttribute("class", (n + e).trim());
          }
      }
      function $a(t, e) {
        if (e && (e = e.trim()))
          if (t.classList)
            e.indexOf(" ") > -1
              ? e.split(qa).forEach(function (e) {
                  return t.classList.remove(e);
                })
              : t.classList.remove(e),
              t.classList.length || t.removeAttribute("class");
          else {
            var n = " ".concat(t.getAttribute("class") || "", " "),
              r = " " + e + " ";
            while (n.indexOf(r) >= 0) n = n.replace(r, " ");
            (n = n.trim()),
              n ? t.setAttribute("class", n) : t.removeAttribute("class");
          }
      }
      function Ya(t) {
        if (t) {
          if ("object" === typeof t) {
            var e = {};
            return !1 !== t.css && k(e, Ja(t.name || "v")), k(e, t), e;
          }
          return "string" === typeof t ? Ja(t) : void 0;
        }
      }
      var Ja = M(function (t) {
          return {
            enterClass: "".concat(t, "-enter"),
            enterToClass: "".concat(t, "-enter-to"),
            enterActiveClass: "".concat(t, "-enter-active"),
            leaveClass: "".concat(t, "-leave"),
            leaveToClass: "".concat(t, "-leave-to"),
            leaveActiveClass: "".concat(t, "-leave-active"),
          };
        }),
        Ka = Q && !nt,
        Za = "transition",
        Qa = "animation",
        to = "transition",
        eo = "transitionend",
        no = "animation",
        ro = "animationend";
      Ka &&
        (void 0 === window.ontransitionend &&
          void 0 !== window.onwebkittransitionend &&
          ((to = "WebkitTransition"), (eo = "webkitTransitionEnd")),
        void 0 === window.onanimationend &&
          void 0 !== window.onwebkitanimationend &&
          ((no = "WebkitAnimation"), (ro = "webkitAnimationEnd")));
      var io = Q
        ? window.requestAnimationFrame
          ? window.requestAnimationFrame.bind(window)
          : setTimeout
        : function (t) {
            return t();
          };
      function ao(t) {
        io(function () {
          io(t);
        });
      }
      function oo(t, e) {
        var n = t._transitionClasses || (t._transitionClasses = []);
        n.indexOf(e) < 0 && (n.push(e), Xa(t, e));
      }
      function so(t, e) {
        t._transitionClasses && _(t._transitionClasses, e), $a(t, e);
      }
      function co(t, e, n) {
        var r = uo(t, e),
          i = r.type,
          a = r.timeout,
          o = r.propCount;
        if (!i) return n();
        var s = i === Za ? eo : ro,
          c = 0,
          l = function () {
            t.removeEventListener(s, u), n();
          },
          u = function (e) {
            e.target === t && ++c >= o && l();
          };
        setTimeout(function () {
          c < o && l();
        }, a + 1),
          t.addEventListener(s, u);
      }
      var lo = /\b(transform|all)(,|$)/;
      function uo(t, e) {
        var n,
          r = window.getComputedStyle(t),
          i = (r[to + "Delay"] || "").split(", "),
          a = (r[to + "Duration"] || "").split(", "),
          o = ho(i, a),
          s = (r[no + "Delay"] || "").split(", "),
          c = (r[no + "Duration"] || "").split(", "),
          l = ho(s, c),
          u = 0,
          h = 0;
        e === Za
          ? o > 0 && ((n = Za), (u = o), (h = a.length))
          : e === Qa
          ? l > 0 && ((n = Qa), (u = l), (h = c.length))
          : ((u = Math.max(o, l)),
            (n = u > 0 ? (o > l ? Za : Qa) : null),
            (h = n ? (n === Za ? a.length : c.length) : 0));
        var d = n === Za && lo.test(r[to + "Property"]);
        return { type: n, timeout: u, propCount: h, hasTransform: d };
      }
      function ho(t, e) {
        while (t.length < e.length) t = t.concat(t);
        return Math.max.apply(
          null,
          e.map(function (e, n) {
            return fo(e) + fo(t[n]);
          })
        );
      }
      function fo(t) {
        return 1e3 * Number(t.slice(0, -1).replace(",", "."));
      }
      function po(t, e) {
        var n = t.elm;
        o(n._leaveCb) && ((n._leaveCb.cancelled = !0), n._leaveCb());
        var r = Ya(t.data.transition);
        if (!a(r) && !o(n._enterCb) && 1 === n.nodeType) {
          var i = r.css,
            s = r.type,
            c = r.enterClass,
            l = r.enterToClass,
            d = r.enterActiveClass,
            f = r.appearClass,
            p = r.appearToClass,
            m = r.appearActiveClass,
            g = r.beforeEnter,
            v = r.enter,
            b = r.afterEnter,
            x = r.enterCancelled,
            _ = r.beforeAppear,
            w = r.appear,
            S = r.afterAppear,
            M = r.appearCancelled,
            T = r.duration,
            E = wn,
            A = wn.$vnode;
          while (A && A.parent) (E = A.context), (A = A.parent);
          var C = !E._isMounted || !t.isRootInsert;
          if (!C || w || "" === w) {
            var L = C && f ? f : c,
              R = C && m ? m : d,
              P = C && p ? p : l,
              I = (C && _) || g,
              O = C && u(w) ? w : v,
              k = (C && S) || b,
              N = (C && M) || x,
              D = y(h(T) ? T.enter : T);
            0;
            var z = !1 !== i && !nt,
              F = vo(O),
              U = (n._enterCb = j(function () {
                z && (so(n, P), so(n, R)),
                  U.cancelled ? (z && so(n, L), N && N(n)) : k && k(n),
                  (n._enterCb = null);
              }));
            t.data.show ||
              Qt(t, "insert", function () {
                var e = n.parentNode,
                  r = e && e._pending && e._pending[t.key];
                r && r.tag === t.tag && r.elm._leaveCb && r.elm._leaveCb(),
                  O && O(n, U);
              }),
              I && I(n),
              z &&
                (oo(n, L),
                oo(n, R),
                ao(function () {
                  so(n, L),
                    U.cancelled ||
                      (oo(n, P), F || (go(D) ? setTimeout(U, D) : co(n, s, U)));
                })),
              t.data.show && (e && e(), O && O(n, U)),
              z || F || U();
          }
        }
      }
      function mo(t, e) {
        var n = t.elm;
        o(n._enterCb) && ((n._enterCb.cancelled = !0), n._enterCb());
        var r = Ya(t.data.transition);
        if (a(r) || 1 !== n.nodeType) return e();
        if (!o(n._leaveCb)) {
          var i = r.css,
            s = r.type,
            c = r.leaveClass,
            l = r.leaveToClass,
            u = r.leaveActiveClass,
            d = r.beforeLeave,
            f = r.leave,
            p = r.afterLeave,
            m = r.leaveCancelled,
            g = r.delayLeave,
            v = r.duration,
            b = !1 !== i && !nt,
            x = vo(f),
            _ = y(h(v) ? v.leave : v);
          0;
          var w = (n._leaveCb = j(function () {
            n.parentNode &&
              n.parentNode._pending &&
              (n.parentNode._pending[t.key] = null),
              b && (so(n, l), so(n, u)),
              w.cancelled ? (b && so(n, c), m && m(n)) : (e(), p && p(n)),
              (n._leaveCb = null);
          }));
          g ? g(S) : S();
        }
        function S() {
          w.cancelled ||
            (!t.data.show &&
              n.parentNode &&
              ((n.parentNode._pending || (n.parentNode._pending = {}))[t.key] =
                t),
            d && d(n),
            b &&
              (oo(n, c),
              oo(n, u),
              ao(function () {
                so(n, c),
                  w.cancelled ||
                    (oo(n, l), x || (go(_) ? setTimeout(w, _) : co(n, s, w)));
              })),
            f && f(n, w),
            b || x || w());
        }
      }
      function go(t) {
        return "number" === typeof t && !isNaN(t);
      }
      function vo(t) {
        if (a(t)) return !1;
        var e = t.fns;
        return o(e)
          ? vo(Array.isArray(e) ? e[0] : e)
          : (t._length || t.length) > 1;
      }
      function yo(t, e) {
        !0 !== e.data.show && po(e);
      }
      var bo = Q
          ? {
              create: yo,
              activate: yo,
              remove: function (t, e) {
                !0 !== t.data.show ? mo(t, e) : e();
              },
            }
          : {},
        xo = [ma, ya, Ca, Oa, Wa, bo],
        _o = xo.concat(ha),
        wo = ra({ nodeOps: $i, modules: _o });
      nt &&
        document.addEventListener("selectionchange", function () {
          var t = document.activeElement;
          t && t.vmodel && Ro(t, "input");
        });
      var So = {
        inserted: function (t, e, n, r) {
          "select" === n.tag
            ? (r.elm && !r.elm._vOptions
                ? Qt(n, "postpatch", function () {
                    So.componentUpdated(t, e, n);
                  })
                : Mo(t, e, n.context),
              (t._vOptions = [].map.call(t.options, Ao)))
            : ("textarea" === n.tag || ki(t.type)) &&
              ((t._vModifiers = e.modifiers),
              e.modifiers.lazy ||
                (t.addEventListener("compositionstart", Co),
                t.addEventListener("compositionend", Lo),
                t.addEventListener("change", Lo),
                nt && (t.vmodel = !0)));
        },
        componentUpdated: function (t, e, n) {
          if ("select" === n.tag) {
            Mo(t, e, n.context);
            var r = t._vOptions,
              i = (t._vOptions = [].map.call(t.options, Ao));
            if (
              i.some(function (t, e) {
                return !U(t, r[e]);
              })
            ) {
              var a = t.multiple
                ? e.value.some(function (t) {
                    return Eo(t, i);
                  })
                : e.value !== e.oldValue && Eo(e.value, i);
              a && Ro(t, "change");
            }
          }
        },
      };
      function Mo(t, e, n) {
        To(t, e, n),
          (et || rt) &&
            setTimeout(function () {
              To(t, e, n);
            }, 0);
      }
      function To(t, e, n) {
        var r = e.value,
          i = t.multiple;
        if (!i || Array.isArray(r)) {
          for (var a, o, s = 0, c = t.options.length; s < c; s++)
            if (((o = t.options[s]), i))
              (a = B(r, Ao(o)) > -1), o.selected !== a && (o.selected = a);
            else if (U(Ao(o), r))
              return void (t.selectedIndex !== s && (t.selectedIndex = s));
          i || (t.selectedIndex = -1);
        }
      }
      function Eo(t, e) {
        return e.every(function (e) {
          return !U(e, t);
        });
      }
      function Ao(t) {
        return "_value" in t ? t._value : t.value;
      }
      function Co(t) {
        t.target.composing = !0;
      }
      function Lo(t) {
        t.target.composing &&
          ((t.target.composing = !1), Ro(t.target, "input"));
      }
      function Ro(t, e) {
        var n = document.createEvent("HTMLEvents");
        n.initEvent(e, !0, !0), t.dispatchEvent(n);
      }
      function Po(t) {
        return !t.componentInstance || (t.data && t.data.transition)
          ? t
          : Po(t.componentInstance._vnode);
      }
      var Io = {
          bind: function (t, e, n) {
            var r = e.value;
            n = Po(n);
            var i = n.data && n.data.transition,
              a = (t.__vOriginalDisplay =
                "none" === t.style.display ? "" : t.style.display);
            r && i
              ? ((n.data.show = !0),
                po(n, function () {
                  t.style.display = a;
                }))
              : (t.style.display = r ? a : "none");
          },
          update: function (t, e, n) {
            var r = e.value,
              i = e.oldValue;
            if (!r !== !i) {
              n = Po(n);
              var a = n.data && n.data.transition;
              a
                ? ((n.data.show = !0),
                  r
                    ? po(n, function () {
                        t.style.display = t.__vOriginalDisplay;
                      })
                    : mo(n, function () {
                        t.style.display = "none";
                      }))
                : (t.style.display = r ? t.__vOriginalDisplay : "none");
            }
          },
          unbind: function (t, e, n, r, i) {
            i || (t.style.display = t.__vOriginalDisplay);
          },
        },
        Oo = { model: So, show: Io },
        ko = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object],
        };
      function No(t) {
        var e = t && t.componentOptions;
        return e && e.Ctor.options.abstract ? No(Ue(e.children)) : t;
      }
      function Do(t) {
        var e = {},
          n = t.$options;
        for (var r in n.propsData) e[r] = t[r];
        var i = n._parentListeners;
        for (var r in i) e[E(r)] = i[r];
        return e;
      }
      function zo(t, e) {
        if (/\d-keep-alive$/.test(e.tag))
          return t("keep-alive", { props: e.componentOptions.propsData });
      }
      function Fo(t) {
        while ((t = t.parent)) if (t.data.transition) return !0;
      }
      function Uo(t, e) {
        return e.key === t.key && e.tag === t.tag;
      }
      var Bo = function (t) {
          return t.tag || Se(t);
        },
        jo = function (t) {
          return "show" === t.name;
        },
        Ho = {
          name: "transition",
          props: ko,
          abstract: !0,
          render: function (t) {
            var e = this,
              n = this.$slots.default;
            if (n && ((n = n.filter(Bo)), n.length)) {
              0;
              var r = this.mode;
              0;
              var i = n[0];
              if (Fo(this.$vnode)) return i;
              var a = No(i);
              if (!a) return i;
              if (this._leaving) return zo(t, i);
              var o = "__transition-".concat(this._uid, "-");
              a.key =
                null == a.key
                  ? a.isComment
                    ? o + "comment"
                    : o + a.tag
                  : l(a.key)
                  ? 0 === String(a.key).indexOf(o)
                    ? a.key
                    : o + a.key
                  : a.key;
              var s = ((a.data || (a.data = {})).transition = Do(this)),
                c = this._vnode,
                u = No(c);
              if (
                (a.data.directives &&
                  a.data.directives.some(jo) &&
                  (a.data.show = !0),
                u &&
                  u.data &&
                  !Uo(a, u) &&
                  !Se(u) &&
                  (!u.componentInstance ||
                    !u.componentInstance._vnode.isComment))
              ) {
                var h = (u.data.transition = k({}, s));
                if ("out-in" === r)
                  return (
                    (this._leaving = !0),
                    Qt(h, "afterLeave", function () {
                      (e._leaving = !1), e.$forceUpdate();
                    }),
                    zo(t, i)
                  );
                if ("in-out" === r) {
                  if (Se(a)) return c;
                  var d,
                    f = function () {
                      d();
                    };
                  Qt(s, "afterEnter", f),
                    Qt(s, "enterCancelled", f),
                    Qt(h, "delayLeave", function (t) {
                      d = t;
                    });
                }
              }
              return i;
            }
          },
        },
        Vo = k({ tag: String, moveClass: String }, ko);
      delete Vo.mode;
      var Go = {
        props: Vo,
        beforeMount: function () {
          var t = this,
            e = this._update;
          this._update = function (n, r) {
            var i = Sn(t);
            t.__patch__(t._vnode, t.kept, !1, !0),
              (t._vnode = t.kept),
              i(),
              e.call(t, n, r);
          };
        },
        render: function (t) {
          for (
            var e = this.tag || this.$vnode.data.tag || "span",
              n = Object.create(null),
              r = (this.prevChildren = this.children),
              i = this.$slots.default || [],
              a = (this.children = []),
              o = Do(this),
              s = 0;
            s < i.length;
            s++
          ) {
            var c = i[s];
            if (c.tag)
              if (null != c.key && 0 !== String(c.key).indexOf("__vlist"))
                a.push(c),
                  (n[c.key] = c),
                  ((c.data || (c.data = {})).transition = o);
              else;
          }
          if (r) {
            var l = [],
              u = [];
            for (s = 0; s < r.length; s++) {
              c = r[s];
              (c.data.transition = o),
                (c.data.pos = c.elm.getBoundingClientRect()),
                n[c.key] ? l.push(c) : u.push(c);
            }
            (this.kept = t(e, null, l)), (this.removed = u);
          }
          return t(e, null, a);
        },
        updated: function () {
          var t = this.prevChildren,
            e = this.moveClass || (this.name || "v") + "-move";
          t.length &&
            this.hasMove(t[0].elm, e) &&
            (t.forEach(Wo),
            t.forEach(qo),
            t.forEach(Xo),
            (this._reflow = document.body.offsetHeight),
            t.forEach(function (t) {
              if (t.data.moved) {
                var n = t.elm,
                  r = n.style;
                oo(n, e),
                  (r.transform = r.WebkitTransform = r.transitionDuration = ""),
                  n.addEventListener(
                    eo,
                    (n._moveCb = function t(r) {
                      (r && r.target !== n) ||
                        (r && !/transform$/.test(r.propertyName)) ||
                        (n.removeEventListener(eo, t),
                        (n._moveCb = null),
                        so(n, e));
                    })
                  );
              }
            }));
        },
        methods: {
          hasMove: function (t, e) {
            if (!Ka) return !1;
            if (this._hasMove) return this._hasMove;
            var n = t.cloneNode();
            t._transitionClasses &&
              t._transitionClasses.forEach(function (t) {
                $a(n, t);
              }),
              Xa(n, e),
              (n.style.display = "none"),
              this.$el.appendChild(n);
            var r = uo(n);
            return this.$el.removeChild(n), (this._hasMove = r.hasTransform);
          },
        },
      };
      function Wo(t) {
        t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb();
      }
      function qo(t) {
        t.data.newPos = t.elm.getBoundingClientRect();
      }
      function Xo(t) {
        var e = t.data.pos,
          n = t.data.newPos,
          r = e.left - n.left,
          i = e.top - n.top;
        if (r || i) {
          t.data.moved = !0;
          var a = t.elm.style;
          (a.transform = a.WebkitTransform =
            "translate(".concat(r, "px,").concat(i, "px)")),
            (a.transitionDuration = "0s");
        }
      }
      var $o = { Transition: Ho, TransitionGroup: Go };
      ($r.config.mustUseProp = hi),
        ($r.config.isReservedTag = Ri),
        ($r.config.isReservedAttr = li),
        ($r.config.getTagNamespace = Pi),
        ($r.config.isUnknownElement = Oi),
        k($r.options.directives, Oo),
        k($r.options.components, $o),
        ($r.prototype.__patch__ = Q ? wo : D),
        ($r.prototype.$mount = function (t, e) {
          return (t = t && Q ? Ni(t) : void 0), En(this, t, e);
        }),
        Q &&
          setTimeout(function () {
            q.devtools && ht && ht.emit("init", $r);
          }, 0);
    },
    2415: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return d;
        },
      });
      var r = function (t) {
          return (
            (function (t) {
              return !!t && "object" == typeof t;
            })(t) &&
            !(function (t) {
              var e = Object.prototype.toString.call(t);
              return (
                "[object RegExp]" === e ||
                "[object Date]" === e ||
                (function (t) {
                  return t.$$typeof === i;
                })(t)
              );
            })(t)
          );
        },
        i =
          "function" == typeof Symbol && Symbol.for
            ? Symbol.for("react.element")
            : 60103;
      function a(t, e) {
        return !1 !== e.clone && e.isMergeableObject(t)
          ? l(Array.isArray(t) ? [] : {}, t, e)
          : t;
      }
      function o(t, e, n) {
        return t.concat(e).map(function (t) {
          return a(t, n);
        });
      }
      function s(t) {
        return Object.keys(t).concat(
          (function (t) {
            return Object.getOwnPropertySymbols
              ? Object.getOwnPropertySymbols(t).filter(function (e) {
                  return t.propertyIsEnumerable(e);
                })
              : [];
          })(t)
        );
      }
      function c(t, e) {
        try {
          return e in t;
        } catch (t) {
          return !1;
        }
      }
      function l(t, e, n) {
        ((n = n || {}).arrayMerge = n.arrayMerge || o),
          (n.isMergeableObject = n.isMergeableObject || r),
          (n.cloneUnlessOtherwiseSpecified = a);
        var i = Array.isArray(e);
        return i === Array.isArray(t)
          ? i
            ? n.arrayMerge(t, e, n)
            : (function (t, e, n) {
                var r = {};
                return (
                  n.isMergeableObject(t) &&
                    s(t).forEach(function (e) {
                      r[e] = a(t[e], n);
                    }),
                  s(e).forEach(function (i) {
                    (function (t, e) {
                      return (
                        c(t, e) &&
                        !(
                          Object.hasOwnProperty.call(t, e) &&
                          Object.propertyIsEnumerable.call(t, e)
                        )
                      );
                    })(t, i) ||
                      (r[i] =
                        c(t, i) && n.isMergeableObject(e[i])
                          ? (function (t, e) {
                              if (!e.customMerge) return l;
                              var n = e.customMerge(t);
                              return "function" == typeof n ? n : l;
                            })(i, n)(t[i], e[i], n)
                          : a(e[i], n));
                  }),
                  r
                );
              })(t, e, n)
          : a(e, n);
      }
      l.all = function (t, e) {
        if (!Array.isArray(t))
          throw new Error("first argument should be an array");
        return t.reduce(function (t, n) {
          return l(t, n, e);
        }, {});
      };
      var u = l;
      function h(t, e, n) {
        return void 0 ===
          (t = (e.split ? e.split(".") : e).reduce(function (t, e) {
            return t && t[e];
          }, t))
          ? n
          : t;
      }
      function d(t, e, n) {
        function r(t, e, n) {
          try {
            return (n = e.getItem(t)) && void 0 !== n ? JSON.parse(n) : void 0;
          } catch (t) {}
        }
        if (
          ((e = (t = t || {}).storage || (window && window.localStorage)),
          (n = t.key || "vuex"),
          !(function (t) {
            try {
              return t.setItem("@@", 1), t.removeItem("@@"), !0;
            } catch (t) {}
            return !1;
          })(e))
        )
          throw new Error("Invalid storage instance given");
        var i,
          a = function () {
            return h(t, "getState", r)(n, e);
          };
        return (
          t.fetchBeforeUse && (i = a()),
          function (r) {
            t.fetchBeforeUse || (i = a()),
              "object" == typeof i &&
                null !== i &&
                (r.replaceState(
                  u(r.state, i, {
                    arrayMerge:
                      t.arrayMerger ||
                      function (t, e) {
                        return e;
                      },
                    clone: !1,
                  })
                ),
                (t.rehydrated || function () {})(r)),
              (
                t.subscriber ||
                function (t) {
                  return function (e) {
                    return t.subscribe(e);
                  };
                }
              )(r)(function (r, i) {
                (
                  t.filter ||
                  function () {
                    return !0;
                  }
                )(r) &&
                  (
                    t.setState ||
                    function (t, e, n) {
                      return n.setItem(t, JSON.stringify(e));
                    }
                  )(
                    n,
                    (
                      t.reducer ||
                      function (t, e) {
                        return 0 === e.length
                          ? t
                          : e.reduce(function (e, n) {
                              return (function (t, e, n, r) {
                                return (
                                  ((e = e.split ? e.split(".") : e)
                                    .slice(0, -1)
                                    .reduce(function (t, e) {
                                      return (t[e] = t[e] || {});
                                    }, t)[e.pop()] = n),
                                  t
                                );
                              })(e, n, h(t, n));
                            }, {});
                      }
                    )(i, t.paths || []),
                    e
                  );
              });
          }
        );
      }
    },
    3822: function (t, e, n) {
      "use strict";
      n.d(e, {
        rn: function () {
          return L;
        },
      });
      /**
       * vuex v2.5.0
       * (c) 2017 Evan You
       * @license MIT
       */
      var r = function (t) {
          var e = Number(t.version.split(".")[0]);
          if (e >= 2) t.mixin({ beforeCreate: r });
          else {
            var n = t.prototype._init;
            t.prototype._init = function (t) {
              void 0 === t && (t = {}),
                (t.init = t.init ? [r].concat(t.init) : r),
                n.call(this, t);
            };
          }
          function r() {
            var t = this.$options;
            t.store
              ? (this.$store =
                  "function" === typeof t.store ? t.store() : t.store)
              : t.parent && t.parent.$store && (this.$store = t.parent.$store);
          }
        },
        i =
          "undefined" !== typeof window && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
      function a(t) {
        i &&
          ((t._devtoolHook = i),
          i.emit("vuex:init", t),
          i.on("vuex:travel-to-state", function (e) {
            t.replaceState(e);
          }),
          t.subscribe(function (t, e) {
            i.emit("vuex:mutation", t, e);
          }));
      }
      function o(t, e) {
        Object.keys(t).forEach(function (n) {
          return e(t[n], n);
        });
      }
      function s(t) {
        return null !== t && "object" === typeof t;
      }
      function c(t) {
        return t && "function" === typeof t.then;
      }
      var l = function (t, e) {
          (this.runtime = e),
            (this._children = Object.create(null)),
            (this._rawModule = t);
          var n = t.state;
          this.state = ("function" === typeof n ? n() : n) || {};
        },
        u = { namespaced: { configurable: !0 } };
      (u.namespaced.get = function () {
        return !!this._rawModule.namespaced;
      }),
        (l.prototype.addChild = function (t, e) {
          this._children[t] = e;
        }),
        (l.prototype.removeChild = function (t) {
          delete this._children[t];
        }),
        (l.prototype.getChild = function (t) {
          return this._children[t];
        }),
        (l.prototype.update = function (t) {
          (this._rawModule.namespaced = t.namespaced),
            t.actions && (this._rawModule.actions = t.actions),
            t.mutations && (this._rawModule.mutations = t.mutations),
            t.getters && (this._rawModule.getters = t.getters);
        }),
        (l.prototype.forEachChild = function (t) {
          o(this._children, t);
        }),
        (l.prototype.forEachGetter = function (t) {
          this._rawModule.getters && o(this._rawModule.getters, t);
        }),
        (l.prototype.forEachAction = function (t) {
          this._rawModule.actions && o(this._rawModule.actions, t);
        }),
        (l.prototype.forEachMutation = function (t) {
          this._rawModule.mutations && o(this._rawModule.mutations, t);
        }),
        Object.defineProperties(l.prototype, u);
      var h = function (t) {
        this.register([], t, !1);
      };
      function d(t, e, n) {
        if ((e.update(n), n.modules))
          for (var r in n.modules) {
            if (!e.getChild(r)) return void 0;
            d(t.concat(r), e.getChild(r), n.modules[r]);
          }
      }
      (h.prototype.get = function (t) {
        return t.reduce(function (t, e) {
          return t.getChild(e);
        }, this.root);
      }),
        (h.prototype.getNamespace = function (t) {
          var e = this.root;
          return t.reduce(function (t, n) {
            return (e = e.getChild(n)), t + (e.namespaced ? n + "/" : "");
          }, "");
        }),
        (h.prototype.update = function (t) {
          d([], this.root, t);
        }),
        (h.prototype.register = function (t, e, n) {
          var r = this;
          void 0 === n && (n = !0);
          var i = new l(e, n);
          if (0 === t.length) this.root = i;
          else {
            var a = this.get(t.slice(0, -1));
            a.addChild(t[t.length - 1], i);
          }
          e.modules &&
            o(e.modules, function (e, i) {
              r.register(t.concat(i), e, n);
            });
        }),
        (h.prototype.unregister = function (t) {
          var e = this.get(t.slice(0, -1)),
            n = t[t.length - 1];
          e.getChild(n).runtime && e.removeChild(n);
        });
      var f;
      var p = function (t) {
          var e = this;
          void 0 === t && (t = {}),
            !f && "undefined" !== typeof window && window.Vue && C(window.Vue);
          var n = t.plugins;
          void 0 === n && (n = []);
          var r = t.strict;
          void 0 === r && (r = !1);
          var i = t.state;
          void 0 === i && (i = {}),
            "function" === typeof i && (i = i() || {}),
            (this._committing = !1),
            (this._actions = Object.create(null)),
            (this._actionSubscribers = []),
            (this._mutations = Object.create(null)),
            (this._wrappedGetters = Object.create(null)),
            (this._modules = new h(t)),
            (this._modulesNamespaceMap = Object.create(null)),
            (this._subscribers = []),
            (this._watcherVM = new f());
          var o = this,
            s = this,
            c = s.dispatch,
            l = s.commit;
          (this.dispatch = function (t, e) {
            return c.call(o, t, e);
          }),
            (this.commit = function (t, e, n) {
              return l.call(o, t, e, n);
            }),
            (this.strict = r),
            b(this, i, [], this._modules.root),
            y(this, i),
            n.forEach(function (t) {
              return t(e);
            }),
            f.config.devtools && a(this);
        },
        m = { state: { configurable: !0 } };
      function g(t, e) {
        return (
          e.indexOf(t) < 0 && e.push(t),
          function () {
            var n = e.indexOf(t);
            n > -1 && e.splice(n, 1);
          }
        );
      }
      function v(t, e) {
        (t._actions = Object.create(null)),
          (t._mutations = Object.create(null)),
          (t._wrappedGetters = Object.create(null)),
          (t._modulesNamespaceMap = Object.create(null));
        var n = t.state;
        b(t, n, [], t._modules.root, !0), y(t, n, e);
      }
      function y(t, e, n) {
        var r = t._vm;
        t.getters = {};
        var i = t._wrappedGetters,
          a = {};
        o(i, function (e, n) {
          (a[n] = function () {
            return e(t);
          }),
            Object.defineProperty(t.getters, n, {
              get: function () {
                return t._vm[n];
              },
              enumerable: !0,
            });
        });
        var s = f.config.silent;
        (f.config.silent = !0),
          (t._vm = new f({ data: { $$state: e }, computed: a })),
          (f.config.silent = s),
          t.strict && T(t),
          r &&
            (n &&
              t._withCommit(function () {
                r._data.$$state = null;
              }),
            f.nextTick(function () {
              return r.$destroy();
            }));
      }
      function b(t, e, n, r, i) {
        var a = !n.length,
          o = t._modules.getNamespace(n);
        if ((r.namespaced && (t._modulesNamespaceMap[o] = r), !a && !i)) {
          var s = E(e, n.slice(0, -1)),
            c = n[n.length - 1];
          t._withCommit(function () {
            f.set(s, c, r.state);
          });
        }
        var l = (r.context = x(t, o, n));
        r.forEachMutation(function (e, n) {
          var r = o + n;
          w(t, r, e, l);
        }),
          r.forEachAction(function (e, n) {
            var r = e.root ? n : o + n,
              i = e.handler || e;
            S(t, r, i, l);
          }),
          r.forEachGetter(function (e, n) {
            var r = o + n;
            M(t, r, e, l);
          }),
          r.forEachChild(function (r, a) {
            b(t, e, n.concat(a), r, i);
          });
      }
      function x(t, e, n) {
        var r = "" === e,
          i = {
            dispatch: r
              ? t.dispatch
              : function (n, r, i) {
                  var a = A(n, r, i),
                    o = a.payload,
                    s = a.options,
                    c = a.type;
                  return (s && s.root) || (c = e + c), t.dispatch(c, o);
                },
            commit: r
              ? t.commit
              : function (n, r, i) {
                  var a = A(n, r, i),
                    o = a.payload,
                    s = a.options,
                    c = a.type;
                  (s && s.root) || (c = e + c), t.commit(c, o, s);
                },
          };
        return (
          Object.defineProperties(i, {
            getters: {
              get: r
                ? function () {
                    return t.getters;
                  }
                : function () {
                    return _(t, e);
                  },
            },
            state: {
              get: function () {
                return E(t.state, n);
              },
            },
          }),
          i
        );
      }
      function _(t, e) {
        var n = {},
          r = e.length;
        return (
          Object.keys(t.getters).forEach(function (i) {
            if (i.slice(0, r) === e) {
              var a = i.slice(r);
              Object.defineProperty(n, a, {
                get: function () {
                  return t.getters[i];
                },
                enumerable: !0,
              });
            }
          }),
          n
        );
      }
      function w(t, e, n, r) {
        var i = t._mutations[e] || (t._mutations[e] = []);
        i.push(function (e) {
          n.call(t, r.state, e);
        });
      }
      function S(t, e, n, r) {
        var i = t._actions[e] || (t._actions[e] = []);
        i.push(function (e, i) {
          var a = n.call(
            t,
            {
              dispatch: r.dispatch,
              commit: r.commit,
              getters: r.getters,
              state: r.state,
              rootGetters: t.getters,
              rootState: t.state,
            },
            e,
            i
          );
          return (
            c(a) || (a = Promise.resolve(a)),
            t._devtoolHook
              ? a.catch(function (e) {
                  throw (t._devtoolHook.emit("vuex:error", e), e);
                })
              : a
          );
        });
      }
      function M(t, e, n, r) {
        t._wrappedGetters[e] ||
          (t._wrappedGetters[e] = function (t) {
            return n(r.state, r.getters, t.state, t.getters);
          });
      }
      function T(t) {
        t._vm.$watch(
          function () {
            return this._data.$$state;
          },
          function () {
            0;
          },
          { deep: !0, sync: !0 }
        );
      }
      function E(t, e) {
        return e.length
          ? e.reduce(function (t, e) {
              return t[e];
            }, t)
          : t;
      }
      function A(t, e, n) {
        return (
          s(t) && t.type && ((n = e), (e = t), (t = t.type)),
          { type: t, payload: e, options: n }
        );
      }
      function C(t) {
        (f && t === f) || ((f = t), r(f));
      }
      (m.state.get = function () {
        return this._vm._data.$$state;
      }),
        (m.state.set = function (t) {
          0;
        }),
        (p.prototype.commit = function (t, e, n) {
          var r = this,
            i = A(t, e, n),
            a = i.type,
            o = i.payload,
            s = (i.options, { type: a, payload: o }),
            c = this._mutations[a];
          c &&
            (this._withCommit(function () {
              c.forEach(function (t) {
                t(o);
              });
            }),
            this._subscribers.forEach(function (t) {
              return t(s, r.state);
            }));
        }),
        (p.prototype.dispatch = function (t, e) {
          var n = this,
            r = A(t, e),
            i = r.type,
            a = r.payload,
            o = { type: i, payload: a },
            s = this._actions[i];
          if (s)
            return (
              this._actionSubscribers.forEach(function (t) {
                return t(o, n.state);
              }),
              s.length > 1
                ? Promise.all(
                    s.map(function (t) {
                      return t(a);
                    })
                  )
                : s[0](a)
            );
        }),
        (p.prototype.subscribe = function (t) {
          return g(t, this._subscribers);
        }),
        (p.prototype.subscribeAction = function (t) {
          return g(t, this._actionSubscribers);
        }),
        (p.prototype.watch = function (t, e, n) {
          var r = this;
          return this._watcherVM.$watch(
            function () {
              return t(r.state, r.getters);
            },
            e,
            n
          );
        }),
        (p.prototype.replaceState = function (t) {
          var e = this;
          this._withCommit(function () {
            e._vm._data.$$state = t;
          });
        }),
        (p.prototype.registerModule = function (t, e, n) {
          void 0 === n && (n = {}),
            "string" === typeof t && (t = [t]),
            this._modules.register(t, e),
            b(this, this.state, t, this._modules.get(t), n.preserveState),
            y(this, this.state);
        }),
        (p.prototype.unregisterModule = function (t) {
          var e = this;
          "string" === typeof t && (t = [t]),
            this._modules.unregister(t),
            this._withCommit(function () {
              var n = E(e.state, t.slice(0, -1));
              f.delete(n, t[t.length - 1]);
            }),
            v(this);
        }),
        (p.prototype.hotUpdate = function (t) {
          this._modules.update(t), v(this, !0);
        }),
        (p.prototype._withCommit = function (t) {
          var e = this._committing;
          (this._committing = !0), t(), (this._committing = e);
        }),
        Object.defineProperties(p.prototype, m);
      var L = N(function (t, e) {
          var n = {};
          return (
            k(e).forEach(function (e) {
              var r = e.key,
                i = e.val;
              (n[r] = function () {
                var e = this.$store.state,
                  n = this.$store.getters;
                if (t) {
                  var r = D(this.$store, "mapState", t);
                  if (!r) return;
                  (e = r.context.state), (n = r.context.getters);
                }
                return "function" === typeof i ? i.call(this, e, n) : e[i];
              }),
                (n[r].vuex = !0);
            }),
            n
          );
        }),
        R = N(function (t, e) {
          var n = {};
          return (
            k(e).forEach(function (e) {
              var r = e.key,
                i = e.val;
              n[r] = function () {
                var e = [],
                  n = arguments.length;
                while (n--) e[n] = arguments[n];
                var r = this.$store.commit;
                if (t) {
                  var a = D(this.$store, "mapMutations", t);
                  if (!a) return;
                  r = a.context.commit;
                }
                return "function" === typeof i
                  ? i.apply(this, [r].concat(e))
                  : r.apply(this.$store, [i].concat(e));
              };
            }),
            n
          );
        }),
        P = N(function (t, e) {
          var n = {};
          return (
            k(e).forEach(function (e) {
              var r = e.key,
                i = e.val;
              (i = t + i),
                (n[r] = function () {
                  if (!t || D(this.$store, "mapGetters", t))
                    return this.$store.getters[i];
                }),
                (n[r].vuex = !0);
            }),
            n
          );
        }),
        I = N(function (t, e) {
          var n = {};
          return (
            k(e).forEach(function (e) {
              var r = e.key,
                i = e.val;
              n[r] = function () {
                var e = [],
                  n = arguments.length;
                while (n--) e[n] = arguments[n];
                var r = this.$store.dispatch;
                if (t) {
                  var a = D(this.$store, "mapActions", t);
                  if (!a) return;
                  r = a.context.dispatch;
                }
                return "function" === typeof i
                  ? i.apply(this, [r].concat(e))
                  : r.apply(this.$store, [i].concat(e));
              };
            }),
            n
          );
        }),
        O = function (t) {
          return {
            mapState: L.bind(null, t),
            mapGetters: P.bind(null, t),
            mapMutations: R.bind(null, t),
            mapActions: I.bind(null, t),
          };
        };
      function k(t) {
        return Array.isArray(t)
          ? t.map(function (t) {
              return { key: t, val: t };
            })
          : Object.keys(t).map(function (e) {
              return { key: e, val: t[e] };
            });
      }
      function N(t) {
        return function (e, n) {
          return (
            "string" !== typeof e
              ? ((n = e), (e = ""))
              : "/" !== e.charAt(e.length - 1) && (e += "/"),
            t(e, n)
          );
        };
      }
      function D(t, e, n) {
        var r = t._modulesNamespaceMap[n];
        return r;
      }
      var z = {
        Store: p,
        install: C,
        version: "2.5.0",
        mapState: L,
        mapMutations: R,
        mapGetters: P,
        mapActions: I,
        createNamespacedHelpers: O,
      };
      e["ZP"] = z;
    },
    7218: function (t, e, n) {
      "use strict";
      function r(t, e) {
        return function () {
          return t.apply(e, arguments);
        };
      }
      const { toString: i } = Object.prototype,
        { getPrototypeOf: a } = Object,
        o = ((t) => (e) => {
          const n = i.call(e);
          return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
        })(Object.create(null)),
        s = (t) => ((t = t.toLowerCase()), (e) => o(e) === t),
        c = (t) => (e) => typeof e === t,
        { isArray: l } = Array,
        u = c("undefined");
      function h(t) {
        return (
          null !== t &&
          !u(t) &&
          null !== t.constructor &&
          !u(t.constructor) &&
          m(t.constructor.isBuffer) &&
          t.constructor.isBuffer(t)
        );
      }
      const d = s("ArrayBuffer");
      function f(t) {
        let e;
        return (
          (e =
            "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView
              ? ArrayBuffer.isView(t)
              : t && t.buffer && d(t.buffer)),
          e
        );
      }
      const p = c("string"),
        m = c("function"),
        g = c("number"),
        v = (t) => null !== t && "object" === typeof t,
        y = (t) => !0 === t || !1 === t,
        b = (t) => {
          if ("object" !== o(t)) return !1;
          const e = a(t);
          return (
            (null === e ||
              e === Object.prototype ||
              null === Object.getPrototypeOf(e)) &&
            !(Symbol.toStringTag in t) &&
            !(Symbol.iterator in t)
          );
        },
        x = s("Date"),
        _ = s("File"),
        w = s("Blob"),
        S = s("FileList"),
        M = (t) => v(t) && m(t.pipe),
        T = (t) => {
          const e = "[object FormData]";
          return (
            t &&
            (("function" === typeof FormData && t instanceof FormData) ||
              i.call(t) === e ||
              (m(t.toString) && t.toString() === e))
          );
        },
        E = s("URLSearchParams"),
        A = (t) =>
          t.trim
            ? t.trim()
            : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function C(t, e, { allOwnKeys: n = !1 } = {}) {
        if (null === t || "undefined" === typeof t) return;
        let r, i;
        if (("object" !== typeof t && (t = [t]), l(t)))
          for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
        else {
          const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            a = i.length;
          let o;
          for (r = 0; r < a; r++) (o = i[r]), e.call(null, t[o], o, t);
        }
      }
      function L(t, e) {
        e = e.toLowerCase();
        const n = Object.keys(t);
        let r,
          i = n.length;
        while (i-- > 0) if (((r = n[i]), e === r.toLowerCase())) return r;
        return null;
      }
      const R = (() =>
          "undefined" !== typeof globalThis
            ? globalThis
            : "undefined" !== typeof self
            ? self
            : "undefined" !== typeof window
            ? window
            : n.g)(),
        P = (t) => !u(t) && t !== R;
      function I() {
        const { caseless: t } = (P(this) && this) || {},
          e = {},
          n = (n, r) => {
            const i = (t && L(e, r)) || r;
            b(e[i]) && b(n)
              ? (e[i] = I(e[i], n))
              : b(n)
              ? (e[i] = I({}, n))
              : l(n)
              ? (e[i] = n.slice())
              : (e[i] = n);
          };
        for (let r = 0, i = arguments.length; r < i; r++)
          arguments[r] && C(arguments[r], n);
        return e;
      }
      const O = (t, e, n, { allOwnKeys: i } = {}) => (
          C(
            e,
            (e, i) => {
              n && m(e) ? (t[i] = r(e, n)) : (t[i] = e);
            },
            { allOwnKeys: i }
          ),
          t
        ),
        k = (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
        N = (t, e, n, r) => {
          (t.prototype = Object.create(e.prototype, r)),
            (t.prototype.constructor = t),
            Object.defineProperty(t, "super", { value: e.prototype }),
            n && Object.assign(t.prototype, n);
        },
        D = (t, e, n, r) => {
          let i, o, s;
          const c = {};
          if (((e = e || {}), null == t)) return e;
          do {
            (i = Object.getOwnPropertyNames(t)), (o = i.length);
            while (o-- > 0)
              (s = i[o]),
                (r && !r(s, t, e)) || c[s] || ((e[s] = t[s]), (c[s] = !0));
            t = !1 !== n && a(t);
          } while (t && (!n || n(t, e)) && t !== Object.prototype);
          return e;
        },
        z = (t, e, n) => {
          (t = String(t)),
            (void 0 === n || n > t.length) && (n = t.length),
            (n -= e.length);
          const r = t.indexOf(e, n);
          return -1 !== r && r === n;
        },
        F = (t) => {
          if (!t) return null;
          if (l(t)) return t;
          let e = t.length;
          if (!g(e)) return null;
          const n = new Array(e);
          while (e-- > 0) n[e] = t[e];
          return n;
        },
        U = (
          (t) => (e) =>
            t && e instanceof t
        )("undefined" !== typeof Uint8Array && a(Uint8Array)),
        B = (t, e) => {
          const n = t && t[Symbol.iterator],
            r = n.call(t);
          let i;
          while ((i = r.next()) && !i.done) {
            const n = i.value;
            e.call(t, n[0], n[1]);
          }
        },
        j = (t, e) => {
          let n;
          const r = [];
          while (null !== (n = t.exec(e))) r.push(n);
          return r;
        },
        H = s("HTMLFormElement"),
        V = (t) =>
          t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, n) {
            return e.toUpperCase() + n;
          }),
        G = (
          ({ hasOwnProperty: t }) =>
          (e, n) =>
            t.call(e, n)
        )(Object.prototype),
        W = s("RegExp"),
        q = (t, e) => {
          const n = Object.getOwnPropertyDescriptors(t),
            r = {};
          C(n, (n, i) => {
            !1 !== e(n, i, t) && (r[i] = n);
          }),
            Object.defineProperties(t, r);
        },
        X = (t) => {
          q(t, (e, n) => {
            if (m(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
              return !1;
            const r = t[n];
            m(r) &&
              ((e.enumerable = !1),
              "writable" in e
                ? (e.writable = !1)
                : e.set ||
                  (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'");
                  }));
          });
        },
        $ = (t, e) => {
          const n = {},
            r = (t) => {
              t.forEach((t) => {
                n[t] = !0;
              });
            };
          return l(t) ? r(t) : r(String(t).split(e)), n;
        },
        Y = () => {},
        J = (t, e) => ((t = +t), Number.isFinite(t) ? t : e),
        K = "abcdefghijklmnopqrstuvwxyz",
        Z = "0123456789",
        Q = { DIGIT: Z, ALPHA: K, ALPHA_DIGIT: K + K.toUpperCase() + Z },
        tt = (t = 16, e = Q.ALPHA_DIGIT) => {
          let n = "";
          const { length: r } = e;
          while (t--) n += e[(Math.random() * r) | 0];
          return n;
        };
      function et(t) {
        return !!(
          t &&
          m(t.append) &&
          "FormData" === t[Symbol.toStringTag] &&
          t[Symbol.iterator]
        );
      }
      const nt = (t) => {
        const e = new Array(10),
          n = (t, r) => {
            if (v(t)) {
              if (e.indexOf(t) >= 0) return;
              if (!("toJSON" in t)) {
                e[r] = t;
                const i = l(t) ? [] : {};
                return (
                  C(t, (t, e) => {
                    const a = n(t, r + 1);
                    !u(a) && (i[e] = a);
                  }),
                  (e[r] = void 0),
                  i
                );
              }
            }
            return t;
          };
        return n(t, 0);
      };
      var rt = {
        isArray: l,
        isArrayBuffer: d,
        isBuffer: h,
        isFormData: T,
        isArrayBufferView: f,
        isString: p,
        isNumber: g,
        isBoolean: y,
        isObject: v,
        isPlainObject: b,
        isUndefined: u,
        isDate: x,
        isFile: _,
        isBlob: w,
        isRegExp: W,
        isFunction: m,
        isStream: M,
        isURLSearchParams: E,
        isTypedArray: U,
        isFileList: S,
        forEach: C,
        merge: I,
        extend: O,
        trim: A,
        stripBOM: k,
        inherits: N,
        toFlatObject: D,
        kindOf: o,
        kindOfTest: s,
        endsWith: z,
        toArray: F,
        forEachEntry: B,
        matchAll: j,
        isHTMLForm: H,
        hasOwnProperty: G,
        hasOwnProp: G,
        reduceDescriptors: q,
        freezeMethods: X,
        toObjectSet: $,
        toCamelCase: V,
        noop: Y,
        toFiniteNumber: J,
        findKey: L,
        global: R,
        isContextDefined: P,
        ALPHABET: Q,
        generateString: tt,
        isSpecCompliantForm: et,
        toJSONObject: nt,
      };
      function it(t, e, n, r, i) {
        Error.call(this),
          Error.captureStackTrace
            ? Error.captureStackTrace(this, this.constructor)
            : (this.stack = new Error().stack),
          (this.message = t),
          (this.name = "AxiosError"),
          e && (this.code = e),
          n && (this.config = n),
          r && (this.request = r),
          i && (this.response = i);
      }
      rt.inherits(it, Error, {
        toJSON: function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: rt.toJSONObject(this.config),
            code: this.code,
            status:
              this.response && this.response.status
                ? this.response.status
                : null,
          };
        },
      });
      const at = it.prototype,
        ot = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL",
      ].forEach((t) => {
        ot[t] = { value: t };
      }),
        Object.defineProperties(it, ot),
        Object.defineProperty(at, "isAxiosError", { value: !0 }),
        (it.from = (t, e, n, r, i, a) => {
          const o = Object.create(at);
          return (
            rt.toFlatObject(
              t,
              o,
              function (t) {
                return t !== Error.prototype;
              },
              (t) => "isAxiosError" !== t
            ),
            it.call(o, t.message, e, n, r, i),
            (o.cause = t),
            (o.name = t.name),
            a && Object.assign(o, a),
            o
          );
        });
      var st = null;
      function ct(t) {
        return rt.isPlainObject(t) || rt.isArray(t);
      }
      function lt(t) {
        return rt.endsWith(t, "[]") ? t.slice(0, -2) : t;
      }
      function ut(t, e, n) {
        return t
          ? t
              .concat(e)
              .map(function (t, e) {
                return (t = lt(t)), !n && e ? "[" + t + "]" : t;
              })
              .join(n ? "." : "")
          : e;
      }
      function ht(t) {
        return rt.isArray(t) && !t.some(ct);
      }
      const dt = rt.toFlatObject(rt, {}, null, function (t) {
        return /^is[A-Z]/.test(t);
      });
      function ft(t, e, n) {
        if (!rt.isObject(t)) throw new TypeError("target must be an object");
        (e = e || new FormData()),
          (n = rt.toFlatObject(
            n,
            { metaTokens: !0, dots: !1, indexes: !1 },
            !1,
            function (t, e) {
              return !rt.isUndefined(e[t]);
            }
          ));
        const r = n.metaTokens,
          i = n.visitor || u,
          a = n.dots,
          o = n.indexes,
          s = n.Blob || ("undefined" !== typeof Blob && Blob),
          c = s && rt.isSpecCompliantForm(e);
        if (!rt.isFunction(i))
          throw new TypeError("visitor must be a function");
        function l(t) {
          if (null === t) return "";
          if (rt.isDate(t)) return t.toISOString();
          if (!c && rt.isBlob(t))
            throw new it("Blob is not supported. Use a Buffer instead.");
          return rt.isArrayBuffer(t) || rt.isTypedArray(t)
            ? c && "function" === typeof Blob
              ? new Blob([t])
              : Buffer.from(t)
            : t;
        }
        function u(t, n, i) {
          let s = t;
          if (t && !i && "object" === typeof t)
            if (rt.endsWith(n, "{}"))
              (n = r ? n : n.slice(0, -2)), (t = JSON.stringify(t));
            else if (
              (rt.isArray(t) && ht(t)) ||
              ((rt.isFileList(t) || rt.endsWith(n, "[]")) &&
                (s = rt.toArray(t)))
            )
              return (
                (n = lt(n)),
                s.forEach(function (t, r) {
                  !rt.isUndefined(t) &&
                    null !== t &&
                    e.append(
                      !0 === o ? ut([n], r, a) : null === o ? n : n + "[]",
                      l(t)
                    );
                }),
                !1
              );
          return !!ct(t) || (e.append(ut(i, n, a), l(t)), !1);
        }
        const h = [],
          d = Object.assign(dt, {
            defaultVisitor: u,
            convertValue: l,
            isVisitable: ct,
          });
        function f(t, n) {
          if (!rt.isUndefined(t)) {
            if (-1 !== h.indexOf(t))
              throw Error("Circular reference detected in " + n.join("."));
            h.push(t),
              rt.forEach(t, function (t, r) {
                const a =
                  !(rt.isUndefined(t) || null === t) &&
                  i.call(e, t, rt.isString(r) ? r.trim() : r, n, d);
                !0 === a && f(t, n ? n.concat(r) : [r]);
              }),
              h.pop();
          }
        }
        if (!rt.isObject(t)) throw new TypeError("data must be an object");
        return f(t), e;
      }
      function pt(t) {
        const e = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0",
        };
        return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
          return e[t];
        });
      }
      function mt(t, e) {
        (this._pairs = []), t && ft(t, this, e);
      }
      const gt = mt.prototype;
      function vt(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      function yt(t, e, n) {
        if (!e) return t;
        const r = (n && n.encode) || vt,
          i = n && n.serialize;
        let a;
        if (
          ((a = i
            ? i(e, n)
            : rt.isURLSearchParams(e)
            ? e.toString()
            : new mt(e, n).toString(r)),
          a)
        ) {
          const e = t.indexOf("#");
          -1 !== e && (t = t.slice(0, e)),
            (t += (-1 === t.indexOf("?") ? "?" : "&") + a);
        }
        return t;
      }
      (gt.append = function (t, e) {
        this._pairs.push([t, e]);
      }),
        (gt.toString = function (t) {
          const e = t
            ? function (e) {
                return t.call(this, e, pt);
              }
            : pt;
          return this._pairs
            .map(function (t) {
              return e(t[0]) + "=" + e(t[1]);
            }, "")
            .join("&");
        });
      class bt {
        constructor() {
          this.handlers = [];
        }
        use(t, e, n) {
          return (
            this.handlers.push({
              fulfilled: t,
              rejected: e,
              synchronous: !!n && n.synchronous,
              runWhen: n ? n.runWhen : null,
            }),
            this.handlers.length - 1
          );
        }
        eject(t) {
          this.handlers[t] && (this.handlers[t] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(t) {
          rt.forEach(this.handlers, function (e) {
            null !== e && t(e);
          });
        }
      }
      var xt = bt,
        _t = {
          silentJSONParsing: !0,
          forcedJSONParsing: !0,
          clarifyTimeoutError: !1,
        },
        wt = "undefined" !== typeof URLSearchParams ? URLSearchParams : mt,
        St = FormData;
      const Mt = (() => {
          let t;
          return (
            ("undefined" === typeof navigator ||
              ("ReactNative" !== (t = navigator.product) &&
                "NativeScript" !== t &&
                "NS" !== t)) &&
            "undefined" !== typeof window &&
            "undefined" !== typeof document
          );
        })(),
        Tt = (() =>
          "undefined" !== typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          "function" === typeof self.importScripts)();
      var Et = {
        isBrowser: !0,
        classes: { URLSearchParams: wt, FormData: St, Blob: Blob },
        isStandardBrowserEnv: Mt,
        isStandardBrowserWebWorkerEnv: Tt,
        protocols: ["http", "https", "file", "blob", "url", "data"],
      };
      function At(t, e) {
        return ft(
          t,
          new Et.classes.URLSearchParams(),
          Object.assign(
            {
              visitor: function (t, e, n, r) {
                return Et.isNode && rt.isBuffer(t)
                  ? (this.append(e, t.toString("base64")), !1)
                  : r.defaultVisitor.apply(this, arguments);
              },
            },
            e
          )
        );
      }
      function Ct(t) {
        return rt
          .matchAll(/\w+|\[(\w*)]/g, t)
          .map((t) => ("[]" === t[0] ? "" : t[1] || t[0]));
      }
      function Lt(t) {
        const e = {},
          n = Object.keys(t);
        let r;
        const i = n.length;
        let a;
        for (r = 0; r < i; r++) (a = n[r]), (e[a] = t[a]);
        return e;
      }
      function Rt(t) {
        function e(t, n, r, i) {
          let a = t[i++];
          const o = Number.isFinite(+a),
            s = i >= t.length;
          if (((a = !a && rt.isArray(r) ? r.length : a), s))
            return rt.hasOwnProp(r, a) ? (r[a] = [r[a], n]) : (r[a] = n), !o;
          (r[a] && rt.isObject(r[a])) || (r[a] = []);
          const c = e(t, n, r[a], i);
          return c && rt.isArray(r[a]) && (r[a] = Lt(r[a])), !o;
        }
        if (rt.isFormData(t) && rt.isFunction(t.entries)) {
          const n = {};
          return (
            rt.forEachEntry(t, (t, r) => {
              e(Ct(t), r, n, 0);
            }),
            n
          );
        }
        return null;
      }
      const Pt = { "Content-Type": void 0 };
      function It(t, e, n) {
        if (rt.isString(t))
          try {
            return (e || JSON.parse)(t), rt.trim(t);
          } catch (r) {
            if ("SyntaxError" !== r.name) throw r;
          }
        return (n || JSON.stringify)(t);
      }
      const Ot = {
        transitional: _t,
        adapter: ["xhr", "http"],
        transformRequest: [
          function (t, e) {
            const n = e.getContentType() || "",
              r = n.indexOf("application/json") > -1,
              i = rt.isObject(t);
            i && rt.isHTMLForm(t) && (t = new FormData(t));
            const a = rt.isFormData(t);
            if (a) return r && r ? JSON.stringify(Rt(t)) : t;
            if (
              rt.isArrayBuffer(t) ||
              rt.isBuffer(t) ||
              rt.isStream(t) ||
              rt.isFile(t) ||
              rt.isBlob(t)
            )
              return t;
            if (rt.isArrayBufferView(t)) return t.buffer;
            if (rt.isURLSearchParams(t))
              return (
                e.setContentType(
                  "application/x-www-form-urlencoded;charset=utf-8",
                  !1
                ),
                t.toString()
              );
            let o;
            if (i) {
              if (n.indexOf("application/x-www-form-urlencoded") > -1)
                return At(t, this.formSerializer).toString();
              if (
                (o = rt.isFileList(t)) ||
                n.indexOf("multipart/form-data") > -1
              ) {
                const e = this.env && this.env.FormData;
                return ft(
                  o ? { "files[]": t } : t,
                  e && new e(),
                  this.formSerializer
                );
              }
            }
            return i || r
              ? (e.setContentType("application/json", !1), It(t))
              : t;
          },
        ],
        transformResponse: [
          function (t) {
            const e = this.transitional || Ot.transitional,
              n = e && e.forcedJSONParsing,
              r = "json" === this.responseType;
            if (t && rt.isString(t) && ((n && !this.responseType) || r)) {
              const n = e && e.silentJSONParsing,
                a = !n && r;
              try {
                return JSON.parse(t);
              } catch (i) {
                if (a) {
                  if ("SyntaxError" === i.name)
                    throw it.from(
                      i,
                      it.ERR_BAD_RESPONSE,
                      this,
                      null,
                      this.response
                    );
                  throw i;
                }
              }
            }
            return t;
          },
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: { FormData: Et.classes.FormData, Blob: Et.classes.Blob },
        validateStatus: function (t) {
          return t >= 200 && t < 300;
        },
        headers: { common: { Accept: "application/json, text/plain, */*" } },
      };
      rt.forEach(["delete", "get", "head"], function (t) {
        Ot.headers[t] = {};
      }),
        rt.forEach(["post", "put", "patch"], function (t) {
          Ot.headers[t] = rt.merge(Pt);
        });
      var kt = Ot;
      const Nt = rt.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ]);
      var Dt = (t) => {
        const e = {};
        let n, r, i;
        return (
          t &&
            t.split("\n").forEach(function (t) {
              (i = t.indexOf(":")),
                (n = t.substring(0, i).trim().toLowerCase()),
                (r = t.substring(i + 1).trim()),
                !n ||
                  (e[n] && Nt[n]) ||
                  ("set-cookie" === n
                    ? e[n]
                      ? e[n].push(r)
                      : (e[n] = [r])
                    : (e[n] = e[n] ? e[n] + ", " + r : r));
            }),
          e
        );
      };
      const zt = Symbol("internals");
      function Ft(t) {
        return t && String(t).trim().toLowerCase();
      }
      function Ut(t) {
        return !1 === t || null == t
          ? t
          : rt.isArray(t)
          ? t.map(Ut)
          : String(t);
      }
      function Bt(t) {
        const e = Object.create(null),
          n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let r;
        while ((r = n.exec(t))) e[r[1]] = r[2];
        return e;
      }
      function jt(t) {
        return /^[-_a-zA-Z]+$/.test(t.trim());
      }
      function Ht(t, e, n, r) {
        return rt.isFunction(r)
          ? r.call(this, e, n)
          : rt.isString(e)
          ? rt.isString(r)
            ? -1 !== e.indexOf(r)
            : rt.isRegExp(r)
            ? r.test(e)
            : void 0
          : void 0;
      }
      function Vt(t) {
        return t
          .trim()
          .toLowerCase()
          .replace(/([a-z\d])(\w*)/g, (t, e, n) => e.toUpperCase() + n);
      }
      function Gt(t, e) {
        const n = rt.toCamelCase(" " + e);
        ["get", "set", "has"].forEach((r) => {
          Object.defineProperty(t, r + n, {
            value: function (t, n, i) {
              return this[r].call(this, e, t, n, i);
            },
            configurable: !0,
          });
        });
      }
      class Wt {
        constructor(t) {
          t && this.set(t);
        }
        set(t, e, n) {
          const r = this;
          function i(t, e, n) {
            const i = Ft(e);
            if (!i) throw new Error("header name must be a non-empty string");
            const a = rt.findKey(r, i);
            (!a ||
              void 0 === r[a] ||
              !0 === n ||
              (void 0 === n && !1 !== r[a])) &&
              (r[a || e] = Ut(t));
          }
          const a = (t, e) => rt.forEach(t, (t, n) => i(t, n, e));
          return (
            rt.isPlainObject(t) || t instanceof this.constructor
              ? a(t, e)
              : rt.isString(t) && (t = t.trim()) && !jt(t)
              ? a(Dt(t), e)
              : null != t && i(e, t, n),
            this
          );
        }
        get(t, e) {
          if (((t = Ft(t)), t)) {
            const n = rt.findKey(this, t);
            if (n) {
              const t = this[n];
              if (!e) return t;
              if (!0 === e) return Bt(t);
              if (rt.isFunction(e)) return e.call(this, t, n);
              if (rt.isRegExp(e)) return e.exec(t);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(t, e) {
          if (((t = Ft(t)), t)) {
            const n = rt.findKey(this, t);
            return !(
              !n ||
              void 0 === this[n] ||
              (e && !Ht(this, this[n], n, e))
            );
          }
          return !1;
        }
        delete(t, e) {
          const n = this;
          let r = !1;
          function i(t) {
            if (((t = Ft(t)), t)) {
              const i = rt.findKey(n, t);
              !i || (e && !Ht(n, n[i], i, e)) || (delete n[i], (r = !0));
            }
          }
          return rt.isArray(t) ? t.forEach(i) : i(t), r;
        }
        clear(t) {
          const e = Object.keys(this);
          let n = e.length,
            r = !1;
          while (n--) {
            const i = e[n];
            (t && !Ht(this, this[i], i, t)) || (delete this[i], (r = !0));
          }
          return r;
        }
        normalize(t) {
          const e = this,
            n = {};
          return (
            rt.forEach(this, (r, i) => {
              const a = rt.findKey(n, i);
              if (a) return (e[a] = Ut(r)), void delete e[i];
              const o = t ? Vt(i) : String(i).trim();
              o !== i && delete e[i], (e[o] = Ut(r)), (n[o] = !0);
            }),
            this
          );
        }
        concat(...t) {
          return this.constructor.concat(this, ...t);
        }
        toJSON(t) {
          const e = Object.create(null);
          return (
            rt.forEach(this, (n, r) => {
              null != n &&
                !1 !== n &&
                (e[r] = t && rt.isArray(n) ? n.join(", ") : n);
            }),
            e
          );
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON())
            .map(([t, e]) => t + ": " + e)
            .join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(t) {
          return t instanceof this ? t : new this(t);
        }
        static concat(t, ...e) {
          const n = new this(t);
          return e.forEach((t) => n.set(t)), n;
        }
        static accessor(t) {
          const e = (this[zt] = this[zt] = { accessors: {} }),
            n = e.accessors,
            r = this.prototype;
          function i(t) {
            const e = Ft(t);
            n[e] || (Gt(r, t), (n[e] = !0));
          }
          return rt.isArray(t) ? t.forEach(i) : i(t), this;
        }
      }
      Wt.accessor([
        "Content-Type",
        "Content-Length",
        "Accept",
        "Accept-Encoding",
        "User-Agent",
        "Authorization",
      ]),
        rt.freezeMethods(Wt.prototype),
        rt.freezeMethods(Wt);
      var qt = Wt;
      function Xt(t, e) {
        const n = this || kt,
          r = e || n,
          i = qt.from(r.headers);
        let a = r.data;
        return (
          rt.forEach(t, function (t) {
            a = t.call(n, a, i.normalize(), e ? e.status : void 0);
          }),
          i.normalize(),
          a
        );
      }
      function $t(t) {
        return !(!t || !t.__CANCEL__);
      }
      function Yt(t, e, n) {
        it.call(this, null == t ? "canceled" : t, it.ERR_CANCELED, e, n),
          (this.name = "CanceledError");
      }
      function Jt(t, e, n) {
        const r = n.config.validateStatus;
        n.status && r && !r(n.status)
          ? e(
              new it(
                "Request failed with status code " + n.status,
                [it.ERR_BAD_REQUEST, it.ERR_BAD_RESPONSE][
                  Math.floor(n.status / 100) - 4
                ],
                n.config,
                n.request,
                n
              )
            )
          : t(n);
      }
      rt.inherits(Yt, it, { __CANCEL__: !0 });
      var Kt = Et.isStandardBrowserEnv
        ? (function () {
            return {
              write: function (t, e, n, r, i, a) {
                const o = [];
                o.push(t + "=" + encodeURIComponent(e)),
                  rt.isNumber(n) &&
                    o.push("expires=" + new Date(n).toGMTString()),
                  rt.isString(r) && o.push("path=" + r),
                  rt.isString(i) && o.push("domain=" + i),
                  !0 === a && o.push("secure"),
                  (document.cookie = o.join("; "));
              },
              read: function (t) {
                const e = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
                );
                return e ? decodeURIComponent(e[3]) : null;
              },
              remove: function (t) {
                this.write(t, "", Date.now() - 864e5);
              },
            };
          })()
        : (function () {
            return {
              write: function () {},
              read: function () {
                return null;
              },
              remove: function () {},
            };
          })();
      function Zt(t) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
      }
      function Qt(t, e) {
        return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
      }
      function te(t, e) {
        return t && !Zt(e) ? Qt(t, e) : e;
      }
      var ee = Et.isStandardBrowserEnv
        ? (function () {
            const t = /(msie|trident)/i.test(navigator.userAgent),
              e = document.createElement("a");
            let n;
            function r(n) {
              let r = n;
              return (
                t && (e.setAttribute("href", r), (r = e.href)),
                e.setAttribute("href", r),
                {
                  href: e.href,
                  protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                  host: e.host,
                  search: e.search ? e.search.replace(/^\?/, "") : "",
                  hash: e.hash ? e.hash.replace(/^#/, "") : "",
                  hostname: e.hostname,
                  port: e.port,
                  pathname:
                    "/" === e.pathname.charAt(0)
                      ? e.pathname
                      : "/" + e.pathname,
                }
              );
            }
            return (
              (n = r(window.location.href)),
              function (t) {
                const e = rt.isString(t) ? r(t) : t;
                return e.protocol === n.protocol && e.host === n.host;
              }
            );
          })()
        : (function () {
            return function () {
              return !0;
            };
          })();
      function ne(t) {
        const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
        return (e && e[1]) || "";
      }
      function re(t, e) {
        t = t || 10;
        const n = new Array(t),
          r = new Array(t);
        let i,
          a = 0,
          o = 0;
        return (
          (e = void 0 !== e ? e : 1e3),
          function (s) {
            const c = Date.now(),
              l = r[o];
            i || (i = c), (n[a] = s), (r[a] = c);
            let u = o,
              h = 0;
            while (u !== a) (h += n[u++]), (u %= t);
            if (((a = (a + 1) % t), a === o && (o = (o + 1) % t), c - i < e))
              return;
            const d = l && c - l;
            return d ? Math.round((1e3 * h) / d) : void 0;
          }
        );
      }
      function ie(t, e) {
        let n = 0;
        const r = re(50, 250);
        return (i) => {
          const a = i.loaded,
            o = i.lengthComputable ? i.total : void 0,
            s = a - n,
            c = r(s),
            l = a <= o;
          n = a;
          const u = {
            loaded: a,
            total: o,
            progress: o ? a / o : void 0,
            bytes: s,
            rate: c || void 0,
            estimated: c && o && l ? (o - a) / c : void 0,
            event: i,
          };
          (u[e ? "download" : "upload"] = !0), t(u);
        };
      }
      const ae = "undefined" !== typeof XMLHttpRequest;
      var oe =
        ae &&
        function (t) {
          return new Promise(function (e, n) {
            let r = t.data;
            const i = qt.from(t.headers).normalize(),
              a = t.responseType;
            let o;
            function s() {
              t.cancelToken && t.cancelToken.unsubscribe(o),
                t.signal && t.signal.removeEventListener("abort", o);
            }
            rt.isFormData(r) &&
              (Et.isStandardBrowserEnv || Et.isStandardBrowserWebWorkerEnv) &&
              i.setContentType(!1);
            let c = new XMLHttpRequest();
            if (t.auth) {
              const e = t.auth.username || "",
                n = t.auth.password
                  ? unescape(encodeURIComponent(t.auth.password))
                  : "";
              i.set("Authorization", "Basic " + btoa(e + ":" + n));
            }
            const l = te(t.baseURL, t.url);
            function u() {
              if (!c) return;
              const r = qt.from(
                  "getAllResponseHeaders" in c && c.getAllResponseHeaders()
                ),
                i =
                  a && "text" !== a && "json" !== a
                    ? c.response
                    : c.responseText,
                o = {
                  data: i,
                  status: c.status,
                  statusText: c.statusText,
                  headers: r,
                  config: t,
                  request: c,
                };
              Jt(
                function (t) {
                  e(t), s();
                },
                function (t) {
                  n(t), s();
                },
                o
              ),
                (c = null);
            }
            if (
              (c.open(
                t.method.toUpperCase(),
                yt(l, t.params, t.paramsSerializer),
                !0
              ),
              (c.timeout = t.timeout),
              "onloadend" in c
                ? (c.onloadend = u)
                : (c.onreadystatechange = function () {
                    c &&
                      4 === c.readyState &&
                      (0 !== c.status ||
                        (c.responseURL &&
                          0 === c.responseURL.indexOf("file:"))) &&
                      setTimeout(u);
                  }),
              (c.onabort = function () {
                c &&
                  (n(new it("Request aborted", it.ECONNABORTED, t, c)),
                  (c = null));
              }),
              (c.onerror = function () {
                n(new it("Network Error", it.ERR_NETWORK, t, c)), (c = null);
              }),
              (c.ontimeout = function () {
                let e = t.timeout
                  ? "timeout of " + t.timeout + "ms exceeded"
                  : "timeout exceeded";
                const r = t.transitional || _t;
                t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                  n(
                    new it(
                      e,
                      r.clarifyTimeoutError ? it.ETIMEDOUT : it.ECONNABORTED,
                      t,
                      c
                    )
                  ),
                  (c = null);
              }),
              Et.isStandardBrowserEnv)
            ) {
              const e =
                (t.withCredentials || ee(l)) &&
                t.xsrfCookieName &&
                Kt.read(t.xsrfCookieName);
              e && i.set(t.xsrfHeaderName, e);
            }
            void 0 === r && i.setContentType(null),
              "setRequestHeader" in c &&
                rt.forEach(i.toJSON(), function (t, e) {
                  c.setRequestHeader(e, t);
                }),
              rt.isUndefined(t.withCredentials) ||
                (c.withCredentials = !!t.withCredentials),
              a && "json" !== a && (c.responseType = t.responseType),
              "function" === typeof t.onDownloadProgress &&
                c.addEventListener("progress", ie(t.onDownloadProgress, !0)),
              "function" === typeof t.onUploadProgress &&
                c.upload &&
                c.upload.addEventListener("progress", ie(t.onUploadProgress)),
              (t.cancelToken || t.signal) &&
                ((o = (e) => {
                  c &&
                    (n(!e || e.type ? new Yt(null, t, c) : e),
                    c.abort(),
                    (c = null));
                }),
                t.cancelToken && t.cancelToken.subscribe(o),
                t.signal &&
                  (t.signal.aborted
                    ? o()
                    : t.signal.addEventListener("abort", o)));
            const h = ne(l);
            h && -1 === Et.protocols.indexOf(h)
              ? n(
                  new it(
                    "Unsupported protocol " + h + ":",
                    it.ERR_BAD_REQUEST,
                    t
                  )
                )
              : c.send(r || null);
          });
        };
      const se = { http: st, xhr: oe };
      rt.forEach(se, (t, e) => {
        if (t) {
          try {
            Object.defineProperty(t, "name", { value: e });
          } catch (n) {}
          Object.defineProperty(t, "adapterName", { value: e });
        }
      });
      var ce = {
        getAdapter: (t) => {
          t = rt.isArray(t) ? t : [t];
          const { length: e } = t;
          let n, r;
          for (let i = 0; i < e; i++)
            if (((n = t[i]), (r = rt.isString(n) ? se[n.toLowerCase()] : n)))
              break;
          if (!r) {
            if (!1 === r)
              throw new it(
                `Adapter ${n} is not supported by the environment`,
                "ERR_NOT_SUPPORT"
              );
            throw new Error(
              rt.hasOwnProp(se, n)
                ? `Adapter '${n}' is not available in the build`
                : `Unknown adapter '${n}'`
            );
          }
          if (!rt.isFunction(r))
            throw new TypeError("adapter is not a function");
          return r;
        },
        adapters: se,
      };
      function le(t) {
        if (
          (t.cancelToken && t.cancelToken.throwIfRequested(),
          t.signal && t.signal.aborted)
        )
          throw new Yt(null, t);
      }
      function ue(t) {
        le(t),
          (t.headers = qt.from(t.headers)),
          (t.data = Xt.call(t, t.transformRequest)),
          -1 !== ["post", "put", "patch"].indexOf(t.method) &&
            t.headers.setContentType("application/x-www-form-urlencoded", !1);
        const e = ce.getAdapter(t.adapter || kt.adapter);
        return e(t).then(
          function (e) {
            return (
              le(t),
              (e.data = Xt.call(t, t.transformResponse, e)),
              (e.headers = qt.from(e.headers)),
              e
            );
          },
          function (e) {
            return (
              $t(e) ||
                (le(t),
                e &&
                  e.response &&
                  ((e.response.data = Xt.call(
                    t,
                    t.transformResponse,
                    e.response
                  )),
                  (e.response.headers = qt.from(e.response.headers)))),
              Promise.reject(e)
            );
          }
        );
      }
      const he = (t) => (t instanceof qt ? t.toJSON() : t);
      function de(t, e) {
        e = e || {};
        const n = {};
        function r(t, e, n) {
          return rt.isPlainObject(t) && rt.isPlainObject(e)
            ? rt.merge.call({ caseless: n }, t, e)
            : rt.isPlainObject(e)
            ? rt.merge({}, e)
            : rt.isArray(e)
            ? e.slice()
            : e;
        }
        function i(t, e, n) {
          return rt.isUndefined(e)
            ? rt.isUndefined(t)
              ? void 0
              : r(void 0, t, n)
            : r(t, e, n);
        }
        function a(t, e) {
          if (!rt.isUndefined(e)) return r(void 0, e);
        }
        function o(t, e) {
          return rt.isUndefined(e)
            ? rt.isUndefined(t)
              ? void 0
              : r(void 0, t)
            : r(void 0, e);
        }
        function s(n, i, a) {
          return a in e ? r(n, i) : a in t ? r(void 0, n) : void 0;
        }
        const c = {
          url: a,
          method: a,
          data: a,
          baseURL: o,
          transformRequest: o,
          transformResponse: o,
          paramsSerializer: o,
          timeout: o,
          timeoutMessage: o,
          withCredentials: o,
          adapter: o,
          responseType: o,
          xsrfCookieName: o,
          xsrfHeaderName: o,
          onUploadProgress: o,
          onDownloadProgress: o,
          decompress: o,
          maxContentLength: o,
          maxBodyLength: o,
          beforeRedirect: o,
          transport: o,
          httpAgent: o,
          httpsAgent: o,
          cancelToken: o,
          socketPath: o,
          responseEncoding: o,
          validateStatus: s,
          headers: (t, e) => i(he(t), he(e), !0),
        };
        return (
          rt.forEach(Object.keys(t).concat(Object.keys(e)), function (r) {
            const a = c[r] || i,
              o = a(t[r], e[r], r);
            (rt.isUndefined(o) && a !== s) || (n[r] = o);
          }),
          n
        );
      }
      const fe = "1.3.2",
        pe = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        (t, e) => {
          pe[t] = function (n) {
            return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
          };
        }
      );
      const me = {};
      function ge(t, e, n) {
        if ("object" !== typeof t)
          throw new it("options must be an object", it.ERR_BAD_OPTION_VALUE);
        const r = Object.keys(t);
        let i = r.length;
        while (i-- > 0) {
          const a = r[i],
            o = e[a];
          if (o) {
            const e = t[a],
              n = void 0 === e || o(e, a, t);
            if (!0 !== n)
              throw new it(
                "option " + a + " must be " + n,
                it.ERR_BAD_OPTION_VALUE
              );
          } else if (!0 !== n)
            throw new it("Unknown option " + a, it.ERR_BAD_OPTION);
        }
      }
      pe.transitional = function (t, e, n) {
        function r(t, e) {
          return (
            "[Axios v" +
            fe +
            "] Transitional option '" +
            t +
            "'" +
            e +
            (n ? ". " + n : "")
          );
        }
        return (n, i, a) => {
          if (!1 === t)
            throw new it(
              r(i, " has been removed" + (e ? " in " + e : "")),
              it.ERR_DEPRECATED
            );
          return (
            e &&
              !me[i] &&
              ((me[i] = !0),
              console.warn(
                r(
                  i,
                  " has been deprecated since v" +
                    e +
                    " and will be removed in the near future"
                )
              )),
            !t || t(n, i, a)
          );
        };
      };
      var ve = { assertOptions: ge, validators: pe };
      const ye = ve.validators;
      class be {
        constructor(t) {
          (this.defaults = t),
            (this.interceptors = { request: new xt(), response: new xt() });
        }
        request(t, e) {
          "string" === typeof t ? ((e = e || {}), (e.url = t)) : (e = t || {}),
            (e = de(this.defaults, e));
          const { transitional: n, paramsSerializer: r, headers: i } = e;
          let a;
          void 0 !== n &&
            ve.assertOptions(
              n,
              {
                silentJSONParsing: ye.transitional(ye.boolean),
                forcedJSONParsing: ye.transitional(ye.boolean),
                clarifyTimeoutError: ye.transitional(ye.boolean),
              },
              !1
            ),
            void 0 !== r &&
              ve.assertOptions(
                r,
                { encode: ye.function, serialize: ye.function },
                !0
              ),
            (e.method = (
              e.method ||
              this.defaults.method ||
              "get"
            ).toLowerCase()),
            (a = i && rt.merge(i.common, i[e.method])),
            a &&
              rt.forEach(
                ["delete", "get", "head", "post", "put", "patch", "common"],
                (t) => {
                  delete i[t];
                }
              ),
            (e.headers = qt.concat(a, i));
          const o = [];
          let s = !0;
          this.interceptors.request.forEach(function (t) {
            ("function" === typeof t.runWhen && !1 === t.runWhen(e)) ||
              ((s = s && t.synchronous), o.unshift(t.fulfilled, t.rejected));
          });
          const c = [];
          let l;
          this.interceptors.response.forEach(function (t) {
            c.push(t.fulfilled, t.rejected);
          });
          let u,
            h = 0;
          if (!s) {
            const t = [ue.bind(this), void 0];
            t.unshift.apply(t, o),
              t.push.apply(t, c),
              (u = t.length),
              (l = Promise.resolve(e));
            while (h < u) l = l.then(t[h++], t[h++]);
            return l;
          }
          u = o.length;
          let d = e;
          h = 0;
          while (h < u) {
            const t = o[h++],
              e = o[h++];
            try {
              d = t(d);
            } catch (f) {
              e.call(this, f);
              break;
            }
          }
          try {
            l = ue.call(this, d);
          } catch (f) {
            return Promise.reject(f);
          }
          (h = 0), (u = c.length);
          while (h < u) l = l.then(c[h++], c[h++]);
          return l;
        }
        getUri(t) {
          t = de(this.defaults, t);
          const e = te(t.baseURL, t.url);
          return yt(e, t.params, t.paramsSerializer);
        }
      }
      rt.forEach(["delete", "get", "head", "options"], function (t) {
        be.prototype[t] = function (e, n) {
          return this.request(
            de(n || {}, { method: t, url: e, data: (n || {}).data })
          );
        };
      }),
        rt.forEach(["post", "put", "patch"], function (t) {
          function e(e) {
            return function (n, r, i) {
              return this.request(
                de(i || {}, {
                  method: t,
                  headers: e ? { "Content-Type": "multipart/form-data" } : {},
                  url: n,
                  data: r,
                })
              );
            };
          }
          (be.prototype[t] = e()), (be.prototype[t + "Form"] = e(!0));
        });
      var xe = be;
      class _e {
        constructor(t) {
          if ("function" !== typeof t)
            throw new TypeError("executor must be a function.");
          let e;
          this.promise = new Promise(function (t) {
            e = t;
          });
          const n = this;
          this.promise.then((t) => {
            if (!n._listeners) return;
            let e = n._listeners.length;
            while (e-- > 0) n._listeners[e](t);
            n._listeners = null;
          }),
            (this.promise.then = (t) => {
              let e;
              const r = new Promise((t) => {
                n.subscribe(t), (e = t);
              }).then(t);
              return (
                (r.cancel = function () {
                  n.unsubscribe(e);
                }),
                r
              );
            }),
            t(function (t, r, i) {
              n.reason || ((n.reason = new Yt(t, r, i)), e(n.reason));
            });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(t) {
          this.reason
            ? t(this.reason)
            : this._listeners
            ? this._listeners.push(t)
            : (this._listeners = [t]);
        }
        unsubscribe(t) {
          if (!this._listeners) return;
          const e = this._listeners.indexOf(t);
          -1 !== e && this._listeners.splice(e, 1);
        }
        static source() {
          let t;
          const e = new _e(function (e) {
            t = e;
          });
          return { token: e, cancel: t };
        }
      }
      var we = _e;
      function Se(t) {
        return function (e) {
          return t.apply(null, e);
        };
      }
      function Me(t) {
        return rt.isObject(t) && !0 === t.isAxiosError;
      }
      const Te = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511,
      };
      Object.entries(Te).forEach(([t, e]) => {
        Te[e] = t;
      });
      var Ee = Te;
      function Ae(t) {
        const e = new xe(t),
          n = r(xe.prototype.request, e);
        return (
          rt.extend(n, xe.prototype, e, { allOwnKeys: !0 }),
          rt.extend(n, e, null, { allOwnKeys: !0 }),
          (n.create = function (e) {
            return Ae(de(t, e));
          }),
          n
        );
      }
      const Ce = Ae(kt);
      (Ce.Axios = xe),
        (Ce.CanceledError = Yt),
        (Ce.CancelToken = we),
        (Ce.isCancel = $t),
        (Ce.VERSION = fe),
        (Ce.toFormData = ft),
        (Ce.AxiosError = it),
        (Ce.Cancel = Ce.CanceledError),
        (Ce.all = function (t) {
          return Promise.all(t);
        }),
        (Ce.spread = Se),
        (Ce.isAxiosError = Me),
        (Ce.mergeConfig = de),
        (Ce.AxiosHeaders = qt),
        (Ce.formToJSON = (t) => Rt(rt.isHTMLForm(t) ? new FormData(t) : t)),
        (Ce.HttpStatusCode = Ee),
        (Ce.default = Ce),
        (t.exports = Ce);
    },
    3494: function (t, e, n) {
      "use strict";
      function r(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function i(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? r(Object(n), !0).forEach(function (e) {
                l(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : r(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function a(t) {
        return (
          (a =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          a(t)
        );
      }
      function o(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      function s(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function c(t, e, n) {
        return (
          e && s(t.prototype, e),
          n && s(t, n),
          Object.defineProperty(t, "prototype", { writable: !1 }),
          t
        );
      }
      function l(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function u(t, e) {
        return f(t) || m(t, e) || g(t, e) || b();
      }
      function h(t) {
        return d(t) || p(t) || g(t) || y();
      }
      function d(t) {
        if (Array.isArray(t)) return v(t);
      }
      function f(t) {
        if (Array.isArray(t)) return t;
      }
      function p(t) {
        if (
          ("undefined" !== typeof Symbol && null != t[Symbol.iterator]) ||
          null != t["@@iterator"]
        )
          return Array.from(t);
      }
      function m(t, e) {
        var n =
          null == t
            ? null
            : ("undefined" !== typeof Symbol && t[Symbol.iterator]) ||
              t["@@iterator"];
        if (null != n) {
          var r,
            i,
            a = [],
            o = !0,
            s = !1;
          try {
            for (n = n.call(t); !(o = (r = n.next()).done); o = !0)
              if ((a.push(r.value), e && a.length === e)) break;
          } catch (c) {
            (s = !0), (i = c);
          } finally {
            try {
              o || null == n["return"] || n["return"]();
            } finally {
              if (s) throw i;
            }
          }
          return a;
        }
      }
      function g(t, e) {
        if (t) {
          if ("string" === typeof t) return v(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === n && t.constructor && (n = t.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(t)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? v(t, e)
              : void 0
          );
        }
      }
      function v(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function y() {
        throw new TypeError(
          "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      function b() {
        throw new TypeError(
          "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      n.d(e, {
        Qc: function () {
          return hr;
        },
        fL: function () {
          return fr;
        },
        qv: function () {
          return dr;
        },
        vI: function () {
          return ur;
        },
        vc: function () {
          return lr;
        },
      });
      var x = function () {},
        _ = {},
        w = {},
        S = null,
        M = { mark: x, measure: x };
      try {
        "undefined" !== typeof window && (_ = window),
          "undefined" !== typeof document && (w = document),
          "undefined" !== typeof MutationObserver && (S = MutationObserver),
          "undefined" !== typeof performance && (M = performance);
      } catch (pr) {}
      var T,
        E,
        A,
        C,
        L,
        R = _.navigator || {},
        P = R.userAgent,
        I = void 0 === P ? "" : P,
        O = _,
        k = w,
        N = S,
        D = M,
        z =
          (O.document,
          !!k.documentElement &&
            !!k.head &&
            "function" === typeof k.addEventListener &&
            "function" === typeof k.createElement),
        F = ~I.indexOf("MSIE") || ~I.indexOf("Trident/"),
        U = "___FONT_AWESOME___",
        B = 16,
        j = "fa",
        H = "svg-inline--fa",
        V = "data-fa-i2svg",
        G = "data-fa-pseudo-element",
        W = "data-fa-pseudo-element-pending",
        q = "data-prefix",
        X = "data-icon",
        $ = "fontawesome-i2svg",
        Y = "async",
        J = ["HTML", "HEAD", "STYLE", "SCRIPT"],
        K = (function () {
          try {
            return !0;
          } catch (pr) {
            return !1;
          }
        })(),
        Z = "classic",
        Q = "sharp",
        tt = [Z, Q];
      function et(t) {
        return new Proxy(t, {
          get: function (t, e) {
            return e in t ? t[e] : t[Z];
          },
        });
      }
      var nt = et(
          ((T = {}),
          l(T, Z, {
            fa: "solid",
            fas: "solid",
            "fa-solid": "solid",
            far: "regular",
            "fa-regular": "regular",
            fal: "light",
            "fa-light": "light",
            fat: "thin",
            "fa-thin": "thin",
            fad: "duotone",
            "fa-duotone": "duotone",
            fab: "brands",
            "fa-brands": "brands",
            fak: "kit",
            "fa-kit": "kit",
          }),
          l(T, Q, { fa: "solid", fass: "solid", "fa-solid": "solid" }),
          T)
        ),
        rt = et(
          ((E = {}),
          l(E, Z, {
            solid: "fas",
            regular: "far",
            light: "fal",
            thin: "fat",
            duotone: "fad",
            brands: "fab",
            kit: "fak",
          }),
          l(E, Q, { solid: "fass" }),
          E)
        ),
        it = et(
          ((A = {}),
          l(A, Z, {
            fab: "fa-brands",
            fad: "fa-duotone",
            fak: "fa-kit",
            fal: "fa-light",
            far: "fa-regular",
            fas: "fa-solid",
            fat: "fa-thin",
          }),
          l(A, Q, { fass: "fa-solid" }),
          A)
        ),
        at = et(
          ((C = {}),
          l(C, Z, {
            "fa-brands": "fab",
            "fa-duotone": "fad",
            "fa-kit": "fak",
            "fa-light": "fal",
            "fa-regular": "far",
            "fa-solid": "fas",
            "fa-thin": "fat",
          }),
          l(C, Q, { "fa-solid": "fass" }),
          C)
        ),
        ot = /fa(s|r|l|t|d|b|k|ss)?[\-\ ]/,
        st = "fa-layers-text",
        ct =
          /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i,
        lt = et(
          ((L = {}),
          l(L, Z, {
            900: "fas",
            400: "far",
            normal: "far",
            300: "fal",
            100: "fat",
          }),
          l(L, Q, { 900: "fass" }),
          L)
        ),
        ut = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        ht = ut.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
        dt = [
          "class",
          "data-prefix",
          "data-icon",
          "data-fa-transform",
          "data-fa-mask",
        ],
        ft = {
          GROUP: "duotone-group",
          SWAP_OPACITY: "swap-opacity",
          PRIMARY: "primary",
          SECONDARY: "secondary",
        },
        pt = new Set();
      Object.keys(rt[Z]).map(pt.add.bind(pt)),
        Object.keys(rt[Q]).map(pt.add.bind(pt));
      var mt = []
          .concat(tt, h(pt), [
            "2xs",
            "xs",
            "sm",
            "lg",
            "xl",
            "2xl",
            "beat",
            "border",
            "fade",
            "beat-fade",
            "bounce",
            "flip-both",
            "flip-horizontal",
            "flip-vertical",
            "flip",
            "fw",
            "inverse",
            "layers-counter",
            "layers-text",
            "layers",
            "li",
            "pull-left",
            "pull-right",
            "pulse",
            "rotate-180",
            "rotate-270",
            "rotate-90",
            "rotate-by",
            "shake",
            "spin-pulse",
            "spin-reverse",
            "spin",
            "stack-1x",
            "stack-2x",
            "stack",
            "ul",
            ft.GROUP,
            ft.SWAP_OPACITY,
            ft.PRIMARY,
            ft.SECONDARY,
          ])
          .concat(
            ut.map(function (t) {
              return "".concat(t, "x");
            })
          )
          .concat(
            ht.map(function (t) {
              return "w-".concat(t);
            })
          ),
        gt = O.FontAwesomeConfig || {};
      function vt(t) {
        var e = k.querySelector("script[" + t + "]");
        if (e) return e.getAttribute(t);
      }
      function yt(t) {
        return "" === t || ("false" !== t && ("true" === t || t));
      }
      if (k && "function" === typeof k.querySelector) {
        var bt = [
          ["data-family-prefix", "familyPrefix"],
          ["data-css-prefix", "cssPrefix"],
          ["data-family-default", "familyDefault"],
          ["data-style-default", "styleDefault"],
          ["data-replacement-class", "replacementClass"],
          ["data-auto-replace-svg", "autoReplaceSvg"],
          ["data-auto-add-css", "autoAddCss"],
          ["data-auto-a11y", "autoA11y"],
          ["data-search-pseudo-elements", "searchPseudoElements"],
          ["data-observe-mutations", "observeMutations"],
          ["data-mutate-approach", "mutateApproach"],
          ["data-keep-original-source", "keepOriginalSource"],
          ["data-measure-performance", "measurePerformance"],
          ["data-show-missing-icons", "showMissingIcons"],
        ];
        bt.forEach(function (t) {
          var e = u(t, 2),
            n = e[0],
            r = e[1],
            i = yt(vt(n));
          void 0 !== i && null !== i && (gt[r] = i);
        });
      }
      var xt = {
        styleDefault: "solid",
        familyDefault: "classic",
        cssPrefix: j,
        replacementClass: H,
        autoReplaceSvg: !0,
        autoAddCss: !0,
        autoA11y: !0,
        searchPseudoElements: !1,
        observeMutations: !0,
        mutateApproach: "async",
        keepOriginalSource: !0,
        measurePerformance: !1,
        showMissingIcons: !0,
      };
      gt.familyPrefix && (gt.cssPrefix = gt.familyPrefix);
      var _t = i(i({}, xt), gt);
      _t.autoReplaceSvg || (_t.observeMutations = !1);
      var wt = {};
      Object.keys(xt).forEach(function (t) {
        Object.defineProperty(wt, t, {
          enumerable: !0,
          set: function (e) {
            (_t[t] = e),
              St.forEach(function (t) {
                return t(wt);
              });
          },
          get: function () {
            return _t[t];
          },
        });
      }),
        Object.defineProperty(wt, "familyPrefix", {
          enumerable: !0,
          set: function (t) {
            (_t.cssPrefix = t),
              St.forEach(function (t) {
                return t(wt);
              });
          },
          get: function () {
            return _t.cssPrefix;
          },
        }),
        (O.FontAwesomeConfig = wt);
      var St = [];
      function Mt(t) {
        return (
          St.push(t),
          function () {
            St.splice(St.indexOf(t), 1);
          }
        );
      }
      var Tt = B,
        Et = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 };
      function At(t) {
        if (t && z) {
          var e = k.createElement("style");
          e.setAttribute("type", "text/css"), (e.innerHTML = t);
          for (
            var n = k.head.childNodes, r = null, i = n.length - 1;
            i > -1;
            i--
          ) {
            var a = n[i],
              o = (a.tagName || "").toUpperCase();
            ["STYLE", "LINK"].indexOf(o) > -1 && (r = a);
          }
          return k.head.insertBefore(e, r), t;
        }
      }
      var Ct = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      function Lt() {
        var t = 12,
          e = "";
        while (t-- > 0) e += Ct[(62 * Math.random()) | 0];
        return e;
      }
      function Rt(t) {
        for (var e = [], n = (t || []).length >>> 0; n--; ) e[n] = t[n];
        return e;
      }
      function Pt(t) {
        return t.classList
          ? Rt(t.classList)
          : (t.getAttribute("class") || "").split(" ").filter(function (t) {
              return t;
            });
      }
      function It(t) {
        return ""
          .concat(t)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      function Ot(t) {
        return Object.keys(t || {})
          .reduce(function (e, n) {
            return e + "".concat(n, '="').concat(It(t[n]), '" ');
          }, "")
          .trim();
      }
      function kt(t) {
        return Object.keys(t || {}).reduce(function (e, n) {
          return e + "".concat(n, ": ").concat(t[n].trim(), ";");
        }, "");
      }
      function Nt(t) {
        return (
          t.size !== Et.size ||
          t.x !== Et.x ||
          t.y !== Et.y ||
          t.rotate !== Et.rotate ||
          t.flipX ||
          t.flipY
        );
      }
      function Dt(t) {
        var e = t.transform,
          n = t.containerWidth,
          r = t.iconWidth,
          i = { transform: "translate(".concat(n / 2, " 256)") },
          a = "translate(".concat(32 * e.x, ", ").concat(32 * e.y, ") "),
          o = "scale("
            .concat((e.size / 16) * (e.flipX ? -1 : 1), ", ")
            .concat((e.size / 16) * (e.flipY ? -1 : 1), ") "),
          s = "rotate(".concat(e.rotate, " 0 0)"),
          c = { transform: "".concat(a, " ").concat(o, " ").concat(s) },
          l = { transform: "translate(".concat((r / 2) * -1, " -256)") };
        return { outer: i, inner: c, path: l };
      }
      function zt(t) {
        var e = t.transform,
          n = t.width,
          r = void 0 === n ? B : n,
          i = t.height,
          a = void 0 === i ? B : i,
          o = t.startCentered,
          s = void 0 !== o && o,
          c = "";
        return (
          (c +=
            s && F
              ? "translate("
                  .concat(e.x / Tt - r / 2, "em, ")
                  .concat(e.y / Tt - a / 2, "em) ")
              : s
              ? "translate(calc(-50% + "
                  .concat(e.x / Tt, "em), calc(-50% + ")
                  .concat(e.y / Tt, "em)) ")
              : "translate(".concat(e.x / Tt, "em, ").concat(e.y / Tt, "em) ")),
          (c += "scale("
            .concat((e.size / Tt) * (e.flipX ? -1 : 1), ", ")
            .concat((e.size / Tt) * (e.flipY ? -1 : 1), ") ")),
          (c += "rotate(".concat(e.rotate, "deg) ")),
          c
        );
      }
      var Ft =
        ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
      function Ut() {
        var t = j,
          e = H,
          n = wt.cssPrefix,
          r = wt.replacementClass,
          i = Ft;
        if (n !== t || r !== e) {
          var a = new RegExp("\\.".concat(t, "\\-"), "g"),
            o = new RegExp("\\--".concat(t, "\\-"), "g"),
            s = new RegExp("\\.".concat(e), "g");
          i = i
            .replace(a, ".".concat(n, "-"))
            .replace(o, "--".concat(n, "-"))
            .replace(s, ".".concat(r));
        }
        return i;
      }
      var Bt = !1;
      function jt() {
        wt.autoAddCss && !Bt && (At(Ut()), (Bt = !0));
      }
      var Ht = {
          mixout: function () {
            return { dom: { css: Ut, insertCss: jt } };
          },
          hooks: function () {
            return {
              beforeDOMElementCreation: function () {
                jt();
              },
              beforeI2svg: function () {
                jt();
              },
            };
          },
        },
        Vt = O || {};
      Vt[U] || (Vt[U] = {}),
        Vt[U].styles || (Vt[U].styles = {}),
        Vt[U].hooks || (Vt[U].hooks = {}),
        Vt[U].shims || (Vt[U].shims = []);
      var Gt = Vt[U],
        Wt = [],
        qt = function t() {
          k.removeEventListener("DOMContentLoaded", t),
            (Xt = 1),
            Wt.map(function (t) {
              return t();
            });
        },
        Xt = !1;
      function $t(t) {
        z && (Xt ? setTimeout(t, 0) : Wt.push(t));
      }
      function Yt(t) {
        var e = t.tag,
          n = t.attributes,
          r = void 0 === n ? {} : n,
          i = t.children,
          a = void 0 === i ? [] : i;
        return "string" === typeof t
          ? It(t)
          : "<"
              .concat(e, " ")
              .concat(Ot(r), ">")
              .concat(a.map(Yt).join(""), "</")
              .concat(e, ">");
      }
      function Jt(t, e, n) {
        if (t && t[e] && t[e][n])
          return { prefix: e, iconName: n, icon: t[e][n] };
      }
      z &&
        ((Xt = (
          k.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/
        ).test(k.readyState)),
        Xt || k.addEventListener("DOMContentLoaded", qt));
      var Kt = function (t, e) {
          return function (n, r, i, a) {
            return t.call(e, n, r, i, a);
          };
        },
        Zt = function (t, e, n, r) {
          var i,
            a,
            o,
            s = Object.keys(t),
            c = s.length,
            l = void 0 !== r ? Kt(e, r) : e;
          for (
            void 0 === n ? ((i = 1), (o = t[s[0]])) : ((i = 0), (o = n));
            i < c;
            i++
          )
            (a = s[i]), (o = l(o, t[a], a, t));
          return o;
        };
      function Qt(t) {
        var e = [],
          n = 0,
          r = t.length;
        while (n < r) {
          var i = t.charCodeAt(n++);
          if (i >= 55296 && i <= 56319 && n < r) {
            var a = t.charCodeAt(n++);
            56320 == (64512 & a)
              ? e.push(((1023 & i) << 10) + (1023 & a) + 65536)
              : (e.push(i), n--);
          } else e.push(i);
        }
        return e;
      }
      function te(t) {
        var e = Qt(t);
        return 1 === e.length ? e[0].toString(16) : null;
      }
      function ee(t, e) {
        var n,
          r = t.length,
          i = t.charCodeAt(e);
        return i >= 55296 &&
          i <= 56319 &&
          r > e + 1 &&
          ((n = t.charCodeAt(e + 1)), n >= 56320 && n <= 57343)
          ? 1024 * (i - 55296) + n - 56320 + 65536
          : i;
      }
      function ne(t) {
        return Object.keys(t).reduce(function (e, n) {
          var r = t[n],
            i = !!r.icon;
          return i ? (e[r.iconName] = r.icon) : (e[n] = r), e;
        }, {});
      }
      function re(t, e) {
        var n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          r = n.skipHooks,
          a = void 0 !== r && r,
          o = ne(e);
        "function" !== typeof Gt.hooks.addPack || a
          ? (Gt.styles[t] = i(i({}, Gt.styles[t] || {}), o))
          : Gt.hooks.addPack(t, ne(e)),
          "fas" === t && re("fa", e);
      }
      var ie,
        ae,
        oe,
        se = Gt.styles,
        ce = Gt.shims,
        le =
          ((ie = {}),
          l(ie, Z, Object.values(it[Z])),
          l(ie, Q, Object.values(it[Q])),
          ie),
        ue = null,
        he = {},
        de = {},
        fe = {},
        pe = {},
        me = {},
        ge =
          ((ae = {}),
          l(ae, Z, Object.keys(nt[Z])),
          l(ae, Q, Object.keys(nt[Q])),
          ae);
      function ve(t) {
        return ~mt.indexOf(t);
      }
      function ye(t, e) {
        var n = e.split("-"),
          r = n[0],
          i = n.slice(1).join("-");
        return r !== t || "" === i || ve(i) ? null : i;
      }
      var be = function () {
        var t = function (t) {
          return Zt(
            se,
            function (e, n, r) {
              return (e[r] = Zt(n, t, {})), e;
            },
            {}
          );
        };
        (he = t(function (t, e, n) {
          if ((e[3] && (t[e[3]] = n), e[2])) {
            var r = e[2].filter(function (t) {
              return "number" === typeof t;
            });
            r.forEach(function (e) {
              t[e.toString(16)] = n;
            });
          }
          return t;
        })),
          (de = t(function (t, e, n) {
            if (((t[n] = n), e[2])) {
              var r = e[2].filter(function (t) {
                return "string" === typeof t;
              });
              r.forEach(function (e) {
                t[e] = n;
              });
            }
            return t;
          })),
          (me = t(function (t, e, n) {
            var r = e[2];
            return (
              (t[n] = n),
              r.forEach(function (e) {
                t[e] = n;
              }),
              t
            );
          }));
        var e = "far" in se || wt.autoFetchSvg,
          n = Zt(
            ce,
            function (t, n) {
              var r = n[0],
                i = n[1],
                a = n[2];
              return (
                "far" !== i || e || (i = "fas"),
                "string" === typeof r &&
                  (t.names[r] = { prefix: i, iconName: a }),
                "number" === typeof r &&
                  (t.unicodes[r.toString(16)] = { prefix: i, iconName: a }),
                t
              );
            },
            { names: {}, unicodes: {} }
          );
        (fe = n.names),
          (pe = n.unicodes),
          (ue = Ae(wt.styleDefault, { family: wt.familyDefault }));
      };
      function xe(t, e) {
        return (he[t] || {})[e];
      }
      function _e(t, e) {
        return (de[t] || {})[e];
      }
      function we(t, e) {
        return (me[t] || {})[e];
      }
      function Se(t) {
        return fe[t] || { prefix: null, iconName: null };
      }
      function Me(t) {
        var e = pe[t],
          n = xe("fas", t);
        return (
          e ||
          (n ? { prefix: "fas", iconName: n } : null) || {
            prefix: null,
            iconName: null,
          }
        );
      }
      function Te() {
        return ue;
      }
      Mt(function (t) {
        ue = Ae(t.styleDefault, { family: wt.familyDefault });
      }),
        be();
      var Ee = function () {
        return { prefix: null, iconName: null, rest: [] };
      };
      function Ae(t) {
        var e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          n = e.family,
          r = void 0 === n ? Z : n,
          i = nt[r][t],
          a = rt[r][t] || rt[r][i],
          o = t in Gt.styles ? t : null;
        return a || o || null;
      }
      var Ce =
        ((oe = {}),
        l(oe, Z, Object.keys(it[Z])),
        l(oe, Q, Object.keys(it[Q])),
        oe);
      function Le(t) {
        var e,
          n =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          r = n.skipLookups,
          i = void 0 !== r && r,
          a =
            ((e = {}),
            l(e, Z, "".concat(wt.cssPrefix, "-").concat(Z)),
            l(e, Q, "".concat(wt.cssPrefix, "-").concat(Q)),
            e),
          o = null,
          s = Z;
        (t.includes(a[Z]) ||
          t.some(function (t) {
            return Ce[Z].includes(t);
          })) &&
          (s = Z),
          (t.includes(a[Q]) ||
            t.some(function (t) {
              return Ce[Q].includes(t);
            })) &&
            (s = Q);
        var c = t.reduce(function (t, e) {
          var n = ye(wt.cssPrefix, e);
          if (
            (se[e]
              ? ((e = le[s].includes(e) ? at[s][e] : e),
                (o = e),
                (t.prefix = e))
              : ge[s].indexOf(e) > -1
              ? ((o = e), (t.prefix = Ae(e, { family: s })))
              : n
              ? (t.iconName = n)
              : e !== wt.replacementClass &&
                e !== a[Z] &&
                e !== a[Q] &&
                t.rest.push(e),
            !i && t.prefix && t.iconName)
          ) {
            var r = "fa" === o ? Se(t.iconName) : {},
              c = we(t.prefix, t.iconName);
            r.prefix && (o = null),
              (t.iconName = r.iconName || c || t.iconName),
              (t.prefix = r.prefix || t.prefix),
              "far" !== t.prefix ||
                se["far"] ||
                !se["fas"] ||
                wt.autoFetchSvg ||
                (t.prefix = "fas");
          }
          return t;
        }, Ee());
        return (
          (t.includes("fa-brands") || t.includes("fab")) && (c.prefix = "fab"),
          (t.includes("fa-duotone") || t.includes("fad")) && (c.prefix = "fad"),
          c.prefix ||
            s !== Q ||
            (!se["fass"] && !wt.autoFetchSvg) ||
            ((c.prefix = "fass"),
            (c.iconName = we(c.prefix, c.iconName) || c.iconName)),
          ("fa" !== c.prefix && "fa" !== o) || (c.prefix = Te() || "fas"),
          c
        );
      }
      var Re = (function () {
          function t() {
            o(this, t), (this.definitions = {});
          }
          return (
            c(t, [
              {
                key: "add",
                value: function () {
                  for (
                    var t = this, e = arguments.length, n = new Array(e), r = 0;
                    r < e;
                    r++
                  )
                    n[r] = arguments[r];
                  var a = n.reduce(this._pullDefinitions, {});
                  Object.keys(a).forEach(function (e) {
                    (t.definitions[e] = i(i({}, t.definitions[e] || {}), a[e])),
                      re(e, a[e]);
                    var n = it[Z][e];
                    n && re(n, a[e]), be();
                  });
                },
              },
              {
                key: "reset",
                value: function () {
                  this.definitions = {};
                },
              },
              {
                key: "_pullDefinitions",
                value: function (t, e) {
                  var n = e.prefix && e.iconName && e.icon ? { 0: e } : e;
                  return (
                    Object.keys(n).map(function (e) {
                      var r = n[e],
                        i = r.prefix,
                        a = r.iconName,
                        o = r.icon,
                        s = o[2];
                      t[i] || (t[i] = {}),
                        s.length > 0 &&
                          s.forEach(function (e) {
                            "string" === typeof e && (t[i][e] = o);
                          }),
                        (t[i][a] = o);
                    }),
                    t
                  );
                },
              },
            ]),
            t
          );
        })(),
        Pe = [],
        Ie = {},
        Oe = {},
        ke = Object.keys(Oe);
      function Ne(t, e) {
        var n = e.mixoutsTo;
        return (
          (Pe = t),
          (Ie = {}),
          Object.keys(Oe).forEach(function (t) {
            -1 === ke.indexOf(t) && delete Oe[t];
          }),
          Pe.forEach(function (t) {
            var e = t.mixout ? t.mixout() : {};
            if (
              (Object.keys(e).forEach(function (t) {
                "function" === typeof e[t] && (n[t] = e[t]),
                  "object" === a(e[t]) &&
                    Object.keys(e[t]).forEach(function (r) {
                      n[t] || (n[t] = {}), (n[t][r] = e[t][r]);
                    });
              }),
              t.hooks)
            ) {
              var r = t.hooks();
              Object.keys(r).forEach(function (t) {
                Ie[t] || (Ie[t] = []), Ie[t].push(r[t]);
              });
            }
            t.provides && t.provides(Oe);
          }),
          n
        );
      }
      function De(t, e) {
        for (
          var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2;
          i < n;
          i++
        )
          r[i - 2] = arguments[i];
        var a = Ie[t] || [];
        return (
          a.forEach(function (t) {
            e = t.apply(null, [e].concat(r));
          }),
          e
        );
      }
      function ze(t) {
        for (
          var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
          r < e;
          r++
        )
          n[r - 1] = arguments[r];
        var i = Ie[t] || [];
        i.forEach(function (t) {
          t.apply(null, n);
        });
      }
      function Fe() {
        var t = arguments[0],
          e = Array.prototype.slice.call(arguments, 1);
        return Oe[t] ? Oe[t].apply(null, e) : void 0;
      }
      function Ue(t) {
        "fa" === t.prefix && (t.prefix = "fas");
        var e = t.iconName,
          n = t.prefix || Te();
        if (e)
          return (
            (e = we(n, e) || e), Jt(Be.definitions, n, e) || Jt(Gt.styles, n, e)
          );
      }
      var Be = new Re(),
        je = function () {
          (wt.autoReplaceSvg = !1), (wt.observeMutations = !1), ze("noAuto");
        },
        He = {
          i2svg: function () {
            var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            return z
              ? (ze("beforeI2svg", t),
                Fe("pseudoElements2svg", t),
                Fe("i2svg", t))
              : Promise.reject("Operation requires a DOM of some kind.");
          },
          watch: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {},
              e = t.autoReplaceSvgRoot;
            !1 === wt.autoReplaceSvg && (wt.autoReplaceSvg = !0),
              (wt.observeMutations = !0),
              $t(function () {
                We({ autoReplaceSvgRoot: e }), ze("watch", t);
              });
          },
        },
        Ve = {
          icon: function (t) {
            if (null === t) return null;
            if ("object" === a(t) && t.prefix && t.iconName)
              return {
                prefix: t.prefix,
                iconName: we(t.prefix, t.iconName) || t.iconName,
              };
            if (Array.isArray(t) && 2 === t.length) {
              var e = 0 === t[1].indexOf("fa-") ? t[1].slice(3) : t[1],
                n = Ae(t[0]);
              return { prefix: n, iconName: we(n, e) || e };
            }
            if (
              "string" === typeof t &&
              (t.indexOf("".concat(wt.cssPrefix, "-")) > -1 || t.match(ot))
            ) {
              var r = Le(t.split(" "), { skipLookups: !0 });
              return {
                prefix: r.prefix || Te(),
                iconName: we(r.prefix, r.iconName) || r.iconName,
              };
            }
            if ("string" === typeof t) {
              var i = Te();
              return { prefix: i, iconName: we(i, t) || t };
            }
          },
        },
        Ge = {
          noAuto: je,
          config: wt,
          dom: He,
          parse: Ve,
          library: Be,
          findIconDefinition: Ue,
          toHtml: Yt,
        },
        We = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            e = t.autoReplaceSvgRoot,
            n = void 0 === e ? k : e;
          (Object.keys(Gt.styles).length > 0 || wt.autoFetchSvg) &&
            z &&
            wt.autoReplaceSvg &&
            Ge.dom.i2svg({ node: n });
        };
      function qe(t, e) {
        return (
          Object.defineProperty(t, "abstract", { get: e }),
          Object.defineProperty(t, "html", {
            get: function () {
              return t.abstract.map(function (t) {
                return Yt(t);
              });
            },
          }),
          Object.defineProperty(t, "node", {
            get: function () {
              if (z) {
                var e = k.createElement("div");
                return (e.innerHTML = t.html), e.children;
              }
            },
          }),
          t
        );
      }
      function Xe(t) {
        var e = t.children,
          n = t.main,
          r = t.mask,
          a = t.attributes,
          o = t.styles,
          s = t.transform;
        if (Nt(s) && n.found && !r.found) {
          var c = n.width,
            l = n.height,
            u = { x: c / l / 2, y: 0.5 };
          a["style"] = kt(
            i(
              i({}, o),
              {},
              {
                "transform-origin": ""
                  .concat(u.x + s.x / 16, "em ")
                  .concat(u.y + s.y / 16, "em"),
              }
            )
          );
        }
        return [{ tag: "svg", attributes: a, children: e }];
      }
      function $e(t) {
        var e = t.prefix,
          n = t.iconName,
          r = t.children,
          a = t.attributes,
          o = t.symbol,
          s =
            !0 === o
              ? "".concat(e, "-").concat(wt.cssPrefix, "-").concat(n)
              : o;
        return [
          {
            tag: "svg",
            attributes: { style: "display: none;" },
            children: [
              {
                tag: "symbol",
                attributes: i(i({}, a), {}, { id: s }),
                children: r,
              },
            ],
          },
        ];
      }
      function Ye(t) {
        var e = t.icons,
          n = e.main,
          r = e.mask,
          a = t.prefix,
          o = t.iconName,
          s = t.transform,
          c = t.symbol,
          l = t.title,
          u = t.maskId,
          h = t.titleId,
          d = t.extra,
          f = t.watchable,
          p = void 0 !== f && f,
          m = r.found ? r : n,
          g = m.width,
          v = m.height,
          y = "fak" === a,
          b = [
            wt.replacementClass,
            o ? "".concat(wt.cssPrefix, "-").concat(o) : "",
          ]
            .filter(function (t) {
              return -1 === d.classes.indexOf(t);
            })
            .filter(function (t) {
              return "" !== t || !!t;
            })
            .concat(d.classes)
            .join(" "),
          x = {
            children: [],
            attributes: i(
              i({}, d.attributes),
              {},
              {
                "data-prefix": a,
                "data-icon": o,
                class: b,
                role: d.attributes.role || "img",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 ".concat(g, " ").concat(v),
              }
            ),
          },
          _ =
            y && !~d.classes.indexOf("fa-fw")
              ? { width: "".concat((g / v) * 16 * 0.0625, "em") }
              : {};
        p && (x.attributes[V] = ""),
          l &&
            (x.children.push({
              tag: "title",
              attributes: {
                id:
                  x.attributes["aria-labelledby"] || "title-".concat(h || Lt()),
              },
              children: [l],
            }),
            delete x.attributes.title);
        var w = i(
            i({}, x),
            {},
            {
              prefix: a,
              iconName: o,
              main: n,
              mask: r,
              maskId: u,
              transform: s,
              symbol: c,
              styles: i(i({}, _), d.styles),
            }
          ),
          S =
            r.found && n.found
              ? Fe("generateAbstractMask", w) || {
                  children: [],
                  attributes: {},
                }
              : Fe("generateAbstractIcon", w) || {
                  children: [],
                  attributes: {},
                },
          M = S.children,
          T = S.attributes;
        return (w.children = M), (w.attributes = T), c ? $e(w) : Xe(w);
      }
      function Je(t) {
        var e = t.content,
          n = t.width,
          r = t.height,
          a = t.transform,
          o = t.title,
          s = t.extra,
          c = t.watchable,
          l = void 0 !== c && c,
          u = i(
            i(i({}, s.attributes), o ? { title: o } : {}),
            {},
            { class: s.classes.join(" ") }
          );
        l && (u[V] = "");
        var h = i({}, s.styles);
        Nt(a) &&
          ((h["transform"] = zt({
            transform: a,
            startCentered: !0,
            width: n,
            height: r,
          })),
          (h["-webkit-transform"] = h["transform"]));
        var d = kt(h);
        d.length > 0 && (u["style"] = d);
        var f = [];
        return (
          f.push({ tag: "span", attributes: u, children: [e] }),
          o &&
            f.push({
              tag: "span",
              attributes: { class: "sr-only" },
              children: [o],
            }),
          f
        );
      }
      function Ke(t) {
        var e = t.content,
          n = t.title,
          r = t.extra,
          a = i(
            i(i({}, r.attributes), n ? { title: n } : {}),
            {},
            { class: r.classes.join(" ") }
          ),
          o = kt(r.styles);
        o.length > 0 && (a["style"] = o);
        var s = [];
        return (
          s.push({ tag: "span", attributes: a, children: [e] }),
          n &&
            s.push({
              tag: "span",
              attributes: { class: "sr-only" },
              children: [n],
            }),
          s
        );
      }
      var Ze = Gt.styles;
      function Qe(t) {
        var e = t[0],
          n = t[1],
          r = t.slice(4),
          i = u(r, 1),
          a = i[0],
          o = null;
        return (
          (o = Array.isArray(a)
            ? {
                tag: "g",
                attributes: {
                  class: "".concat(wt.cssPrefix, "-").concat(ft.GROUP),
                },
                children: [
                  {
                    tag: "path",
                    attributes: {
                      class: "".concat(wt.cssPrefix, "-").concat(ft.SECONDARY),
                      fill: "currentColor",
                      d: a[0],
                    },
                  },
                  {
                    tag: "path",
                    attributes: {
                      class: "".concat(wt.cssPrefix, "-").concat(ft.PRIMARY),
                      fill: "currentColor",
                      d: a[1],
                    },
                  },
                ],
              }
            : { tag: "path", attributes: { fill: "currentColor", d: a } }),
          { found: !0, width: e, height: n, icon: o }
        );
      }
      var tn = { found: !1, width: 512, height: 512 };
      function en(t, e) {
        K ||
          wt.showMissingIcons ||
          !t ||
          console.error(
            'Icon with name "'
              .concat(t, '" and prefix "')
              .concat(e, '" is missing.')
          );
      }
      function nn(t, e) {
        var n = e;
        return (
          "fa" === e && null !== wt.styleDefault && (e = Te()),
          new Promise(function (r, a) {
            Fe("missingIconAbstract");
            if ("fa" === n) {
              var o = Se(t) || {};
              (t = o.iconName || t), (e = o.prefix || e);
            }
            if (t && e && Ze[e] && Ze[e][t]) {
              var s = Ze[e][t];
              return r(Qe(s));
            }
            en(t, e),
              r(
                i(
                  i({}, tn),
                  {},
                  {
                    icon:
                      (wt.showMissingIcons && t && Fe("missingIconAbstract")) ||
                      {},
                  }
                )
              );
          })
        );
      }
      var rn = function () {},
        an =
          wt.measurePerformance && D && D.mark && D.measure
            ? D
            : { mark: rn, measure: rn },
        on = 'FA "6.2.0"',
        sn = function (t) {
          return (
            an.mark("".concat(on, " ").concat(t, " begins")),
            function () {
              return cn(t);
            }
          );
        },
        cn = function (t) {
          an.mark("".concat(on, " ").concat(t, " ends")),
            an.measure(
              "".concat(on, " ").concat(t),
              "".concat(on, " ").concat(t, " begins"),
              "".concat(on, " ").concat(t, " ends")
            );
        },
        ln = { begin: sn, end: cn },
        un = function () {};
      function hn(t) {
        var e = t.getAttribute ? t.getAttribute(V) : null;
        return "string" === typeof e;
      }
      function dn(t) {
        var e = t.getAttribute ? t.getAttribute(q) : null,
          n = t.getAttribute ? t.getAttribute(X) : null;
        return e && n;
      }
      function fn(t) {
        return (
          t &&
          t.classList &&
          t.classList.contains &&
          t.classList.contains(wt.replacementClass)
        );
      }
      function pn() {
        if (!0 === wt.autoReplaceSvg) return bn.replace;
        var t = bn[wt.autoReplaceSvg];
        return t || bn.replace;
      }
      function mn(t) {
        return k.createElementNS("http://www.w3.org/2000/svg", t);
      }
      function gn(t) {
        return k.createElement(t);
      }
      function vn(t) {
        var e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          n = e.ceFn,
          r = void 0 === n ? ("svg" === t.tag ? mn : gn) : n;
        if ("string" === typeof t) return k.createTextNode(t);
        var i = r(t.tag);
        Object.keys(t.attributes || []).forEach(function (e) {
          i.setAttribute(e, t.attributes[e]);
        });
        var a = t.children || [];
        return (
          a.forEach(function (t) {
            i.appendChild(vn(t, { ceFn: r }));
          }),
          i
        );
      }
      function yn(t) {
        var e = " ".concat(t.outerHTML, " ");
        return (e = "".concat(e, "Font Awesome fontawesome.com ")), e;
      }
      var bn = {
        replace: function (t) {
          var e = t[0];
          if (e.parentNode)
            if (
              (t[1].forEach(function (t) {
                e.parentNode.insertBefore(vn(t), e);
              }),
              null === e.getAttribute(V) && wt.keepOriginalSource)
            ) {
              var n = k.createComment(yn(e));
              e.parentNode.replaceChild(n, e);
            } else e.remove();
        },
        nest: function (t) {
          var e = t[0],
            n = t[1];
          if (~Pt(e).indexOf(wt.replacementClass)) return bn.replace(t);
          var r = new RegExp("".concat(wt.cssPrefix, "-.*"));
          if ((delete n[0].attributes.id, n[0].attributes.class)) {
            var i = n[0].attributes.class.split(" ").reduce(
              function (t, e) {
                return (
                  e === wt.replacementClass || e.match(r)
                    ? t.toSvg.push(e)
                    : t.toNode.push(e),
                  t
                );
              },
              { toNode: [], toSvg: [] }
            );
            (n[0].attributes.class = i.toSvg.join(" ")),
              0 === i.toNode.length
                ? e.removeAttribute("class")
                : e.setAttribute("class", i.toNode.join(" "));
          }
          var a = n
            .map(function (t) {
              return Yt(t);
            })
            .join("\n");
          e.setAttribute(V, ""), (e.innerHTML = a);
        },
      };
      function xn(t) {
        t();
      }
      function _n(t, e) {
        var n = "function" === typeof e ? e : un;
        if (0 === t.length) n();
        else {
          var r = xn;
          wt.mutateApproach === Y && (r = O.requestAnimationFrame || xn),
            r(function () {
              var e = pn(),
                r = ln.begin("mutate");
              t.map(e), r(), n();
            });
        }
      }
      var wn = !1;
      function Sn() {
        wn = !0;
      }
      function Mn() {
        wn = !1;
      }
      var Tn = null;
      function En(t) {
        if (N && wt.observeMutations) {
          var e = t.treeCallback,
            n = void 0 === e ? un : e,
            r = t.nodeCallback,
            i = void 0 === r ? un : r,
            a = t.pseudoElementsCallback,
            o = void 0 === a ? un : a,
            s = t.observeMutationsRoot,
            c = void 0 === s ? k : s;
          (Tn = new N(function (t) {
            if (!wn) {
              var e = Te();
              Rt(t).forEach(function (t) {
                if (
                  ("childList" === t.type &&
                    t.addedNodes.length > 0 &&
                    !hn(t.addedNodes[0]) &&
                    (wt.searchPseudoElements && o(t.target), n(t.target)),
                  "attributes" === t.type &&
                    t.target.parentNode &&
                    wt.searchPseudoElements &&
                    o(t.target.parentNode),
                  "attributes" === t.type &&
                    hn(t.target) &&
                    ~dt.indexOf(t.attributeName))
                )
                  if ("class" === t.attributeName && dn(t.target)) {
                    var r = Le(Pt(t.target)),
                      a = r.prefix,
                      s = r.iconName;
                    t.target.setAttribute(q, a || e),
                      s && t.target.setAttribute(X, s);
                  } else fn(t.target) && i(t.target);
              });
            }
          })),
            z &&
              Tn.observe(c, {
                childList: !0,
                attributes: !0,
                characterData: !0,
                subtree: !0,
              });
        }
      }
      function An() {
        Tn && Tn.disconnect();
      }
      function Cn(t) {
        var e = t.getAttribute("style"),
          n = [];
        return (
          e &&
            (n = e.split(";").reduce(function (t, e) {
              var n = e.split(":"),
                r = n[0],
                i = n.slice(1);
              return r && i.length > 0 && (t[r] = i.join(":").trim()), t;
            }, {})),
          n
        );
      }
      function Ln(t) {
        var e = t.getAttribute("data-prefix"),
          n = t.getAttribute("data-icon"),
          r = void 0 !== t.innerText ? t.innerText.trim() : "",
          i = Le(Pt(t));
        return (
          i.prefix || (i.prefix = Te()),
          e && n && ((i.prefix = e), (i.iconName = n)),
          (i.iconName && i.prefix) ||
            (i.prefix &&
              r.length > 0 &&
              (i.iconName =
                _e(i.prefix, t.innerText) || xe(i.prefix, te(t.innerText))),
            !i.iconName &&
              wt.autoFetchSvg &&
              t.firstChild &&
              t.firstChild.nodeType === Node.TEXT_NODE &&
              (i.iconName = t.firstChild.data)),
          i
        );
      }
      function Rn(t) {
        var e = Rt(t.attributes).reduce(function (t, e) {
            return (
              "class" !== t.name && "style" !== t.name && (t[e.name] = e.value),
              t
            );
          }, {}),
          n = t.getAttribute("title"),
          r = t.getAttribute("data-fa-title-id");
        return (
          wt.autoA11y &&
            (n
              ? (e["aria-labelledby"] = ""
                  .concat(wt.replacementClass, "-title-")
                  .concat(r || Lt()))
              : ((e["aria-hidden"] = "true"), (e["focusable"] = "false"))),
          e
        );
      }
      function Pn() {
        return {
          iconName: null,
          title: null,
          titleId: null,
          prefix: null,
          transform: Et,
          symbol: !1,
          mask: { iconName: null, prefix: null, rest: [] },
          maskId: null,
          extra: { classes: [], styles: {}, attributes: {} },
        };
      }
      function In(t) {
        var e =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { styleParser: !0 },
          n = Ln(t),
          r = n.iconName,
          a = n.prefix,
          o = n.rest,
          s = Rn(t),
          c = De("parseNodeAttributes", {}, t),
          l = e.styleParser ? Cn(t) : [];
        return i(
          {
            iconName: r,
            title: t.getAttribute("title"),
            titleId: t.getAttribute("data-fa-title-id"),
            prefix: a,
            transform: Et,
            mask: { iconName: null, prefix: null, rest: [] },
            maskId: null,
            symbol: !1,
            extra: { classes: o, styles: l, attributes: s },
          },
          c
        );
      }
      var On = Gt.styles;
      function kn(t) {
        var e =
          "nest" === wt.autoReplaceSvg ? In(t, { styleParser: !1 }) : In(t);
        return ~e.extra.classes.indexOf(st)
          ? Fe("generateLayersText", t, e)
          : Fe("generateSvgReplacementMutation", t, e);
      }
      var Nn = new Set();
      function Dn(t) {
        var e =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        if (!z) return Promise.resolve();
        var n = k.documentElement.classList,
          r = function (t) {
            return n.add("".concat($, "-").concat(t));
          },
          i = function (t) {
            return n.remove("".concat($, "-").concat(t));
          },
          a = wt.autoFetchSvg
            ? Nn
            : tt
                .map(function (t) {
                  return "fa-".concat(t);
                })
                .concat(Object.keys(On));
        a.includes("fa") || a.push("fa");
        var o = [".".concat(st, ":not([").concat(V, "])")]
          .concat(
            a.map(function (t) {
              return ".".concat(t, ":not([").concat(V, "])");
            })
          )
          .join(", ");
        if (0 === o.length) return Promise.resolve();
        var s = [];
        try {
          s = Rt(t.querySelectorAll(o));
        } catch (pr) {}
        if (!(s.length > 0)) return Promise.resolve();
        r("pending"), i("complete");
        var c = ln.begin("onTree"),
          l = s.reduce(function (t, e) {
            try {
              var n = kn(e);
              n && t.push(n);
            } catch (pr) {
              K || ("MissingIcon" === pr.name && console.error(pr));
            }
            return t;
          }, []);
        return new Promise(function (t, n) {
          Promise.all(l)
            .then(function (n) {
              _n(n, function () {
                r("active"),
                  r("complete"),
                  i("pending"),
                  "function" === typeof e && e(),
                  c(),
                  t();
              });
            })
            .catch(function (t) {
              c(), n(t);
            });
        });
      }
      function zn(t) {
        var e =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        kn(t).then(function (t) {
          t && _n([t], e);
        });
      }
      function Fn(t) {
        return function (e) {
          var n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            r = (e || {}).icon ? e : Ue(e || {}),
            a = n.mask;
          return (
            a && (a = (a || {}).icon ? a : Ue(a || {})),
            t(r, i(i({}, n), {}, { mask: a }))
          );
        };
      }
      tt.map(function (t) {
        Nn.add("fa-".concat(t));
      }),
        Object.keys(nt[Z]).map(Nn.add.bind(Nn)),
        Object.keys(nt[Q]).map(Nn.add.bind(Nn)),
        (Nn = h(Nn));
      var Un = function (t) {
          var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = e.transform,
            r = void 0 === n ? Et : n,
            a = e.symbol,
            o = void 0 !== a && a,
            s = e.mask,
            c = void 0 === s ? null : s,
            l = e.maskId,
            u = void 0 === l ? null : l,
            h = e.title,
            d = void 0 === h ? null : h,
            f = e.titleId,
            p = void 0 === f ? null : f,
            m = e.classes,
            g = void 0 === m ? [] : m,
            v = e.attributes,
            y = void 0 === v ? {} : v,
            b = e.styles,
            x = void 0 === b ? {} : b;
          if (t) {
            var _ = t.prefix,
              w = t.iconName,
              S = t.icon;
            return qe(i({ type: "icon" }, t), function () {
              return (
                ze("beforeDOMElementCreation", {
                  iconDefinition: t,
                  params: e,
                }),
                wt.autoA11y &&
                  (d
                    ? (y["aria-labelledby"] = ""
                        .concat(wt.replacementClass, "-title-")
                        .concat(p || Lt()))
                    : ((y["aria-hidden"] = "true"),
                      (y["focusable"] = "false"))),
                Ye({
                  icons: {
                    main: Qe(S),
                    mask: c
                      ? Qe(c.icon)
                      : { found: !1, width: null, height: null, icon: {} },
                  },
                  prefix: _,
                  iconName: w,
                  transform: i(i({}, Et), r),
                  symbol: o,
                  title: d,
                  maskId: u,
                  titleId: p,
                  extra: { attributes: y, styles: x, classes: g },
                })
              );
            });
          }
        },
        Bn = {
          mixout: function () {
            return { icon: Fn(Un) };
          },
          hooks: function () {
            return {
              mutationObserverCallbacks: function (t) {
                return (t.treeCallback = Dn), (t.nodeCallback = zn), t;
              },
            };
          },
          provides: function (t) {
            (t.i2svg = function (t) {
              var e = t.node,
                n = void 0 === e ? k : e,
                r = t.callback,
                i = void 0 === r ? function () {} : r;
              return Dn(n, i);
            }),
              (t.generateSvgReplacementMutation = function (t, e) {
                var n = e.iconName,
                  r = e.title,
                  i = e.titleId,
                  a = e.prefix,
                  o = e.transform,
                  s = e.symbol,
                  c = e.mask,
                  l = e.maskId,
                  h = e.extra;
                return new Promise(function (e, d) {
                  Promise.all([
                    nn(n, a),
                    c.iconName
                      ? nn(c.iconName, c.prefix)
                      : Promise.resolve({
                          found: !1,
                          width: 512,
                          height: 512,
                          icon: {},
                        }),
                  ])
                    .then(function (c) {
                      var d = u(c, 2),
                        f = d[0],
                        p = d[1];
                      e([
                        t,
                        Ye({
                          icons: { main: f, mask: p },
                          prefix: a,
                          iconName: n,
                          transform: o,
                          symbol: s,
                          maskId: l,
                          title: r,
                          titleId: i,
                          extra: h,
                          watchable: !0,
                        }),
                      ]);
                    })
                    .catch(d);
                });
              }),
              (t.generateAbstractIcon = function (t) {
                var e,
                  n = t.children,
                  r = t.attributes,
                  i = t.main,
                  a = t.transform,
                  o = t.styles,
                  s = kt(o);
                return (
                  s.length > 0 && (r["style"] = s),
                  Nt(a) &&
                    (e = Fe("generateAbstractTransformGrouping", {
                      main: i,
                      transform: a,
                      containerWidth: i.width,
                      iconWidth: i.width,
                    })),
                  n.push(e || i.icon),
                  { children: n, attributes: r }
                );
              });
          },
        },
        jn = {
          mixout: function () {
            return {
              layer: function (t) {
                var e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  n = e.classes,
                  r = void 0 === n ? [] : n;
                return qe({ type: "layer" }, function () {
                  ze("beforeDOMElementCreation", { assembler: t, params: e });
                  var n = [];
                  return (
                    t(function (t) {
                      Array.isArray(t)
                        ? t.map(function (t) {
                            n = n.concat(t.abstract);
                          })
                        : (n = n.concat(t.abstract));
                    }),
                    [
                      {
                        tag: "span",
                        attributes: {
                          class: ["".concat(wt.cssPrefix, "-layers")]
                            .concat(h(r))
                            .join(" "),
                        },
                        children: n,
                      },
                    ]
                  );
                });
              },
            };
          },
        },
        Hn = {
          mixout: function () {
            return {
              counter: function (t) {
                var e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  n = e.title,
                  r = void 0 === n ? null : n,
                  i = e.classes,
                  a = void 0 === i ? [] : i,
                  o = e.attributes,
                  s = void 0 === o ? {} : o,
                  c = e.styles,
                  l = void 0 === c ? {} : c;
                return qe({ type: "counter", content: t }, function () {
                  return (
                    ze("beforeDOMElementCreation", { content: t, params: e }),
                    Ke({
                      content: t.toString(),
                      title: r,
                      extra: {
                        attributes: s,
                        styles: l,
                        classes: [
                          "".concat(wt.cssPrefix, "-layers-counter"),
                        ].concat(h(a)),
                      },
                    })
                  );
                });
              },
            };
          },
        },
        Vn = {
          mixout: function () {
            return {
              text: function (t) {
                var e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  n = e.transform,
                  r = void 0 === n ? Et : n,
                  a = e.title,
                  o = void 0 === a ? null : a,
                  s = e.classes,
                  c = void 0 === s ? [] : s,
                  l = e.attributes,
                  u = void 0 === l ? {} : l,
                  d = e.styles,
                  f = void 0 === d ? {} : d;
                return qe({ type: "text", content: t }, function () {
                  return (
                    ze("beforeDOMElementCreation", { content: t, params: e }),
                    Je({
                      content: t,
                      transform: i(i({}, Et), r),
                      title: o,
                      extra: {
                        attributes: u,
                        styles: f,
                        classes: [
                          "".concat(wt.cssPrefix, "-layers-text"),
                        ].concat(h(c)),
                      },
                    })
                  );
                });
              },
            };
          },
          provides: function (t) {
            t.generateLayersText = function (t, e) {
              var n = e.title,
                r = e.transform,
                i = e.extra,
                a = null,
                o = null;
              if (F) {
                var s = parseInt(getComputedStyle(t).fontSize, 10),
                  c = t.getBoundingClientRect();
                (a = c.width / s), (o = c.height / s);
              }
              return (
                wt.autoA11y && !n && (i.attributes["aria-hidden"] = "true"),
                Promise.resolve([
                  t,
                  Je({
                    content: t.innerHTML,
                    width: a,
                    height: o,
                    transform: r,
                    title: n,
                    extra: i,
                    watchable: !0,
                  }),
                ])
              );
            };
          },
        },
        Gn = new RegExp('"', "ug"),
        Wn = [1105920, 1112319];
      function qn(t) {
        var e = t.replace(Gn, ""),
          n = ee(e, 0),
          r = n >= Wn[0] && n <= Wn[1],
          i = 2 === e.length && e[0] === e[1];
        return { value: te(i ? e[0] : e), isSecondary: r || i };
      }
      function Xn(t, e) {
        var n = "".concat(W).concat(e.replace(":", "-"));
        return new Promise(function (r, a) {
          if (null !== t.getAttribute(n)) return r();
          var o = Rt(t.children),
            s = o.filter(function (t) {
              return t.getAttribute(G) === e;
            })[0],
            c = O.getComputedStyle(t, e),
            l = c.getPropertyValue("font-family").match(ct),
            u = c.getPropertyValue("font-weight"),
            h = c.getPropertyValue("content");
          if (s && !l) return t.removeChild(s), r();
          if (l && "none" !== h && "" !== h) {
            var d = c.getPropertyValue("content"),
              f = ~["Sharp"].indexOf(l[2]) ? Q : Z,
              p = ~[
                "Solid",
                "Regular",
                "Light",
                "Thin",
                "Duotone",
                "Brands",
                "Kit",
              ].indexOf(l[2])
                ? rt[f][l[2].toLowerCase()]
                : lt[f][u],
              m = qn(d),
              g = m.value,
              v = m.isSecondary,
              y = l[0].startsWith("FontAwesome"),
              b = xe(p, g),
              x = b;
            if (y) {
              var _ = Me(g);
              _.iconName && _.prefix && ((b = _.iconName), (p = _.prefix));
            }
            if (
              !b ||
              v ||
              (s && s.getAttribute(q) === p && s.getAttribute(X) === x)
            )
              r();
            else {
              t.setAttribute(n, x), s && t.removeChild(s);
              var w = Pn(),
                S = w.extra;
              (S.attributes[G] = e),
                nn(b, p)
                  .then(function (a) {
                    var o = Ye(
                        i(
                          i({}, w),
                          {},
                          {
                            icons: { main: a, mask: Ee() },
                            prefix: p,
                            iconName: x,
                            extra: S,
                            watchable: !0,
                          }
                        )
                      ),
                      s = k.createElement("svg");
                    "::before" === e
                      ? t.insertBefore(s, t.firstChild)
                      : t.appendChild(s),
                      (s.outerHTML = o
                        .map(function (t) {
                          return Yt(t);
                        })
                        .join("\n")),
                      t.removeAttribute(n),
                      r();
                  })
                  .catch(a);
            }
          } else r();
        });
      }
      function $n(t) {
        return Promise.all([Xn(t, "::before"), Xn(t, "::after")]);
      }
      function Yn(t) {
        return (
          t.parentNode !== document.head &&
          !~J.indexOf(t.tagName.toUpperCase()) &&
          !t.getAttribute(G) &&
          (!t.parentNode || "svg" !== t.parentNode.tagName)
        );
      }
      function Jn(t) {
        if (z)
          return new Promise(function (e, n) {
            var r = Rt(t.querySelectorAll("*")).filter(Yn).map($n),
              i = ln.begin("searchPseudoElements");
            Sn(),
              Promise.all(r)
                .then(function () {
                  i(), Mn(), e();
                })
                .catch(function () {
                  i(), Mn(), n();
                });
          });
      }
      var Kn = {
          hooks: function () {
            return {
              mutationObserverCallbacks: function (t) {
                return (t.pseudoElementsCallback = Jn), t;
              },
            };
          },
          provides: function (t) {
            t.pseudoElements2svg = function (t) {
              var e = t.node,
                n = void 0 === e ? k : e;
              wt.searchPseudoElements && Jn(n);
            };
          },
        },
        Zn = !1,
        Qn = {
          mixout: function () {
            return {
              dom: {
                unwatch: function () {
                  Sn(), (Zn = !0);
                },
              },
            };
          },
          hooks: function () {
            return {
              bootstrap: function () {
                En(De("mutationObserverCallbacks", {}));
              },
              noAuto: function () {
                An();
              },
              watch: function (t) {
                var e = t.observeMutationsRoot;
                Zn
                  ? Mn()
                  : En(
                      De("mutationObserverCallbacks", {
                        observeMutationsRoot: e,
                      })
                    );
              },
            };
          },
        },
        tr = function (t) {
          var e = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 };
          return t
            .toLowerCase()
            .split(" ")
            .reduce(function (t, e) {
              var n = e.toLowerCase().split("-"),
                r = n[0],
                i = n.slice(1).join("-");
              if (r && "h" === i) return (t.flipX = !0), t;
              if (r && "v" === i) return (t.flipY = !0), t;
              if (((i = parseFloat(i)), isNaN(i))) return t;
              switch (r) {
                case "grow":
                  t.size = t.size + i;
                  break;
                case "shrink":
                  t.size = t.size - i;
                  break;
                case "left":
                  t.x = t.x - i;
                  break;
                case "right":
                  t.x = t.x + i;
                  break;
                case "up":
                  t.y = t.y - i;
                  break;
                case "down":
                  t.y = t.y + i;
                  break;
                case "rotate":
                  t.rotate = t.rotate + i;
                  break;
              }
              return t;
            }, e);
        },
        er = {
          mixout: function () {
            return {
              parse: {
                transform: function (t) {
                  return tr(t);
                },
              },
            };
          },
          hooks: function () {
            return {
              parseNodeAttributes: function (t, e) {
                var n = e.getAttribute("data-fa-transform");
                return n && (t.transform = tr(n)), t;
              },
            };
          },
          provides: function (t) {
            t.generateAbstractTransformGrouping = function (t) {
              var e = t.main,
                n = t.transform,
                r = t.containerWidth,
                a = t.iconWidth,
                o = { transform: "translate(".concat(r / 2, " 256)") },
                s = "translate(".concat(32 * n.x, ", ").concat(32 * n.y, ") "),
                c = "scale("
                  .concat((n.size / 16) * (n.flipX ? -1 : 1), ", ")
                  .concat((n.size / 16) * (n.flipY ? -1 : 1), ") "),
                l = "rotate(".concat(n.rotate, " 0 0)"),
                u = { transform: "".concat(s, " ").concat(c, " ").concat(l) },
                h = { transform: "translate(".concat((a / 2) * -1, " -256)") },
                d = { outer: o, inner: u, path: h };
              return {
                tag: "g",
                attributes: i({}, d.outer),
                children: [
                  {
                    tag: "g",
                    attributes: i({}, d.inner),
                    children: [
                      {
                        tag: e.icon.tag,
                        children: e.icon.children,
                        attributes: i(i({}, e.icon.attributes), d.path),
                      },
                    ],
                  },
                ],
              };
            };
          },
        },
        nr = { x: 0, y: 0, width: "100%", height: "100%" };
      function rr(t) {
        var e =
          !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return (
          t.attributes &&
            (t.attributes.fill || e) &&
            (t.attributes.fill = "black"),
          t
        );
      }
      function ir(t) {
        return "g" === t.tag ? t.children : [t];
      }
      var ar = {
          hooks: function () {
            return {
              parseNodeAttributes: function (t, e) {
                var n = e.getAttribute("data-fa-mask"),
                  r = n
                    ? Le(
                        n.split(" ").map(function (t) {
                          return t.trim();
                        })
                      )
                    : Ee();
                return (
                  r.prefix || (r.prefix = Te()),
                  (t.mask = r),
                  (t.maskId = e.getAttribute("data-fa-mask-id")),
                  t
                );
              },
            };
          },
          provides: function (t) {
            t.generateAbstractMask = function (t) {
              var e = t.children,
                n = t.attributes,
                r = t.main,
                a = t.mask,
                o = t.maskId,
                s = t.transform,
                c = r.width,
                l = r.icon,
                u = a.width,
                h = a.icon,
                d = Dt({ transform: s, containerWidth: u, iconWidth: c }),
                f = {
                  tag: "rect",
                  attributes: i(i({}, nr), {}, { fill: "white" }),
                },
                p = l.children ? { children: l.children.map(rr) } : {},
                m = {
                  tag: "g",
                  attributes: i({}, d.inner),
                  children: [
                    rr(
                      i(
                        {
                          tag: l.tag,
                          attributes: i(i({}, l.attributes), d.path),
                        },
                        p
                      )
                    ),
                  ],
                },
                g = { tag: "g", attributes: i({}, d.outer), children: [m] },
                v = "mask-".concat(o || Lt()),
                y = "clip-".concat(o || Lt()),
                b = {
                  tag: "mask",
                  attributes: i(
                    i({}, nr),
                    {},
                    {
                      id: v,
                      maskUnits: "userSpaceOnUse",
                      maskContentUnits: "userSpaceOnUse",
                    }
                  ),
                  children: [f, g],
                },
                x = {
                  tag: "defs",
                  children: [
                    { tag: "clipPath", attributes: { id: y }, children: ir(h) },
                    b,
                  ],
                };
              return (
                e.push(x, {
                  tag: "rect",
                  attributes: i(
                    {
                      fill: "currentColor",
                      "clip-path": "url(#".concat(y, ")"),
                      mask: "url(#".concat(v, ")"),
                    },
                    nr
                  ),
                }),
                { children: e, attributes: n }
              );
            };
          },
        },
        or = {
          provides: function (t) {
            var e = !1;
            O.matchMedia &&
              (e = O.matchMedia("(prefers-reduced-motion: reduce)").matches),
              (t.missingIconAbstract = function () {
                var t = [],
                  n = { fill: "currentColor" },
                  r = {
                    attributeType: "XML",
                    repeatCount: "indefinite",
                    dur: "2s",
                  };
                t.push({
                  tag: "path",
                  attributes: i(
                    i({}, n),
                    {},
                    {
                      d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z",
                    }
                  ),
                });
                var a = i(i({}, r), {}, { attributeName: "opacity" }),
                  o = {
                    tag: "circle",
                    attributes: i(
                      i({}, n),
                      {},
                      { cx: "256", cy: "364", r: "28" }
                    ),
                    children: [],
                  };
                return (
                  e ||
                    o.children.push(
                      {
                        tag: "animate",
                        attributes: i(
                          i({}, r),
                          {},
                          { attributeName: "r", values: "28;14;28;28;14;28;" }
                        ),
                      },
                      {
                        tag: "animate",
                        attributes: i(i({}, a), {}, { values: "1;0;1;1;0;1;" }),
                      }
                    ),
                  t.push(o),
                  t.push({
                    tag: "path",
                    attributes: i(
                      i({}, n),
                      {},
                      {
                        opacity: "1",
                        d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z",
                      }
                    ),
                    children: e
                      ? []
                      : [
                          {
                            tag: "animate",
                            attributes: i(
                              i({}, a),
                              {},
                              { values: "1;0;0;0;0;1;" }
                            ),
                          },
                        ],
                  }),
                  e ||
                    t.push({
                      tag: "path",
                      attributes: i(
                        i({}, n),
                        {},
                        {
                          opacity: "0",
                          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z",
                        }
                      ),
                      children: [
                        {
                          tag: "animate",
                          attributes: i(
                            i({}, a),
                            {},
                            { values: "0;0;1;1;0;0;" }
                          ),
                        },
                      ],
                    }),
                  { tag: "g", attributes: { class: "missing" }, children: t }
                );
              });
          },
        },
        sr = {
          hooks: function () {
            return {
              parseNodeAttributes: function (t, e) {
                var n = e.getAttribute("data-fa-symbol"),
                  r = null !== n && ("" === n || n);
                return (t["symbol"] = r), t;
              },
            };
          },
        },
        cr = [Ht, Bn, jn, Hn, Vn, Kn, Qn, er, ar, or, sr];
      Ne(cr, { mixoutsTo: Ge });
      Ge.noAuto;
      var lr = Ge.config,
        ur = Ge.library,
        hr = (Ge.dom, Ge.parse),
        dr = (Ge.findIconDefinition, Ge.toHtml, Ge.icon),
        fr = (Ge.layer, Ge.text);
      Ge.counter;
    },
    8539: function (t, e, n) {
      "use strict";
      n.d(e, {
        AQZ: function () {
          return a;
        },
        L2e: function () {
          return o;
        },
        O24: function () {
          return s;
        },
        OEn: function () {
          return c;
        },
        WA2: function () {
          return d;
        },
        XQY: function () {
          return i;
        },
        nre: function () {
          return h;
        },
        oo5: function () {
          return r;
        },
        zc: function () {
          return l;
        },
      });
      var r = {
          prefix: "fas",
          iconName: "volume-low",
          icon: [
            448,
            512,
            [128264, "volume-down"],
            "f027",
            "M301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM412.6 181.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5z",
          ],
        },
        i = {
          prefix: "fas",
          iconName: "pause",
          icon: [
            320,
            512,
            [9208],
            "f04c",
            "M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z",
          ],
        },
        a = {
          prefix: "fas",
          iconName: "volume-high",
          icon: [
            640,
            512,
            [128266, "volume-up"],
            "f028",
            "M533.6 32.5C598.5 85.3 640 165.8 640 256s-41.5 170.8-106.4 223.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C557.5 398.2 592 331.2 592 256s-34.5-142.2-88.7-186.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM473.1 107c43.2 35.2 70.9 88.9 70.9 149s-27.7 113.8-70.9 149c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C475.3 341.3 496 301.1 496 256s-20.7-85.3-53.2-111.8c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zm-60.5 74.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zM301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3z",
          ],
        },
        o = {
          prefix: "fas",
          iconName: "house-chimney",
          icon: [
            576,
            512,
            [63499, "home-lg"],
            "e3af",
            "M543.8 287.6c17 0 32-14 32-32.1c1-9-3-17-11-24L512 185V64c0-17.7-14.3-32-32-32H448c-17.7 0-32 14.3-32 32v36.7L309.5 7c-6-5-14-7-21-7s-15 1-22 8L10 231.5c-7 7-10 15-10 24c0 18 14 32.1 32 32.1h32v69.7c-.1 .9-.1 1.8-.1 2.8V472c0 22.1 17.9 40 40 40h16c1.2 0 2.4-.1 3.6-.2c1.5 .1 3 .2 4.5 .2H160h24c22.1 0 40-17.9 40-40V448 384c0-17.7 14.3-32 32-32h64c17.7 0 32 14.3 32 32v64 24c0 22.1 17.9 40 40 40h24 32.5c1.4 0 2.8 0 4.2-.1c1.1 .1 2.2 .1 3.3 .1h16c22.1 0 40-17.9 40-40V455.8c.3-2.6 .5-5.3 .5-8.1l-.7-160.2h32z",
          ],
        },
        s = {
          prefix: "fas",
          iconName: "circle-left",
          icon: [
            512,
            512,
            [61840, "arrow-alt-circle-left"],
            "f359",
            "M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256S114.6 512 256 512s256-114.6 256-256zM116.7 244.7l112-112c4.6-4.6 11.5-5.9 17.4-3.5s9.9 8.3 9.9 14.8l0 64 96 0c17.7 0 32 14.3 32 32l0 32c0 17.7-14.3 32-32 32l-96 0 0 64c0 6.5-3.9 12.3-9.9 14.8s-12.9 1.1-17.4-3.5l-112-112c-6.2-6.2-6.2-16.4 0-22.6z",
          ],
        },
        c = {
          prefix: "fas",
          iconName: "volume-off",
          icon: [
            320,
            512,
            [],
            "f026",
            "M320 64c0-12.6-7.4-24-18.9-29.2s-25-3.1-34.4 5.3L131.8 160H64c-35.3 0-64 28.7-64 64v64c0 35.3 28.7 64 64 64h67.8L266.7 471.9c9.4 8.4 22.9 10.4 34.4 5.3S320 460.6 320 448V64z",
          ],
        },
        l = {
          prefix: "fas",
          iconName: "play",
          icon: [
            384,
            512,
            [9654],
            "f04b",
            "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z",
          ],
        },
        u = {
          prefix: "fas",
          iconName: "volume-xmark",
          icon: [
            576,
            512,
            ["volume-mute", "volume-times"],
            "f6a9",
            "M301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM425 167l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0z",
          ],
        },
        h = u,
        d = {
          prefix: "fas",
          iconName: "circle-xmark",
          icon: [
            512,
            512,
            [61532, "times-circle", "xmark-circle"],
            "f057",
            "M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z",
          ],
        };
    },
  },
]);
//# sourceMappingURL=chunk-vendors.3e6ced3b.js.map
